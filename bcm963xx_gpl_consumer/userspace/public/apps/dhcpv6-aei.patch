diff -Naur dhcpv6-aei/addrconf.c dhcpv6-aei-brcm/addrconf.c
--- dhcpv6-aei/addrconf.c	2008-06-15 04:48:40.000000000 -0300
+++ dhcpv6-aei-brcm/addrconf.c	2019-06-13 11:48:57.543013322 -0300
@@ -59,7 +59,16 @@
 #include "timer.h"
 #include "dhcp6c_ia.h"
 #include "prefixconf.h"
-
+#ifdef AEI_CONTROL_LAYER
+#include "ctl_msg.h"
+#include "dbussend_msg.h"
+extern void *ctlMsgHandle;
+extern CtlDhcp6cStateChangedMsgBody ctldhcp6cMsgBody;
+extern CtlDhcp6cStateChangedMsgBody ctldhcp6cMsgBody_Old;
+#ifdef CONFIG_IOT_RECONFIGURATION
+extern int got_valid_ia_na;
+#endif
+#endif
 TAILQ_HEAD(statefuladdr_list, statefuladdr);
 struct iactl_na {
 	struct iactl common;
@@ -101,6 +110,11 @@
 
 extern struct dhcp6_timer *client6_timo __P((void *));
 
+#if 1 //brcm
+static int updateIp6AddrFile __P((ifaddrconf_cmd_t, char *, struct sockaddr_in6 *));
+static void sendAddrEventMessage __P((ifaddrconf_cmd_t, const char *, const char *));
+#endif
+
 int
 update_address(ia, addr, dhcpifp, ctlp, callback)
 	struct ia *ia;
@@ -117,7 +131,7 @@
 	/*
 	 * A client discards any addresses for which the preferred
          * lifetime is greater than the valid lifetime.
-	 * [RFC3315 22.6] 
+	 * [RFC3315 22.6]
 	 */
 	if (addr->vltime != DHCP6_DURATION_INFINITE &&
 	    (addr->pltime == DHCP6_DURATION_INFINITE ||
@@ -175,7 +189,13 @@
 
 	if (sa->addr.vltime != 0)
 		if (na_ifaddrconf(IFADDRCONF_ADD, sa) < 0)
+		    {
+							ctllog_debug(LOG_NOTICE,FLNAME,LINENUM,FNAME,
+				    "failed to add stateful addr ,ignore this error");
+#ifndef CDROUTER_TEST_DHCP6C
 			return (-1);
+#endif
+		    }
 
 	/*
 	 * If the new vltime is 0, this address immediately expires.
@@ -293,6 +313,11 @@
 		TAILQ_REMOVE(&iac_na->statefuladdr_head, sa, link);
 		remove_addr(sa);
 	}
+    if (memcmp(&ctldhcp6cMsgBody, &ctldhcp6cMsgBody_Old, sizeof(CtlDhcp6cStateChangedMsgBody)))
+    {
+         sendDhcp6cEventMessage();
+         memcpy(&ctldhcp6cMsgBody_Old, &ctldhcp6cMsgBody, sizeof(CtlDhcp6cStateChangedMsgBody));
+    }
 
 	free(iac);
 }
@@ -311,14 +336,14 @@
 	for (sa = TAILQ_FIRST(&iac_na->statefuladdr_head); sa;
 	    sa = TAILQ_NEXT(sa, link)) {
 		if (dhcp6_add_listval(&pl, DHCP6_LISTVAL_STATEFULADDR6,
-		    &sa->addr, NULL) == NULL)
+		    &sa->addr, NULL, 0) == NULL)
 			goto fail;
 	}
 
 	if ((ial = malloc(sizeof(*ial))) == NULL)
 		goto fail;
 	TAILQ_INIT(ial);
-	if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IANA, iaparam, &pl) == NULL)
+	if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IANA, iaparam, &pl, 0) == NULL)
 		goto fail;
 	dhcp6_clear_list(&pl);
 
@@ -373,6 +398,14 @@
 
 	remove_addr(sa);
 
+       //when addr tiomeout need send the message to smd immediately
+      //add by harrison 2012-08-07
+      if (memcmp(&ctldhcp6cMsgBody, &ctldhcp6cMsgBody_Old, sizeof(CtlDhcp6cStateChangedMsgBody)))
+     {
+              sendDhcp6cEventMessage();
+              memcpy(&ctldhcp6cMsgBody_Old, &ctldhcp6cMsgBody, sizeof(CtlDhcp6cStateChangedMsgBody));
+      }
+
 	(*callback)(ia);
 
 	return (NULL);
@@ -389,11 +422,289 @@
 	addr = &sa->addr;
 	memset(&sin6, 0, sizeof(sin6));
 	sin6.sin6_family = AF_INET6;
-#ifdef HAVE_SA_LEN
+//#ifdef HAVE_SA_LEN
+#ifndef __linux__
 	sin6.sin6_len = sizeof(sin6);
 #endif
 	sin6.sin6_addr = addr->addr;
 
+#if 1 //brcm
+	return (ifaddrconf(cmd, sa->dhcpif->ifname, &sin6, 64,
+	    addr->pltime, addr->vltime));
+#else
 	return (ifaddrconf(cmd, sa->dhcpif->ifname, &sin6, 128,
 	    addr->pltime, addr->vltime));
+#endif
 }
+
+#if 1 //brcm: moved from common.c */
+int
+ifaddrconf(cmd, ifname, addr, plen, pltime, vltime)
+	ifaddrconf_cmd_t cmd;
+	char *ifname;
+	struct sockaddr_in6 *addr;
+	int plen;
+	int pltime;
+	int vltime;
+{
+#ifdef __KAME__
+	struct in6_aliasreq req;
+#endif
+#ifdef __linux__
+	struct in6_ifreq req;
+	struct ifreq ifr;
+#endif
+#ifdef __sun__
+	struct lifreq req;
+#endif
+	unsigned long ioctl_cmd;
+	char *cmdstr;
+	int s;			/* XXX overhead */
+
+	switch(cmd) {
+	case IFADDRCONF_ADD:
+		cmdstr = "add";
+#ifdef __KAME__
+		ioctl_cmd = SIOCAIFADDR_IN6;
+#endif
+#ifdef __linux__
+		ioctl_cmd = SIOCSIFADDR;
+#endif
+#ifdef __sun__
+		ioctl_cmd = SIOCLIFADDIF;
+#endif
+		break;
+	case IFADDRCONF_REMOVE:
+		cmdstr = "remove";
+#ifdef __KAME__
+		ioctl_cmd = SIOCDIFADDR_IN6;
+#endif
+#ifdef __linux__
+		ioctl_cmd = SIOCDIFADDR;
+#endif
+#ifdef __sun__
+		ioctl_cmd = SIOCLIFREMOVEIF;
+#endif
+		break;
+	default:
+		return (-1);
+	}
+
+	if ((s = socket(PF_INET6, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+		dprintf(LOG_ERR, FNAME, "can't open a temporary socket: %s",
+		    strerror(errno));
+		return (-1);
+	}
+
+	memset(&req, 0, sizeof(req));
+#ifdef __KAME__
+	req.ifra_addr = *addr;
+	memcpy(req.ifra_name, ifname, sizeof(req.ifra_name));
+	(void)sa6_plen2mask(&req.ifra_prefixmask, plen);
+	/* XXX: should lifetimes be calculated based on the lease duration? */
+	req.ifra_lifetime.ia6t_vltime = vltime;
+	req.ifra_lifetime.ia6t_pltime = pltime;
+#endif
+#ifdef __linux__
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy(ifr.ifr_name, ifname, IFNAMSIZ - 1);
+	if (ioctl(s, SIOGIFINDEX, &ifr) < 0) {
+		dprintf(LOG_NOTICE, FNAME, "failed to get the index of %s: %s",
+		    ifname, strerror(errno));
+		close(s);
+		return (-1);
+	}
+	memcpy(&req.ifr6_addr, &addr->sin6_addr, sizeof(struct in6_addr));
+	req.ifr6_prefixlen = plen;
+	req.ifr6_ifindex = ifr.ifr_ifindex;
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+	req.ifr6_vltime = vltime;
+	req.ifr6_pltime = pltime;
+		dprintf(LOG_NOTICE, FNAME, "====req.ifr6_vltime=%d,req.ifr6_pltime=%d",req.ifr6_vltime,req.ifr6_pltime);
+
+#endif
+#endif
+#ifdef __sun__
+	strncpy(req.lifr_name, ifname, sizeof (req.lifr_name));
+#endif
+
+	if (ioctl(s, ioctl_cmd, &req)) {
+		dprintf(LOG_NOTICE, FNAME, "failed to %s an address on %s: %s",
+		    cmdstr, ifname, strerror(errno));
+		close(s);
+		return (-1);
+	}
+
+#ifdef __sun__
+	memcpy(&req.lifr_addr, addr, sizeof (*addr));
+	if (ioctl(s, SIOCSLIFADDR, &req) == -1) {
+		dprintf(LOG_NOTICE, FNAME, "failed to %s new address on %s: %s",
+		    cmdstr, ifname, strerror(errno));
+		close(s);
+		return (-1);
+	}
+#endif
+
+	dprintf(LOG_DEBUG, FNAME, "%s an address %s/%d on %s", cmdstr,
+	    addr2str((struct sockaddr *)addr), plen, ifname);
+
+	close(s);
+
+#if 1 //brcm
+   if (updateIp6AddrFile(cmd, ifname, addr) == 0)
+   {
+      /* send SIGUR1 to httpd process only when non-br interface address changes. */
+//      if (strncmp(ifname, "br", 2) != 0)
+//      {
+         char extAddr[BUFLEN_48];
+#if 0
+         const char *f_httpdPid = "/var/run/httpd_pid";
+         FILE  *fp;
+
+         /* send SIGUR1 to httpd process */
+         if ((fp = fopen(f_httpdPid, "r")) != NULL)
+         {
+            char pid[16];
+
+            fgets(pid, sizeof(pid), fp);
+            fclose(fp);
+            dprintf(LOG_INFO, FNAME, "send SIGUR1 to httpd process %s", pid);
+            kill(atoi(pid), SIGUSR1);
+         }
+#endif
+         snprintf(extAddr, sizeof(extAddr), "%s/%d", addr2str((struct sockaddr *)addr), plen);
+         //snprintf(extAddr, sizeof(extAddr), "%s", addr2str((struct sockaddr *)addr));//for IOT
+         sendAddrEventMessage(cmd, ifname, extAddr);
+//      }
+   }
+#endif
+
+	return (0);
+}
+#endif
+
+#if 1 //brcm
+int updateIp6AddrFile(ifaddrconf_cmd_t cmd, char *ifname, struct sockaddr_in6 *addr)
+{
+   const char *f_ip6Addr = "/var/ip6addr";
+   FILE *fp;
+   long curLine;
+   long ifaddrLen;
+   char ifaddr[84];
+   char line[84];
+
+   /* see if the f_ip6Addr file already exists */
+   if (access(f_ip6Addr, F_OK) == 0)
+   {
+      /* open the existing file for update */
+      if ((fp = fopen(f_ip6Addr, "r+")) == NULL)
+      {
+         /* error */
+         dprintf(LOG_ERR, FNAME, "failed to open %s", f_ip6Addr);
+         return -1;
+      }
+   }
+   else
+   {
+      /* open a new file */
+      if ((fp = fopen(f_ip6Addr, "w+")) == NULL)
+      {
+         /* error */
+         dprintf(LOG_ERR, FNAME, "failed to open %s", f_ip6Addr);
+         return -1;
+      }
+   }
+   fseek(fp, 0L, SEEK_SET);
+
+   sprintf(ifaddr, "%s %s", ifname, addr2str((struct sockaddr *)addr));
+   ifaddrLen = strlen(ifaddr);
+
+   if (cmd == IFADDRCONF_ADD)
+   {
+      /* write interface name and address to a blank line or to EOF */
+      curLine = ftell(fp);
+      while (fgets(line, sizeof(line), fp) != NULL)
+      {
+         if (strchr(line, ':') == NULL)
+         {
+            /* write over the blank line */
+            fseek(fp, curLine, SEEK_SET);
+            break;
+         }
+         curLine = ftell(fp);
+      }
+      fprintf(fp, "%-80s\n", ifaddr); /* Note: each line must be 80 chars long */
+      fclose(fp);
+      return 0;
+   }
+   else if (cmd == IFADDRCONF_REMOVE)
+   {
+      curLine = ftell(fp);
+      while (fgets(line, sizeof(line), fp) != NULL)
+      {
+         if (strncmp(line, ifaddr, ifaddrLen) == 0)
+         {
+            /* erase the line */
+            fseek(fp, curLine, SEEK_SET);
+            fprintf(fp, "%-80s\n", " ");  /* Note: each line must be 80 chars long */
+            fclose(fp);
+            return 0;
+         }
+         curLine = ftell(fp);
+      }
+   }
+
+   fclose(fp);
+   return -1;
+
+}  /* End of updateIp6AddrFile() */
+
+#ifdef AEI_CONTROL_LAYER
+void sendAddrEventMessage(ifaddrconf_cmd_t cmd, const char *ifname, const char *addr)
+{
+   /* TODO: Currently, we always assume br0 as the  PD interface */
+#if defined(AEI_COVERITY_FIX)
+   if ( strncmp(ifname, "br0", strlen("br0")) == 0 )  /* address of the PD interface */
+#else
+   if ( strncmp(ifname, "br0", sizeof(ifname)) == 0 )  /* address of the PD interface */
+#endif
+   {
+      snprintf(ctldhcp6cMsgBody.pdIfAddress, sizeof(ctldhcp6cMsgBody.pdIfAddress), "%s", addr);
+   }
+   else  /* address of the WAN interface */
+   {
+#ifdef CONFIG_IOT_RECONFIGURATION
+    if(cmd==IFADDRCONF_ADD)
+        {
+            //got_valid_ia_na++;
+            ctllog_debug(LOG_INFO,FLNAME,LINENUM,FNAME, "add valid ia na(ifname=%s,addr=%s) now,got_valid_ia_na=%d",
+                ifname,addr,got_valid_ia_na);
+
+        }
+       //support remove ia_na
+      //modify by harrison 2012-08-07
+        else if(cmd==IFADDRCONF_REMOVE)
+        {
+            ctllog_debug(LOG_INFO,FLNAME,LINENUM,FNAME, "remove valid ia na(ifname=%s,addr=%s) now,got_valid_ia_na=%d",
+                ifname,addr,got_valid_ia_na);
+        }
+    /*else if(got_valid_ia_na >0 )
+        {
+             ctllog_debug(LOG_INFO,FLNAME,LINENUM,FNAME, "got valid ia na(ifname=%s,addr=%s) before,cann't do remove!got_valid_ia_na=%d",
+                ctldhcp6cMsgBody.ifname,ctldhcp6cMsgBody.address,got_valid_ia_na);
+            return;
+        }*/
+#endif
+      ctldhcp6cMsgBody.addrAssigned = TRUE;
+      ctldhcp6cMsgBody.addrCmd      = cmd;
+      snprintf(ctldhcp6cMsgBody.ifname, sizeof(ctldhcp6cMsgBody.ifname), "%s", ifname);
+      snprintf(ctldhcp6cMsgBody.address, sizeof(ctldhcp6cMsgBody.address), "%s", addr);
+   }
+
+   dprintf(LOG_NOTICE, FNAME, "DHCP6C_ADDR_CHANGED");
+
+   return;
+
+}  /* End of sendAddrEventMessage() */
+#endif
+#endif
diff -Naur dhcpv6-aei/auth.c dhcpv6-aei-brcm/auth.c
--- dhcpv6-aei/auth.c	2007-03-21 06:52:57.000000000 -0300
+++ dhcpv6-aei-brcm/auth.c	2019-06-13 11:48:57.543013322 -0300
@@ -151,6 +151,47 @@
 	return (0);
 }
 
+#ifdef CONFIG_IOT_RECONFIGURATION
+int
+dhcp6_reconf_verify_mac(buf, len, proto, alg, off, key,key_len)
+		char *buf;
+		ssize_t len;
+		int proto;
+		int alg;
+		size_t off;
+		char *key;
+		int key_len;
+{
+		hmacmd5_t ctx;
+		unsigned char digest[MD5_DIGESTLENGTH];
+		int result;
+
+		/* right now, we don't care about the protocol */
+
+		if (alg != DHCP6_AUTHALG_HMACMD5)
+				return (-1);
+
+		if (off + MD5_DIGESTLENGTH > len)
+				return (-1);
+
+		/*
+		 * Copy the MAC value and clear the field.
+		 * XXX: should we make a local working copy?
+		 */
+		memcpy(digest, buf + off, sizeof(digest));
+		memset(buf + off, 0, sizeof(digest));
+
+		hmacmd5_init(&ctx, key, key_len);
+		hmacmd5_update(&ctx, buf, len);
+		result = hmacmd5_verify(&ctx, digest);
+
+		/* copy back the digest value (XXX) */
+		memcpy(buf + off, digest, sizeof(digest));
+
+		return (result);
+}
+#endif
+
 int
 dhcp6_verify_mac(buf, len, proto, alg, off, key)
 	char *buf;
@@ -222,7 +263,11 @@
 {
 	md5_invalidate(&ctx->md5ctx);
 	memset(ctx->key, 0, sizeof(ctx->key));
+#if defined(AEI_COVERITY_FIX)
+	memset(ctx, 0, sizeof(hmacmd5_t));
+#else
 	memset(ctx, 0, sizeof(ctx));
+#endif
 }
 
 /*
diff -Naur dhcpv6-aei/auth.h dhcpv6-aei-brcm/auth.h
--- dhcpv6-aei/auth.h	2007-03-21 06:52:57.000000000 -0300
+++ dhcpv6-aei-brcm/auth.h	2019-06-13 11:48:57.543013322 -0300
@@ -58,3 +58,7 @@
     struct keyinfo *));
 extern int dhcp6_verify_mac __P((char *, ssize_t, int, int, size_t,
     struct keyinfo *));
+#ifdef CONFIG_IOT_RECONFIGURATION
+extern int dhcp6_reconf_verify_mac __P((char *, ssize_t, int, int, size_t,
+	 char *,int));
+#endif
diff -Naur dhcpv6-aei/cftoken.l dhcpv6-aei-brcm/cftoken.l
--- dhcpv6-aei/cftoken.l	2007-03-21 06:52:55.000000000 -0300
+++ dhcpv6-aei-brcm/cftoken.l	2019-06-13 11:48:57.543013322 -0300
@@ -70,7 +70,7 @@
 
 static int yy_first_time = 1;
 static int yyerrorcount = 0;
- 
+
 #ifndef NOCONFIG_DEBUG
 #define YYDEBUG 1
 
@@ -120,6 +120,7 @@
 %s S_SECRET
 %s S_ADDRPOOL
 %s S_INCL
+%option noyywrap
 
 %%
 %{
@@ -147,7 +148,7 @@
 }
 
 	/* address pool configuration */
-<S_CNF>pool { DECHO; BEGIN S_ADDRPOOL; return (ADDRPOOL); }  
+<S_CNF>pool { DECHO; BEGIN S_ADDRPOOL; return (ADDRPOOL); }
 
 <S_ADDRPOOL>{string} {
 	DECHO;
@@ -208,7 +209,7 @@
 
 	/* provided for a backward compatibility to WIDE-DHCPv6 before Oct 1 2006 */
 <S_CNF>nis-server-domain-name { DECHO; return (NIS_NAME); }
-<S_CNF>nisp-server-domain-name { DECHO; return (NISP_NAME); }	
+<S_CNF>nisp-server-domain-name { DECHO; return (NISP_NAME); }
 
 	/* generic options */
 <S_CNF>information-only { DECHO; return (INFO_ONLY); }
diff -Naur dhcpv6-aei/common.c dhcpv6-aei-brcm/common.c
--- dhcpv6-aei/common.c	2008-06-15 04:48:41.000000000 -0300
+++ dhcpv6-aei-brcm/common.c	2019-06-13 11:48:57.543013322 -0300
@@ -2,7 +2,7 @@
 /*
  * Copyright (C) 1998 and 1999 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -14,7 +14,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -86,6 +86,7 @@
 #include <common.h>
 #include <timer.h>
 
+#if 0 //brcm: moved to common.h
 #ifdef __linux__
 /* from /usr/include/linux/ipv6.h */
 
@@ -95,13 +96,14 @@
 	unsigned int ifr6_ifindex;
 };
 #endif
+#endif
 
 #define MAXDNAME 255
 
 int foreground;
 int debug_thresh;
 
-static int dhcp6_count_list __P((struct dhcp6_list *));
+//static int dhcp6_count_list __P((struct dhcp6_list *));
 static int in6_matchflags __P((struct sockaddr *, char *, int));
 static ssize_t dnsencode __P((const char *, char *, size_t));
 static char *dnsdecode __P((u_char **, u_char *, char *, size_t));
@@ -122,7 +124,7 @@
 
 	for (ent = TAILQ_FIRST(src); ent; ent = TAILQ_NEXT(ent, link)) {
 		if (dhcp6_add_listval(dst, ent->type,
-		    &ent->uv, &ent->sublist) == NULL)
+		    &ent->uv, &ent->sublist, 0) == NULL)
 			goto fail;
 	}
 
@@ -159,7 +161,7 @@
 	return;
 }
 
-static int
+int
 dhcp6_count_list(head)
 	struct dhcp6_list *head;
 {
@@ -199,7 +201,7 @@
 	int option;
 {
 	struct dhcp6_listval *lv;
-
+char tmpbuf[48]="";
 	for (lv = TAILQ_FIRST(head); lv; lv = TAILQ_NEXT(lv, link)) {
 		if (lv->type != type)
 			continue;
@@ -232,7 +234,28 @@
 			}
 			break;
 		case DHCP6_LISTVAL_STATEFULADDR6:
-			if (IN6_ARE_ADDR_EQUAL(&lv->val_statefuladdr6.addr,
+            if (option & MATCHLIST_PREFIXLEN)
+                {
+#ifdef AEI_COVERITY_FIX
+					 snprintf(tmpbuf, sizeof(tmpbuf), "%s", in6addr2str(&lv->val_statefuladdr6.addr, 0));
+#else
+                     strncpy(tmpbuf,in6addr2str(&lv->val_statefuladdr6.addr, 0),sizeof(tmpbuf));
+#endif
+                    dprintf(LOG_DEBUG, FNAME, "tmpbuf=%s,val=%s",tmpbuf,val?(char*)val:"NULL");
+
+                    if(val && !strncmp(tmpbuf,(char *)val,strlen(val)))
+                        {
+					dprintf(LOG_DEBUG, FNAME,
+			    "%s ==%s",tmpbuf,val) ;
+
+                            return (lv);
+                        }
+                    else
+                        {
+                            return (NULL);
+                        }
+                }
+		else if (IN6_ARE_ADDR_EQUAL(&lv->val_statefuladdr6.addr,
 			    &((struct dhcp6_prefix *)val)->addr)) {
 				return (lv);
 			}
@@ -257,10 +280,11 @@
 }
 
 struct dhcp6_listval *
-dhcp6_add_listval(head, type, val, sublist)
+dhcp6_add_listval(head, type, val, sublist, flag)
 	struct dhcp6_list *head, *sublist;
 	dhcp6_listval_type_t type;
 	void *val;
+    int flag;
 {
 	struct dhcp6_listval *lv = NULL;
 
@@ -306,8 +330,14 @@
 	if (sublist && dhcp6_copy_list(&lv->sublist, sublist))
 		goto fail;
 
-	TAILQ_INSERT_TAIL(head, lv, link);
-
+    if(!flag)
+    {
+	    TAILQ_INSERT_TAIL(head, lv, link);
+    }
+    else
+    {
+	    TAILQ_INSERT_HEAD(head, lv, link);
+    }
 	return (lv);
 
   fail:
@@ -377,7 +407,7 @@
 		}
 
 		if (dhcp6_add_listval(list, DHCP6_LISTVAL_ADDR6,
-		    &valaddr, NULL) == NULL) {
+		    &valaddr, NULL, 0) == NULL) {
 			dprintf(LOG_ERR, FNAME,
 			    "failed to copy %s address", dhcp6optstr(type));
 			return -1;
@@ -451,7 +481,7 @@
 		vb.dv_buf = name;
 
 		if (dhcp6_add_listval(list,
-		    DHCP6_LISTVAL_VBUF, &vb, NULL) == NULL) {
+		    DHCP6_LISTVAL_VBUF, &vb, NULL, 0) == NULL) {
 			dprintf(LOG_ERR, FNAME, "failed to "
 			    "copy a %s domain name", dhcp6optstr(type));
 			return -1;
@@ -574,6 +604,9 @@
 		free(ev->authparam);
 
 	free(ev);
+#ifdef AEI_COVERITY_FIX
+    ev = NULL;
+#endif
 }
 
 void
@@ -744,7 +777,7 @@
 		memcpy(addr, &sin6.sin6_addr, sizeof(sin6.sin6_addr));
 #ifdef __KAME__
 		if (IN6_IS_ADDR_LINKLOCAL(addr))
-			addr->s6_addr[2] = addr->s6_addr[3] = 0; 
+			addr->s6_addr[2] = addr->s6_addr[3] = 0;
 #endif
 		error = 0;
 		break;
@@ -799,7 +832,7 @@
 	struct in6_addr *addr;
 	char *ifnam;
 {
-	u_int ifindex; 
+	u_int ifindex;
 
 	if ((ifindex = if_nametoindex(ifnam)) == 0)
 		return (-1);
@@ -989,9 +1022,10 @@
 }
 
 int
-get_duid(idfile, duid)
+get_duid(idfile, duid, brcm_ifname)
 	char *idfile;
 	struct duid *duid;
+	char *brcm_ifname;
 {
 	FILE *fp = NULL;
 	u_int16_t len = 0, hwtype;
@@ -1011,7 +1045,7 @@
 	} else {
 		int l;
 
-		if ((l = gethwid(tmpbuf, sizeof(tmpbuf), NULL, &hwtype)) < 0) {
+		if ((l = gethwid(tmpbuf, sizeof(tmpbuf), brcm_ifname, &hwtype)) < 0) {
 			dprintf(LOG_INFO, FNAME,
 			    "failed to get a hardware address");
 			goto fail;
@@ -1040,11 +1074,13 @@
 		u_int64_t t64;
 
 		dp = (struct dhcp6opt_duid_type1 *)duid->duid_id;
-		dp->dh6_duid1_type = htons(1); /* type 1 */
+		dp->dh6_duid1_type = htons(3); /* brcm: was type 1 (DUID-LLT). Change to type 3 (DUID-LL). */
 		dp->dh6_duid1_hwtype = htons(hwtype);
+#if 0 //brcm: change to type 3 (DUID-LL)
 		/* time is Jan 1, 2000 (UTC), modulo 2^32 */
 		t64 = (u_int64_t)(time(NULL) - 946684800);
 		dp->dh6_duid1_time = htonl((u_long)(t64 & 0xffffffff));
+#endif
 		memcpy((void *)(dp + 1), tmpbuf, (len - sizeof(*dp)));
 
 		dprintf(LOG_DEBUG, FNAME, "generated a new DUID: %s",
@@ -1556,7 +1592,7 @@
 			/* need to check duplication? */
 
 			if (dhcp6_add_listval(&optinfo->stcode_list,
-			    DHCP6_LISTVAL_STCODE, &num16, NULL) == NULL) {
+			    DHCP6_LISTVAL_STCODE, &num16, NULL, 0) == NULL) {
 				dprintf(LOG_ERR, FNAME, "failed to copy "
 				    "status code");
 				goto fail;
@@ -1587,7 +1623,7 @@
 				}
 
 				if (dhcp6_add_listval(&optinfo->reqopt_list,
-				    DHCP6_LISTVAL_NUM, &num, NULL) == NULL) {
+				    DHCP6_LISTVAL_NUM, &num, NULL, 0) == NULL) {
 					dprintf(LOG_ERR, FNAME,
 					    "failed to copy requested option");
 					goto fail;
@@ -1693,8 +1729,38 @@
 				    optinfo->delayedauth_offset,
 				    optinfo->delayedauth_realmlen);
 				break;
-#ifdef notyet
+#ifdef CONFIG_IOT_RECONFIGURATION
+			case 0:
+				if (authinfolen == 11 ) {
+					dprintf(LOG_INFO, FNAME, "REconfig Auth protocol fron juniper os. wrong,but let it go");
+					optinfo->authflags |=
+					    DHCP6OPT_AUTHFLAG_NOINFO;
+					optinfo->reconfigauth_type = 0;
+				}
+
+				optinfo->reconfigauth_type = *((char *)cp);
+				cp +=authinfolen;
+
+				break;
 			case DHCP6_AUTHPROTO_RECONFIG:
+				if (authinfolen != DHCP6_RECONFIGURE_AUTH_INFO_LENGTH ) {
+						dprintf(LOG_INFO, FNAME, "Configure Message with wrong Length");
+						optinfo->authflags |=
+							DHCP6OPT_AUTHFLAG_NOINFO;
+						optinfo->reconfigauth_type = 0;
+						goto malformed;
+				}
+
+				optinfo->reconfigauth_type = *((char *)cp);
+				cp ++;
+
+				optinfo->reconfigauth_offset = cp - bp;
+				memcpy(optinfo->reconfigauth_val, cp,DHCP6_RECONFIGURE_AUTH_VAL_LENGTH);
+
+				cp += DHCP6_RECONFIGURE_AUTH_VAL_LENGTH;
+
+				dprintf(LOG_INFO, FNAME, "REconfig Auth protocol");
+
 				break;
 #endif
 			default:
@@ -1801,7 +1867,7 @@
 
 			/* link this option set */
 			if (dhcp6_add_listval(&optinfo->iapd_list,
-			    DHCP6_LISTVAL_IAPD, &ia, &sublist) == NULL) {
+			    DHCP6_LISTVAL_IAPD, &ia, &sublist, 0) == NULL) {
 				dhcp6_clear_list(&sublist);
 				goto fail;
 			}
@@ -1865,13 +1931,65 @@
 
 			/* link this option set */
 			if (dhcp6_add_listval(&optinfo->iana_list,
-			    DHCP6_LISTVAL_IANA, &ia, &sublist) == NULL) {
+			    DHCP6_LISTVAL_IANA, &ia, &sublist, 0) == NULL) {
 				dhcp6_clear_list(&sublist);
 				goto fail;
 			}
 			dhcp6_clear_list(&sublist);
 
 			break;
+#ifdef CONFIG_IOT_RECONFIGURATION
+		case DH6OPT_RECONF_MSG:
+			if (optlen != 1)
+				goto malformed;
+			dprintf(LOG_DEBUG, "", "  Reconfigure message: %d",
+			    (int)*(u_char *)cp);
+			optinfo->reconf_type = (int)*(u_char *)cp;
+			break;
+#endif
+//brcm- start
+		case DH6OPT_USER_CLASS:
+      {
+         char *instance, *instanceNext;
+         char csav;
+
+        // printf("DHCP6 received User Class Option (15):\n");
+         for (instance = cp; instance < (char *)np; instance = instanceNext) {
+            instanceNext = instance + 2 + *(u_int16_t *)instance;
+            if (instanceNext <= (char *)np) {
+               /* save the first char of the next instance data */
+               csav = *instanceNext;
+               /* replace it with a NULL */
+               *instanceNext = '\0';
+               printf("    user class data: %s\n", instance+2);
+               /* restore the original char */
+               *instanceNext = csav;
+            }
+         }
+         break;
+      }
+		case DH6OPT_VENDOR_CLASS:
+      {
+         char *instance, *instanceNext;
+         char csav;
+
+       //  printf("DHCP6 received Vendor Class Option (16):\n");
+       //  printf("    enterprise-number: %d\n", *(u_int32_t *)cp);
+         for (instance = cp+4; instance < (char *)np; instance = instanceNext) {
+            instanceNext = instance + 2 + *(u_int16_t *)instance;
+            if (instanceNext <= (char *)np) {
+               /* save the first char of the next instance data */
+               csav = *instanceNext;
+               /* replace it with a NULL */
+               *instanceNext = '\0';
+              // printf("    vendor class data: %s\n", instance+2);
+               /* restore the original char */
+               *instanceNext = csav;
+            }
+         }
+         break;
+      }
+//brcm- end
 		default:
 			/* no option specific behavior */
 			dprintf(LOG_INFO, FNAME,
@@ -2014,7 +2132,7 @@
 
 			if (dhcp6_find_listval(list, DHCP6_LISTVAL_PREFIX6,
 			    &iapd_prefix, 0)) {
-				dprintf(LOG_INFO, FNAME, 
+				dprintf(LOG_INFO, FNAME,
 				    "duplicated IA_PD prefix "
 				    "%s/%d pltime=%lu vltime=%lu",
 				    in6addr2str(&iapd_prefix.addr, 0),
@@ -2032,7 +2150,7 @@
 			}
 
 			if (dhcp6_add_listval(list, DHCP6_LISTVAL_PREFIX6,
-			    &iapd_prefix, &sublist) == NULL) {
+			    &iapd_prefix, &sublist, 0) == NULL) {
 				dhcp6_clear_list(&sublist);
 				goto fail;
 			}
@@ -2064,7 +2182,7 @@
 
 			if (dhcp6_find_listval(list,
 			    DHCP6_LISTVAL_STATEFULADDR6, &ia_addr, 0)) {
-				dprintf(LOG_INFO, FNAME, 
+				dprintf(LOG_INFO, FNAME,
 				    "duplicated IA_NA address"
 				    "%s pltime=%lu vltime=%lu",
 				    in6addr2str(&ia_addr.addr, 0),
@@ -2081,7 +2199,7 @@
 			}
 
 			if (dhcp6_add_listval(list, DHCP6_LISTVAL_STATEFULADDR6,
-			    &ia_addr, &sublist) == NULL) {
+			    &ia_addr, &sublist, 0) == NULL) {
 				dhcp6_clear_list(&sublist);
 				goto fail;
 			}
@@ -2121,7 +2239,7 @@
 
 			/* copy-in the code value */
 			if (dhcp6_add_listval(list, DHCP6_LISTVAL_STCODE,
-			    &opt_stcode.dh6_stcode_code, NULL) == NULL)
+			    &opt_stcode.dh6_stcode_code, NULL, 0) == NULL)
 				goto fail;
 
 			break;
@@ -2232,7 +2350,7 @@
 		memcpy(opt + 1, val, len);
 
 	*optp = (struct dhcp6opt *)((char *)(opt + 1) + len);
- 	*totallenp += sizeof(struct dhcp6opt) + len;
+	*totallenp += sizeof(struct dhcp6opt) + len;
 	dprintf(LOG_DEBUG, FNAME, "set %s (len %d)", dhcp6optstr(type), len);
 
 	return (0);
@@ -2300,6 +2418,18 @@
 			goto fail;
 		}
 	}
+#ifdef CONFIG_IOT_RECONFIGURATION
+
+		if (DH6_SOLICIT == type || DH6_REQUEST == type) {
+			if (copy_option(DH6OPT_RECONF_ACCEPT, 0, NULL, &p,
+				optep, &len) != 0) {
+				goto fail;
+			}
+			dprintf(LOG_INFO, FNAME,
+				"Add option DH6OPT_RECONF_ACCEPT");
+		}
+
+#endif
 
 	if (optinfo->pref != DH6OPT_PREF_UNDEF) {
 		u_int8_t p8 = (u_int8_t)optinfo->pref;
@@ -2537,7 +2667,7 @@
 				dprintf(LOG_DEBUG, FNAME,
 				    "key ID %x, offset %d",
 				    optinfo->delayedauth_keyid,
-				    optinfo->delayedauth_offset); 
+				    optinfo->delayedauth_offset);
 				break;
 #ifdef notyet
 			case DHCP6_AUTHPROTO_RECONFIG:
@@ -2552,6 +2682,10 @@
 
 		if (copy_option(DH6OPT_AUTH, authlen - 4,
 		    &auth->dh6_auth_proto, &p, optep, &len) != 0) {
+/*coverity CID:11993 added by libby*/
+#ifdef AEI_COVERITY_FIX
+            free(auth);
+#endif
 			goto fail;
 		}
 		free(auth);
@@ -2811,12 +2945,58 @@
 		ev->init_retrans = REL_TIMEOUT;
 		ev->max_retrans_cnt = REL_MAX_RC;
 		break;
+#ifdef ACTION_TEC_IPV6_CODE_FOR_CONFIRM
+	case DHCP6S_CONFIRM:
+		ev->init_retrans = SOL_TIMEOUT;
+		ev->max_retrans_time = SOL_MAX_RT;
+		break;
+#endif
+#ifdef ACTION_TEC_IPV6_CODE_FOR_DECLINE
+	case DHCP6S_DECLINE:
+		ev->init_retrans = REQ_TIMEOUT;
+		ev->max_retrans_time = REQ_MAX_RT;
+		ev->max_retrans_cnt = REQ_MAX_RC;
+		break;
+#endif
 	default:
 		dprintf(LOG_ERR, FNAME, "unexpected event state %d on %s",
 		    ev->state, ev->ifp->ifname);
 		exit(1);
 	}
 }
+void
+ctllog_debug(int level, const char *filename,int linenum,const char *fname, const char *fmt, ...)
+{
+	va_list ap;
+	char logbuf[LINE_MAX];
+	int printfname = 1;
+    if(!filename || !fname) return;
+	va_start(ap, fmt);
+	vsnprintf(logbuf, sizeof(logbuf), fmt, ap);
+
+	if (*fname == '\0')
+		printfname = 0;
+
+	if (foreground && debug_thresh >= level) {
+		time_t now;
+		struct tm *tm_now;
+		const char *month[] = {
+			"Jan", "Feb", "Mar", "Apr", "May", "Jun",
+			"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
+		};
+
+		if ((now = time(NULL)) < 0)
+			exit(1); /* XXX */
+		tm_now = localtime(&now);
+		fprintf(stderr, "%3s/%02d/%04d %02d:%02d:%02d: %s=%d=%s%s%s\n",
+		    month[tm_now->tm_mon], tm_now->tm_mday,
+		    tm_now->tm_year + 1900,
+		    tm_now->tm_hour, tm_now->tm_min, tm_now->tm_sec,
+		    filename,linenum,fname, printfname ? ": " : "",
+		    logbuf);
+	} else
+		syslog(level, "%s%s%s", fname, printfname ? ": " : "", logbuf);
+}
 
 void
 dhcp6_reset_timer(ev)
@@ -3173,6 +3353,14 @@
 		return ("RELEASE");
 	case DHCP6S_IDLE:
 		return ("IDLE");
+#ifdef ACTION_TEC_IPV6_CODE_FOR_CONFIRM
+	case DHCP6S_CONFIRM:
+		return ("CONFIRM");
+#endif
+#ifdef ACTION_TEC_IPV6_CODE_FOR_DECLINE
+	case DHCP6S_DECLINE:
+		return ("DECLINE");
+#endif
 	default:
 		return ("???"); /* XXX */
 	}
@@ -3240,6 +3428,7 @@
 		syslog(level, "%s%s%s", fname, printfname ? ": " : "", logbuf);
 }
 
+#if 0 //brcm: moved to addrconf.c
 int
 ifaddrconf(cmd, ifname, addr, plen, pltime, vltime)
 	ifaddrconf_cmd_t cmd;
@@ -3313,8 +3502,8 @@
 	if (ioctl(s, SIOGIFINDEX, &ifr) < 0) {
 		dprintf(LOG_NOTICE, FNAME, "failed to get the index of %s: %s",
 		    ifname, strerror(errno));
-		close(s); 
-		return (-1); 
+		close(s);
+		return (-1);
 	}
 	memcpy(&req.ifr6_addr, &addr->sin6_addr, sizeof(struct in6_addr));
 	req.ifr6_prefixlen = plen;
@@ -3347,6 +3536,7 @@
 	close(s);
 	return (0);
 }
+#endif
 
 int
 safefile(path)
diff -Naur dhcpv6-aei/common.h dhcpv6-aei-brcm/common.h
--- dhcpv6-aei/common.h	2007-03-21 06:52:57.000000000 -0300
+++ dhcpv6-aei-brcm/common.h	2019-06-13 11:48:57.543013322 -0300
@@ -2,7 +2,7 @@
 /*
  * Copyright (C) 1998 and 1999 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -14,7 +14,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -35,6 +35,9 @@
 #define IN6_IFF_INVALID (0)
 #endif
 
+#define FLNAME __FILE__
+#define LINENUM __LINE__
+
 #ifdef HAVE_ANSI_FUNC
 #define FNAME __func__
 #elif defined (HAVE_GCC_FUNCTION)
@@ -124,16 +127,34 @@
 /* search option for dhcp6_find_listval() */
 #define MATCHLIST_PREFIXLEN 0x1
 
+//brcm: moved from common.c
+#ifdef __linux__
+/* from /usr/include/linux/ipv6.h */
+
+struct in6_ifreq {
+	struct in6_addr ifr6_addr;
+	u_int32_t ifr6_prefixlen;
+	unsigned int ifr6_ifindex;
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+		u_int32_t ifr6_vltime;
+		u_int32_t ifr6_pltime;
+#endif
+};
+#endif
+
+
 /* common.c */
 typedef enum { IFADDRCONF_ADD, IFADDRCONF_REMOVE } ifaddrconf_cmd_t;
 extern int dhcp6_copy_list __P((struct dhcp6_list *, struct dhcp6_list *));
 extern void dhcp6_move_list __P((struct dhcp6_list *, struct dhcp6_list *));
 extern void dhcp6_clear_list __P((struct dhcp6_list *));
+extern void ctllog_debug __P((int, const char *,int ,const char *, const char *, ...));
+
 extern void dhcp6_clear_listval __P((struct dhcp6_listval *));
 extern struct dhcp6_listval *dhcp6_find_listval __P((struct dhcp6_list *,
     dhcp6_listval_type_t, void *, int));
 extern struct dhcp6_listval *dhcp6_add_listval __P((struct dhcp6_list *,
-    dhcp6_listval_type_t, void *, struct dhcp6_list *));
+    dhcp6_listval_type_t, void *, struct dhcp6_list *, int flag));
 extern int dhcp6_vbuf_copy __P((struct dhcp6_vbuf *, struct dhcp6_vbuf *));
 extern void dhcp6_vbuf_free __P((struct dhcp6_vbuf *));
 extern int dhcp6_vbuf_cmp __P((struct dhcp6_vbuf *, struct dhcp6_vbuf *));
@@ -156,7 +177,7 @@
 extern int in6_scope __P((struct in6_addr *));
 extern void setloglevel __P((int));
 extern void dprintf __P((int, const char *, const char *, ...));
-extern int get_duid __P((char *, struct duid *));
+extern int get_duid __P((char *, struct duid *, char *));
 extern void dhcp6_init_options __P((struct dhcp6_optinfo *));
 extern void dhcp6_clear_options __P((struct dhcp6_optinfo *));
 extern int dhcp6_copy_options __P((struct dhcp6_optinfo *,
diff -Naur dhcpv6-aei/config.c dhcpv6-aei-brcm/config.c
--- dhcpv6-aei/config.c	2008-06-15 04:48:41.000000000 -0300
+++ dhcpv6-aei-brcm/config.c	2019-06-13 11:48:57.543013322 -0300
@@ -275,7 +275,7 @@
 						dprintf(LOG_ERR, FNAME, "%s:%d "
 							"pool '%s' not found",
 							configfilename, cfl->line,
-					   		spec->name);
+							spec->name);
 						goto bad;
 					}
 					if (spec->vltime != DHCP6_DURATION_INFINITE &&
@@ -306,7 +306,7 @@
 			}
 		}
 	}
-	
+
 	return (0);
 
   bad:
@@ -487,7 +487,7 @@
 			if (pif->sla_len < 0 || pif->sla_len > 128) {
 				dprintf(LOG_ERR, FNAME, "%s:%d "
 				    "invalid SLA length: %d",
-				    configfilename, cfl->line, pif->sla_len); 
+				    configfilename, cfl->line, pif->sla_len);
 				goto bad;
 			}
 			break;
@@ -613,7 +613,7 @@
 						dprintf(LOG_ERR, FNAME, "%s:%d "
 							"pool '%s' not found",
 							configfilename, cfl->line,
-					   		spec->name);
+							spec->name);
 						goto bad;
 					}
 					if (spec->vltime != DHCP6_DURATION_INFINITE &&
@@ -757,7 +757,7 @@
 					    "for secret");
 					goto bad;
 				}
-				memcpy(kinfo->secret, secret, secretlen); 
+				memcpy(kinfo->secret, secret, secretlen);
 				kinfo->secretlen = secretlen;
 				break;
 			case KEYPARAM_EXPIRE:
@@ -809,7 +809,7 @@
 				}
 				lt = localtime(&now);
 				lt->tm_sec = 0;
-				
+
 				if (strptime(expire, "%Y-%m-%d %H:%M", lt)
 				    == NULL &&
 				    strptime(expire, "%m-%d %H:%M", lt)
@@ -1057,7 +1057,7 @@
 			return -1;
 		}
 		if (dhcp6_add_listval(list0, DHCP6_LISTVAL_ADDR6,
-		    cl->ptr, NULL) == NULL) {
+		    cl->ptr, NULL, 0) == NULL) {
 			dprintf(LOG_ERR, FNAME, "failed to add a %s server",
 			    optname);
 			return -1;
@@ -1113,7 +1113,7 @@
 
 		/* add the name */
 		if (dhcp6_add_listval(list0, DHCP6_LISTVAL_VBUF,
-		    &name_vbuf, NULL) == NULL) {
+		    &name_vbuf, NULL, 0) == NULL) {
 			dprintf(LOG_ERR, FNAME, "failed to add a %s name",
 			    optname);
 			dhcp6_vbuf_free(&name_vbuf);
@@ -1315,7 +1315,7 @@
 			free(ifp->scriptpath);
 		ifp->scriptpath = NULL;
 		ifp->authproto = DHCP6_AUTHPROTO_UNDEF;
-		ifp->authalgorithm = DHCP6_AUTHALG_UNDEF; 
+		ifp->authalgorithm = DHCP6_AUTHALG_UNDEF;
 		ifp->authrdm = DHCP6_AUTHRDM_UNDEF;
 
 		for (ifc = dhcp6_ifconflist; ifc; ifc = ifc->next) {
@@ -1586,7 +1586,7 @@
 				    configfilename, cfl->line, ifc->ifname);
 				return (-1);
 			}
-			ifc->authinfo = ainfo; 
+			ifc->authinfo = ainfo;
 			break;
 		case DHCPOPT_IA_PD:
 			switch (opcode) {
@@ -1699,7 +1699,7 @@
 					goto next; /* ignore it */
 				}
 				if (dhcp6_add_listval(&ifc->reqopt_list,
-				    DHCP6_LISTVAL_NUM, &opttype, NULL)
+				    DHCP6_LISTVAL_NUM, &opttype, NULL, 0)
 				    == NULL) {
 					dprintf(LOG_ERR, FNAME, "failed to "
 					    "configure an option");
@@ -1795,7 +1795,7 @@
 	}
 
 	/* insert the new prefix to the chain */
-	if (dhcp6_add_listval(head, type, &oprefix, NULL) == NULL) {
+	if (dhcp6_add_listval(head, type, &oprefix, NULL, 0) == NULL) {
 		return (-1);
 	}
 
@@ -2047,7 +2047,7 @@
 
 	dynconf->host = host;
 	TAILQ_INSERT_HEAD(&dynamic_hostconf_head, dynconf, link);
-	dynamic_hostconf_count++; 
+	dynamic_hostconf_count++;
 
 	dprintf(LOG_DEBUG, FNAME, "created host_conf (name=%s)", host->name);
 
@@ -2118,6 +2118,9 @@
 	}
 	pool->min = range->min;
 	pool->max = range->max;
+#ifdef SUPPORT_IANA_RR
+        pool->rr_idx = pool->min;
+#endif
 
 	return (pool);
 }
@@ -2127,7 +2130,7 @@
 	const char *name;
 {
 	struct pool_conf *pool = NULL;
-	
+
 	if (!name)
 		return (NULL);
 
@@ -2156,6 +2159,50 @@
 
 	dprintf(LOG_DEBUG, FNAME, "called (pool=%s)", pool->name);
 
+#ifdef SUPPORT_IANA_RR
+	for (cur = pool->rr_idx; in6_addr_cmp(&cur, &pool->max) <= 0;
+	    in6_addr_inc(&cur)) {
+		if (!is_leased(&cur) &&
+		    !IN6_IS_ADDR_MULTICAST(&cur) &&
+		    !IN6_IS_ADDR_LINKLOCAL(&cur) &&
+		    !IN6_IS_ADDR_SITELOCAL(&cur)) {
+			dprintf(LOG_DEBUG, FNAME, "found %s",
+				in6addr2str(&cur, 0));
+			*addr= cur;
+			// update rr_idx
+			pool->rr_idx = cur;
+			in6_addr_inc( & pool->rr_idx);
+			if( in6_addr_cmp(&pool->rr_idx, &pool->max) > 0 ) {
+				pool->rr_idx = pool->min;
+			}
+			return 1;
+		}
+
+		dprintf(LOG_DEBUG, FNAME, "next address %s",
+			in6addr2str(&cur, 0));
+	}
+	for (cur = pool->min; in6_addr_cmp(&cur, &pool->rr_idx) < 0;
+	    in6_addr_inc(&cur)) {
+		if (!is_leased(&cur) &&
+		    !IN6_IS_ADDR_MULTICAST(&cur) &&
+		    !IN6_IS_ADDR_LINKLOCAL(&cur) &&
+		    !IN6_IS_ADDR_SITELOCAL(&cur)) {
+			dprintf(LOG_DEBUG, FNAME, "found %s",
+				in6addr2str(&cur, 0));
+			*addr= cur;
+			// update rr_idx
+			pool->rr_idx = cur;
+			in6_addr_inc( & pool->rr_idx);
+			if( in6_addr_cmp(&pool->rr_idx, &pool->max) > 0 ) {
+				pool->rr_idx = pool->min;
+			}
+			return 1;
+		}
+
+		dprintf(LOG_DEBUG, FNAME, "next address %s",
+			in6addr2str(&cur, 0));
+	}
+#else
 	for (cur = pool->min; in6_addr_cmp(&cur, &pool->max) <= 0;
 	    in6_addr_inc(&cur)) {
 		if (!is_leased(&cur) &&
@@ -2171,6 +2218,7 @@
 		dprintf(LOG_DEBUG, FNAME, "next address %s",
 			in6addr2str(&cur, 0));
 	}
+#endif
 
 	dprintf(LOG_NOTICE, FNAME, "no available address");
 	return 0;
@@ -2202,7 +2250,71 @@
 	return (0);
 }
 
-static int 
+#ifdef AEI_DHCP6S_SERIALIZE
+int
+is_in_pool(addr)
+    struct in6_addr *addr;
+{
+    struct pool_conf *pool = NULL;
+
+    if (!addr)
+        return 0;
+
+    for (pool = pool_conflist; pool; pool = pool->next) {
+        if (in6_addr_cmp(addr, &pool->min) >= 0 &&
+            in6_addr_cmp(addr, &pool->max) <= 0) {
+            return (1);
+        }
+    }
+
+    return (0);
+}
+
+void getPoolNum(int *num, int *isGUA)
+{
+    int ula_pool = 0;
+    int gua_pool = 0;
+    struct pool_conf *pool = NULL;
+
+    for (pool = pool_conflist; pool; pool = pool->next)
+    {
+        dprintf(LOG_DEBUG, FNAME, "pool->name = %s", pool->name);
+        if(strncmp(pool->name, "IPv6ULAPool", strlen("IPv6ULAPool")) == 0)
+        {
+            ula_pool = 1;
+        }
+        else if(pool->name)
+        {
+            gua_pool = 1;
+        }
+    }
+
+    if(gua_pool && ula_pool)
+    {
+        *num = 2;
+    }
+    else if(gua_pool)
+         {
+             *num = 1;
+             *isGUA = 1;
+         }
+         else if(ula_pool)
+              {
+                  *num = 1;
+                  *isGUA = 0;
+              }
+              else
+              {
+                  dprintf(LOG_ERR, FNAME, "No valid pool!");
+                  *num = 0;
+              }
+
+    return;
+
+}
+#endif
+
+static int
 in6_addr_cmp(addr1, addr2)
 	struct in6_addr *addr1, *addr2;
 {
@@ -2210,7 +2322,7 @@
 
 	for (i = 0; i < 16; i++) {
 		if (addr1->s6_addr[i] != addr2->s6_addr[i]) {
-        	if (addr1->s6_addr[i] > addr2->s6_addr[i])
+		if (addr1->s6_addr[i] > addr2->s6_addr[i])
 				return (1);
 			else
 				return (-1);
diff -Naur dhcpv6-aei/config.h dhcpv6-aei-brcm/config.h
--- dhcpv6-aei/config.h	2008-06-15 04:48:41.000000000 -0300
+++ dhcpv6-aei-brcm/config.h	2019-06-13 11:48:57.543013322 -0300
@@ -44,6 +44,7 @@
 	struct in6_addr max;
 };
 
+#define SUPPORT_IANA_RR
 struct pool_conf {
 	struct pool_conf *next;
 
@@ -51,6 +52,9 @@
 
 	struct in6_addr min;
 	struct in6_addr max;
+#ifdef SUPPORT_IANA_RR
+	struct in6_addr rr_idx;
+#endif
 };
 
 /* per-interface information */
@@ -100,6 +104,10 @@
 #define AUTHPARAM_FLAGS_NOPREVRD	0x1
 
 	u_int64_t prevrd;	/* previous RD value provided by the peer */
+#ifdef CONFIG_IOT_RECONFIGURATION
+    int reconf_key_type;
+    char reconf_key[DHCP6_RECONFIGURE_AUTH_KEY_LENGTH];
+#endif
 };
 
 struct dhcp6_event {
@@ -161,8 +169,14 @@
 };
 
 /* client status code */
-enum {DHCP6S_INIT, DHCP6S_SOLICIT, DHCP6S_INFOREQ, DHCP6S_REQUEST,
-      DHCP6S_RENEW, DHCP6S_REBIND, DHCP6S_RELEASE, DHCP6S_IDLE};
+enum {DHCP6S_INIT,
+      DHCP6S_SOLICIT, DHCP6S_INFOREQ, DHCP6S_REQUEST,
+      DHCP6S_CONFIRM,
+      DHCP6S_RENEW, DHCP6S_REBIND, DHCP6S_RELEASE,
+      DHCP6S_DECLINE,
+      DHCP6S_RECONFIGURE,
+      DHCP6S_IDLE};
+
 
 struct prefix_ifconf {
 	TAILQ_ENTRY(prefix_ifconf) link;
@@ -271,9 +285,9 @@
        DHCPOPT_DNS, DHCPOPT_DNSNAME,
        DHCPOPT_IA_PD, DHCPOPT_IA_NA, DHCPOPT_NTP,
        DHCPOPT_REFRESHTIME,
-       DHCPOPT_NIS, DHCPOPT_NISNAME, 
-       DHCPOPT_NISP, DHCPOPT_NISPNAME, 
-       DHCPOPT_BCMCS, DHCPOPT_BCMCSNAME, 
+       DHCPOPT_NIS, DHCPOPT_NISNAME,
+       DHCPOPT_NISP, DHCPOPT_NISPNAME,
+       DHCPOPT_BCMCS, DHCPOPT_BCMCSNAME,
        CFLISTENT_GENERIC,
        IACONF_PIF, IACONF_PREFIX, IACONF_ADDR,
        DHCPOPT_SIP, DHCPOPT_SIPNAME,
@@ -324,6 +338,10 @@
 extern int configure_pool __P((struct cf_namelist *));
 extern struct pool_conf *find_pool __P((const char *));
 extern int is_available_in_pool __P((struct pool_conf *, struct in6_addr *));
+#ifdef AEI_DHCP6S_SERIALIZE
+extern int is_in_pool __P((struct in6_addr *));
+extern void getPoolNum __P((int *, int *));
+#endif
 extern int get_free_address_from_pool __P((struct pool_conf *,
 	struct in6_addr *));
 struct host_conf *create_dynamic_hostconf __P((struct duid *,
diff -Naur dhcpv6-aei/config.log dhcpv6-aei-brcm/config.log
--- dhcpv6-aei/config.log	1969-12-31 20:00:00.000000000 -0400
+++ dhcpv6-aei-brcm/config.log	2019-06-13 11:48:57.547013062 -0300
@@ -0,0 +1,1409 @@
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by configure, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ ./configure
+
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = builder-ubt1004
+uname -m = i686
+uname -r = 2.6.32-21-generic
+uname -s = Linux
+uname -v = #32-Ubuntu SMP Fri Apr 16 08:10:02 UTC 2010
+
+/usr/bin/uname -p = unknown
+/bin/uname -X     = unknown
+
+/bin/arch              = unknown
+/usr/bin/arch -k       = unknown
+/usr/convex/getsysinfo = unknown
+hostinfo               = unknown
+/bin/machine           = unknown
+/usr/bin/oslevel       = unknown
+/bin/universe          = unknown
+
+PATH: /usr/local/sbin
+PATH: /usr/local/bin
+PATH: /usr/sbin
+PATH: /usr/bin
+PATH: /sbin
+PATH: /bin
+PATH: /usr/games
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+configure:1338: checking for a BSD-compatible install
+configure:1393: result: /usr/bin/install -c
+configure:1404: checking whether make sets $(MAKE)
+configure:1424: result: yes
+configure:1479: checking for gcc
+configure:1495: found /usr/bin/gcc
+configure:1505: result: gcc
+configure:1749: checking for C compiler version
+configure:1752: gcc --version </dev/null >&5
+gcc (Ubuntu 4.4.3-4ubuntu5) 4.4.3
+Copyright (C) 2009 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:1755: $? = 0
+configure:1757: gcc -v </dev/null >&5
+Using built-in specs.
+Target: i486-linux-gnu
+Configured with: ../src/configure -v --with-pkgversion='Ubuntu 4.4.3-4ubuntu5' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --program-suffix=-4.4 --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-plugin --enable-objc-gc --enable-targets=all --disable-werror --with-arch-32=i486 --with-tune=generic --enable-checking=release --build=i486-linux-gnu --host=i486-linux-gnu --target=i486-linux-gnu
+Thread model: posix
+gcc version 4.4.3 (Ubuntu 4.4.3-4ubuntu5)
+configure:1760: $? = 0
+configure:1762: gcc -V </dev/null >&5
+gcc: '-V' option must have argument
+configure:1765: $? = 1
+configure:1788: checking for C compiler default output file name
+configure:1791: gcc    conftest.c  >&5
+configure:1794: $? = 0
+configure:1840: result: a.out
+configure:1845: checking whether the C compiler works
+configure:1851: ./a.out
+configure:1854: $? = 0
+configure:1871: result: yes
+configure:1878: checking whether we are cross compiling
+configure:1880: result: no
+configure:1883: checking for suffix of executables
+configure:1885: gcc -o conftest    conftest.c  >&5
+configure:1888: $? = 0
+configure:1913: result:
+configure:1919: checking for suffix of object files
+configure:1940: gcc -c   conftest.c >&5
+configure:1943: $? = 0
+configure:1965: result: o
+configure:1969: checking whether we are using the GNU C compiler
+configure:1993: gcc -c   conftest.c >&5
+configure:1999: $? = 0
+configure:2003: test -z
+			 || test ! -s conftest.err
+configure:2006: $? = 0
+configure:2009: test -s conftest.o
+configure:2012: $? = 0
+configure:2025: result: yes
+configure:2031: checking whether gcc accepts -g
+configure:2052: gcc -c -g  conftest.c >&5
+configure:2058: $? = 0
+configure:2062: test -z
+			 || test ! -s conftest.err
+configure:2065: $? = 0
+configure:2068: test -s conftest.o
+configure:2071: $? = 0
+configure:2082: result: yes
+configure:2099: checking for gcc option to accept ANSI C
+configure:2169: gcc  -c -g -O2  conftest.c >&5
+configure:2175: $? = 0
+configure:2179: test -z
+			 || test ! -s conftest.err
+configure:2182: $? = 0
+configure:2185: test -s conftest.o
+configure:2188: $? = 0
+configure:2206: result: none needed
+configure:2224: gcc -c -g -O2  conftest.c >&5
+conftest.c:2: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'me'
+configure:2230: $? = 1
+configure: failed program was:
+| #ifndef __cplusplus
+|   choke me
+| #endif
+configure:2368: checking how to run the C preprocessor
+configure:2403: gcc -E  conftest.c
+configure:2409: $? = 0
+configure:2441: gcc -E  conftest.c
+conftest.c:9:28: error: ac_nonexistent.h: No such file or directory
+configure:2447: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+|
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:2486: result: gcc -E
+configure:2510: gcc -E  conftest.c
+configure:2516: $? = 0
+configure:2548: gcc -E  conftest.c
+conftest.c:9:28: error: ac_nonexistent.h: No such file or directory
+configure:2554: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+|
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:2601: checking for bison
+configure:2617: found /usr/bin/bison
+configure:2627: result: bison -y
+configure:2643: checking for flex
+configure:2659: found /usr/bin/flex
+configure:2669: result: flex
+configure:2682: checking for yywrap in -lfl
+configure:2712: gcc -o conftest -g -O2   conftest.c -lfl   >&5
+configure:2718: $? = 0
+configure:2722: test -z
+			 || test ! -s conftest.err
+configure:2725: $? = 0
+configure:2728: test -s conftest
+configure:2731: $? = 0
+configure:2744: result: yes
+configure:2822: checking lex output file root
+configure:2833: flex conftest.l
+configure:2836: $? = 0
+configure:2848: result: lex.yy
+configure:2853: checking whether yytext is a pointer
+configure:2869: gcc -o conftest -g -O2   conftest.c  -lfl >&5
+configure:2875: $? = 0
+configure:2879: test -z
+			 || test ! -s conftest.err
+configure:2882: $? = 0
+configure:2885: test -s conftest
+configure:2888: $? = 0
+configure:2902: result: yes
+configure:2923: checking for sys/queue.h
+configure:2941: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:2947: $? = 0
+configure:2951: test -z
+			 || test ! -s conftest.err
+configure:2954: $? = 0
+configure:2957: test -s conftest.o
+configure:2960: $? = 0
+configure:2962: result: yes
+configure:2975: checking for egrep
+configure:2985: result: grep -E
+configure:3009: checking for getaddrinfo/getnameinfo library
+configure:3011: result: regular
+configure:3104: checking for getaddrinfo
+configure:3161: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3167: $? = 0
+configure:3171: test -z
+			 || test ! -s conftest.err
+configure:3174: $? = 0
+configure:3177: test -s conftest
+configure:3180: $? = 0
+configure:3192: result: yes
+configure:3216: checking for getnameinfo
+configure:3273: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3279: $? = 0
+configure:3283: test -z
+			 || test ! -s conftest.err
+configure:3286: $? = 0
+configure:3289: test -s conftest
+configure:3292: $? = 0
+configure:3304: result: yes
+configure:3328: checking for getifaddrs
+configure:3385: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3391: $? = 0
+configure:3395: test -z
+			 || test ! -s conftest.err
+configure:3398: $? = 0
+configure:3401: test -s conftest
+configure:3404: $? = 0
+configure:3416: result: yes
+configure:3440: checking for if_nametoindex
+configure:3497: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3503: $? = 0
+configure:3507: test -z
+			 || test ! -s conftest.err
+configure:3510: $? = 0
+configure:3513: test -s conftest
+configure:3516: $? = 0
+configure:3528: result: yes
+configure:3543: checking for strlcpy
+configure:3600: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+/tmp/ccRQioLL.o: In function `main':
+/home/leon/dhcpv6/wide-dhcpv6-20080615/conftest.c:53: undefined reference to `strlcpy'
+/tmp/ccRQioLL.o:(.data+0x0): undefined reference to `strlcpy'
+collect2: ld returned 1 exit status
+configure:3606: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+|
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| /* end confdefs.h.  */
+| /* Define strlcpy to an innocuous variant, in case <limits.h> declares strlcpy.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define strlcpy innocuous_strlcpy
+|
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char strlcpy (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+|
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+|
+| #undef strlcpy
+|
+| /* Override any gcc2 internal prototype to avoid an error.  */
+| #ifdef __cplusplus
+| extern "C"
+| {
+| #endif
+| /* We use char because int might match the return type of a gcc2
+|    builtin and then its argument prototype would still apply.  */
+| char strlcpy ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined (__stub_strlcpy) || defined (__stub___strlcpy)
+| choke me
+| #else
+| char (*f) () = strlcpy;
+| #endif
+| #ifdef __cplusplus
+| }
+| #endif
+|
+| int
+| main ()
+| {
+| return f != strlcpy;
+|   ;
+|   return 0;
+| }
+configure:3631: result: no
+configure:3543: checking for strlcat
+configure:3600: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+/tmp/ccyAH3OQ.o: In function `main':
+/home/leon/dhcpv6/wide-dhcpv6-20080615/conftest.c:53: undefined reference to `strlcat'
+/tmp/ccyAH3OQ.o:(.data+0x0): undefined reference to `strlcat'
+collect2: ld returned 1 exit status
+configure:3606: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+|
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| /* end confdefs.h.  */
+| /* Define strlcat to an innocuous variant, in case <limits.h> declares strlcat.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define strlcat innocuous_strlcat
+|
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char strlcat (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+|
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+|
+| #undef strlcat
+|
+| /* Override any gcc2 internal prototype to avoid an error.  */
+| #ifdef __cplusplus
+| extern "C"
+| {
+| #endif
+| /* We use char because int might match the return type of a gcc2
+|    builtin and then its argument prototype would still apply.  */
+| char strlcat ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined (__stub_strlcat) || defined (__stub___strlcat)
+| choke me
+| #else
+| char (*f) () = strlcat;
+| #endif
+| #ifdef __cplusplus
+| }
+| #endif
+|
+| int
+| main ()
+| {
+| return f != strlcat;
+|   ;
+|   return 0;
+| }
+configure:3631: result: no
+configure:3655: checking for daemon
+configure:3712: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3718: $? = 0
+configure:3722: test -z
+			 || test ! -s conftest.err
+configure:3725: $? = 0
+configure:3728: test -s conftest
+configure:3731: $? = 0
+configure:3743: result: yes
+configure:3767: checking for warnx
+configure:3824: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:3830: $? = 0
+configure:3834: test -z
+			 || test ! -s conftest.err
+configure:3837: $? = 0
+configure:3840: test -s conftest
+configure:3843: $? = 0
+configure:3855: result: yes
+configure:3876: checking for ANSI C header files
+configure:3901: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:3907: $? = 0
+configure:3911: test -z
+			 || test ! -s conftest.err
+configure:3914: $? = 0
+configure:3917: test -s conftest.o
+configure:3920: $? = 0
+configure:4009: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+conftest.c: In function 'main':
+conftest.c:33: warning: incompatible implicit declaration of built-in function 'exit'
+configure:4012: $? = 0
+configure:4014: ./conftest
+configure:4017: $? = 0
+configure:4032: result: yes
+configure:4056: checking for sys/types.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for sys/stat.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for stdlib.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for string.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for memory.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for strings.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for inttypes.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for stdint.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4056: checking for unistd.h
+configure:4072: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4078: $? = 0
+configure:4082: test -z
+			 || test ! -s conftest.err
+configure:4085: $? = 0
+configure:4088: test -s conftest.o
+configure:4091: $? = 0
+configure:4102: result: yes
+configure:4133: checking fcntl.h usability
+configure:4145: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4151: $? = 0
+configure:4155: test -z
+			 || test ! -s conftest.err
+configure:4158: $? = 0
+configure:4161: test -s conftest.o
+configure:4164: $? = 0
+configure:4174: result: yes
+configure:4178: checking fcntl.h presence
+configure:4188: gcc -E  conftest.c
+configure:4194: $? = 0
+configure:4214: result: yes
+configure:4249: checking for fcntl.h
+configure:4256: result: yes
+configure:4133: checking sys/ioctl.h usability
+configure:4145: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4151: $? = 0
+configure:4155: test -z
+			 || test ! -s conftest.err
+configure:4158: $? = 0
+configure:4161: test -s conftest.o
+configure:4164: $? = 0
+configure:4174: result: yes
+configure:4178: checking sys/ioctl.h presence
+configure:4188: gcc -E  conftest.c
+configure:4194: $? = 0
+configure:4214: result: yes
+configure:4249: checking for sys/ioctl.h
+configure:4256: result: yes
+configure:4133: checking sys/time.h usability
+configure:4145: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4151: $? = 0
+configure:4155: test -z
+			 || test ! -s conftest.err
+configure:4158: $? = 0
+configure:4161: test -s conftest.o
+configure:4164: $? = 0
+configure:4174: result: yes
+configure:4178: checking sys/time.h presence
+configure:4188: gcc -E  conftest.c
+configure:4194: $? = 0
+configure:4214: result: yes
+configure:4249: checking for sys/time.h
+configure:4256: result: yes
+configure:4133: checking syslog.h usability
+configure:4145: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4151: $? = 0
+configure:4155: test -z
+			 || test ! -s conftest.err
+configure:4158: $? = 0
+configure:4161: test -s conftest.o
+configure:4164: $? = 0
+configure:4174: result: yes
+configure:4178: checking syslog.h presence
+configure:4188: gcc -E  conftest.c
+configure:4194: $? = 0
+configure:4214: result: yes
+configure:4249: checking for syslog.h
+configure:4256: result: yes
+configure:4124: checking for unistd.h
+configure:4129: result: yes
+configure:4133: checking ifaddrs.h usability
+configure:4145: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4151: $? = 0
+configure:4155: test -z
+			 || test ! -s conftest.err
+configure:4158: $? = 0
+configure:4161: test -s conftest.o
+configure:4164: $? = 0
+configure:4174: result: yes
+configure:4178: checking ifaddrs.h presence
+configure:4188: gcc -E  conftest.c
+configure:4194: $? = 0
+configure:4214: result: yes
+configure:4249: checking for ifaddrs.h
+configure:4256: result: yes
+configure:4269: checking for socklen_t
+configure:4288: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4294: $? = 0
+configure:4298: test -z
+			 || test ! -s conftest.err
+configure:4301: $? = 0
+configure:4304: test -s conftest.o
+configure:4307: $? = 0
+configure:4309: result: yes
+configure:4386: checking for an ANSI C-conforming const
+configure:4453: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4459: $? = 0
+configure:4463: test -z
+			 || test ! -s conftest.err
+configure:4466: $? = 0
+configure:4469: test -s conftest.o
+configure:4472: $? = 0
+configure:4483: result: yes
+configure:4493: checking for size_t
+configure:4517: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4523: $? = 0
+configure:4527: test -z
+			 || test ! -s conftest.err
+configure:4530: $? = 0
+configure:4533: test -s conftest.o
+configure:4536: $? = 0
+configure:4547: result: yes
+configure:4559: checking whether time.h and sys/time.h may both be included
+configure:4584: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4590: $? = 0
+configure:4594: test -z
+			 || test ! -s conftest.err
+configure:4597: $? = 0
+configure:4600: test -s conftest.o
+configure:4603: $? = 0
+configure:4614: result: yes
+configure:4624: checking whether struct tm is in sys/time.h or time.h
+configure:4647: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4653: $? = 0
+configure:4657: test -z
+			 || test ! -s conftest.err
+configure:4660: $? = 0
+configure:4663: test -s conftest.o
+configure:4666: $? = 0
+configure:4677: result: time.h
+configure:4687: checking for struct tm.tm_zone
+configure:4713: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4719: $? = 0
+configure:4723: test -z
+			 || test ! -s conftest.err
+configure:4726: $? = 0
+configure:4729: test -s conftest.o
+configure:4732: $? = 0
+configure:4792: result: yes
+configure:4877: checking for sig_atomic_t
+configure:4903: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:4909: $? = 0
+configure:4913: test -z
+			 || test ! -s conftest.err
+configure:4916: $? = 0
+configure:4919: test -s conftest.o
+configure:4922: $? = 0
+configure:4933: result: yes
+configure:4951: checking whether getpgrp requires zero arguments
+configure:4973: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+conftest.c: In function 'main':
+conftest.c:73: error: too many arguments to function 'getpgrp'
+configure:4979: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+|
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| /* end confdefs.h.  */
+| #include <stdio.h>
+| #if HAVE_SYS_TYPES_H
+| # include <sys/types.h>
+| #endif
+| #if HAVE_SYS_STAT_H
+| # include <sys/stat.h>
+| #endif
+| #if STDC_HEADERS
+| # include <stdlib.h>
+| # include <stddef.h>
+| #else
+| # if HAVE_STDLIB_H
+| #  include <stdlib.h>
+| # endif
+| #endif
+| #if HAVE_STRING_H
+| # if !STDC_HEADERS && HAVE_MEMORY_H
+| #  include <memory.h>
+| # endif
+| # include <string.h>
+| #endif
+| #if HAVE_STRINGS_H
+| # include <strings.h>
+| #endif
+| #if HAVE_INTTYPES_H
+| # include <inttypes.h>
+| #else
+| # if HAVE_STDINT_H
+| #  include <stdint.h>
+| # endif
+| #endif
+| #if HAVE_UNISTD_H
+| # include <unistd.h>
+| #endif
+| int
+| main ()
+| {
+| getpgrp (0);
+|   ;
+|   return 0;
+| }
+configure:5004: result: yes
+configure:5015: checking whether gcc needs -traditional
+configure:5057: result: no
+configure:5064: checking whether setpgrp takes no argument
+configure:5096: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+conftest.c: In function 'main':
+conftest.c:47: warning: incompatible implicit declaration of built-in function 'exit'
+conftest.c:47: error: too many arguments to function 'setpgrp'
+configure:5099: $? = 1
+configure: program exited with status 1
+configure: failed program was:
+| /* confdefs.h.  */
+|
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| #define GETPGRP_VOID 1
+| /* end confdefs.h.  */
+| #if HAVE_UNISTD_H
+| # include <unistd.h>
+| #endif
+|
+| int
+| main ()
+| {
+| /* If this system has a BSD-style setpgrp which takes arguments,
+|   setpgrp(1, 1) will fail with ESRCH and return -1, in that case
+|   exit successfully. */
+|   exit (setpgrp (1,1) == -1 ? 0 : 1);
+|   ;
+|   return 0;
+| }
+configure:5118: result: yes
+configure:5128: checking return type of signal handlers
+configure:5159: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:5165: $? = 0
+configure:5169: test -z
+			 || test ! -s conftest.err
+configure:5172: $? = 0
+configure:5175: test -s conftest.o
+configure:5178: $? = 0
+configure:5189: result: void
+configure:5203: checking for mktime
+configure:5260: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:5266: $? = 0
+configure:5270: test -z
+			 || test ! -s conftest.err
+configure:5273: $? = 0
+configure:5276: test -s conftest
+configure:5279: $? = 0
+configure:5291: result: yes
+configure:5203: checking for select
+configure:5260: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:5266: $? = 0
+configure:5270: test -z
+			 || test ! -s conftest.err
+configure:5273: $? = 0
+configure:5276: test -s conftest
+configure:5279: $? = 0
+configure:5291: result: yes
+configure:5203: checking for socket
+configure:5260: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+configure:5266: $? = 0
+configure:5270: test -z
+			 || test ! -s conftest.err
+configure:5273: $? = 0
+configure:5276: test -s conftest
+configure:5279: $? = 0
+configure:5291: result: yes
+configure:5305: checking for clock_gettime
+configure:5362: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+/tmp/ccnomzde.o: In function `main':
+/home/leon/dhcpv6/wide-dhcpv6-20080615/conftest.c:81: undefined reference to `clock_gettime'
+/tmp/ccnomzde.o:(.data+0x0): undefined reference to `clock_gettime'
+collect2: ld returned 1 exit status
+configure:5368: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+|
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| #define GETPGRP_VOID 1
+| #define SETPGRP_VOID 1
+| #define RETSIGTYPE void
+| #define HAVE_MKTIME 1
+| #define HAVE_SELECT 1
+| #define HAVE_SOCKET 1
+| /* end confdefs.h.  */
+| /* Define clock_gettime to an innocuous variant, in case <limits.h> declares clock_gettime.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define clock_gettime innocuous_clock_gettime
+|
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char clock_gettime (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+|
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+|
+| #undef clock_gettime
+|
+| /* Override any gcc2 internal prototype to avoid an error.  */
+| #ifdef __cplusplus
+| extern "C"
+| {
+| #endif
+| /* We use char because int might match the return type of a gcc2
+|    builtin and then its argument prototype would still apply.  */
+| char clock_gettime ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined (__stub_clock_gettime) || defined (__stub___clock_gettime)
+| choke me
+| #else
+| char (*f) () = clock_gettime;
+| #endif
+| #ifdef __cplusplus
+| }
+| #endif
+|
+| int
+| main ()
+| {
+| return f != clock_gettime;
+|   ;
+|   return 0;
+| }
+configure:5393: result: no
+configure:5404: checking for local DB directory
+configure:5414: result: /var/db
+configure:5422: checking for arc4random
+configure:5479: gcc -o conftest -g -O2 -I$(srcdir)   conftest.c  >&5
+/tmp/ccTjrGmj.o: In function `main':
+/home/leon/dhcpv6/wide-dhcpv6-20080615/conftest.c:81: undefined reference to `arc4random'
+/tmp/ccTjrGmj.o:(.data+0x0): undefined reference to `arc4random'
+collect2: ld returned 1 exit status
+configure:5485: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+|
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| #define GETPGRP_VOID 1
+| #define SETPGRP_VOID 1
+| #define RETSIGTYPE void
+| #define HAVE_MKTIME 1
+| #define HAVE_SELECT 1
+| #define HAVE_SOCKET 1
+| /* end confdefs.h.  */
+| /* Define arc4random to an innocuous variant, in case <limits.h> declares arc4random.
+|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+| #define arc4random innocuous_arc4random
+|
+| /* System header to define __stub macros and hopefully few prototypes,
+|     which can conflict with char arc4random (); below.
+|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+|     <limits.h> exists even on freestanding compilers.  */
+|
+| #ifdef __STDC__
+| # include <limits.h>
+| #else
+| # include <assert.h>
+| #endif
+|
+| #undef arc4random
+|
+| /* Override any gcc2 internal prototype to avoid an error.  */
+| #ifdef __cplusplus
+| extern "C"
+| {
+| #endif
+| /* We use char because int might match the return type of a gcc2
+|    builtin and then its argument prototype would still apply.  */
+| char arc4random ();
+| /* The GNU C library defines this for functions which it implements
+|     to always fail with ENOSYS.  Some functions are actually named
+|     something starting with __ and the normal name is an alias.  */
+| #if defined (__stub_arc4random) || defined (__stub___arc4random)
+| choke me
+| #else
+| char (*f) () = arc4random;
+| #endif
+| #ifdef __cplusplus
+| }
+| #endif
+|
+| int
+| main ()
+| {
+| return f != arc4random;
+|   ;
+|   return 0;
+| }
+configure:5510: result: no
+configure:5531: checking if --enable-pedant option is specified
+configure:5542: result: no
+configure:5545: checking ANSI predeclared __func__
+configure:5563: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+conftest.c: In function 'func':
+conftest.c:46: warning: incompatible implicit declaration of built-in function 'printf'
+configure:5569: $? = 0
+configure:5573: test -z
+			 || test ! -s conftest.err
+configure:5576: $? = 0
+configure:5579: test -s conftest.o
+configure:5582: $? = 0
+configure:5584: result: yes
+configure:5665: checking checking the existence TAILQ_FOREACH_REVERSE
+configure:5686: result: yes
+configure:5696: checking argument order of TAILQ_FOREACH_REVERSE
+configure:5728: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+In file included from /usr/include/stdio.h:907,
+                 from conftest.c:48:
+/usr/include/bits/stdio.h: In function 'main':
+/usr/include/bits/stdio.h:46: error: nested function 'getchar' declared 'extern'
+/usr/include/bits/stdio.h:45: error: static declaration of 'getchar' follows non-static declaration
+/usr/include/stdio.h:520: note: previous declaration of 'getchar' was here
+/usr/include/bits/stdio.h:55: error: nested function 'fgetc_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:54: error: static declaration of 'fgetc_unlocked' follows non-static declaration
+/usr/include/stdio.h:543: note: previous declaration of 'fgetc_unlocked' was here
+/usr/include/bits/stdio.h:65: error: nested function 'getc_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:64: error: static declaration of 'getc_unlocked' follows non-static declaration
+/usr/include/stdio.h:532: note: previous declaration of 'getc_unlocked' was here
+/usr/include/bits/stdio.h:72: error: nested function 'getchar_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:71: error: static declaration of 'getchar_unlocked' follows non-static declaration
+/usr/include/stdio.h:533: note: previous declaration of 'getchar_unlocked' was here
+/usr/include/bits/stdio.h:81: error: nested function 'putchar' declared 'extern'
+/usr/include/bits/stdio.h:80: error: static declaration of 'putchar' follows non-static declaration
+/usr/include/bits/stdio.h:90: error: nested function 'fputc_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:89: error: static declaration of 'fputc_unlocked' follows non-static declaration
+/usr/include/bits/stdio.h:100: error: nested function 'putc_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:99: error: static declaration of 'putc_unlocked' follows non-static declaration
+/usr/include/bits/stdio.h:107: error: nested function 'putchar_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:106: error: static declaration of 'putchar_unlocked' follows non-static declaration
+/usr/include/bits/stdio.h:127: error: nested function 'feof_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:126: error: static declaration of 'feof_unlocked' follows non-static declaration
+/usr/include/stdio.h:809: note: previous declaration of 'feof_unlocked' was here
+/usr/include/bits/stdio.h:134: error: nested function 'ferror_unlocked' declared 'extern'
+/usr/include/bits/stdio.h:133: error: static declaration of 'ferror_unlocked' follows non-static declaration
+/usr/include/stdio.h:810: note: previous declaration of 'ferror_unlocked' was here
+In file included from /usr/include/stdio.h:910,
+                 from conftest.c:48:
+/usr/include/bits/stdio2.h:33: error: nested function 'sprintf' declared 'extern'
+/usr/include/bits/stdio2.h:32: error: static declaration of 'sprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:46: error: nested function 'vsprintf' declared 'extern'
+/usr/include/bits/stdio2.h:44: error: static declaration of 'vsprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:64: error: nested function 'snprintf' declared 'extern'
+/usr/include/bits/stdio2.h:62: error: static declaration of 'snprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:77: error: nested function 'vsnprintf' declared 'extern'
+/usr/include/bits/stdio2.h:75: error: static declaration of 'vsnprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:97: error: nested function 'fprintf' declared 'extern'
+/usr/include/bits/stdio2.h:96: error: static declaration of 'fprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:104: error: nested function 'printf' declared 'extern'
+/usr/include/bits/stdio2.h:103: error: static declaration of 'printf' follows non-static declaration
+/usr/include/bits/stdio2.h:116: error: nested function 'vprintf' declared 'extern'
+/usr/include/bits/stdio2.h:115: error: static declaration of 'vprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:127: error: nested function 'vfprintf' declared 'extern'
+/usr/include/bits/stdio2.h:125: error: static declaration of 'vfprintf' follows non-static declaration
+/usr/include/bits/stdio2.h:227: error: nested function 'gets' declared 'extern'
+/usr/include/bits/stdio2.h:226: error: static declaration of 'gets' follows non-static declaration
+/usr/include/stdio.h:612: note: previous declaration of 'gets' was here
+/usr/include/bits/stdio2.h:246: error: nested function 'fgets' declared 'extern'
+/usr/include/bits/stdio2.h:245: error: static declaration of 'fgets' follows non-static declaration
+/usr/include/stdio.h:604: note: previous declaration of 'fgets' was here
+/usr/include/bits/stdio2.h:276: error: nested function 'fread' declared 'extern'
+/usr/include/bits/stdio2.h:274: error: static declaration of 'fread' follows non-static declaration
+/usr/include/stdio.h:682: note: previous declaration of 'fread' was here
+/usr/include/bits/stdio2.h:337: error: nested function 'fread_unlocked' declared 'extern'
+/usr/include/bits/stdio2.h:335: error: static declaration of 'fread_unlocked' follows non-static declaration
+/usr/include/stdio.h:710: note: previous declaration of 'fread_unlocked' was here
+configure:5734: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+|
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| #define GETPGRP_VOID 1
+| #define SETPGRP_VOID 1
+| #define RETSIGTYPE void
+| #define HAVE_MKTIME 1
+| #define HAVE_SELECT 1
+| #define HAVE_SOCKET 1
+| #define HAVE_ANSI_FUNC 1
+| /* end confdefs.h.  */
+|
+| int
+| main ()
+| {
+|
+| 	#include <stdio.h>
+| 	#include <sys/queue.h>
+|
+| 	TAILQ_HEAD(tailhead, entry) head = TAILQ_HEAD_INITIALIZER(head);
+| 	struct entry {
+| 		TAILQ_ENTRY(entry) entries;
+| 	} *p;
+|
+| 	int i;
+| 	struct tailhead *headp;
+|
+| 	TAILQ_FOREACH_REVERSE(p, headp, tailhead, entries) {
+| 	}
+|
+|   ;
+|   return 0;
+| }
+configure:5759: result: old
+configure:5769: checking if you have a length field in struct sockaddr*
+configure:5796: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+conftest.c: In function 'main':
+conftest.c:53: error: 'struct sockaddr' has no member named 'sa_len'
+configure:5802: $? = 1
+configure: failed program was:
+| /* confdefs.h.  */
+|
+| #define PACKAGE_NAME ""
+| #define PACKAGE_TARNAME ""
+| #define PACKAGE_VERSION ""
+| #define PACKAGE_STRING ""
+| #define PACKAGE_BUGREPORT ""
+| #define YYTEXT_POINTER 1
+| #define HAVE_GETADDRINFO 1
+| #define HAVE_GETNAMEINFO 1
+| #define HAVE_GETIFADDRS 1
+| #define HAVE_IF_NAMETOINDEX 1
+| #define HAVE_DAEMON 1
+| #define HAVE_WARNX 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_FCNTL_H 1
+| #define HAVE_SYS_IOCTL_H 1
+| #define HAVE_SYS_TIME_H 1
+| #define HAVE_SYSLOG_H 1
+| #define HAVE_UNISTD_H 1
+| #define HAVE_IFADDRS_H 1
+| #define TIME_WITH_SYS_TIME 1
+| #define HAVE_STRUCT_TM_TM_ZONE 1
+| #define HAVE_TM_ZONE 1
+| #define HAVE_SIG_ATOMIC_T 1
+| #define GETPGRP_VOID 1
+| #define SETPGRP_VOID 1
+| #define RETSIGTYPE void
+| #define HAVE_MKTIME 1
+| #define HAVE_SELECT 1
+| #define HAVE_SOCKET 1
+| #define HAVE_ANSI_FUNC 1
+| #define HAVE_TAILQ_FOREACH_REVERSE_OLD 1
+| /* end confdefs.h.  */
+|
+|  #include <sys/types.h>
+|  #include <sys/socket.h>
+|
+| int
+| main ()
+| {
+|
+|  struct sockaddr a;
+|  a.sa_len = 1;
+|
+|   ;
+|   return 0;
+| }
+configure:5827: result: no
+configure:5837: checking the owner of the programs
+configure:5847: result: bin
+configure:5851: checking the group owner of the programs
+configure:5861: result: bin
+configure:5879: checking stdarg.h usability
+configure:5891: gcc -c -g -O2 -I$(srcdir)  conftest.c >&5
+configure:5897: $? = 0
+configure:5901: test -z
+			 || test ! -s conftest.err
+configure:5904: $? = 0
+configure:5907: test -s conftest.o
+configure:5910: $? = 0
+configure:5920: result: yes
+configure:5924: checking stdarg.h presence
+configure:5934: gcc -E  conftest.c
+configure:5940: $? = 0
+configure:5960: result: yes
+configure:5995: checking for stdarg.h
+configure:6002: result: yes
+configure:6143: creating ./config.status
+
+## ---------------------- ##
+## Running config.status. ##
+## ---------------------- ##
+
+This file was extended by config.status, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    =
+  CONFIG_HEADERS  =
+  CONFIG_LINKS    =
+  CONFIG_COMMANDS =
+  $ ./config.status
+
+on builder-ubt1004
+
+config.status:649: creating Makefile
+
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+
+ac_cv_c_compiler_gnu=yes
+ac_cv_c_const=yes
+ac_cv_env_CC_set=
+ac_cv_env_CC_value=
+ac_cv_env_CFLAGS_set=
+ac_cv_env_CFLAGS_value=
+ac_cv_env_CPPFLAGS_set=
+ac_cv_env_CPPFLAGS_value=
+ac_cv_env_CPP_set=
+ac_cv_env_CPP_value=
+ac_cv_env_LDFLAGS_set=
+ac_cv_env_LDFLAGS_value=
+ac_cv_env_build_alias_set=
+ac_cv_env_build_alias_value=
+ac_cv_env_host_alias_set=
+ac_cv_env_host_alias_value=
+ac_cv_env_target_alias_set=
+ac_cv_env_target_alias_value=
+ac_cv_exeext=
+ac_cv_func_arc4random=no
+ac_cv_func_clock_gettime=no
+ac_cv_func_daemon=yes
+ac_cv_func_getaddrinfo=yes
+ac_cv_func_getifaddrs=yes
+ac_cv_func_getnameinfo=yes
+ac_cv_func_getpgrp_void=yes
+ac_cv_func_if_nametoindex=yes
+ac_cv_func_mktime=yes
+ac_cv_func_select=yes
+ac_cv_func_setpgrp_void=yes
+ac_cv_func_socket=yes
+ac_cv_func_strlcat=no
+ac_cv_func_strlcpy=no
+ac_cv_func_warnx=yes
+ac_cv_header_fcntl_h=yes
+ac_cv_header_ifaddrs_h=yes
+ac_cv_header_inttypes_h=yes
+ac_cv_header_memory_h=yes
+ac_cv_header_stdarg_h=yes
+ac_cv_header_stdc=yes
+ac_cv_header_stdint_h=yes
+ac_cv_header_stdlib_h=yes
+ac_cv_header_string_h=yes
+ac_cv_header_strings_h=yes
+ac_cv_header_sys_ioctl_h=yes
+ac_cv_header_sys_stat_h=yes
+ac_cv_header_sys_time_h=yes
+ac_cv_header_sys_types_h=yes
+ac_cv_header_syslog_h=yes
+ac_cv_header_time=yes
+ac_cv_header_unistd_h=yes
+ac_cv_lib_fl_yywrap=yes
+ac_cv_member_struct_tm_tm_zone=yes
+ac_cv_objext=o
+ac_cv_path_install='/usr/bin/install -c'
+ac_cv_prog_CPP='gcc -E'
+ac_cv_prog_LEX=flex
+ac_cv_prog_YACC='bison -y'
+ac_cv_prog_ac_ct_CC=gcc
+ac_cv_prog_cc_g=yes
+ac_cv_prog_cc_stdc=
+ac_cv_prog_egrep='grep -E'
+ac_cv_prog_gcc_traditional=no
+ac_cv_prog_lex_root=lex.yy
+ac_cv_prog_lex_yytext_pointer=yes
+ac_cv_prog_make_make_set=yes
+ac_cv_struct_tm=time.h
+ac_cv_type_sig_atomic_t=yes
+ac_cv_type_signal=void
+ac_cv_type_size_t=yes
+ts_cv_sa_len=no
+
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+
+CC='gcc'
+CFLAGS='-g -O2 -I$(srcdir)'
+CPP='gcc -E'
+CPPFLAGS=''
+DEFS='-DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\" -DYYTEXT_POINTER=1 -DHAVE_GETADDRINFO=1 -DHAVE_GETNAMEINFO=1 -DHAVE_GETIFADDRS=1 -DHAVE_IF_NAMETOINDEX=1 -DHAVE_DAEMON=1 -DHAVE_WARNX=1 -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_FCNTL_H=1 -DHAVE_SYS_IOCTL_H=1 -DHAVE_SYS_TIME_H=1 -DHAVE_SYSLOG_H=1 -DHAVE_UNISTD_H=1 -DHAVE_IFADDRS_H=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_STRUCT_TM_TM_ZONE=1 -DHAVE_TM_ZONE=1 -DHAVE_SIG_ATOMIC_T=1 -DGETPGRP_VOID=1 -DSETPGRP_VOID=1 -DRETSIGTYPE=void -DHAVE_MKTIME=1 -DHAVE_SELECT=1 -DHAVE_SOCKET=1 -DHAVE_ANSI_FUNC=1 -DHAVE_TAILQ_FOREACH_REVERSE_OLD=1 -DHAVE_STDARG_H=1 '
+ECHO_C=''
+ECHO_N='-n'
+ECHO_T=''
+EGREP='grep -E'
+EXEEXT=''
+INSTALL_DATA='${INSTALL} -m 644'
+INSTALL_PROGRAM='${INSTALL}'
+INSTALL_SCRIPT='${INSTALL}'
+LDFLAGS=''
+LEX='flex'
+LEXLIB='-lfl'
+LEX_OUTPUT_ROOT='lex.yy'
+LIBOBJS=' strlcpy$U.o strlcat$U.o arc4random$U.o'
+LIBS=''
+LTLIBOBJS=' strlcpy$U.lo strlcat$U.lo arc4random$U.lo'
+OBJEXT='o'
+PACKAGE_BUGREPORT=''
+PACKAGE_NAME=''
+PACKAGE_STRING=''
+PACKAGE_TARNAME=''
+PACKAGE_VERSION=''
+PATH_SEPARATOR=':'
+SET_MAKE=''
+SHELL='/bin/sh'
+YACC='bison -y'
+ac_ct_CC='gcc'
+bindir='${exec_prefix}/bin'
+build_alias=''
+datadir='${prefix}/share'
+exec_prefix='${prefix}'
+group='bin'
+host_alias=''
+includedir='${prefix}/include'
+infodir='${prefix}/info'
+libdir='${exec_prefix}/lib'
+libexecdir='${exec_prefix}/libexec'
+localdbdir='/var/db'
+localstatedir='${prefix}/var'
+mandir='${prefix}/man'
+oldincludedir='/usr/include'
+prefix='/usr/local'
+program_transform_name='s,x,x,'
+sbindir='${exec_prefix}/sbin'
+sharedstatedir='${prefix}/com'
+sysconfdir='${prefix}/etc'
+target_alias=''
+user='bin'
+
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+
+#define GETPGRP_VOID 1
+#define HAVE_ANSI_FUNC 1
+#define HAVE_DAEMON 1
+#define HAVE_FCNTL_H 1
+#define HAVE_GETADDRINFO 1
+#define HAVE_GETIFADDRS 1
+#define HAVE_GETNAMEINFO 1
+#define HAVE_IFADDRS_H 1
+#define HAVE_IF_NAMETOINDEX 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_MKTIME 1
+#define HAVE_SELECT 1
+#define HAVE_SIG_ATOMIC_T 1
+#define HAVE_SOCKET 1
+#define HAVE_STDARG_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_STRING_H 1
+#define HAVE_STRUCT_TM_TM_ZONE 1
+#define HAVE_SYSLOG_H 1
+#define HAVE_SYS_IOCTL_H 1
+#define HAVE_SYS_STAT_H 1
+#define HAVE_SYS_TIME_H 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_TAILQ_FOREACH_REVERSE_OLD 1
+#define HAVE_TM_ZONE 1
+#define HAVE_UNISTD_H 1
+#define HAVE_UNISTD_H 1
+#define HAVE_WARNX 1
+#define PACKAGE_BUGREPORT ""
+#define PACKAGE_NAME ""
+#define PACKAGE_STRING ""
+#define PACKAGE_TARNAME ""
+#define PACKAGE_VERSION ""
+#define RETSIGTYPE void
+#define SETPGRP_VOID 1
+#define STDC_HEADERS 1
+#define TIME_WITH_SYS_TIME 1
+#define YYTEXT_POINTER 1
+
+configure: exit 0
diff -Naur dhcpv6-aei/config.status dhcpv6-aei-brcm/config.status
--- dhcpv6-aei/config.status	1969-12-31 20:00:00.000000000 -0400
+++ dhcpv6-aei-brcm/config.status	2019-06-13 11:48:57.547013062 -0300
@@ -0,0 +1,723 @@
+#! /bin/sh
+# Generated by configure.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=${CONFIG_SHELL-/bin/sh}
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+	  /^X\/\(\/\).*/{ s//\1/; q; }
+	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+config_files=" Makefile"
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Report bugs to <bug-autoconf@gnu.org>."
+ac_cs_version="\
+config.status
+configured by ./configure, generated by GNU Autoconf 2.59,
+  with options \"\"
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=.
+INSTALL="/usr/bin/install -c"
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+if $ac_cs_recheck; then
+  echo "running /bin/sh ./configure "  $ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec /bin/sh ./configure  $ac_configure_extra_args --no-create --no-recursion
+fi
+
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t$/@;t t/; /@;t t$/s/[\\&,]/\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t$/,;t t/' >$tmp/subs.sed <<\CEOF
+s,@SHELL@,/bin/sh,;t t
+s,@PATH_SEPARATOR@,:,;t t
+s,@PACKAGE_NAME@,,;t t
+s,@PACKAGE_TARNAME@,,;t t
+s,@PACKAGE_VERSION@,,;t t
+s,@PACKAGE_STRING@,,;t t
+s,@PACKAGE_BUGREPORT@,,;t t
+s,@exec_prefix@,${prefix},;t t
+s,@prefix@,/usr/local,;t t
+s,@program_transform_name@,s,x,x,,;t t
+s,@bindir@,${exec_prefix}/bin,;t t
+s,@sbindir@,${exec_prefix}/sbin,;t t
+s,@libexecdir@,${exec_prefix}/libexec,;t t
+s,@datadir@,${prefix}/share,;t t
+s,@sysconfdir@,${prefix}/etc,;t t
+s,@sharedstatedir@,${prefix}/com,;t t
+s,@localstatedir@,${prefix}/var,;t t
+s,@libdir@,${exec_prefix}/lib,;t t
+s,@includedir@,${prefix}/include,;t t
+s,@oldincludedir@,/usr/include,;t t
+s,@infodir@,${prefix}/info,;t t
+s,@mandir@,${prefix}/man,;t t
+s,@build_alias@,,;t t
+s,@host_alias@,,;t t
+s,@target_alias@,,;t t
+s,@DEFS@,-DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\" -DYYTEXT_POINTER=1 -DHAVE_GETADDRINFO=1 -DHAVE_GETNAMEINFO=1 -DHAVE_GETIFADDRS=1 -DHAVE_IF_NAMETOINDEX=1 -DHAVE_DAEMON=1 -DHAVE_WARNX=1 -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_FCNTL_H=1 -DHAVE_SYS_IOCTL_H=1 -DHAVE_SYS_TIME_H=1 -DHAVE_SYSLOG_H=1 -DHAVE_UNISTD_H=1 -DHAVE_IFADDRS_H=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_STRUCT_TM_TM_ZONE=1 -DHAVE_TM_ZONE=1 -DHAVE_SIG_ATOMIC_T=1 -DGETPGRP_VOID=1 -DSETPGRP_VOID=1 -DRETSIGTYPE=void -DHAVE_MKTIME=1 -DHAVE_SELECT=1 -DHAVE_SOCKET=1 -DHAVE_ANSI_FUNC=1 -DHAVE_TAILQ_FOREACH_REVERSE_OLD=1 -DHAVE_STDARG_H=1 ,;t t
+s,@ECHO_C@,,;t t
+s,@ECHO_N@,-n,;t t
+s,@ECHO_T@,,;t t
+s,@LIBS@,,;t t
+s,@INSTALL_PROGRAM@,${INSTALL},;t t
+s,@INSTALL_SCRIPT@,${INSTALL},;t t
+s,@INSTALL_DATA@,${INSTALL} -m 644,;t t
+s,@SET_MAKE@,,;t t
+s,@CC@,gcc,;t t
+s,@CFLAGS@,-g -O2 -I$(srcdir),;t t
+s,@LDFLAGS@,,;t t
+s,@CPPFLAGS@,,;t t
+s,@ac_ct_CC@,gcc,;t t
+s,@EXEEXT@,,;t t
+s,@OBJEXT@,o,;t t
+s,@CPP@,gcc -E,;t t
+s,@YACC@,bison -y,;t t
+s,@LEX@,flex,;t t
+s,@LEXLIB@,-lfl,;t t
+s,@LEX_OUTPUT_ROOT@,lex.yy,;t t
+s,@EGREP@,grep -E,;t t
+s,@LIBOBJS@, strlcpy$U.o strlcat$U.o arc4random$U.o,;t t
+s,@localdbdir@,/var/db,;t t
+s,@user@,bin,;t t
+s,@group@,bin,;t t
+s,@LTLIBOBJS@, strlcpy$U.lo strlcat$U.lo arc4random$U.lo,;t t
+CEOF
+
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+	  /^X\(\/\/\)$/{ s//\1/; q; }
+	  /^X\(\/\).*/{ s//\1/; q; }
+	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+	  /^X\(\/\/\)$/{ s//\1/; q; }
+	  /^X\(\/\).*/{ s//\1/; q; }
+	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
+  esac
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  sed "/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}
+
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+
+{ (exit 0); exit 0; }
diff -Naur dhcpv6-aei/configure dhcpv6-aei-brcm/configure
--- dhcpv6-aei/configure	2008-06-15 04:48:41.000000000 -0300
+++ dhcpv6-aei-brcm/configure	2019-06-13 11:48:57.551012801 -0300
@@ -70,9 +70,9 @@
 	 .     : '\(.\)' 2>/dev/null ||
 echo X/"$0" |
     sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
-  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\/\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
+	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+	  /^X\/\(\/\).*/{ s//\1/; q; }
+	  s/.*/./; q'`
 
 
 # PATH needs CR, and LINENO needs CR and PATH.
@@ -714,10 +714,10 @@
 	 .     : '\(.\)' 2>/dev/null ||
 echo X"$0" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
+	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+	  /^X\(\/\/\)$/{ s//\1/; q; }
+	  /^X\(\/\).*/{ s//\1/; q; }
+	  s/.*/./; q'`
   srcdir=$ac_confdir
   if test ! -r $srcdir/$ac_unique_file; then
     srcdir=..
@@ -5687,7 +5687,7 @@
 echo "${ECHO_T}$result" >&6
 case $result in
 yes)	tailq_foreach=yes
- 	;;
+	;;
 *)	tailq_foreach=no
 	;;
 esac
@@ -6221,9 +6221,9 @@
 	 .     : '\(.\)' 2>/dev/null ||
 echo X/"$0" |
     sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
-  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\/\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
+	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+	  /^X\/\(\/\).*/{ s//\1/; q; }
+	  s/.*/./; q'`
 
 
 # PATH needs CR, and LINENO needs CR and PATH.
@@ -6737,10 +6737,10 @@
 	 .     : '\(.\)' 2>/dev/null ||
 echo X"$ac_file" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
+	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+	  /^X\(\/\/\)$/{ s//\1/; q; }
+	  /^X\(\/\).*/{ s//\1/; q; }
+	  s/.*/./; q'`
   { if $as_mkdir_p; then
     mkdir -p "$ac_dir"
   else
@@ -6756,10 +6756,10 @@
 	 .     : '\(.\)' 2>/dev/null ||
 echo X"$as_dir" |
     sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
-  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
-  	  /^X\(\/\/\)$/{ s//\1/; q; }
-  	  /^X\(\/\).*/{ s//\1/; q; }
-  	  s/.*/./; q'`
+	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+	  /^X\(\/\/\)$/{ s//\1/; q; }
+	  /^X\(\/\).*/{ s//\1/; q; }
+	  s/.*/./; q'`
     done
     test ! -n "$as_dirs" || mkdir $as_dirs
   fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
@@ -6938,4 +6938,3 @@
   # would make configure fail if this is the last instruction.
   $ac_cs_success || { (exit 1); exit 1; }
 fi
-
diff -Naur dhcpv6-aei/debug.h dhcpv6-aei-brcm/debug.h
--- dhcpv6-aei/debug.h	1969-12-31 20:00:00.000000000 -0400
+++ dhcpv6-aei-brcm/debug.h	2019-06-13 11:48:57.551012801 -0300
@@ -0,0 +1,13 @@
+#ifndef MY_DEBUG_H_
+#define MY_DEBUG_H_
+
+/* First include stdio.h, which may contain the prototype for the external dprintf.
+ * We do not want that. We redefine dprintf to our local implementation. */
+#include <stdio.h>
+#define dprintf my_dprintf
+#ifndef __P
+# define __P(x) x
+#endif
+extern void my_dprintf __P((int, const char *, const char *, ...));
+
+#endif /* MY_DEBUG_H_ */
diff -Naur dhcpv6-aei/dhcp6c.c dhcpv6-aei-brcm/dhcp6c.c
--- dhcpv6-aei/dhcp6c.c	2008-06-15 04:48:41.000000000 -0300
+++ dhcpv6-aei-brcm/dhcp6c.c	2019-06-13 11:48:57.551012801 -0300
@@ -2,7 +2,7 @@
 /*
  * Copyright (C) 1998 and 1999 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -14,7 +14,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -79,6 +79,53 @@
 #include <prefixconf.h>
 #include <auth.h>
 
+#ifdef AEI_CONTROL_LAYER
+#include "tsl_common.h"
+#include "ctl_msg.h"
+#include "dbussend_msg.h"
+
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+#include "netlink_dad.h"
+#endif
+
+//#define ACTION_TEC_IPV6_CODE_FOR_RAD
+#if defined(ACTION_TEC_IPV6_CODE_FOR_IOT)// && defined(ACTION_TEC_IPV6_CODE_FOR_RAD)
+#include <sys/ioctl.h>
+#include <linux/rtnetlink.h>
+#include <asm/byteorder.h>
+
+#include "ctl_objectid.h"
+#include "ctl_validstrings.h"
+
+static int rad_ra_Mbit = -1;
+static int rad_ra_Obit = -1;
+static int rad_ra_routelifetime = -1;
+static int rad_fd = -1;
+struct msghdr rad_msg;
+struct sockaddr_nl rad_dest_addr;
+struct nlmsghdr *p_rad_nlh;
+struct iovec rad_iov;
+struct icmpv6_nd_ra *p_rad_icmpv6;
+#endif
+
+#ifdef CDROUTER_TEST_DHCP6C
+int all_ia_pre_order=0;
+#endif
+CtlDhcp6cStateChangedMsgBody ctldhcp6cMsgBody;
+CtlDhcp6cStateChangedMsgBody ctldhcp6cMsgBody_Old;
+static int send_confirm=1;
+#ifdef CONFIG_IOT_RECONFIGURATION
+static struct authparam g_auth_param;
+//current only support one valid PD.
+int got_valid_ia_pd=0;
+int got_valid_ia_na=0;
+#endif
+#endif
+//#define AEI_RENEW_OLD_PD
+#ifdef AEI_RENEW_OLD_PD
+static int iReq = 1;
+#endif
+
 static int debug = 0;
 static int exit_ok = 0;
 static sig_atomic_t sig_flags = 0;
@@ -107,6 +154,7 @@
 static int ctldigestlen;
 
 static int infreq_mode = 0;
+static int infreq_reconf = 0;
 
 static inline int get_val32 __P((char **, int *, u_int32_t *));
 static inline int get_ifname __P((char **, int *, char *, int));
@@ -132,6 +180,17 @@
 static void client6_signal __P((int));
 static struct dhcp6_event *find_event_withid __P((struct dhcp6_if *,
 						  u_int32_t));
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+#ifdef CONFIG_IOT_RECONFIGURATION
+static int client6_reconfigure __P((struct dhcp6_if *, struct dhcp6 *,
+				  ssize_t, struct dhcp6_optinfo *));
+static int client6_reconfigure_info __P((struct dhcp6_if *));
+static struct dhcp6_event *find_event_withoutid __P((struct dhcp6_if *));
+#endif
+void remove_na_address __P((struct dhcp6_if *,char*,int*) );
+int rmna = 0;
+int rmpd = 0;
+#endif
 static int construct_confdata __P((struct dhcp6_if *, struct dhcp6_event *));
 static int construct_reqdata __P((struct dhcp6_if *, struct dhcp6_optinfo *,
     struct dhcp6_event *));
@@ -146,8 +205,1020 @@
 int client6_start __P((struct dhcp6_if *));
 static void info_printf __P((const char *, ...));
 
+#if 1 //brcm
+int updateDhcp6sConfDnsList __P((struct dhcp6_optinfo *));
+static void sendDnsEventMessage __P((const char *));
+//static void sendDhcp6cEventMessage __P((void));
+char *ifname_info;
+char *brcm_ptr;
+char brcm_ifname[32];
+char l2_ifname[32];
+#endif
+
 extern int client6_script __P((char *, int, struct dhcp6_optinfo *));
 
+#if ACTION_TEC_IPV6_CODE_FOR_IOT
+#include <libtr69_client.h>
+//#define CTLOID_WAN_IP_CONN              "InternetGatewayDevice.WANDevice.1.WANConnectionDevice.1.WANIPConnection.1"
+
+#define MAX_TIMES_TO_RETRY_TR69 	(5)  // Try 5 times, interval 1 seconds.
+
+tsl_int_t tsl_strcmp(const char *s1, const char *s2)
+{
+   char emptyStr = '\0';
+   char *str1 = (char *) s1;
+   char *str2 = (char *) s2;
+
+   if (str1 == NULL)
+   {
+      str1 = &emptyStr;
+   }
+   if (str2 == NULL)
+   {
+      str2 = &emptyStr;
+   }
+
+   return strcmp(str1, str2);
+}
+
+tsl_int_t ctlUtl_getWANDeviceID(const char* WANAccessType)
+{
+	tsl_char_t *c_WANDeviceCount = NULL;
+	tsl_int_t i_WANDeviceCount =1;
+	tsl_int_t i;
+	tsl_char_t WANDeviceOID[256] = {0};
+	tsl_char_t *c_WANAccessType = NULL;
+	tsl_int_t  val_type;
+
+	tr69_get_unfresh_leaf_data( CTLOID_IGD".WANDeviceNumberOfEntries",
+				& c_WANDeviceCount,
+				& val_type );
+	i_WANDeviceCount = (tsl_int_t)c_WANDeviceCount;
+
+	for(i = 0; i<i_WANDeviceCount; i++)
+	{
+		sprintf(WANDeviceOID, "InternetGatewayDevice.WANDevice.%d.WANCommonInterfaceConfig.WANAccessType", i+1);
+		//ctllog_debug("WANDeviceOID = %s\n", WANDeviceOID);
+		tr69_get_unfresh_leaf_data( WANDeviceOID,
+					& c_WANAccessType,
+					& val_type );
+		if(!tsl_strcmp(WANAccessType,c_WANAccessType))
+		{
+			CTLMEM_FREE_BUF_AND_NULL_PTR(c_WANAccessType);
+			return i+1;
+		}
+		CTLMEM_FREE_BUF_AND_NULL_PTR(c_WANAccessType);
+	}
+	return -1;
+}
+tsl_bool_t ctlUtl_genNewCtlObjectID(const char* srcOid, char* destOid, int iIndex, int newId)
+{
+	char* delim = ".";
+	char* p;
+	int i = 0;
+	tsl_bool_t rv = tsl_b_false;
+	char src_Oid[256] = {0};
+	char new_Id[2]={0};
+	strncpy(src_Oid, srcOid, 256);
+	strcpy(destOid, strtok(src_Oid, delim));
+	//ctllog_debug("src_Oid = %s \n", src_Oid);
+	//ctllog_debug("destOid = %s \n", destOid);
+//	if(newId>=10 || newId<=0)
+//		perror("not support device id: %d now, only allow 1~9\n", newId);
+	newId = newId%10;
+	sprintf(new_Id, "%d", newId);
+	//ctllog_debug("newId = %d \n", newId);
+	//ctllog_debug("new_Id = %s \n", new_Id);
+	//ctllog_debug("new_Id[0] = %c \n", new_Id[0]);
+
+	while((p=strtok(NULL, delim)))
+	{
+		strcat(destOid, ".");
+		//ctllog_debug("destOid = %s \n", destOid);
+		//ctllog_debug("p = %s \n", p);
+
+		if(!strcmp(p, "1"))
+		{
+			i++;
+			if(i == iIndex)
+			{
+				strcat(destOid, new_Id);
+				//ctllog_debug("destOid = %s \n", destOid);
+				rv = tsl_b_true;
+			}
+			else
+			{
+				strcat(destOid, "1");
+				//ctllog_debug("destOid = %s \n", destOid);
+			}
+		}
+		else
+		{
+			strcat(destOid, p);
+			//ctllog_debug("destOid = %s \n", destOid);
+		}
+	}
+	return rv;
+}
+
+tsl_int_t getPppConnOID(char* strPPPOID)
+{
+	tsl_int_t result = -1;
+	tsl_int_t i;
+	tsl_int_t type;
+	tsl_char_t * conntype = NULL;
+	tsl_int_t i_DeviceID = 1;
+
+	do {
+		if( NULL == strPPPOID ) {
+			perror("PppOid NULL!\n");
+			break;
+		}
+
+		for( i=0; i<MAX_TIMES_TO_RETRY_TR69; i++) {
+			if( tr69_get_unfresh_leaf_data( CTLOID_IGD".X_AEI_COM_Physical_WAN",
+						& conntype,
+						& type ) >=0 )
+			{
+				break;
+			}
+			sleep(1);
+		}
+		if( i>= MAX_TIMES_TO_RETRY_TR69 ) {
+			perror("FAIL to access DataCenter!\n");
+			break;
+		}
+		if( (i_DeviceID = ctlUtl_getWANDeviceID(conntype)) < 0 ) {
+			CTLMEM_FREE_BUF_AND_NULL_PTR(conntype);
+			perror("FAIL to get Physical_WAN device ID\n");
+			break;
+		}
+		ctlUtl_genNewCtlObjectID(CTLOID_WAN_PPP_CONN, strPPPOID, 1, i_DeviceID);
+		CTLMEM_FREE_BUF_AND_NULL_PTR(conntype);
+		result = 0;
+	} while(0);
+
+	return result;
+}
+
+tsl_int_t getIPConnOID(char* strIPOID)
+{
+	tsl_int_t result = -1;
+	tsl_int_t i;
+	tsl_int_t type;
+	tsl_char_t * conntype = NULL;
+	tsl_int_t i_DeviceID = 1;
+
+	do {
+		if( NULL == strIPOID ) {
+			perror("IpOid NULL!\n");
+			break;
+		}
+
+		for( i=0; i<MAX_TIMES_TO_RETRY_TR69; i++) {
+			if( tr69_get_unfresh_leaf_data( CTLOID_IGD".X_AEI_COM_Physical_WAN",
+						& conntype,
+						& type ) >=0 )
+			{
+				break;
+			}
+			sleep(1);
+		}
+		if( i>= MAX_TIMES_TO_RETRY_TR69 ) {
+			perror("FAIL to access DataCenter!\n");
+			break;
+		}
+		if( (i_DeviceID = ctlUtl_getWANDeviceID(conntype)) < 0 ) {
+			CTLMEM_FREE_BUF_AND_NULL_PTR(conntype);
+			perror("FAIL to get Physical_WAN device ID\n");
+			break;
+		}
+		ctlUtl_genNewCtlObjectID(CTLOID_WAN_IP_CONN, strIPOID, 1, i_DeviceID);
+		CTLMEM_FREE_BUF_AND_NULL_PTR(conntype);
+		result = 0;
+	} while(0);
+
+	return result;
+}
+
+
+
+int
+ctl_layer_cfg_check( struct dhcp6_if *ifp,
+        char* wan_dhcpv6_ipv6_addr )
+{
+       /* read startup data from ctl_layer data center */
+       char* data_val = NULL;
+       int data_type = 0;
+
+
+	   tsl_bool ipConn = TSL_B_FALSE;
+	   tsl_bool pppConn = TSL_B_FALSE;
+	   tsl_int_t ret;
+	   tsl_int_t  type;
+	   tsl_bool found = TSL_B_FALSE;
+
+	   tsl_bool b_ipv6enable = TSL_B_FALSE;
+	   tsl_char_t *c_ipv6enable = NULL;
+	   tsl_char_t *ifName = NULL;
+	   /////////////////////////////////////////
+
+	   tsl_char_t strIPOID[256]={0};
+	   tsl_char_t strPara[256]={0};
+	   tsl_char_t strPPPOID[256]={0};
+
+	   if( getPppConnOID(strPPPOID) < 0 ) {
+		   perror( "Fail to get PPPConnOid\n" );
+		   return -1;
+	   }
+	   if( getIPConnOID(strIPOID) < 0 ) {
+		   perror( "Fail to get IPConnOid\n" );
+		   return -1;
+	   }
+
+	   sprintf(strPara, "%s.Enable", strIPOID);
+	   ret = tr69_get_unfresh_leaf_data( strPara,
+				   & c_ipv6enable,
+				   & type );
+	   if( ret >=0 ) {
+		   b_ipv6enable = (tsl_bool)c_ipv6enable;
+		   if( b_ipv6enable ) {
+			   found = TSL_B_TRUE;
+			   ipConn = TSL_B_TRUE;
+		   }
+	   }
+	   if( TSL_B_FALSE == found ) {
+				   sprintf(strPara, "%s.Enable", strPPPOID);
+				   ret = tr69_get_unfresh_leaf_data( strPara,
+				   & c_ipv6enable,
+				   & type );
+		   if( ret >= 0 ) {
+			   b_ipv6enable = (tsl_bool)c_ipv6enable;
+			   if( b_ipv6enable ) {
+				   found = TSL_B_TRUE;
+				   pppConn = TSL_B_TRUE;
+			   }
+		   }
+	   }
+
+	   if (TSL_B_FALSE == found) {
+		   perror( "NOT found wan connection!" );
+		   return -1;
+	   } else {
+
+		   sprintf(strPara, "%s.X_BROADCOM_COM_ExternalIPv6Address", ipConn ?strIPOID :strPPPOID );
+	       tr69_get_unfresh_leaf_data( strPara,
+	           &data_val,
+	           &data_type);
+			if(!IS_EMPTY_STRING(data_val))
+			{
+				strcpy( wan_dhcpv6_ipv6_addr, data_val );
+				CTLMEM_FREE_BUF_AND_NULL_PTR(data_val);
+			}
+			else {
+                if(data_val) {
+                    CTLMEM_FREE_BUF_AND_NULL_PTR(data_val);
+                }
+
+				return -1;
+             }
+
+	   }
+
+    return 0;
+}
+
+void remove_na_address(struct dhcp6_if *ifp,char * wanip,int* flag )
+{
+	if( 0 == *flag )
+	{
+		char szCmd[264] = {0};
+		snprintf(szCmd,263, "ip -6 addr del %s dev %s", wanip,ifp->ifname);
+		system(szCmd);
+		*flag  = 1;
+	}
+}
+#endif
+
+/**********************************************************************************
+*	ACTION_TEC_IPV6_CODE_FOR_IOT  and  ACTION_TEC_IPV6_CODE_FOR_RAD
+**********************************************************************************/
+#if defined(ACTION_TEC_IPV6_CODE_FOR_IOT) && defined(ACTION_TEC_IPV6_CODE_FOR_RAD)
+typedef enum {
+	DHCPV6_MODE_NONE,
+	DHCPV6_MODE_STATELESS,
+	DHCPV6_MODE_STATEFUL
+}DHCPV6_MODE;
+
+#define MAX_PAYLOAD 1024
+struct icmpv6_nd_ra {
+			__u8		hop_limit;
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+			__u8		reserved:3,
+					router_pref:2,
+				        home_agent:1,
+					other:1,
+					managed:1;
+
+#elif defined(__BIG_ENDIAN_BITFIELD)
+			__u8		managed:1,
+					other:1,
+				        home_agent:1,
+					router_pref:2,
+					reserved:3;
+#else
+#error	"Please fix <asm/byteorder.h>"
+#endif
+			__u16		rt_lifetime;
+                } u_nd_ra;
+
+static void nl_close(int sd)
+{
+    if (sd >= 0) close(sd);
+}
+
+static int nl_open(void)
+{
+    struct sockaddr_nl nladdr;
+    int sd;
+
+    sd = socket(PF_NETLINK, SOCK_RAW, NETLINK_RAD);
+    if (sd < 0)
+    {
+	perror("DHCP6c: open socket failed!\n");
+		return -1;
+    }
+    memset(&nladdr, 0, sizeof(nladdr));
+    nladdr.nl_family = AF_NETLINK;
+
+    nladdr.nl_pid = getpid();  /* self pid */
+    /* interested in group 1<<0 */
+    nladdr.nl_groups = 1;
+
+    if (bind(sd, (struct sockaddr*)&nladdr, sizeof(nladdr)) < 0)
+	{
+        nl_close(sd);
+		fprintf(stdout, "DHCP6c: bind socket failed!\n");
+        return -1;
+    }
+    return sd;
+}
+
+static int nl_get_msg(int fd, fd_set ra)
+{
+
+}
+
+static int get_ifname_from_datamodel(char **pp_ifname)
+{
+	tsl_bool_t b_enable;
+
+	tsl_int_t tr69_type = 0;
+
+	tsl_int_t found = 0;
+
+    char *p_ifname = NULL;
+
+
+	tsl_char_t strIPOID[256]={0};
+	tsl_char_t strPara[256]={0};
+	tsl_char_t strPPPOID[256]={0};
+
+	getPppConnOID(strPPPOID);
+	getIPConnOID(strIPOID);
+
+	do {
+		sprintf(strPara, "%s.Enable", strIPOID);
+		if( tr69_get_unfresh_leaf_data(strPara,	&b_enable, &tr69_type ) < 0 )
+			break;
+		if( TSL_B_FALSE == b_enable ) {
+			fprintf( stdout,"WAN IPConn being Disabled.\n" );
+			break;
+		}
+		///
+		sprintf(strPara, "%s.X_BROADCOM_COM_IfName", strIPOID);
+		if (tr69_get_unfresh_leaf_data(strPara, (tsl_void_t **)&p_ifname, (tsl_int_t *)&tr69_type) < 0)
+			break;
+
+        *pp_ifname = p_ifname;
+        found = 1;
+
+
+
+	} while(0);
+
+
+	do {
+		if (found )
+			break;
+		sprintf(strPara, "%s.Enable", strPPPOID);
+		if( tr69_get_unfresh_leaf_data(strPara,	&b_enable, &tr69_type ) < 0 )
+			break;
+		if( TSL_B_FALSE == b_enable ) {
+			fprintf( stdout,"WAN PPPConn being Disabled.\n" );
+			break;
+		}
+
+		sprintf(strPara, "%s.X_BROADCOM_COM_IfName", strPPPOID);
+		if (tr69_get_unfresh_leaf_data(strPara, (tsl_void_t **)&p_ifname, (tsl_int_t *)&tr69_type) < 0)
+			break;
+
+        *pp_ifname = p_ifname;
+        found = 1;
+
+
+	} while(0);
+
+	if (found) {
+        fprintf(stdout,"pp_ifname is: %s\n", *pp_ifname);
+		return 0;
+	}
+    else
+    {
+        fprintf(stdout,"pp_ifname: both IP and PPP disconnected\n");
+        return -1;
+    }
+
+}
+
+static int get_wan_conn_type(void)
+{
+	int tr69_type = 0;
+	char *tr69_chr_val = NULL;
+	int bb_type = 1;		//1:Eth;	2:Moca
+
+	if (tr69_get_unfresh_leaf_data(CTLOID_IGD".X_AEI_COM_Physical_WAN",
+					(tsl_void_t **)&tr69_chr_val,
+					(tsl_int_t *)&tr69_type ) < 0)
+	{
+		fprintf(stdout, "%s[%d]: get WAN physical type failed\n", __FILE__, __LINE__);
+		return -1;
+	}
+	if ((tr69_chr_val != NULL) && (strcmp(tr69_chr_val, CTLVS_ETHERNET) == 0))
+		bb_type = 1;
+	else
+		bb_type = 2;
+	free(tr69_chr_val);
+	tr69_chr_val = NULL;
+
+	return bb_type;
+}
+
+static int get_router_lifetime_from_datamodel(void)
+{
+	tsl_bool_t b_enable;
+
+	tsl_int_t tr69_type = 0;
+
+	tsl_int_t found = 0;
+
+    tsl_int_t param_int = 0;
+    tsl_int_t route_lifetime = 0;
+
+	tsl_char_t strIPOID[256]={0};
+	tsl_char_t strPara[256]={0};
+	tsl_char_t strPPPOID[256]={0};
+
+	getPppConnOID(strPPPOID);
+	getIPConnOID(strIPOID);
+
+	do {
+		sprintf(strPara, "%s.Enable", strIPOID);
+		if( tr69_get_unfresh_leaf_data(strPara,	&b_enable, &tr69_type ) < 0 )
+			break;
+		if( TSL_B_FALSE == b_enable ) {
+			fprintf(stdout, "WAN IPConn being Disabled.\n" );
+			break;
+		}
+		///
+		sprintf(strPara, "%s.X_BROADCOM_COM_TMP_RALIFETIME", strIPOID);
+		if (tr69_get_unfresh_leaf_data(strPara, (tsl_void_t **)&param_int, (tsl_int_t *)&tr69_type) < 0)
+			break;
+
+        route_lifetime = param_int;
+        found = 1;
+
+
+
+	} while(0);
+
+
+	do {
+		if (found )
+			break;
+		sprintf(strPara, "%s.Enable", strPPPOID);
+		if( tr69_get_unfresh_leaf_data(strPara,	&b_enable, &tr69_type ) < 0 )
+			break;
+		if( TSL_B_FALSE == b_enable ) {
+			fprintf(stdout, "WAN PPPConn being Disabled.\n" );
+			break;
+		}
+		sprintf(strPara, "%s.X_BROADCOM_COM_TMP_RALIFETIME", strPPPOID);
+		if (tr69_get_unfresh_leaf_data(strPara, (tsl_void_t **)&param_int, (tsl_int_t *)&tr69_type) < 0)
+			break;
+
+        route_lifetime = param_int;
+        found = 1;
+
+
+	} while(0);
+
+	if (found) {
+        fprintf(stdout,"RADVD Router Lifetime is: %d\n", route_lifetime);
+		//return 0;
+	}
+    else
+    {
+        fprintf(stdout,"RADVD Router Lifetime is: both IP and PPP disconnected\n");
+        //return -1;
+    }
+
+	fprintf(stdout, "%s[%d]: route_lifetime=%d\n", __FILE__, __LINE__, route_lifetime);
+
+	return route_lifetime;
+}
+
+static int get_RA_config_type_from_datamodel(void)
+{
+    char * ipv6RAtype = NULL;
+    int tr69_type = 0;
+    tr69_get_unfresh_leaf_data( CTLOID_IPV6_LAN_HOST_CFG ".X_AEI_COM_IPv6RAConfigType",(tsl_void_t **)&ipv6RAtype, (tsl_int_t *)&tr69_type );
+    if (!tsl_strcmp( ipv6RAtype, "Static"))
+	{
+	    CTLMEM_FREE_BUF_AND_NULL_PTR( ipv6RAtype );
+		return 0;
+	}
+    else
+        {
+            CTLMEM_FREE_BUF_AND_NULL_PTR( ipv6RAtype );
+            return 1;
+        }
+}
+
+
+
+static int save_ra_info_to_datamodel(int Mbit, int Obit, int router_lifetime)
+{
+	tsl_bool_t b_enable;
+
+	tsl_int_t tr69_type = 0;
+
+	tsl_int_t found = 0;
+
+    tsl_int_t param_int = 0;
+
+	tsl_char_t strIPOID[256]={0};
+	tsl_char_t strPara[256]={0};
+	tsl_char_t strPPPOID[256]={0};
+
+	getPppConnOID(strPPPOID);
+	getIPConnOID(strIPOID);
+
+	do {
+		sprintf(strPara, "%s.Enable", strIPOID);
+		if( tr69_get_unfresh_leaf_data(strPara,	&b_enable, &tr69_type ) < 0 )
+			break;
+		if( TSL_B_FALSE == b_enable ) {
+			fprintf( stdout,"WAN IPConn being Disabled.\n" );
+			break;
+		}
+		///
+		param_int = Mbit;
+		sprintf(strPara, "%s.X_BROADCOM_COM_MBIT", strIPOID);
+		tr69_set_unfresh_leaf_data(strPara, (void *)&param_int, TR69_NODE_LEAF_TYPE_INT);
+
+        param_int = Obit;
+        sprintf(strPara, "%s.X_BROADCOM_COM_OBIT", strIPOID);
+        tr69_set_unfresh_leaf_data(strPara, (void *)&param_int, TR69_NODE_LEAF_TYPE_INT);
+
+         param_int = router_lifetime;
+        sprintf(strPara, "%s.X_BROADCOM_COM_TMP_RALIFETIME", strIPOID);
+		tr69_set_unfresh_leaf_data(strPara, (void *)&param_int, TR69_NODE_LEAF_TYPE_INT);
+
+        found = 1;
+
+	} while(0);
+
+
+	do {
+		if (found )
+			break;
+		sprintf(strPara, "%s.Enable", strPPPOID);
+		if( tr69_get_unfresh_leaf_data(strPara,	&b_enable, &tr69_type ) < 0 )
+			break;
+		if( TSL_B_FALSE == b_enable ) {
+			fprintf(stdout, "WAN PPPConn being Disabled.\n" );
+			break;
+		}
+		param_int = Mbit;
+		sprintf(strPara, "%s.X_BROADCOM_COM_MBIT", strPPPOID);
+		tr69_set_unfresh_leaf_data(strPara, (void *)&param_int, TR69_NODE_LEAF_TYPE_INT);
+
+        param_int = Obit;
+        sprintf(strPara, "%s.X_BROADCOM_COM_OBIT", strPPPOID);
+        tr69_set_unfresh_leaf_data(strPara, (void *)&param_int, TR69_NODE_LEAF_TYPE_INT);
+
+         param_int = router_lifetime;
+        sprintf(strPara, "%s.X_BROADCOM_COM_TMP_RALIFETIME", strPPPOID);
+		tr69_set_unfresh_leaf_data(strPara, (void *)&param_int, TR69_NODE_LEAF_TYPE_INT);
+
+        //found = 1;
+
+
+	} while(0);
+
+
+	return 0;
+}
+
+static int is_MO_flags_changed(int Mbit, int Obit)
+{
+	tsl_bool_t b_enable;
+
+	tsl_int_t tr69_type = 0;
+
+	tsl_int_t found = 0;
+	int dm_Mbit = -1;
+	int dm_Obit = -1;
+	int is_changed = 0;
+
+	char *tr69_chr_val = NULL;
+
+	tsl_char_t strIPOID[256]={0};
+	tsl_char_t strPara[256]={0};
+	tsl_char_t strPPPOID[256]={0};
+
+	getPppConnOID(strPPPOID);
+	getIPConnOID(strIPOID);
+
+	do {
+		sprintf(strPara, "%s.Enable", strIPOID);
+		if( tr69_get_unfresh_leaf_data(strPara,	&b_enable, &tr69_type ) < 0 )
+			break;
+		if( TSL_B_FALSE == b_enable ) {
+			fprintf( stdout,"WAN IPConn being Disabled.\n" );
+			break;
+		}
+		///
+
+		sprintf(strPara, "%s.X_BROADCOM_COM_MBIT", strIPOID);
+		if (tr69_get_unfresh_leaf_data(strPara, (tsl_void_t **)&tr69_chr_val, (tsl_int_t *)&tr69_type) < 0)
+			break;
+        dm_Mbit = (int)((long)tr69_chr_val);
+
+        sprintf(strPara, "%s.X_BROADCOM_COM_OBIT", strIPOID);
+		if (tr69_get_unfresh_leaf_data(strPara, (tsl_void_t **)&tr69_chr_val, (tsl_int_t *)&tr69_type) < 0)
+            break;
+        dm_Obit = (int)((long)tr69_chr_val);
+
+        found = 1;
+
+	} while(0);
+
+
+	do {
+		if (found )
+			break;
+		sprintf(strPara, "%s.Enable", strPPPOID);
+		if( tr69_get_unfresh_leaf_data(strPara,	&b_enable, &tr69_type ) < 0 )
+			break;
+		if( TSL_B_FALSE == b_enable ) {
+			fprintf( stdout,"WAN PPPConn being Disabled.\n" );
+			break;
+		}
+		sprintf(strPara, "%s.X_BROADCOM_COM_MBIT", strPPPOID);
+		if (tr69_get_unfresh_leaf_data(strPara, (tsl_void_t **)&tr69_chr_val, (tsl_int_t *)&tr69_type) < 0)
+			break;
+        dm_Mbit = (int)((long)tr69_chr_val);
+
+        sprintf(strPara, "%s.X_BROADCOM_COM_OBIT", strPPPOID);
+		if (tr69_get_unfresh_leaf_data(strPara, (tsl_void_t **)&tr69_chr_val, (tsl_int_t *)&tr69_type) < 0)
+            break;
+        dm_Obit = (int)((long)tr69_chr_val);
+
+        //found = 1;
+
+
+	} while(0);
+
+
+
+	if ((dm_Mbit == -1) || (dm_Obit == -1))
+		is_changed = 0;
+	else
+	{
+		if ((dm_Mbit == Mbit) && (dm_Obit == Obit))
+			is_changed = 0;
+		else if ((dm_Mbit == Mbit) && ((dm_Mbit == 1) && (dm_Obit != Obit)))
+			is_changed = 0;
+		else
+			is_changed = 1;
+	}
+	fprintf(stdout, "rad: M/O, is_changed(%d)(%d,%d->%d,%d)\n", is_changed, dm_Mbit, dm_Obit, Mbit, Obit);
+
+	return is_changed;
+}
+
+static DHCPV6_MODE get_dhcpv6_mode(int Mbit, int Obit)
+{
+	DHCPV6_MODE mode = DHCPV6_MODE_NONE;
+	if ((0 == Mbit) && (0 == Obit))
+		mode = DHCPV6_MODE_NONE;
+	else if ((0 == Mbit) &&(1 == Obit))
+		mode = DHCPV6_MODE_STATELESS;
+	else
+		mode = DHCPV6_MODE_STATEFUL;
+	fprintf(stdout, "get_dhcpv6_mode: mode(%d), M(%d), O(%d)\n", mode, Mbit, Obit);
+	return mode;
+}
+static int isUserDefineMode()
+{
+    int ret=0;
+    /*only pppv6 mode could define address type
+    * if dynamic address/pd and dynamic DNS,following normal case
+    * if dyncmic address/pd and static DNS, following normal case
+    * if static ddress/pd and dynamic DNS,should ignore RA M/O flag
+    * if static ddress/pd and static DNS,should not dhcp6c
+    */
+	tsl_bool_t b_enable=TSL_B_FALSE;
+
+	tsl_int_t tr69_type = 0;
+	char strPara[256]={0};
+	char strPPPOID[256]={0};
+    char *addrType=NULL;
+
+	getPppConnOID(strPPPOID);
+	sprintf(strPara, "%s.Enable", strPPPOID);
+    tr69_get_unfresh_leaf_data(strPara,	&b_enable, &tr69_type );
+    fprintf(stdout, "%s[%d]: ===>>strPara=%s,b_enable=%d!\n", __FILE__, __LINE__, strPara,b_enable);
+    if( TSL_B_FALSE == b_enable )
+        return 0;
+    sprintf(strPara, "%s.X_BROADCOM_COM_IPv6AddressingType", strPPPOID);
+    tr69_get_unfresh_leaf_data(strPara,	&addrType, &tr69_type );
+    fprintf(stdout, "%s[%d]: addrType=%s!\n", __FILE__, __LINE__, addrType);
+    if(!IS_EMPTY_STRING(addrType)&& cmsUtl_strcmp(addrType, CTLVS_STATIC)==0)
+        return 1;
+
+//tr69_get_unfresh_leaf_data( CTLOID_IPV6_LAN_HOST_CFG ".IPv6DNSConfigType",&ipv6dnstype, &type );
+
+
+    return ret;
+}
+static int gen_dhcp6c_conf(const char *ifName_info, tsl_bool dynamicIpEnabled, DHCPV6_MODE mode)
+{
+   char cmdLine[128];
+   char ifName[32];
+   char *ptr;
+   //tsl_u32_t pid;
+   char dhcp6cConfFile[64];
+   char ianaAssoc_buff[512] = { 0 };
+   FILE *fp;
+   char iapdAssocLine[256];
+const char *dhcp6cConf = "\
+interface %s\n\
+{\n\
+   send %s%s%s;\n\
+   request domain-name-servers;\n\
+   request domain-name;\n\
+};\n\
+%s\
+%s\
+";
+const char *dhcp6cConf_none = "\
+interface %s\n\
+{\n\
+   send %s%s%s;\n\
+};\n\
+%s\
+%s\
+";
+
+	const char *dhcp6cConf1 = "\
+	interface %s\n\
+	{\n\
+	   request domain-name-servers;\n\
+	   request domain-name;\n\
+	};\n\
+	";
+/*
+ * AEI_IPV6_DEPLOY
+ * Sam @ Fri Oct 22 16:22:07 CST 2010
+ */
+const char *iapd = "ia-pd 0";
+const char *iapdAssoc = "\
+id-assoc pd 0\n\
+{\n\
+   prefix-interface br0\n\
+   {\n\
+	  sla-id 0;\n\
+	  sla-len 0;\n\
+   };\n\
+};\n\
+";
+const char *iapdAssoc1 = "\
+id-assoc pd 0\n\
+{\n\
+   prefix-interface br0\n\
+   {\n\
+	  sla-id 0;\n\
+	  sla-len 0;\n\
+   };\n\
+   prefix %s infinity;\n\
+};\n\
+";
+const char *iana = "ia-na 1";
+
+// UNH-IOT
+// for No WAN.IPv6.address
+const char *ianaAssoc_0 = "\
+id-assoc na 1\n\
+{\n\
+};\n\
+";
+// for Having WAN.IPv6.address
+const char *ianaAssoc_1 = "\
+id-assoc na 1\n\
+{\n\
+	address %s %u %u;\n\
+};\n\
+";
+	char* wan_ipv6_addr = NULL;
+	char* pfx = NULL;
+	//int type;
+	//int ret = -1;
+	tsl_bool_t b_enable=TSL_B_FALSE;
+
+	tsl_int_t tr69_type = 0;
+
+	tsl_int_t found = 0;
+
+	char strIPOID[256]={0};
+	char strPara[256]={0};
+	char strPPPOID[256]={0};
+
+	getPppConnOID(strPPPOID);
+	getIPConnOID(strIPOID);
+
+	do {
+		sprintf(strPara, "%s.Enable", strIPOID);
+		if( tr69_get_unfresh_leaf_data(strPara,	&b_enable, &tr69_type ) < 0 )
+			break;
+
+		if( TSL_B_FALSE == b_enable ) {
+			fprintf( stdout,"WAN IPConn being Disabled.\n" );
+			break;
+		}
+		///
+		sprintf(strPara, "%s.X_AEI_COM_IPv6SitePrefix_BackUp", strIPOID);
+		if (tr69_get_unfresh_leaf_data(strPara, (void**)&pfx, (tsl_int_t *)&tr69_type) < 0)
+			break;
+
+		sprintf(strPara, "%s.X_BROADCOM_COM_ExternalIPv6Address", strIPOID);
+		if(tr69_get_unfresh_leaf_data(strPara, (void**)&wan_ipv6_addr, &tr69_type)<0)
+          break;
+        found = 1;
+
+	} while(0);
+
+	do {
+		if (found )
+			break;
+		sprintf(strPara, "%s.Enable", strPPPOID);
+		if( tr69_get_unfresh_leaf_data(strPara,	&b_enable, &tr69_type ) < 0 )
+			break;
+		if( TSL_B_FALSE == b_enable ) {
+			fprintf( stdout,"WAN PPPConn being Disabled.\n" );
+			break;
+		}
+		sprintf(strPara, "%s.X_AEI_COM_IPv6SitePrefix_BackUp", strPPPOID);
+		if (tr69_get_unfresh_leaf_data(strPara, (void**)&pfx, (tsl_int_t *)&tr69_type) < 0)
+			break;
+
+
+        found = 1;
+
+
+	} while(0);
+
+
+	if (found == 1)
+	{
+		if (!IS_EMPTY_STRING(pfx))
+		{
+			fprintf(stdout, "X_BROADCOM_COM_IPv6SitePrefix = %s\n", pfx);
+			snprintf(iapdAssocLine, sizeof(iapdAssocLine), iapdAssoc1, pfx);
+			CTLMEM_FREE_BUF_AND_NULL_PTR(pfx);
+		}
+		else
+		{
+			fprintf(stdout, "X_BROADCOM_COM_IPv6SitePrefix = NULL\n");
+			snprintf(iapdAssocLine, sizeof(iapdAssocLine), iapdAssoc);
+		}
+	}
+	else
+	{
+		fprintf(stdout, "can't get X_BROADCOM_COM_IPv6SitePrefix\n");
+		snprintf(iapdAssocLine, sizeof(iapdAssocLine), iapdAssoc);
+	}
+
+	// UNH-IOT
+	// for adding dhcp6c.conf with WAN.IPv6.address
+	if (found == 1)
+	{
+		if (!IS_EMPTY_STRING(wan_ipv6_addr))
+		{
+		char* pTmp = strstr(wan_ipv6_addr, "/");
+			if(pTmp!=NULL)
+				*pTmp = '\0';
+			fprintf(stdout, "X_BROADCOM_COM_ExternalIPv6Address = %s\n", wan_ipv6_addr );
+			snprintf( ianaAssoc_buff, sizeof(ianaAssoc_buff), ianaAssoc_1, wan_ipv6_addr, 1800, 3600 );
+			CTLMEM_FREE_BUF_AND_NULL_PTR(wan_ipv6_addr);
+		}
+		else
+		{
+			fprintf(stdout, "X_BROADCOM_COM_ExternalIPv6Address = NULL\n");
+			snprintf( ianaAssoc_buff, sizeof(ianaAssoc_buff), ianaAssoc_0 );
+		}
+	}
+	else
+	{
+		fprintf(stdout, "can't get X_BROADCOM_COM_ExternalIPv6Address\n");
+	}
+
+
+	strncpy(ifName, ifName_info, sizeof(ifName));
+	if ((ptr = strstr(ifName_info, "__")) != NULL)
+	{
+	  ifName[ptr-ifName_info] = '\0';
+	}
+
+	sprintf(dhcp6cConfFile, "/var/dhcp6c_%s.conf", ifName);
+	if ((fp = fopen(dhcp6cConfFile, "w")) == NULL)
+	{
+	  /* error */
+	  fprintf(stdout, "failed to create %s\n", dhcp6cConfFile);
+	  return TSL_B_FALSE;
+	}
+	else
+	{
+	  /* create dhcp6c.conf */
+	  if (dynamicIpEnabled)
+	  {
+		 //fprintf(fp, dhcp6cConf, ifName, iapd, ", ", iana, iapdAssocLine, ianaAssoc);
+		 if (mode == DHCPV6_MODE_STATEFUL)
+			 fprintf(fp, dhcp6cConf, ifName, iapd, ", ", iana, iapdAssocLine, ianaAssoc_buff );
+		 else if (mode == DHCPV6_MODE_STATELESS)
+			fprintf(fp, dhcp6cConf, ifName, iapd, "", "", iapdAssocLine, "");
+		 else if (mode == DHCPV6_MODE_NONE)
+			fprintf(fp, dhcp6cConf_none, ifName, iapd, "", "", iapdAssocLine, "");
+	  }
+	  else
+	  {
+		 //fprintf(fp, dhcp6cConf, ifName, iapd, "", "", iapdAssocLine, "");
+		 fprintf(fp, dhcp6cConf1, ifName);
+	  }
+
+	  fclose(fp);
+	}
+
+	//	 ctl_rutIpt_setupFirewallForDHCPv6(TSL_B_TRUE, ifName);
+
+#if defined( _BHR2 ) || defined( SUPPORT_BHR1 )
+	snprintf(cmdLine, sizeof(cmdLine), "/bin/dhcp6c -c %s -f %s -D", dhcp6cConfFile, ifName_info);
+#elif defined (SUPPORT_PK5000)
+	snprintf(cmdLine, sizeof(cmdLine), "/bin/dhcp6c -c %s -dDf %s ", dhcp6cConfFile, ifName_info);
+#else
+	snprintf(cmdLine, sizeof(cmdLine), "/bin/dhcp6c -c %s %s ", dhcp6cConfFile, ifName_info);
+#endif
+	//ctllog_debug("==================>>>>>>>>>>>>>>cmdLine: %s \n"  cmdLine);
+
+   return 0;
+}
+
+
+#endif		//defined(ACTION_TEC_IPV6_CODE_FOR_IOT) && defined(ACTION_TEC_IPV6_CODE_FOR_RAD)
+/**********************************************************************************
+*	ACTION_TEC_IPV6_CODE_FOR_IOT  and  ACTION_TEC_IPV6_CODE_FOR_RAD   end
+**********************************************************************************/
+static int get_dhcpv6_request_manner(void)
+{
+    char * dhcpv6_manner = NULL;
+    int tr69_type = 0;
+    tr69_get_unfresh_leaf_data( CTLOID_IPV6_LAN_HOST_CFG ".X_AEI_COM_IPv6DHCPReqManner",(tsl_void_t **)&dhcpv6_manner, (tsl_int_t *)&tr69_type );
+    if (!tsl_strcmp( dhcpv6_manner, "Renew"))
+	{
+	    CTLMEM_FREE_BUF_AND_NULL_PTR( dhcpv6_manner );
+		return 0;
+	}
+    else
+        {
+            CTLMEM_FREE_BUF_AND_NULL_PTR( dhcpv6_manner );
+            return 1;
+        }
+}
+
+
+
 #define MAX_ELAPSED_TIME 0xffff
 
 int
@@ -159,6 +1230,13 @@
 	char *progname;
 	FILE *pidfp;
 	struct dhcp6_if *ifp;
+#if defined(ACTION_TEC_IPV6_CODE_FOR_IOT) && defined(ACTION_TEC_IPV6_CODE_FOR_RAD)
+		int retval = 0;
+		static fd_set rad_fds;
+		struct timeval timeout;
+		char *p_ifname = NULL;
+		int status = -1;
+#endif
 
 #ifndef HAVE_ARC4RANDOM
 	srandom(time(NULL) & getpid());
@@ -205,13 +1283,112 @@
 		exit(0);
 	}
 
+#if defined(ACTION_TEC_IPV6_CODE_FOR_IOT) && defined(ACTION_TEC_IPV6_CODE_FOR_RAD)
+		rad_fd = nl_open();
+		if (rad_fd < 0)
+		{
+			fprintf(stdout, "nl_open failed\n");
+			return -1;
+		}
+		p_rad_nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(MAX_PAYLOAD));
+		if (!p_rad_nlh) {
+			fprintf(stdout, "Malloc Error\n");
+			return -1;
+		}
+		memset(p_rad_nlh, 0, NLMSG_SPACE(MAX_PAYLOAD));
+
+		rad_iov.iov_base = (void *)p_rad_nlh;
+		rad_iov.iov_len = NLMSG_SPACE(MAX_PAYLOAD);
+		rad_msg.msg_name = (void *)&rad_dest_addr;
+		rad_msg.msg_namelen = sizeof(rad_dest_addr);
+		rad_msg.msg_iov = &rad_iov;
+		rad_msg.msg_iovlen = 1;
+
+		FD_ZERO(&rad_fds);
+		FD_SET(rad_fd, &rad_fds);
+		timeout.tv_sec = 3;
+		timeout.tv_usec = 0;
+		retval = select(rad_fd + 1, &rad_fds, NULL, NULL, &timeout);
+		if (-1 == retval)
+		{
+			fprintf(stdout, "%s[%d]: select error!\n", __FILE__, __LINE__);
+			nl_close(rad_fd);
+			return -1;
+		}
+		else if (0 == retval)
+		{//timeout
+			rad_ra_Mbit = 1;
+			rad_ra_Obit = 1;
+			/* save default ra indo to datamode */
+			save_ra_info_to_datamodel(rad_ra_Mbit, rad_ra_Obit, 0);
+		}
+		else if (retval)
+		{
+			status = recvmsg(rad_fd, &rad_msg, 0);
+			if (status < 0)
+			{
+				nl_close(rad_fd);
+				free(p_rad_nlh);
+				fprintf(stdout, "%s[%d]: recvmsg failed!\n", __FILE__, __LINE__);
+				return -1;
+			}
+			p_rad_icmpv6 = (struct icmpv6_nd_ra *)NLMSG_DATA(p_rad_nlh);
+			fprintf(stdout, "Message length is %d,M bit %d,O bit %d,lifetime is %d\n",
+				p_rad_nlh->nlmsg_len,p_rad_icmpv6->managed,p_rad_icmpv6->other,ntohs(p_rad_icmpv6->rt_lifetime));
+
+			/* check if Mbit and Obit is invalid */
+			rad_ra_Mbit = p_rad_icmpv6->managed;
+			rad_ra_Obit = p_rad_icmpv6->other;
+			if ((rad_ra_Mbit < 0) || (rad_ra_Obit < 0))
+			{
+				fprintf(stdout, "%s[%d]: M(%d) or O(%d) flag is wrong!\n", __FILE__, __LINE__, rad_ra_Mbit, rad_ra_Obit);
+				nl_close(rad_fd);
+				free(p_rad_nlh);
+				return -1;
+			}
+
+			/* save ra info to datamode */
+			save_ra_info_to_datamodel(p_rad_icmpv6->managed, p_rad_icmpv6->other, p_rad_icmpv6->rt_lifetime);
+		}
+		if (get_ifname_from_datamodel(&p_ifname) < 0)
+		{
+			fprintf(stdout, "%s[%d]: get ifname from datamodel failed!\n", __FILE__, __LINE__);
+			nl_close(rad_fd);
+			free(p_rad_nlh);
+			return -1;
+		}
+		fprintf(stdout, "%s[%d]: ifname=%s,rad_ra_Mbit=%d,rad_ra_Obit=%d!\n",
+          __FILE__, __LINE__, p_ifname,rad_ra_Mbit,rad_ra_Obit);
+        if(!isUserDefineMode())
+		gen_dhcp6c_conf(p_ifname, 1, get_dhcpv6_mode(rad_ra_Mbit, rad_ra_Obit));
+		fprintf(stdout, "dhcp6c mode when starting: %d\n", get_dhcpv6_mode(rad_ra_Mbit, rad_ra_Obit));
+#endif
+
+	memset(&ctldhcp6cMsgBody, 0, sizeof(CtlDhcp6cStateChangedMsgBody));
+	memset(&ctldhcp6cMsgBody_Old, 0, sizeof(CtlDhcp6cStateChangedMsgBody));
+
 	if (foreground == 0)
 		openlog(progname, LOG_NDELAY|LOG_PID, LOG_DAEMON);
 
+
 	setloglevel(debug);
 
+   ifname_info = argv[0];
+
+   cmsUtl_strncpy(brcm_ifname, ifname_info, sizeof(brcm_ifname));
+   if ( (brcm_ptr = strstr(ifname_info, "__")) == NULL)
+   {
+      cmsUtl_strncpy(l2_ifname, ifname_info, sizeof(l2_ifname));
+   }
+   else
+   {
+      brcm_ifname[brcm_ptr-ifname_info] = '\0';
+      brcm_ptr += 2;
+      cmsUtl_strncpy(l2_ifname, brcm_ptr, sizeof(l2_ifname));
+   }
+
 	client6_init();
-	while (argc-- > 0) { 
+	while (argc-- > 0) {
 		if ((ifp = ifinit(argv[0])) == NULL) {
 			dprintf(LOG_ERR, FNAME, "failed to initialize %s",
 			    argv[0]);
@@ -225,10 +1402,12 @@
 		exit(1);
 	}
 
+#if 0 //brcm
 	if (foreground == 0 && infreq_mode == 0) {
 		if (daemon(0, 0) < 0)
 			err(1, "daemon");
 	}
+#endif
 
 	/* dump current PID */
 	pid = getpid();
@@ -239,6 +1418,10 @@
 
 	client6_startall(0);
 	client6_mainloop();
+#if defined(ACTION_TEC_IPV6_CODE_FOR_IOT) && defined(ACTION_TEC_IPV6_CODE_FOR_RAD)
+	nl_close(rad_fd);
+	rad_fd = -1;
+#endif
 	exit(0);
 }
 
@@ -252,17 +1435,59 @@
 
 /*------------------------------------------------------------*/
 
+
+static tsl_int_t _get_link_local_address(tsl_char_t *lladdr, tsl_char_t *ifname)
+{
+    tsl_int_t rv = TSL_RV_ERR;
+    char cmd[100] = {0};
+
+    FILE *fp = NULL;
+    sprintf(cmd, "ip -6 address show %s",ifname);
+    if ((fp = popen(cmd, "r")) != NULL)
+    {
+        char line[1024] = {0};
+        while (fgets(line, sizeof(line), fp))
+        {
+            char* p = NULL;
+            p = strstr(line, "scope link");
+            if ( p != NULL)
+            {
+                p = strstr(line, "/");
+                strcpy(p, "\0");
+                p = strstr(line, "inet6");
+                if(p != NULL)
+                {
+                    sprintf(lladdr, "%s", p+6);
+                    rv = TSL_RV_SUC;
+                    break;
+                }
+            }
+
+        }
+        pclose(fp);
+    }
+
+    return rv;
+}
 void
 client6_init()
 {
 	struct addrinfo hints, *res;
 	static struct sockaddr_in6 sa6_allagent_storage;
-	int error, on = 1;
+    struct sockaddr_in6 bind_addr = {0};
 
+	int error, on = 1;
+    tsl_char_t lladdr[128] = "\0";
 	/* get our DUID */
-	if (get_duid(DUID_FILE, &client_duid)) {
+	if (get_duid(DUID_FILE, &client_duid, l2_ifname)) {
+#ifdef AEI_CONTROL_LAYER
+		if (get_duid(DUID_FILE, &client_duid, "br0")) {
+#endif
 		dprintf(LOG_ERR, FNAME, "failed to get a DUID");
 		exit(1);
+#ifdef AEI_CONTROL_LAYER
+		}
+#endif
 	}
 
 	if (dhcp6_ctl_authinit(ctlkeyfile, &ctlkey, &ctldigestlen) != 0) {
@@ -326,12 +1551,27 @@
 	}
 #endif
 
+    /*QA-Bug #4304: use local link address and bind to wan interface.*/
+    memcpy(&bind_addr, (struct sockaddr_in6 *)(res->ai_addr), res->ai_addrlen);
+    
+    if(TSL_RV_ERR == _get_link_local_address(lladdr, ifname_info))
+    {
+        dprintf(LOG_ERR, FNAME, "_get_link_local_address error");
+        exit(1);
+    }
+    inet_pton(AF_INET6, lladdr, &(bind_addr.sin6_addr.s6_addr));
+    bind_addr.sin6_scope_id = if_nametoindex(ifname_info);
+
+
+
 	/*
 	 * According RFC3315 2.2, only the incoming port should be bound to UDP
 	 * port 546.  However, to have an interoperability with some servers,
 	 * the outgoing port is also bound to the DH6PORT_DOWNSTREAM.
 	 */
-	if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
+	//if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
+	if (bind(sock, &bind_addr, sizeof(bind_addr)) < 0) {
+
 		dprintf(LOG_ERR, FNAME, "bind: %s", strerror(errno));
 		exit(1);
 	}
@@ -480,7 +1720,8 @@
 		 * exit for now.
 		 */
 		if (!TAILQ_EMPTY(&ifp->event_list))
-			return;
+			dprintf(LOG_INFO, FNAME, "WARNING: EVENT LEFT WHILE EXITING!!");
+//			return;   //brcm: TODO!!
 	}
 
 	/* We have no existing event.  Do exit. */
@@ -514,6 +1755,19 @@
 	int ret, maxsock;
 	fd_set r;
 
+#ifdef ACTION_TEC_IPV6_CODE_FOR_DAD
+	 int fd_netlink = 0;
+	 int rc_netlink = 0;
+
+	 rc_netlink = netlink_dad_start( &fd_netlink );
+	 if( rc_netlink == 0 ) {
+				dprintf(LOG_INFO, FNAME, "netlink_dad_start ok, fd_netlink = %u", fd_netlink );
+	 }
+	 else {
+				dprintf(LOG_INFO, FNAME, "netlink_dad_start failed, so, I cannot get the DAD failed messge from kernel.");
+	 }
+#endif
+
 	while(1) {
 		if (sig_flags)
 			process_signals();
@@ -529,6 +1783,20 @@
 			(void)dhcp6_ctl_setreadfds(&r, &maxsock);
 		}
 
+#ifdef ACTION_TEC_IPV6_CODE_FOR_DAD
+		 // added fd_netlink
+		 if( rc_netlink == 0 ) {
+						FD_SET( fd_netlink, &r);
+						maxsock = (fd_netlink > maxsock) ? fd_netlink: maxsock;
+
+			 //dprintf(LOG_INFO, FNAME, "FD_SET: fd_netlink, maxsock = %u", maxsock );
+		 }
+#endif
+#if defined(ACTION_TEC_IPV6_CODE_FOR_IOT) && defined(ACTION_TEC_IPV6_CODE_FOR_RAD)
+				FD_SET(rad_fd, &r);
+				maxsock = (rad_fd > maxsock) ? rad_fd: maxsock;
+#endif
+
 		ret = select(maxsock + 1, &r, NULL, NULL, w);
 
 		switch (ret) {
@@ -546,6 +1814,112 @@
 		}
 		if (FD_ISSET(sock, &r))
 			client6_recv();
+
+#ifdef ACTION_TEC_IPV6_CODE_FOR_DAD
+        if (FD_ISSET(fd_netlink, &r)) {
+            static struct dhcp6_if *p_if = NULL;
+
+            rc_netlink = netlink_recv( fd_netlink, &p_if );
+            if( rc_netlink == 0 ) {
+                // ifconfig DADFAILED detected
+                char temp[64] = { 0 };
+                inet_ntop( AF_INET6, &( p_if->addr), temp, sizeof(temp));
+                dprintf(LOG_INFO, FNAME, "netlink_recv: DADFAILED detected, ifname: %s, ipaddr: %s", p_if->ifname, temp );
+
+                decline_all_ia( p_if );
+            }
+        }
+#endif
+
+#if defined(ACTION_TEC_IPV6_CODE_FOR_IOT) && defined(ACTION_TEC_IPV6_CODE_FOR_RAD)
+				if (FD_ISSET(rad_fd, &r))
+				{
+					int status = -1;
+					int tr69_type = 0;
+					char *tr69_chr_val = NULL;
+					int b_dhcp6senable;
+
+					status = recvmsg(rad_fd, &rad_msg, 0);
+					if (status < 0)
+					{
+						nl_close(rad_fd);
+						free(p_rad_nlh);
+						fprintf(stdout, "%s[%d]: select, recvmsg failed!!!\n", __FILE__, __LINE__);
+					}
+					else
+					{
+						p_rad_icmpv6 = (struct icmpv6_nd_ra *)NLMSG_DATA(p_rad_nlh);
+						fprintf(stdout, "Message length is %d,M bit %d,O bit %d,lifetime is %d\n",
+							p_rad_nlh->nlmsg_len,p_rad_icmpv6->managed,p_rad_icmpv6->other,ntohs(p_rad_icmpv6->rt_lifetime));
+
+						/* check if Mbit and Obit is invalid */
+						rad_ra_Mbit = p_rad_icmpv6->managed;
+						rad_ra_Obit = p_rad_icmpv6->other;
+						if ((rad_ra_Mbit < 0) || (rad_ra_Obit < 0))
+						{
+							fprintf(stdout, "%s[%d]: select, M(%d) or O(%d) flag is wrong!!!\n", __FILE__, __LINE__, rad_ra_Mbit, rad_ra_Obit);
+							nl_close(rad_fd);
+							free(p_rad_nlh);
+						}
+						else	//M and O flag is right
+						{
+							/* check if M/O flags is changed */
+							if (is_MO_flags_changed(rad_ra_Mbit, rad_ra_Obit) == 1) //M and O flag is changed
+							{
+								char *p_ifname = NULL;
+
+								if (get_ifname_from_datamodel(&p_ifname) < 0)
+								{
+									fprintf(stdout, "%s[%d]: select, get ifname from datamodel failed!\n", __FILE__, __LINE__);
+									nl_close(rad_fd);
+									free(p_rad_nlh);
+								}
+								else	//get ifname right
+								{
+								    if(!isUserDefineMode())
+								        {
+									//re-generate conf file
+									fprintf(stdout, "%s[%d]: ifname=%s!\n", __FILE__, __LINE__, p_ifname);
+									gen_dhcp6c_conf(p_ifname, 1, get_dhcpv6_mode(rad_ra_Mbit, rad_ra_Obit));
+									fprintf(stdout, "dhcp6c mode change: %d\n", get_dhcpv6_mode(rad_ra_Mbit, rad_ra_Obit));
+
+									//reload dhcp6c
+									free_resources(NULL);
+									client6_reload();
+									//restart dhcp6c
+									dprintf(LOG_INFO, FNAME, "dhcp6c restarting!!!!!\n");
+									client6_startall(1);
+								}
+							}
+						}
+						}
+
+						/* Check if router lifetime is changed */
+						rad_ra_routelifetime = get_router_lifetime_from_datamodel();
+						/* save ra info to datamode */
+						save_ra_info_to_datamodel(p_rad_icmpv6->managed, p_rad_icmpv6->other, p_rad_icmpv6->rt_lifetime);
+
+						/* check if Rouetr Lifetime is changed */
+                        if(get_RA_config_type_from_datamodel()==1)//dynamic
+                        {
+						if ((rad_ra_routelifetime != p_rad_icmpv6->rt_lifetime) &&
+							((p_rad_icmpv6->rt_lifetime == 0) || (rad_ra_routelifetime == 0)))
+						{
+							rad_ra_routelifetime = p_rad_icmpv6->rt_lifetime;
+							tr69_get_unfresh_leaf_data( CTLOID_IPV6_LAN_HOST_CFG".DHCPv6ServerEnable",
+									(tsl_void_t **)&tr69_chr_val,
+									(tsl_int_t *)&tr69_type);
+							b_dhcp6senable = (int)((long)tr69_chr_val);
+							fprintf(stdout, "rad: b_dhcp6senable=%d\n", b_dhcp6senable);
+							tr69_set_leaf_data( CTLOID_IPV6_LAN_HOST_CFG".DHCPv6ServerEnable",
+									(tsl_void_t *)&b_dhcp6senable,
+									TR69_NODE_LEAF_TYPE_BOOL);
+						}
+                        }
+					}
+				}
+#endif
+
 		if (ctlsock >= 0) {
 			if (FD_ISSET(ctlsock, &r)) {
 				(void)dhcp6_ctl_acceptcommand(ctlsock,
@@ -596,7 +1970,11 @@
 	if (*lenp < ifnamelen || ifnamelen > ifbuflen)
 		return (-1);
 
+#if defined(AEI_COVERITY_FIX)
+	memset(ifbuf, 0, ifnamelen);
+#else
 	memset(ifbuf, 0, sizeof(ifbuf));
+#endif
 	memcpy(ifbuf, *bpp, ifnamelen);
 	if (ifbuf[ifbuflen - 1] != '\0')
 		return (-1);	/* not null terminated */
@@ -726,7 +2104,7 @@
 		return (DHCP6CTL_R_FAILURE);
 	}
 
-  	return (DHCP6CTL_R_DONE);
+	return (DHCP6CTL_R_DONE);
 }
 
 static void
@@ -800,6 +2178,34 @@
 
 	return (NULL);
 }
+#ifdef CDROUTER_TEST_DHCP6C
+static int all_ia_busy(ifp)
+    struct dhcp6_if *ifp;
+{
+    struct ia_conf *iac;
+    int tot_ia_cnt=0;
+    int busy_ia_cnt=0;
+	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
+	    iac = TAILQ_NEXT(iac, link)) {
+		tot_ia_cnt++;
+
+		if (!TAILQ_EMPTY(&iac->iadata))
+		    {
+                ctllog_debug(LOG_NOTICE,FLNAME,LINENUM,FNAME,"iac->type=%d,iac->iaid=%d, busy now",iac->type,iac->iaid);
+                busy_ia_cnt++;
+		    }
+	     }
+              ctllog_debug(LOG_ERR,FLNAME,LINENUM,FNAME, "tot_ia_cnt=%d,busy_ia_cnt=%d",tot_ia_cnt,busy_ia_cnt);
+
+     if(tot_ia_cnt && tot_ia_cnt==busy_ia_cnt)
+        {
+            ctllog_debug(LOG_NOTICE,FLNAME,LINENUM,FNAME,"==>all IA busy now");
+            return 1;
+        }
+     else
+        return 0;
+}
+#endif
 
 struct dhcp6_timer *
 client6_timo(arg)
@@ -830,26 +2236,96 @@
 	switch(ev->state) {
 	case DHCP6S_INIT:
 		ev->timeouts = 0; /* indicate to generate a new XID. */
+#ifdef CONFIG_IOT_RECONFIGURATION
+		if ((ifp->send_flags & DHCIFF_INFO_ONLY) || infreq_mode || infreq_reconf)
+#else
 		if ((ifp->send_flags & DHCIFF_INFO_ONLY) || infreq_mode)
+#endif
 			ev->state = DHCP6S_INFOREQ;
 		else {
+#ifdef CDROUTER_TEST_DHCP6C
+          ctllog_debug(LOG_INFO,FLNAME,LINENUM,FNAME, "to test al ia busy,all_ia_pre_order=%d",
+          all_ia_pre_order);
+            if( all_ia_busy(ifp) || all_ia_pre_order==1)
+            {
+                ctllog_debug(LOG_INFO,FLNAME,LINENUM,FNAME,"dhcp6_remove_event");
+                dhcp6_remove_event(ev);
+                return (NULL);
+            }
+#endif
 			ev->state = DHCP6S_SOLICIT;
 			if (construct_confdata(ifp, ev)) {
 				dprintf(LOG_ERR, FNAME, "can't send solicit");
 				exit(1); /* XXX */
 			}
 		}
+//confict with XXX requirement,we wan to keep the old PD
+//#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+	if( ev->state == DHCP6S_SOLICIT )
+	    {
+            if(get_dhcpv6_request_manner()==1 && send_confirm==1)
+            {
+				 char *wan_dhcpv6_ipv6_addr[64] = { 0 };
+				 if( ctl_layer_cfg_check( ifp, (char *)wan_dhcpv6_ipv6_addr ) == 0 ) {
+					 ev->state = DHCP6S_CONFIRM;
+
+					 dprintf(LOG_INFO, FNAME, "wan_dhcpv6_ipv6_addr = %s\n", wan_dhcpv6_ipv6_addr);
+				 }
+
+                }
+                dprintf(LOG_NOTICE, FNAME,
+			    "will not send comfirm later");
+                send_confirm=0;
+            }
+
+//#endif
+
 		dhcp6_set_timeoparam(ev); /* XXX */
 		/* fall through */
 	case DHCP6S_REQUEST:
 	case DHCP6S_RELEASE:
 	case DHCP6S_INFOREQ:
+#ifdef ACTION_TEC_IPV6_CODE_FOR_CONFIRM
+       case DHCP6S_CONFIRM:
+#endif
 		client6_send(ev);
 		break;
 	case DHCP6S_RENEW:
 	case DHCP6S_REBIND:
 		if (!TAILQ_EMPTY(&ev->data_list))
+		{
+#if 0 //ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+			if(  DHCP6S_REBIND == ev->state )
+			{
+				dprintf(LOG_INFO, FNAME,"******DHCP6S_REBIND %d\n ",rmna);
+				struct dhcp6_eventdata * pevt =NULL;
+				for (pevt = TAILQ_FIRST(&ev->data_list); pevt; pevt = TAILQ_NEXT(pevt, link))
+					{
+						if( pevt->type == DHCP6_EVDATA_IANA && 0 == rmna)
+							{
+							       char *wan_dhcpv6_ipv6_addr[64] = { 0 };
+							       if( ctl_layer_cfg_check( ifp, wan_dhcpv6_ipv6_addr ) == 0 )
+							       {
+									remove_na_address(ifp,wan_dhcpv6_ipv6_addr, &rmna);
+									dprintf(LOG_INFO, FNAME,"*****RM_NA_Addr type[%d] ifname[%s]  wan[%s]",
+										pevt->type,ifp->ifname,wan_dhcpv6_ipv6_addr);
+							       }
+							}
+						else if( pevt->type == DHCP6_EVDATA_IAPD && 0 == rmpd )
+							{
+								char *wan_dhcpv6_ipv6_addr[64] = { 0 };
+							       if( ctl_layer_cfg_check( ifp, wan_dhcpv6_ipv6_addr ) == 0 )
+							       {
+									remove_na_address(ifp,wan_dhcpv6_ipv6_addr, &rmpd);
+									dprintf(LOG_INFO, FNAME,"*****RM_PD_Addr type[%d] ifname[%s]  wan[%s]",
+										pevt->type,ifp->ifname,wan_dhcpv6_ipv6_addr);
+							       }
+							}
+					}
+			}
+#endif
 			client6_send(ev);
+		}
 		else {
 			dprintf(LOG_INFO, FNAME,
 			    "all information to be updated was canceled");
@@ -899,10 +2375,28 @@
 		client6_send(ev);
 		break;
 	}
+/*coverity CID:12833 added by libby*/
+#ifdef AEI_COVERITY_FIX
+   if(ev)
+   {
+     dhcp6_reset_timer(ev);
+   }
+#else
+    dhcp6_reset_timer(ev);
+#endif
 
-	dhcp6_reset_timer(ev);
-
-	return (ev->timer);
+#ifdef AEI_COVERITY_FIX
+    if(ev)
+    {
+	    return (ev->timer);
+    }
+    else
+    {
+        return NULL;
+    }
+#else
+    return (ev->timer);
+#endif
 }
 
 static int
@@ -914,14 +2408,26 @@
 	struct dhcp6_eventdata *evd = NULL;
 	struct dhcp6_list *ial = NULL, pl;
 	struct dhcp6_ia iaparam;
-
+#ifdef CDROUTER_TEST_DHCP6C
+    int tot_ia_cnt=0;
+    int busy_ia_cnt=0;
+#endif
 	TAILQ_INIT(&pl);	/* for safety */
 
 	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
 	    iac = TAILQ_NEXT(iac, link)) {
+#ifdef CDROUTER_TEST_DHCP6C
+         tot_ia_cnt++;
+#endif
 		/* ignore IA config currently used */
 		if (!TAILQ_EMPTY(&iac->iadata))
+		    {
+#ifdef CDROUTER_TEST_DHCP6C
+        ctllog_debug(LOG_NOTICE,FLNAME,LINENUM,FNAME,"iac->type=%d,iac->iaid=%d",iac->type,iac->iaid);
+		        busy_ia_cnt++;
+#endif
 			continue;
+		    }
 
 		evd = NULL;
 		if ((evd = malloc(sizeof(*evd))) == NULL) {
@@ -929,7 +2435,11 @@
 			    "failed to create a new event data");
 			goto fail;
 		}
+#if defined(AEI_COVERITY_FIX)
+		memset(evd, 0, sizeof(*evd));
+#else
 		memset(evd, 0, sizeof(evd));
+#endif
 
 		memset(&iaparam, 0, sizeof(iaparam));
 		iaparam.iaid = iac->iaid;
@@ -944,7 +2454,7 @@
 			dhcp6_copy_list(&pl,
 			    &((struct iapd_conf *)iac)->iapd_prefix_list);
 			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IAPD,
-			    &iaparam, &pl) == NULL) {
+			    &iaparam, &pl, 0) == NULL) {
 				goto fail;
 			}
 			dhcp6_clear_list(&pl);
@@ -965,7 +2475,7 @@
 			dhcp6_copy_list(&pl,
 			    &((struct iana_conf *)iac)->iana_address_list);
 			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IANA,
-			    &iaparam, &pl) == NULL) {
+			    &iaparam, &pl, 0) == NULL) {
 				goto fail;
 			}
 			dhcp6_clear_list(&pl);
@@ -981,7 +2491,14 @@
 			exit(1);
 		}
 	}
-
+#ifdef CDROUTER_TEST_DHCP6C
+     ctllog_debug(LOG_ERR,FLNAME,LINENUM,FNAME, "tot_ia_cnt=%d,busy_ia_cnt=%d",tot_ia_cnt,busy_ia_cnt);
+    if(busy_ia_cnt==0)
+        {
+            all_ia_pre_order=1;
+            ctllog_debug(LOG_ERR,FLNAME,LINENUM,FNAME, "set all_ia_pre_order to %d",all_ia_pre_order);
+        }
+#endif
 	return (0);
 
   fail:
@@ -990,7 +2507,7 @@
 	if (ial)
 		free(ial);
 	dhcp6_remove_event(ev);	/* XXX */
-	
+
 	return (-1);
 }
 
@@ -1036,7 +2553,7 @@
 
 			TAILQ_INIT(ial);
 			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IAPD,
-			    &iaparam, &v->sublist) == NULL) {
+			    &iaparam, &v->sublist, 0) == NULL) {
 				goto fail;
 			}
 
@@ -1059,7 +2576,7 @@
 
 			TAILQ_INIT(ial);
 			if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IANA,
-			    &iaparam, &v->sublist) == NULL) {
+			    &iaparam, &v->sublist, 0) == NULL) {
 				goto fail;
 			}
 
@@ -1086,7 +2603,7 @@
 	if (ial)
 		free(ial);
 	dhcp6_remove_event(ev);	/* XXX */
-	
+
 	return (-1);
 }
 
@@ -1143,6 +2660,10 @@
 	}
 }
 
+#ifdef ACTION_TEC_IPV6_CODE_FOR_CONFIRM
+static int s_stcode_confirm = -1; // Restore CONFRIM state code
+#endif
+
 void
 client6_send(ev)
 	struct dhcp6_event *ev;
@@ -1167,6 +2688,14 @@
 	case DHCP6S_REQUEST:
 		dh6->dh6_msgtype = DH6_REQUEST;
 		break;
+#ifdef ACTION_TEC_IPV6_CODE_FOR_CONFIRM
+	case DHCP6S_CONFIRM:
+		dh6->dh6_msgtype = DH6_CONFIRM;
+		break;
+    case DHCP6S_DECLINE:
+        dh6->dh6_msgtype = DH6_DECLINE;
+        break;
+#endif
 	case DHCP6S_RENEW:
 		dh6->dh6_msgtype = DH6_RENEW;
 		break;
@@ -1215,6 +2744,9 @@
 	case DHCP6S_REQUEST:
 	case DHCP6S_RENEW:
 	case DHCP6S_RELEASE:
+#ifdef ACTION_TEC_IPV6_CODE_FOR_DECLINE
+	case DHCP6S_DECLINE:
+#endif
 		if (duidcpy(&optinfo.serverID, &ev->serverid)) {
 			dprintf(LOG_ERR, FNAME, "failed to copy server ID");
 			goto end;
@@ -1255,7 +2787,7 @@
 			/*
 			 * Perhaps we are nervous too much, but without this
 			 * additional check, we would see an overflow in 248
-			 * days (of no responses). 
+			 * days (of no responses).
 			 */
 			et = MAX_ELAPSED_TIME;
 		} else {
@@ -1268,6 +2800,9 @@
 
 	/* option request options */
 	if (ev->state != DHCP6S_RELEASE &&
+#ifdef ACTION_TEC_IPV6_CODE_FOR_DECLINE
+	    ev->state != DHCP6S_DECLINE &&
+#endif
 	    dhcp6_copy_list(&optinfo.reqopt_list, &ifp->reqopt_list)) {
 		dprintf(LOG_ERR, FNAME, "failed to copy requested options");
 		goto end;
@@ -1278,14 +2813,34 @@
 	     evd = TAILQ_NEXT(evd, link)) {
 		switch(evd->type) {
 		case DHCP6_EVDATA_IAPD:
+#ifdef ACTION_TEC_IPV6_CODE_FOR_CONFIRM
+						// CONFIRM cannot send IA_PD @ RFC3633 12.1
+						if ( ev->state == DHCP6S_CONFIRM )
+							break;
+#endif
 			if (dhcp6_copy_list(&optinfo.iapd_list,
 			    (struct dhcp6_list *)evd->data)) {
 				dprintf(LOG_NOTICE, FNAME,
 				    "failed to add an IAPD");
 				goto end;
 			}
+#ifdef AEI_RENEW_OLD_PD
+            if(get_dhcpv6_request_manner()==0)
+            {
+			if(iReq==1 && dh6->dh6_msgtype == DH6_REQUEST)
+			{
+				iReq=2;
+				dh6->dh6_msgtype = DH6_RENEW;
+			}
+            }
+#endif
 			break;
 		case DHCP6_EVDATA_IANA:
+#ifdef ACTION_TEC_IPV6_CODE_FOR_CONFIRM
+            // After CONFIRM, Only SOLICIT for PD, not for NA
+            if ( ev->state == DHCP6S_SOLICIT && s_stcode_confirm == DH6OPT_STCODE_SUCCESS )
+                break;
+#endif
 			if (dhcp6_copy_list(&optinfo.iana_list,
 			    (struct dhcp6_list *)evd->data)) {
 				dprintf(LOG_NOTICE, FNAME,
@@ -1388,7 +2943,13 @@
 static void
 client6_recv()
 {
-	char rbuf[BUFSIZ], cmsgbuf[BUFSIZ];
+   ctllog_debug(LOG_ERR,FLNAME,LINENUM,FNAME, "<<===========recv msg, BUFSIZ=%d",BUFSIZ);
+#ifdef CDROUTER_TEST_DHCP6C
+    char rbuf[BUFSIZ*2];
+#else
+    char rbuf[BUFSIZ];
+#endif
+	char cmsgbuf[BUFSIZ];
 	struct msghdr mhdr;
 	struct iovec iov;
 	struct sockaddr_storage from;
@@ -1415,7 +2976,7 @@
 		dprintf(LOG_ERR, FNAME, "recvmsg: %s", strerror(errno));
 		return;
 	}
-
+    ctllog_debug(LOG_ERR,FLNAME,LINENUM,FNAME, "msg length=%d",len );
 	/* detect receiving interface */
 	for (cm = (struct cmsghdr *)CMSG_FIRSTHDR(&mhdr); cm;
 	     cm = (struct cmsghdr *)CMSG_NXTHDR(&mhdr, cm)) {
@@ -1458,11 +3019,20 @@
 
 	switch(dh6->dh6_msgtype) {
 	case DH6_ADVERTISE:
+#ifdef AEI_CONTROL_LAYER
+		ctldhcp6cMsgBody.defaultGWAssigned = TSL_B_TRUE;
+		strcpy(ctldhcp6cMsgBody.defaultGW, addr2str((struct sockaddr *)&from));
+#endif
 		(void)client6_recvadvert(ifp, dh6, len, &optinfo);
 		break;
 	case DH6_REPLY:
 		(void)client6_recvreply(ifp, dh6, len, &optinfo);
 		break;
+#ifdef CONFIG_IOT_RECONFIGURATION
+	case DH6_RECONFIGURE:
+		(void)client6_reconfigure(ifp,dh6,len, &optinfo);
+		break;
+#endif
 	default:
 		dprintf(LOG_INFO, FNAME, "received an unexpected message (%s) "
 		    "from %s", dhcp6msgstr(dh6->dh6_msgtype),
@@ -1523,7 +3093,7 @@
 	 * includes a Status Code option containing the value NoPrefixAvail
 	 * [RFC3633 Section 11.1].
 	 * Likewise, the client MUST ignore any Advertise message that includes
-	 * a Status Code option containing the value NoAddrsAvail. 
+	 * a Status Code option containing the value NoAddrsAvail.
 	 * [RFC3315 Section 17.1.3].
 	 * We only apply this when we are going to request an address or
 	 * a prefix.
@@ -1713,11 +3283,17 @@
 	state = ev->state;
 	if (state != DHCP6S_INFOREQ &&
 	    state != DHCP6S_REQUEST &&
+#ifdef ACTION_TEC_IPV6_CODE_FOR_CONFIRM
+           state != DHCP6S_CONFIRM &&
+#endif
 	    state != DHCP6S_RENEW &&
 	    state != DHCP6S_REBIND &&
 	    state != DHCP6S_RELEASE &&
-	    (state != DHCP6S_SOLICIT ||
-	     !(ifp->send_flags & DHCIFF_RAPID_COMMIT))) {
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+		(state != DHCP6S_SOLICIT)) {
+#else
+		(state != DHCP6S_SOLICIT || !(ifp->send_flags & DHCIFF_RAPID_COMMIT))) {
+#endif
 		dprintf(LOG_INFO, FNAME, "unexpected reply");
 		return (-1);
 	}
@@ -1766,8 +3342,14 @@
 	 * status code option in the Reply message.
 	 * [RFC3315 Section 18.1.8]
 	 */
+
+	unsigned short stcode = 0;
+
 	for (lv = TAILQ_FIRST(&optinfo->stcode_list); lv;
 	     lv = TAILQ_NEXT(lv, link)) {
+#ifdef ACTION_TEC_IPV6_CODE_FOR_CONFIRM
+		 stcode = lv->val_num16;
+#endif
 		dprintf(LOG_INFO, FNAME, "status code: %s",
 		    dhcp6_stcodestr(lv->val_num16));
 	}
@@ -1781,6 +3363,14 @@
 			info_printf("nameserver[%d] %s",
 			    i, in6addr2str(&d->val_addr6, 0));
 		}
+
+#if 1 //brcm
+      updateDhcp6sConfDnsList(optinfo);
+#endif
+#ifdef CONFIG_IOT_RECONFIGURATION
+	if( state ==  DHCP6S_INFOREQ && infreq_reconf )
+		infreq_reconf = 0;
+#endif
 	}
 
 	if (!TAILQ_EMPTY(&optinfo->dnsname_list)) {
@@ -1791,7 +3381,25 @@
 		     d = TAILQ_NEXT(d, link), i++) {
 			info_printf("Domain search list[%d] %s",
 			    i, d->val_vbuf.dv_buf);
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+			  if( i == 0 )
+			  {
+						 snprintf(ctldhcp6cMsgBody.namesearchlist, BUFLEN_128-1,"%s",d->val_vbuf.dv_buf);
+				  //remove last dot
+				   int nLen = strlen(ctldhcp6cMsgBody.namesearchlist);
+				   if( nLen > 0 )
+				   {
+					  ctldhcp6cMsgBody.namesearchlist[nLen-1] = '\0';
+				   }
+					  dprintf(LOG_INFO, FNAME, "***DNS from dhcpv6 search list %s\n",ctldhcp6cMsgBody.namesearchlist);
+			  }
+#endif
+
 		}
+#ifdef CONFIG_IOT_RECONFIGURATION
+		if( state ==  DHCP6S_INFOREQ && infreq_reconf )
+			infreq_reconf = 0;
+#endif
 	}
 
 	if (!TAILQ_EMPTY(&optinfo->ntp_list)) {
@@ -1888,8 +3496,55 @@
 		    &optinfo->serverID, ev->authparam);
 	}
 
+//brcm
+//Now, we should finish updating prefix, addr, and dns info
+//send the message to smd now.
+	if (memcmp(&ctldhcp6cMsgBody, &ctldhcp6cMsgBody_Old, sizeof(CtlDhcp6cStateChangedMsgBody))) {
+		sendDhcp6cEventMessage();
+		memcpy(&ctldhcp6cMsgBody_Old, &ctldhcp6cMsgBody, sizeof(CtlDhcp6cStateChangedMsgBody));
+	}
+
+#ifdef ACTION_TEC_IPV6_CODE_FOR_CONFIRM
+    // sam @ 2011-05-12 11:22:40, Thu
+    // for In one case we were able to CONFIM our NA but Cisco replied to CONFIRM for PD with "not on link" error;
+    // we did not recover.
+    // We should SOLICIT for PD per RFC 3315 section 18.1.8 and 20.1.1.
+    if(  DHCP6S_CONFIRM == ev->state ) {
+        s_stcode_confirm = stcode;
+
+        ev->state = DHCP6S_SOLICIT;
+
+        ev->timeouts = -1;  // make sure: timeouts ++ = 0
+        // dhcp6_set_timeoparam(ev);
+        // dhcp6_reset_timer(ev);
+
+        dprintf(LOG_DEBUG, FNAME, "got an expected REPLY for CONFRIM, stcode=%s, then send SOLICIT ...\n", dhcp6_stcodestr(s_stcode_confirm) );
+
+        return (0);
+    }
+#endif
+
 	dhcp6_remove_event(ev);
 
+#ifdef ACTION_TEC_IPV6_CODE_FOR_DECLINE
+    if(ev)
+    {
+		if(  DHCP6S_REBIND == ev->state )
+		{
+			dprintf(LOG_INFO, FNAME,"&&&&&&&&DHCP6C_REBIND restore rm NA address flag1\n ");
+			struct dhcp6_eventdata * pevt =NULL;
+			for (pevt = TAILQ_FIRST(&ev->data_list); pevt; pevt = TAILQ_NEXT(pevt, link))
+				{
+					if( pevt->type == DHCP6_EVDATA_IANA &&	1 == rmna)
+						{
+							rmna = 0;
+							dprintf(LOG_INFO, FNAME,"&&&&&&&&DHCP6C_REBIND restore rm NA address flag2\n ");
+						}
+				}
+		}
+    }
+#endif
+
 	if (state == DHCP6S_RELEASE) {
 		/*
 		 * When the client receives a valid Reply message in response
@@ -1911,6 +3566,92 @@
 	}
 	return (0);
 }
+#ifdef CONFIG_IOT_RECONFIGURATION
+static int
+client6_reconfigure_info(ifp)
+        struct dhcp6_if *ifp;
+{
+        infreq_reconf = 1;
+        return client6_start(ifp);
+}
+
+static int
+client6_reconfigure(ifp, dh6, len, optinfo)
+	struct dhcp6_if *ifp;
+	struct dhcp6 *dh6;
+	ssize_t len;
+	struct dhcp6_optinfo *optinfo;
+{
+	struct ia *ia;
+
+
+       /* RFC 3315, 19.4.1.
+        * The client ignores the transaction-id field in the received Reconfigure
+        * message.
+        */
+       dprintf(LOG_DEBUG, FNAME, "XID should be zero.(%d)\n",ntohl(dh6->dh6_xid));
+
+	   /* A Reconfigure message must contain a Server ID option */
+       if (optinfo->serverID.duid_len == 0) {
+               dprintf(LOG_INFO, FNAME, "no server ID option");
+               return (-1);
+       }
+
+
+       /*
+        * DUID in the Client ID option (which must be contained for our
+        * client implementation) must match ours.
+        */
+       if (optinfo->clientID.duid_len == 0) {
+               dprintf(LOG_INFO, FNAME, "no client ID option");
+               return (-1);
+       }
+       if (duidcmp(&optinfo->clientID, &client_duid)) {
+               dprintf(LOG_INFO, FNAME, "client DUID mismatch");
+               return (-1);
+       }
+	/* validate authentication */
+	if (process_auth(&g_auth_param, dh6, len, optinfo)) {
+		ctllog_debug(LOG_INFO,FLNAME,LINENUM,FNAME, "failed to process authentication");
+		return (-1);
+	}
+        if( optinfo->reconf_type == RECONF_TYPE_INFO)
+        {
+                client6_reconfigure_info(ifp);
+        }
+        else if( optinfo->reconf_type == RECONF_TYPE_RENEW)
+            renew_when_reconfig(ifp,&optinfo->serverID);
+        else if( optinfo->reconf_type == RECONF_TYPE_REBIND)
+        {
+            ctllog_debug(LOG_INFO,FLNAME,LINENUM,FNAME, "reconf_type %d unsupport now!!!",optinfo->reconf_type);
+        }
+        else
+            ctllog_debug(LOG_INFO,FLNAME,LINENUM,FNAME, "reconf_type %d is not define in RFC!!!",optinfo->reconf_type);
+
+
+       if (infreq_mode) {
+               exit_ok = 1;
+               free_resources(NULL);
+               unlink(pid_file);
+               check_exit();
+       }
+       return (0);
+}
+
+static struct dhcp6_event *
+find_event_withoutid(ifp)
+       struct dhcp6_if *ifp;
+{
+       struct dhcp6_event *ev;
+
+       for (ev = TAILQ_FIRST(&ifp->event_list); ev;
+            ev = TAILQ_NEXT(ev, link)) {
+               return (ev);
+       }
+
+       return (NULL);
+}
+#endif
 
 static struct dhcp6_event *
 find_event_withid(ifp, xid)
@@ -2028,6 +3769,83 @@
 		}
 
 		break;
+#ifdef CONFIG_IOT_RECONFIGURATION
+		case DHCP6_AUTHPROTO_RECONFIG:
+				if (optinfo->authflags == DHCP6OPT_AUTHFLAG_NOINFO) {
+						dprintf(LOG_INFO, FNAME, "No INFO for RECONFIGURE KEY");
+						break;
+				}
+
+				dprintf(LOG_INFO, FNAME, "Need check this "
+					"authentication protocol (%d)- AUTHPROTO_RECONFIG, "
+						"Algorithm is %d,RDM is %d",
+										optinfo->authproto,optinfo->authalgorithm,optinfo->authrdm);
+		 if (optinfo->authalgorithm != DHCP6_AUTHALG_HMACMD5) {
+			 dprintf(LOG_INFO, FNAME, "unknown authentication "
+					 "algorithm (%d)", optinfo->authalgorithm);
+			 break;
+		 }
+
+		 if (optinfo->authrdm != DHCP6_AUTHRDM_MONOCOUNTER) {
+			 dprintf(LOG_INFO, FNAME,"unknown RDM (%d)",
+					 optinfo->authrdm);
+			 break;
+		 }
+		 /*
+		 * Replay protection.  If we do not know the previous RD value,
+		 * we accept the message anyway (XXX).
+		 */
+		 if ((authparam->flags & AUTHPARAM_FLAGS_NOPREVRD)) {
+			 dprintf(LOG_WARNING, FNAME, "previous RD value is "
+					 "unknown (accept it)");
+		 }
+		 else {
+			 if (dhcp6_auth_replaycheck(optinfo->authrdm,
+										authparam->prevrd, optinfo->authrd)) {
+				 dprintf(LOG_INFO, FNAME,
+						 "possible replay attack detected");
+				 break;
+			 }
+		 }
+
+				switch(optinfo->reconfigauth_type ) {
+				case DHCP6_RECONF_AUTH_KEY:
+						/*Got the key*/
+						memcpy(authparam->reconf_key,optinfo->reconfigauth_val,DHCP6_RECONFIGURE_AUTH_KEY_LENGTH);
+						authparam->reconf_key_type = optinfo->authalgorithm;
+                        memcpy(g_auth_param.reconf_key,optinfo->reconfigauth_val,DHCP6_RECONFIGURE_AUTH_KEY_LENGTH);
+						g_auth_param.reconf_key_type = optinfo->authalgorithm;
+						authenticated = 1;
+						dprintf(LOG_INFO, FNAME,
+										"GOT KEY");
+			 break;
+		 case DHCP6_RECONF_AUTH_INFO:
+			 /*Need authentication*/
+						if (authparam->reconf_key_type != optinfo->authalgorithm) {
+								dprintf(LOG_INFO, FNAME,
+						 "KEY type and auth algorithm mismatched");
+						}
+
+						/* validate MAC */
+			 if (dhcp6_reconf_verify_mac((char *)dh6, len, optinfo->authproto,
+								  optinfo->authalgorithm,
+								  optinfo->reconfigauth_offset + sizeof(*dh6),
+																 authparam->reconf_key ,DHCP6_RECONFIGURE_AUTH_KEY_LENGTH) == 0) {
+				 dprintf(LOG_DEBUG, FNAME, "message authentication "
+						 "validated");
+				 authenticated = 1;
+			 }
+			 else {
+				 dprintf(LOG_INFO, FNAME, "invalid message "
+						 "authentication");
+			 }
+						break;
+				default:
+						break;
+				}
+
+				break;
+#endif
 	default:
 		dprintf(LOG_INFO, FNAME, "server sent unsupported "
 		    "authentication protocol (%d)", optinfo->authproto);
@@ -2049,6 +3867,10 @@
 		/* if authenticated, update the "previous" RD value */
 		authparam->prevrd = optinfo->authrd;
 		authparam->flags &= ~AUTHPARAM_FLAGS_NOPREVRD;
+#ifdef CONFIG_IOT_RECONFIGURATION
+		g_auth_param.prevrd = optinfo->authrd;
+		g_auth_param.flags &= ~AUTHPARAM_FLAGS_NOPREVRD;
+#endif
 	}
 
 	return (0);
@@ -2146,3 +3968,75 @@
 
 	return;
 }
+
+#ifdef AEI_CONTROL_LAYER
+int updateDhcp6sConfDnsList(struct dhcp6_optinfo *opt)
+{
+   struct dhcp6_listval *d;
+   char   nameserver[BUFLEN_128];
+
+   d = TAILQ_FIRST(&opt->dns_list);
+   if (d != NULL)
+   {
+      sprintf(nameserver, "%s", in6addr2str(&d->val_addr6, 0));
+   }
+   d = TAILQ_NEXT(d, link);
+   if (d != NULL)
+   {
+      strcat(nameserver, ",");
+      strcat(nameserver, in6addr2str(&d->val_addr6, 0));
+   }
+
+   sendDnsEventMessage(nameserver);
+
+   return 0;
+
+}  /* End of updateDhcp6sConfDnsList() */
+
+void sendDnsEventMessage(const char *nameserver)
+{
+	ctldhcp6cMsgBody.dnsAssigned = TSL_B_TRUE;
+	strcpy(ctldhcp6cMsgBody.nameserver, nameserver);
+
+	dprintf(LOG_NOTICE, FNAME, "DHCP6C_DNS_CHANGED");
+
+	return;
+
+}  /* End of sendDnsEventMessage() */
+
+void sendDhcp6cEventMessage(void)
+{
+
+   char buf[sizeof(CtlMsgHeader) + sizeof(CtlDhcp6cStateChangedMsgBody)]={0};
+   CtlMsgHeader *msg=(CtlMsgHeader *) buf;
+   CtlDhcp6cStateChangedMsgBody *dhcp6cBody = (CtlDhcp6cStateChangedMsgBody *) (msg->buffer);
+   dbussend_hdl_st *ctlMsgHandle=NULL;
+   ctlMsgHandle = dbussend_init();
+#ifdef CONFIG_IOT_RECONFIGURATION
+    got_valid_ia_pd=0;
+    got_valid_ia_na=0;
+#endif
+
+   if (!ctlMsgHandle) {
+	   tsl_printf("dbussend_init fail\n");
+	   return -1;
+   }
+
+   memcpy(dhcp6cBody, &ctldhcp6cMsgBody, sizeof(CtlDhcp6cStateChangedMsgBody));
+   msg->data_length=sizeof(CtlDhcp6cStateChangedMsgBody);
+   if (dbussend_sendmsg(ctlMsgHandle, CTL_MSG_TYPE(CTL_MSG_DHCP6C_STATE_CHANGED), NULL, msg, sizeof(CtlMsgHeader)+sizeof(CtlDhcp6cStateChangedMsgBody)) < 0)
+   {
+	   tsl_printf("could not send out DHCP6C_STATUS_CHANGED\n");
+	   dbussend_uninit(ctlMsgHandle);
+	   return -1;
+   }else
+   {
+		//tsl_printf("===>>>sent out DHCP6C_STATUS_CHANGED\n");
+   }
+
+   dbussend_uninit(ctlMsgHandle);
+   return;
+
+}  /* End of sendDhcp6cEventMessage() */
+
+#endif
diff -Naur dhcpv6-aei/dhcp6c.h dhcpv6-aei-brcm/dhcp6c.h
--- dhcpv6-aei/dhcp6c.h	2007-03-21 06:52:54.000000000 -0300
+++ dhcpv6-aei-brcm/dhcp6c.h	2019-06-13 11:48:57.551012801 -0300
@@ -35,3 +35,12 @@
 extern struct dhcp6_timer *client6_timo __P((void *));
 extern int client6_start __P((struct dhcp6_if *));
 extern void client6_send __P((struct dhcp6_event *));
+
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+extern int ctl_layer_cfg_check( struct dhcp6_if *ifp,char* wan_dhcpv6_ipv6_addr );
+extern void remove_na_address __P((struct dhcp6_if *,char*,int*) );
+extern void sendDhcp6cEventMessage __P((void));
+extern int rmna;
+extern int rmpd;
+
+#endif
diff -Naur dhcpv6-aei/dhcp6c_ia.c dhcpv6-aei-brcm/dhcp6c_ia.c
--- dhcpv6-aei/dhcp6c_ia.c	2007-03-21 06:52:55.000000000 -0300
+++ dhcpv6-aei-brcm/dhcp6c_ia.c	2019-06-13 11:48:57.551012801 -0300
@@ -48,8 +48,15 @@
 #include "dhcp6c_ia.h"
 #include "prefixconf.h"
 #include "addrconf.h"
-
-typedef enum {IAS_ACTIVE, IAS_RENEW, IAS_REBIND} iastate_t;
+#include "ctl_msg.h"
+#ifdef CDROUTER_TEST_DHCP6C
+extern int all_ia_pre_order;
+#endif
+extern CtlDhcp6cStateChangedMsgBody ctldhcp6cMsgBody;
+#ifdef CONFIG_IOT_RECONFIGURATION
+extern int got_valid_ia_pd;
+#endif
+typedef enum {IAS_ACTIVE, IAS_RENEW, IAS_REBIND, IAS_REQUEST, IAS_RELEASE} iastate_t;
 
 struct ia {
 	TAILQ_ENTRY(ia) link;
@@ -81,6 +88,7 @@
 static void reestablish_ia __P((struct ia *));
 static void callback __P((struct ia *));
 static int release_ia __P((struct ia *));
+static int decline_ia __P((struct ia *));
 static void remove_ia __P((struct ia *));
 static struct ia *get_ia __P((iatype_t, struct dhcp6_if *, struct ia_conf *,
     struct dhcp6_listval *, struct duid *));
@@ -90,6 +98,202 @@
 static char *iastr __P((iatype_t));
 static char *statestr __P((iastate_t));
 
+#ifdef CONFIG_IOT_RECONFIGURATION
+struct dhcp6_event *
+ia_reconf(arg)
+	void *arg;
+{
+	struct ia *ia = (struct ia *)arg;
+	struct dhcp6_ia iaparam;
+	struct dhcp6_event *ev;
+	struct dhcp6_eventdata *evd;
+	struct timeval timo;
+	int dhcpstate;
+
+	dprintf(LOG_DEBUG, FNAME, "IA timeout for %s-%lu, state=%s",
+	    iastr(ia->conf->type), ia->conf->iaid, statestr(ia->state));
+
+	/* cancel the current event for the prefix. */
+	if (ia->evdata) {
+		TAILQ_REMOVE(&ia->evdata->event->data_list, ia->evdata, link);
+		if (ia->evdata->destructor)
+			ia->evdata->destructor(ia->evdata);
+		free(ia->evdata);
+		ia->evdata = NULL;
+	}
+
+	switch (ia->state) {
+	case IAS_ACTIVE:
+		ia->state = IAS_RENEW;
+		dhcpstate = DHCP6S_RENEW;
+		timo.tv_sec = ia->t1 < ia->t2 ? ia->t2 - ia->t1 : 0;
+		timo.tv_usec = 0;
+		dhcp6_set_timer(&timo, ia->timer);
+		break;
+	case IAS_RENEW:
+		ia->state = IAS_REBIND;
+		dhcpstate = DHCP6S_REBIND;
+
+		/*
+		 * We need keep DUID for sending Release in this state.
+		 * But we don't need a timer for the IA.  We'll just wait for a
+		 * reply for the REBIND until all associated configuration
+		 * parameters for this IA expire.
+		 */
+		dhcp6_remove_timer(&ia->timer);
+		break;
+	default:
+		dprintf(LOG_ERR, FNAME, "invalid IA state (%d)",
+		    (int)ia->state);
+		return (NULL);	/* XXX */
+	}
+
+	if ((ev = dhcp6_create_event(ia->ifp, dhcpstate)) == NULL) {
+		dprintf(LOG_NOTICE, FNAME, "failed to create a new event");
+		goto fail;
+	}
+	TAILQ_INSERT_TAIL(&ia->ifp->event_list, ev, link);
+
+	if ((ev->timer = dhcp6_add_timer(client6_timo, ev)) == NULL) {
+		dprintf(LOG_NOTICE, FNAME,
+		    "failed to create a new event timer");
+		goto fail;
+	}
+
+	if ((evd = malloc(sizeof(*evd))) == NULL) {
+		dprintf(LOG_NOTICE, FNAME,
+		    "failed to create a new event data");
+		goto fail;
+	}
+	memset(evd, 0, sizeof(*evd));
+	evd->event = ev;
+	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+
+	if (ia->state == IAS_RENEW) {
+		if (duidcpy(&ev->serverid, &ia->serverid)) {
+			dprintf(LOG_NOTICE, FNAME, "failed to copy server ID");
+			goto fail;
+		}
+	}
+
+	iaparam.iaid = ia->conf->iaid;
+	iaparam.t1 = ia->t1;
+	iaparam.t2 = ia->t2;
+	switch(ia->state) {
+	case IAS_RENEW:
+		if (ia->ctl && ia->ctl->renew_data) {
+			if ((*ia->ctl->renew_data)(ia->ctl, &iaparam,
+			    &ia->evdata, evd)) {
+				dprintf(LOG_NOTICE, FNAME,
+				    "failed to make renew data");
+				goto fail;
+			}
+		}
+		break;
+	case IAS_REBIND:
+		if (ia->ctl && ia->ctl->rebind_data) {
+			if ((*ia->ctl->rebind_data)(ia->ctl, &iaparam,
+			    &ia->evdata, evd)) {
+				dprintf(LOG_NOTICE, FNAME,
+				    "failed to make rebind data");
+				goto fail;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	ev->timeouts = 0;
+	dhcp6_set_timeoparam(ev);
+	dhcp6_reset_timer(ev);
+
+	if (ia->authparam != NULL) {
+		if ((ev->authparam = copy_authparam(ia->authparam)) == NULL) {
+			dprintf(LOG_WARNING, FNAME,
+			    "failed to copy authparam");
+			goto fail;
+		}
+	}
+
+	ia->evdata = evd;
+
+	switch(ia->state) {
+	case IAS_RENEW:
+	case IAS_REBIND:
+		client6_send(ev);
+		break;
+	case IAS_ACTIVE:
+		/* what to do? */
+		break;
+	}
+
+	return (ia->timer);
+
+  fail:
+	if (ev)
+		dhcp6_remove_event(ev);
+
+	return (NULL);
+}
+struct ia *
+search_ia_with_server_duid(ifp,serverID)
+	struct dhcp6_if *ifp;
+	struct duid *serverID;
+{
+	struct ia_conf *iac;
+	struct ia *ia, *ia_next;
+	struct dhcp6_event *ev;
+
+	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
+	    iac = TAILQ_NEXT(iac, link)) {
+		for (ia = TAILQ_FIRST(&iac->iadata); ia; ia = ia_next) {
+			ia_next = TAILQ_NEXT(ia, link);
+
+			if (!duidcmp(serverID,&ia->serverid)){
+				return ia;
+			}
+		}
+	}
+	return NULL;
+}
+
+struct ia *
+renew_when_reconfig(ifp,serverID)
+	struct dhcp6_if *ifp;
+	struct duid *serverID;
+{
+	struct ia_conf *iac;
+	struct ia *ia, *ia_next;
+	struct dhcp6_event *ev;
+    struct ia_conf *conf;
+     ctllog_debug(LOG_DEBUG,FLNAME,LINENUM,FNAME,"RCF: serverID=(%s)",duidstr(serverID));
+
+
+	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
+	    iac = TAILQ_NEXT(iac, link)) {
+		for (ia = TAILQ_FIRST(&iac->iadata); ia; ia = ia_next) {
+			ia_next = TAILQ_NEXT(ia, link);
+            conf=ia->conf;
+            if(conf)
+                ctllog_debug(LOG_DEBUG,FLNAME,LINENUM,FNAME,"RCF: duidstr=(%s),iatype=%d,iaid=%d",
+                duidstr(&ia->serverid),conf->type,conf->iaid);
+			if (!duidcmp(serverID,&ia->serverid)){
+		   ia_renew(ia);
+				//return ia;
+			}
+
+		}
+	}
+	return NULL;
+}
+
+void ia_renew(struct ia *ia)
+{
+	ia_timo((void *)ia);
+}
+#endif
+
 void
 update_ia(iatype, ialist, ifp, serverid, authparam)
 	iatype_t iatype;
@@ -152,6 +356,15 @@
 			case DHCP6_LISTVAL_PREFIX6:
 				/* add or update the prefix */
 				iapdc = (struct iapd_conf *)iac;
+#ifdef CONFIG_IOT_RECONFIGURATION
+                if(got_valid_ia_pd==0 ||(got_valid_ia_pd>0 && siav->val_prefix6.pltime/*siav->val_prefix6.vltime*/))
+#endif
+                    {
+								ctldhcp6cMsgBody.t1= ia->t1;
+								ctldhcp6cMsgBody.t2 =ia->t2;
+								dprintf(LOG_NOTICE, FNAME,"*******T1 [%d] T2[%d]\n", ctldhcp6cMsgBody.t1,ctldhcp6cMsgBody.t2);
+                    }
+
 				if (update_prefix(ia, &siav->val_prefix6,
 				    &iapdc->iapd_pif_list, ifp, &ia->ctl,
 				    callback)) {
@@ -311,7 +524,7 @@
 	struct dhcp6_event *ev;
 	struct dhcp6_eventdata *evd;
 
-	dprintf(LOG_DEBUG, FNAME, "re-establishing IA: %s-%lu", 
+	dprintf(LOG_DEBUG, FNAME, "re-establishing IA: %s-%lu",
 	    iastr(ia->conf->type), ia->conf->iaid);
 
 	if (ia->state != IAS_RENEW && ia->state != IAS_REBIND) {
@@ -321,11 +534,15 @@
 
 	/* cancel the current event for the prefix. */
 	if (ia->evdata) {
+#ifdef SUPPORT_GPL_UNDEFINED		
+		free_ev_datalist(ia->evdata);
+#else
 		TAILQ_REMOVE(&ia->evdata->event->data_list, ia->evdata, link);
 		if (ia->evdata->destructor)
 			ia->evdata->destructor(ia->evdata);
 		free(ia->evdata);
 		ia->evdata = NULL;
+#endif
 	}
 
 	/* we don't need a timer for the IA (see comments in ia_timo()) */
@@ -344,6 +561,20 @@
 		goto fail;
 	}
 
+	if (duidcpy(&ev->serverid, &ia->serverid)) {
+		dprintf(LOG_NOTICE, FNAME, "failed to copy server ID");
+		goto fail;
+	}
+
+#ifdef SUPPORT_GPL_UNDEFINED
+	ia->state = IAS_REQUEST;
+	//XXX require request IA_NA and IA_PD at the same time
+	if(get_all_ia_data(ia,ev) <= 0)
+	{
+		dprintf(LOG_NOTICE, FNAME, "failed to get IA data");
+		goto fail;
+	}
+#else
 	if ((evd = malloc(sizeof(*evd))) == NULL) {
 		dprintf(LOG_NOTICE, FNAME,
 		    "failed to create a new event data");
@@ -353,11 +584,6 @@
 	evd->event = ev;
 	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
 
-	if (duidcpy(&ev->serverid, &ia->serverid)) {
-		dprintf(LOG_NOTICE, FNAME, "failed to copy server ID");
-		goto fail;
-	}
-
 	iaparam.iaid = ia->conf->iaid;
 	iaparam.t1 = ia->t1;
 	iaparam.t2 = ia->t2;
@@ -371,6 +597,9 @@
 		}
 	}
 
+	ia->evdata = evd;
+#endif
+
 	if (ia->authparam != NULL) {
 		if ((ev->authparam = copy_authparam(ia->authparam)) == NULL) {
 			dprintf(LOG_WARNING, FNAME,
@@ -383,7 +612,6 @@
 	dhcp6_set_timeoparam(ev);
 	dhcp6_reset_timer(ev);
 
-	ia->evdata = evd;
 
 	client6_send(ev);
 
@@ -414,13 +642,17 @@
 {
 	struct ia_conf *iac;
 	struct ia *ia, *ia_next;
+	int ia_num = 0;
 
 	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
 	    iac = TAILQ_NEXT(iac, link)) {
 		for (ia = TAILQ_FIRST(&iac->iadata); ia; ia = ia_next) {
 			ia_next = TAILQ_NEXT(ia, link);
-
-			(void)release_ia(ia);
+#ifdef SUPPORT_GPL_UNDEFINED
+			ia_num ++;
+			if(ia_num == 1) //release all ia at the same time
+#endif
+				(void)release_ia(ia);
 
 			/*
 			 * The client MUST stop using all of the addresses
@@ -431,6 +663,11 @@
 			remove_ia(ia);
 		}
 	}
+#ifdef CDROUTER_TEST_DHCP6C
+             ctllog_debug(LOG_WARNING,FLNAME,LINENUM,FNAME,
+			    "set all_ia_pre_order to 0");
+      all_ia_pre_order=0;
+#endif
 }
 
 static int
@@ -463,6 +700,15 @@
 		goto fail;
 	}
 
+#ifdef SUPPORT_GPL_UNDEFINED
+	ia->state = IAS_RELEASE;
+	//XXX require release IA_NA and IA_PD at the same time
+	if(get_all_ia_data(ia,ev) <= 0)
+	{
+		dprintf(LOG_NOTICE, FNAME, "failed to get IA data");
+		goto fail;
+	}
+#else
 	if ((evd = malloc(sizeof(*evd))) == NULL) {
 		dprintf(LOG_NOTICE, FNAME,
 		    "failed to create a new event data");
@@ -482,7 +728,7 @@
 		}
 	}
 	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
-
+#endif
 	ev->timeouts = 0;
 	dhcp6_set_timeoparam(ev);
 	dhcp6_reset_timer(ev);
@@ -517,18 +763,30 @@
 	    iastr(ia->conf->type), ia->conf->iaid);
 
 	TAILQ_REMOVE(&iac->iadata, ia, link);
-
+#ifdef CDROUTER_TEST_DHCP6C
+    if (TAILQ_EMPTY(&iac->iadata))
+        {
+            ctllog_debug(LOG_WARNING,FLNAME,LINENUM,FNAME,
+			    "set all_ia_pre_order to 0");
+            all_ia_pre_order=0;
+        }
+#endif
 	duidfree(&ia->serverid);
 
 	if (ia->timer)
 		dhcp6_remove_timer(&ia->timer);
 
 	if (ia->evdata) {
+#ifdef SUPPORT_GPL_UNDEFINED		
+		free_ev_datalist(ia->evdata);
+#else
+
 		TAILQ_REMOVE(&ia->evdata->event->data_list, ia->evdata, link);
 		if (ia->evdata->destructor)
 			ia->evdata->destructor(ia->evdata);
 		free(ia->evdata);
 		ia->evdata = NULL;
+#endif
 	}
 
 	if (ia->ctl && ia->ctl->cleanup)
@@ -552,17 +810,22 @@
 	struct dhcp6_eventdata *evd;
 	struct timeval timo;
 	int dhcpstate;
-
+    dhcp6_eventdata_t ia_type=DHCP6_EVDATA_IAPD;
 	dprintf(LOG_DEBUG, FNAME, "IA timeout for %s-%lu, state=%s",
 	    iastr(ia->conf->type), ia->conf->iaid, statestr(ia->state));
 
 	/* cancel the current event for the prefix. */
 	if (ia->evdata) {
+		ia_type=ia->evdata->type;
+#ifdef SUPPORT_GPL_UNDEFINED		
+		free_ev_datalist(ia->evdata);
+#else
 		TAILQ_REMOVE(&ia->evdata->event->data_list, ia->evdata, link);
 		if (ia->evdata->destructor)
 			ia->evdata->destructor(ia->evdata);
 		free(ia->evdata);
 		ia->evdata = NULL;
+#endif        
 	}
 
 	switch (ia->state) {
@@ -603,6 +866,41 @@
 		goto fail;
 	}
 
+    if (ia->state == IAS_RENEW) {
+		if (duidcpy(&ev->serverid, &ia->serverid)) {
+			dprintf(LOG_NOTICE, FNAME, "failed to copy server ID");
+			goto fail;
+		}
+	}
+
+#ifdef SUPPORT_GPL_UNDEFINED	
+	//XXX require renew/rebind IA_NA and IA_PD at the same time
+	if(get_all_ia_data(ia,ev) <= 0)
+	{
+		dprintf(LOG_NOTICE, FNAME, "failed to get IA data");
+		goto fail;
+	}
+
+	
+#ifdef ACTION_TEC_IPV6_CODE_FOR_REBIND
+	if(ia->state == IAS_REBIND)
+	{
+		dprintf(LOG_INFO, FNAME,"******ia_type=%d,DHCP6S_REBIND %d %d\n ",ia_type,rmna,rmpd);
+		if( ia_type== DHCP6_EVDATA_IANA )
+		{
+			char *wan_dhcpv6_ipv6_addr[64] = { 0 };
+			if( ctl_layer_cfg_check( ia->ifp, wan_dhcpv6_ipv6_addr ) == 0 )
+			{
+				remove_na_address(ia->ifp,wan_dhcpv6_ipv6_addr, &rmna);
+				dprintf(LOG_INFO, FNAME,"*****RM_NA_Addr  ifname[%s]  wan[%s]",
+				        ia->ifp->ifname,wan_dhcpv6_ipv6_addr);
+			}
+		}
+	}
+#endif
+
+
+#else
 	if ((evd = malloc(sizeof(*evd))) == NULL) {
 		dprintf(LOG_NOTICE, FNAME,
 		    "failed to create a new event data");
@@ -610,14 +908,7 @@
 	}
 	memset(evd, 0, sizeof(*evd));
 	evd->event = ev;
-	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
-
-	if (ia->state == IAS_RENEW) {
-		if (duidcpy(&ev->serverid, &ia->serverid)) {
-			dprintf(LOG_NOTICE, FNAME, "failed to copy server ID");
-			goto fail;
-		}
-	}
+	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);	
 
 	iaparam.iaid = ia->conf->iaid;
 	iaparam.t1 = ia->t1;
@@ -641,12 +932,51 @@
 				    "failed to make rebind data");
 				goto fail;
 			}
+#ifdef ACTION_TEC_IPV6_CODE_FOR_REBIND
+						dprintf(LOG_INFO, FNAME,"******ia_type=%d,DHCP6S_REBIND %d %d\n ",ia_type,rmna,rmpd);
+						if( ia_type== DHCP6_EVDATA_IANA /*&& 0 == rmna*/)
+							{
+								   char *wan_dhcpv6_ipv6_addr[64] = { 0 };
+								   if( ctl_layer_cfg_check( ia->ifp, wan_dhcpv6_ipv6_addr ) == 0 )
+								   {
+									remove_na_address(ia->ifp,wan_dhcpv6_ipv6_addr, &rmna);
+									dprintf(LOG_INFO, FNAME,"*****RM_NA_Addr  ifname[%s]  wan[%s]",
+										ia->ifp->ifname,wan_dhcpv6_ipv6_addr);
+								   }
+							}
+
+#if 0
+						if( ia->evdata->type == DHCP6_EVDATA_IANA && 0 == rmna)
+							{
+								   char *wan_dhcpv6_ipv6_addr[64] = { 0 };
+								   if( ctl_layer_cfg_check( ia->ifp, wan_dhcpv6_ipv6_addr ) == 0 )
+								   {
+									remove_na_address(ia->ifp,wan_dhcpv6_ipv6_addr, &rmna);
+									dprintf(LOG_INFO, FNAME,"*****RM_NA_Addr type[%d] ifname[%s]  wan[%s]",
+										ia->evdata->type,ia->ifp->ifname,wan_dhcpv6_ipv6_addr);
+								   }
+							}
+						else if( ia->evdata->type == DHCP6_EVDATA_IAPD && 0 == rmpd )
+							{
+								char *wan_dhcpv6_ipv6_addr[64] = { 0 };
+								   if( ctl_layer_cfg_check( ia->ifp, wan_dhcpv6_ipv6_addr ) == 0 )
+								   {
+									remove_na_address(ia->ifp,wan_dhcpv6_ipv6_addr, &rmpd);
+									dprintf(LOG_INFO, FNAME,"*****RM_PD_Addr type[%d] ifname[%s]  wan[%s]",
+										ia->evdata->type,ia->ifp->ifname,wan_dhcpv6_ipv6_addr);
+								   }
+							}
+#endif
+#endif
 		}
 		break;
 	default:
 		break;
 	}
 
+	ia->evdata = evd;
+#endif
+
 	ev->timeouts = 0;
 	dhcp6_set_timeoparam(ev);
 	dhcp6_reset_timer(ev);
@@ -659,7 +989,6 @@
 		}
 	}
 
-	ia->evdata = evd;
 
 	switch(ia->state) {
 	case IAS_RENEW:
@@ -770,3 +1099,287 @@
 		return "???";	/* should be a bug */
 	}
 }
+
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+void
+decline_all_ia(ifp)
+	struct dhcp6_if *ifp;
+{
+	struct ia_conf *iac;
+	struct ia *ia, *ia_next;
+
+    dprintf(LOG_INFO, FNAME, "ifname: %s", ifp->ifname );
+
+	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
+	    iac = TAILQ_NEXT(iac, link)) {
+		for (ia = TAILQ_FIRST(&iac->iadata); ia; ia = ia_next) {
+			ia_next = TAILQ_NEXT(ia, link);
+
+			(void)decline_ia(ia);
+
+			/*
+			 * The client MUST stop using all of the addresses
+			 * being released as soon as the client begins the
+			 * Release message exchange process.
+			 * [RFC3315 Section 18.1.6]
+			 */
+			//remove_ia(ia);
+		}
+	}
+}
+
+static int
+decline_ia(ia)
+	struct ia *ia;
+{
+	struct dhcp6_ia iaparam;
+	struct dhcp6_event *ev;
+	struct dhcp6_eventdata *evd;
+
+	dprintf(LOG_DEBUG, FNAME, "Decline an IA: %s-%lu", iastr(ia->conf->type), ia->conf->iaid);
+
+	/// if ((ev = dhcp6_create_event(ia->ifp, DHCP6S_RELEASE)) == NULL) {
+	if ((ev = dhcp6_create_event(ia->ifp, DHCP6S_DECLINE)) == NULL) {
+		dprintf(LOG_NOTICE, FNAME, "failed to create a new event");
+		goto fail;
+	}
+	TAILQ_INSERT_TAIL(&ia->ifp->event_list, ev, link);
+
+
+	if ((ev->timer = dhcp6_add_timer(client6_timo, ev)) == NULL) {
+		dprintf(LOG_NOTICE, FNAME,
+		    "failed to create a new event timer");
+		goto fail;
+	}
+
+	if (duidcpy(&ev->serverid, &ia->serverid)) {
+		dprintf(LOG_NOTICE, FNAME, "failed to copy server ID");
+		goto fail;
+	}
+
+	if ((evd = malloc(sizeof(*evd))) == NULL) {
+		dprintf(LOG_NOTICE, FNAME,
+		    "failed to create a new event data");
+		goto fail;
+	}
+	memset(evd, 0, sizeof(*evd));
+	iaparam.iaid = ia->conf->iaid;
+	/* XXX: should we set T1/T2 to 0?  spec is silent on this. */
+	iaparam.t1 = ia->t1;
+	iaparam.t2 = ia->t2;
+
+	if (ia->ctl && ia->ctl->release_data) {
+		if ((*ia->ctl->release_data)(ia->ctl, &iaparam, NULL, evd)) {
+			dprintf(LOG_NOTICE, FNAME,
+			    "failed to make DECLINE data");
+			goto fail;
+		}
+	}
+	TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+
+	ev->timeouts = 0;
+	dhcp6_set_timeoparam(ev);
+	dhcp6_reset_timer(ev);
+
+	if (ia->authparam != NULL) {
+		if ((ev->authparam = copy_authparam(ia->authparam)) == NULL) {
+			dprintf(LOG_WARNING, FNAME,
+			    "failed to copy authparam");
+			goto fail;
+		}
+	}
+
+	client6_send(ev);
+
+	return (0);
+
+fail:
+	if (ev)
+		dhcp6_remove_event(ev);
+
+	return (-1);
+}
+
+#endif
+
+#ifdef SUPPORT_GPL_UNDEFINED
+/*
+*   Function: get_all_ia_data
+*
+*   Description: generate all IA data for renew/rebind/release, trigger by IA_NA or IA_PD timer
+*
+*   Input Parameters:
+*   struct ia *ias: the source IA, from this IA get all other IA
+*   struct dhcp6_event *ev: dhcp6 event
+*
+*   Return Values: <=0 error, >0 sucess
+*/
+int get_all_ia_data(ias, ev)
+struct ia *ias;
+struct dhcp6_event *ev;
+{
+
+	struct dhcp6_if *ifp = ias->ifp;
+	struct ia_conf *iac;
+	struct ia *ia, *ia_next;
+	struct dhcp6_ia iaparam;
+	struct dhcp6_eventdata *evd;
+	int ia_num = 0;
+
+	if(ifp == NULL)
+	{
+		dprintf(LOG_INFO, FNAME, "ifp == NULL");
+		return -1;
+	}
+
+	for (iac = TAILQ_FIRST(&ifp->iaconf_list); iac;
+	        iac = TAILQ_NEXT(iac, link)) {
+		for (ia = TAILQ_FIRST(&iac->iadata); ia; ia = ia_next)
+		{
+
+			if ((evd = malloc(sizeof(*evd))) == NULL) {
+				dprintf(LOG_NOTICE, FNAME,
+				        "failed to create a new event data");
+				return -1;
+			}
+			memset(evd, 0, sizeof(*evd));
+			if(ia->conf->iaid == ias->conf->iaid)
+			{
+			    //only source ia need record this event, other just put data to list
+				evd->event = ev;
+			}
+			TAILQ_INSERT_TAIL(&ev->data_list, evd, link);
+
+
+			iaparam.iaid = ia->conf->iaid;
+			iaparam.t1 = ia->t1;
+			iaparam.t2 = ia->t2;
+
+			switch(ias->state) {
+			case IAS_RENEW:
+				if (ia->ctl && ia->ctl->renew_data) {
+					if(ia->conf->iaid == ias->conf->iaid)
+					{
+					    //only source ia need record its event data, other just put data to list
+						if ((*ia->ctl->renew_data)(ia->ctl, &iaparam,
+						                           &ia->evdata, evd)) {
+							dprintf(LOG_NOTICE, FNAME,
+							        "failed to make renew data");
+							return -1;
+						}
+
+						ia->evdata = evd;
+					}
+					else
+					{
+						if ((*ia->ctl->renew_data)(ia->ctl, &iaparam,
+						                           NULL, evd)) {
+							dprintf(LOG_NOTICE, FNAME,
+							        "failed to make renew data");
+							return -1;
+						}
+					}
+					ia_num++;
+				}
+				break;
+			case IAS_REBIND:
+				if (ia->ctl && ia->ctl->rebind_data) {
+					if(ia->conf->iaid == ias->conf->iaid)
+					{
+						if ((*ia->ctl->rebind_data)(ia->ctl, &iaparam,
+						                            &ia->evdata, evd)) {
+							dprintf(LOG_NOTICE, FNAME,
+							        "failed to make rebind data");
+							return -1;
+						}
+
+						ia->evdata = evd;
+					}
+					else
+					{
+						if ((*ia->ctl->rebind_data)(ia->ctl, &iaparam,
+						                            NULL, evd)) {
+							dprintf(LOG_NOTICE, FNAME,
+							        "failed to make rebind data");
+							return -1;
+						}
+					}
+					ia_num++;
+				}
+				break;
+			case IAS_REQUEST:
+				if (ia->ctl && ia->ctl->reestablish_data) {
+					if(ia->conf->iaid == ias->conf->iaid)
+					{
+						if ((*ia->ctl->reestablish_data)(ia->ctl, &iaparam,
+						                                 &ia->evdata, evd)) {
+							dprintf(LOG_NOTICE, FNAME,
+							        "failed to make reestablish data");
+							return -1;
+						}
+
+						ia->evdata = evd;
+					}
+					else
+					{
+						if ((*ia->ctl->reestablish_data)(ia->ctl, &iaparam,
+						                                 NULL, evd)) {
+							dprintf(LOG_NOTICE, FNAME,
+							        "failed to make reestablish data");
+							return -1;
+						}
+					}
+					ia_num++;
+				}
+				break;
+			case IAS_RELEASE:
+				if (ia->ctl && ia->ctl->release_data) {
+					if ((*ia->ctl->release_data)(ia->ctl, &iaparam,
+					                             NULL, evd)) {
+						dprintf(LOG_NOTICE, FNAME,
+						        "failed to make release data");
+						return -1;
+					}
+					ia_num++;
+				}
+				break;
+			default:
+				break;
+			}
+
+			ia_next = TAILQ_NEXT(ia, link);
+
+		}
+	}
+
+	return ia_num;
+}
+
+/*
+*   Function: free_ev_datalist
+*
+*   Description: free all event data list data
+*
+*   Input Parameters:
+*   struct dhcp6_eventdata *evds: the source event data
+*
+*/
+void free_ev_datalist(evds)
+struct dhcp6_eventdata *evds;
+{
+	struct dhcp6_eventdata *evdata = NULL;
+	if(evds == NULL)
+		return;
+
+	while (evdata = TAILQ_FIRST(&evds->event->data_list))
+	{
+		TAILQ_REMOVE(&evds->event->data_list, evdata, link);
+		if (evdata->destructor)
+			evdata->destructor(evdata);
+		free(evdata);
+		evdata = NULL;		
+	}
+
+}
+#endif
+
diff -Naur dhcpv6-aei/dhcp6c_ia.h dhcpv6-aei-brcm/dhcp6c_ia.h
--- dhcpv6-aei/dhcp6c_ia.h	2007-03-21 06:52:55.000000000 -0300
+++ dhcpv6-aei-brcm/dhcp6c_ia.h	2019-06-13 11:48:57.551012801 -0300
@@ -54,3 +54,9 @@
 extern void update_ia __P((iatype_t, struct dhcp6_list *,
     struct dhcp6_if *, struct duid *, struct authparam *));
 extern void release_all_ia __P((struct dhcp6_if *));
+extern void decline_all_ia __P((struct dhcp6_if *));
+#ifdef SUPPORT_GPL_UNDEFINED
+extern int get_all_ia_data(struct ia *ias, struct dhcp6_event *ev);
+extern void free_ev_datalist(struct dhcp6_eventdata *evds);
+#endif
+
diff -Naur dhcpv6-aei/dhcp6.h dhcpv6-aei-brcm/dhcp6.h
--- dhcpv6-aei/dhcp6.h	2007-03-21 06:52:53.000000000 -0300
+++ dhcpv6-aei-brcm/dhcp6.h	2019-06-13 11:48:57.551012801 -0300
@@ -2,7 +2,7 @@
 /*
  * Copyright (C) 1998 and 1999 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -14,7 +14,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -99,6 +99,13 @@
 #define REL_TIMEOUT	1000	/* 1 sec */
 #define REL_MAX_RC	5
 
+#define CNF_MAX_DELAY   1000    // 1 sec   Max delay of first Confirm
+#define CNF_TIMEOUT     1000    // 1 sec   Initial Confirm timeout
+#define CNF_MAX_RT      4000    // 4 secs  Max Confirm timeout
+#define CNF_MAX_RD     10000    // 10 secs Max Confirm duration
+#define DEC_TIMEOUT     1000    // 1 sec   Initial Decline timeout
+#define DEC_MAX_RC      5       // 5       Max Decline attempts
+
 #define DHCP6_DURATION_INFINITE 0xffffffff
 #define DHCP6_DURATION_MIN 30
 
@@ -108,6 +115,14 @@
 #define DHCP6_IRT_DEFAULT 86400	/* 1 day */
 #define DHCP6_IRT_MINIMUM 600
 
+#if 0
+/* Add missing definition of in6_pktinfo so we don't have to use _GNU_SOURCE*/
+struct in6_pktinfo {
+    struct in6_addr ipi6_addr;  /* src/dst IPv6 address */
+    unsigned int ipi6_ifindex;  /* send/recv interface index */
+};
+#endif
+
 /* DUID: DHCP unique Identifier */
 struct duid {
 	size_t duid_len;	/* length */
@@ -180,6 +195,9 @@
 	int pref;		/* server preference */
 	int32_t elapsed_time;	/* elapsed time (from client to server only) */
 	int64_t refreshtime;	/* info refresh time for stateless options */
+#ifdef CONFIG_IOT_RECONFIGURATION
+		int reconf_type;
+#endif
 
 	struct dhcp6_list iapd_list; /* list of IA_PD */
 	struct dhcp6_list iana_list; /* list of IA_NA */
@@ -289,6 +307,7 @@
 #define DH6OPT_VENDOR_OPTS 17
 #define DH6OPT_INTERFACE_ID 18
 #define DH6OPT_RECONF_MSG 19
+#define DH6OPT_RECONF_ACCEPT 20
 
 #define DH6OPT_SIP_SERVER_D 21
 #define DH6OPT_SIP_SERVER_A 22
@@ -309,7 +328,11 @@
 #define DH6OPT_REMOTE_ID 37
 #define DH6OPT_SUBSCRIBER_ID 38
 #define DH6OPT_CLIENT_FQDN 39
-
+#ifdef CONFIG_IOT_RECONFIGURATION
+#define RECONF_TYPE_RENEW       5
+#define RECONF_TYPE_REBIND       6
+#define RECONF_TYPE_INFO                11
+#endif
 /* The followings are KAME specific. */
 
 struct dhcp6opt {
@@ -322,7 +345,9 @@
 struct dhcp6opt_duid_type1 {
 	u_int16_t dh6_duid1_type;
 	u_int16_t dh6_duid1_hwtype;
+#if 0 //brcm: Change to type 3 (DUID-LL).
 	u_int32_t dh6_duid1_time;
+#endif
 	/* link-layer address follows */
 } __attribute__ ((__packed__));
 
@@ -382,4 +407,14 @@
 enum { DHCP6_AUTHALG_UNDEF = -1, DHCP6_AUTHALG_HMACMD5 = 1 };
 enum { DHCP6_AUTHRDM_UNDEF = -1, DHCP6_AUTHRDM_MONOCOUNTER = 0 };
 
+
+#ifdef CONFIG_IOT_RECONFIGURATION
+enum { DHCP6_RECONF_MSG_TYPE_UNDEF = -1, DHCP6_RECONF_MSG_TYPE_RENEW = 5 };
+enum { DHCP6_RECONF_AUTH_KEY = 1,DHCP6_RECONF_AUTH_INFO = 2 };
+
+#define DHCP6_RECONFIGURE_AUTH_INFO_LENGTH		(17)
+#define DHCP6_RECONFIGURE_AUTH_VAL_LENGTH		(16)
+#define DHCP6_RECONFIGURE_AUTH_KEY_LENGTH		(16)
+#endif
+
 #endif /*__DHCP6_H_DEFINED*/
diff -Naur dhcpv6-aei/dhcp6s.c dhcpv6-aei-brcm/dhcp6s.c
--- dhcpv6-aei/dhcp6s.c	2008-06-15 04:51:57.000000000 -0300
+++ dhcpv6-aei-brcm/dhcp6s.c	2019-06-13 11:48:57.555012541 -0300
@@ -2,7 +2,7 @@
 /*
  * Copyright (C) 1998 and 1999 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -14,7 +14,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -77,11 +77,38 @@
 #include <signal.h>
 #include <lease.h>
 
+#define CLR_BUF(b) if (b) { free(b);b = NULL; }
+
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+#include <libtr69_client.h>
+#define CTLOID_WAN_IP_CONN                     "InternetGatewayDevice.WANDevice.1.WANConnectionDevice.1.WANIPConnection.1"
+#define CTLOID_WAN_XDSL_CONN                   "InternetGatewayDevice.WANDevice.2.WANConnectionDevice.1.WANIPConnection.1"
+static int t1 =0;
+static int t2 = 0;
+#endif
+
+#ifdef AEI_DHCP6S_SERIALIZE
+#define AHB_MAX_DUID_LEN 128
+
+static const char* dhcp6sBindFile = "/var/tmp/dhcp6sbinding.conf";
+static const char* lanDhcp6sBindFile = "/var/tmp/dhcp6sLeaseAddr.txt";
+
+static void str2duid __P((const char*, struct duid*));
+static void act_load_binding __P((char *));
+static void act_serialize_binding __P((void));
+static int checkbindinginfor __P((int, int));
+#endif
+
 #define DUID_FILE LOCALDBDIR "/dhcp6s_duid"
 #define DHCP6S_CONF SYSCONFDIR "/dhcp6s.conf"
 #define DEFAULT_KEYFILE SYSCONFDIR "/dhcp6sctlkey"
 #define DHCP6S_PIDFILE "/var/run/dhcp6s.pid"
 
+#define SUPPORT_DHCP6S_MULTI_ADDRESS
+#ifdef SUPPORT_DHCP6S_MULTI_ADDRESS
+static char *ULA_POOL_NAME = "IPv6ULAPool";
+#endif
+
 #define CTLSKEW 300
 
 typedef enum { DHCP6_BINDING_IA } dhcp6_bindingtype_t;
@@ -138,7 +165,7 @@
 
 static const struct sockaddr_in6 *sa6_any_downstream, *sa6_any_relay;
 static struct msghdr rmh;
-static char rdatabuf[BUFSIZ];
+static char rdatabuf[BUFSIZ+1024]; // Bugfix cdrouter_dhcpv6_server_14
 static int rmsgctllen;
 static char *conffile = DHCP6S_CONF;
 static char *rmsgctlbuf;
@@ -175,6 +202,8 @@
     struct relayinfolist *));
 static int react_rebind __P((struct dhcp6_if *, struct dhcp6 *, ssize_t,
     struct dhcp6_optinfo *, struct sockaddr *, int, struct relayinfolist *));
+static void check_binding_all_leased __P((struct dhcp6_binding *));
+
 static int react_release __P((struct dhcp6_if *, struct in6_pktinfo *,
     struct dhcp6 *, ssize_t, struct dhcp6_optinfo *, struct sockaddr *, int,
     struct relayinfolist *));
@@ -221,6 +250,58 @@
     struct dhcp6_optinfo *, struct dhcp6_optinfo *));
 static inline char *clientstr __P((struct host_conf *, struct duid *));
 
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+static void gettimeoutval(void)
+{
+	char* c_val = NULL;
+	char* pt1 = NULL;
+	char* pt2 = NULL;
+	int 	val_type = 0;
+	char wan_t1[256] = { 0 };
+	char wan_t2[256] = { 0 };
+
+	//Get WAN type
+	tr69_get_unfresh_leaf_data( "InternetGatewayDevice.X_AEI_COM_Physical_WAN",&c_val,&val_type);
+
+	if (!c_val) {
+		dprintf(LOG_INFO, FNAME, "wan type is null");
+		return;
+	}
+	if (strcmp(c_val, "Ethernet") == 0) {
+		sprintf(wan_t1, "%s.%s", CTLOID_WAN_IP_CONN, "X_BROADCOM_COM_IPv6SitePrefixT1");
+		sprintf(wan_t2, "%s.%s", CTLOID_WAN_IP_CONN, "X_BROADCOM_COM_IPv6SitePrefixT2");
+		dprintf(LOG_INFO, FNAME, "wan type is ethernet");
+	}
+	else if (strcmp(c_val, "xDSL") == 0) {
+		sprintf(wan_t1, "%s.%s", CTLOID_WAN_XDSL_CONN, "X_BROADCOM_COM_IPv6SitePrefixT1");
+		sprintf(wan_t2, "%s.%s", CTLOID_WAN_XDSL_CONN, "X_BROADCOM_COM_IPv6SitePrefixT2");
+		dprintf(LOG_INFO, FNAME, "wan type is xDSL");
+	}
+	else {
+		dprintf(LOG_INFO, FNAME, "unknown wan type %s", c_val);
+		CLR_BUF(c_val);
+		return;
+	}
+	CLR_BUF(c_val);
+
+    if (tr69_get_unfresh_leaf_data(wan_t1, &pt1, &val_type) >= 0)
+	{
+		t1 = atoi(pt1);
+	        CLR_BUF(pt1);
+	}
+
+    if (tr69_get_unfresh_leaf_data(wan_t2, &pt2, &val_type) >= 0)
+	{
+		t2 = atoi(pt2);
+	        CLR_BUF(pt2);
+	}
+
+	dprintf(LOG_INFO, FNAME, "***DHCP6s get t1 %d t2  %d", t1,t2);
+
+
+}
+#endif
+
 int
 main(argc, argv)
 	int argc;
@@ -307,6 +388,10 @@
 
 	setloglevel(debug);
 
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT
+		gettimeoutval();
+#endif
+
 	if (ifinit(device) == NULL)
 		exit(1);
 
@@ -315,10 +400,12 @@
 		exit(1);
 	}
 
+#if 0 //brcm
 	if (foreground == 0) {
 		if (daemon(0, 0) < 0)
 			err(1, "daemon");
 	}
+#endif
 
 	/* dump current PID */
 	pid = getpid();
@@ -380,7 +467,7 @@
 	}
 
 	/* get our DUID */
-	if (get_duid(DUID_FILE, &server_duid)) {
+	if (get_duid(DUID_FILE, &server_duid, device)) {
 		dprintf(LOG_ERR, FNAME, "failed to get a DUID");
 		exit(1);
 	}
@@ -582,7 +669,12 @@
 		    strerror(errno));
 		exit(1);
 	}
-	return;
+
+#ifdef AEI_DHCP6S_SERIALIZE
+        act_load_binding(device);
+#endif
+
+    return;
 }
 
 static void
@@ -602,7 +694,7 @@
 	fd_set r;
 	int maxsock;
 
-	
+
 	while (1) {
 		if (sig_flags)
 			process_signals();
@@ -809,7 +901,7 @@
 			}
 		}
 		remove_binding(binding);
-		    
+
 		break;
 	default:
 		dprintf(LOG_INFO, FNAME,
@@ -818,7 +910,7 @@
 		return (DHCP6CTL_R_FAILURE);
 	}
 
-  	return (DHCP6CTL_R_DONE);
+	return (DHCP6CTL_R_DONE);
 }
 
 static void
@@ -898,7 +990,7 @@
 		return;
 	}
 	/*
-	 * DHCPv6 server may receive a DHCPv6 packet from a non-listening 
+	 * DHCPv6 server may receive a DHCPv6 packet from a non-listening
 	 * interface, when a DHCPv6 relay agent is running on that interface.
 	 * This check prevents such reception.
 	 */
@@ -945,7 +1037,7 @@
 		dprintf(LOG_INFO, FNAME, "relay reply message from %s",
 		    addr2str((struct sockaddr *)&from));
 		return;
-		
+
 	}
 
 	optend = (struct dhcp6opt *)(rdatabuf + len);
@@ -1348,7 +1440,7 @@
 			u_int16_t stcode = DH6OPT_STCODE_NOPREFIXAVAIL;
 
 			if (dhcp6_add_listval(&roptinfo.stcode_list,
-			    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL)
+			    DHCP6_LISTVAL_STCODE, &stcode, NULL, 0) == NULL)
 				goto fail;
 		}
 	}
@@ -1362,7 +1454,7 @@
 			if ((client_conf = create_dynamic_hostconf(&optinfo->clientID,
 				&ifp->pool)) == NULL)
 				dprintf(LOG_NOTICE, FNAME,
-			    	"failed to make host configuration");
+				"failed to make host configuration");
 		}
 		TAILQ_INIT(&conflist);
 
@@ -1393,7 +1485,7 @@
 			u_int16_t stcode = DH6OPT_STCODE_NOADDRSAVAIL;
 
 			if (dhcp6_add_listval(&roptinfo.stcode_list,
-			    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL)
+			    DHCP6_LISTVAL_STCODE, &stcode, NULL, 0) == NULL)
 				goto fail;
 		}
 	}
@@ -1421,6 +1513,81 @@
 	return (-1);
 }
 
+static int search_ia(struct dhcp6_listval *spec, struct host_conf *client_conf)
+{
+    struct dhcp6_listval *specia      = NULL;
+    struct pool_conf     *pool        = NULL;
+    int                   poolFlag    = 0;
+#ifdef SUPPORT_DHCP6S_MULTI_ADDRESS
+    struct pool_conf     *pool_ula    = NULL;
+    int                   poolUlaFlag = 0;
+#endif
+    int                   found       = 0;
+
+    if(!client_conf)
+    {
+        dprintf(LOG_ERR, FNAME, "client_conf is NULL!");
+        return (1);
+    }
+
+    if(!spec)
+    {
+        dprintf(LOG_ERR, FNAME, "spec is NULL!");
+        return (1);
+    }
+
+    if ((pool = find_pool(client_conf->pool.name)) == NULL)
+    {
+        dprintf(LOG_ERR, FNAME, "pool '%s' not found", client_conf->pool.name);
+    }
+    else
+    {
+        poolFlag = 1;
+    }
+
+#ifdef SUPPORT_DHCP6S_MULTI_ADDRESS
+    if ((pool_ula = find_pool(ULA_POOL_NAME)) == NULL)
+    {
+        dprintf(LOG_ERR, FNAME, "pool '%s' not found", ULA_POOL_NAME);
+    }
+    else
+    {
+        poolUlaFlag = 1;
+    }
+#endif
+
+    for (specia = TAILQ_FIRST(&spec->sublist); specia;
+                specia = TAILQ_NEXT(specia, link))
+    {
+        found = 0;
+
+        if(poolFlag)
+        {
+            if (memcmp(&pool->min, &specia->val_statefuladdr6.addr, 8) == 0)
+            {
+                found++;
+            }
+        }
+
+#ifdef SUPPORT_DHCP6S_MULTI_ADDRESS
+        if(poolUlaFlag)
+        {
+            if (memcmp(&pool_ula->min, &specia->val_statefuladdr6.addr, 8) == 0)
+            {
+                found++;
+            }
+        }
+#endif
+
+        if(!found)
+        {
+            return (0);
+        }
+    }
+
+    return (1);
+}
+
 static int
 react_request(ifp, pi, dh6, len, optinfo, from, fromlen, relayinfohead)
 	struct dhcp6_if *ifp;
@@ -1502,7 +1669,7 @@
 		dprintf(LOG_INFO, FNAME, "unexpected unicast message from %s",
 		    addr2str(from));
 		if (dhcp6_add_listval(&roptinfo.stcode_list,
-		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
+		    DHCP6_LISTVAL_STCODE, &stcode, NULL, 0) == NULL) {
 			dprintf(LOG_ERR, FNAME, "failed to add a status code");
 			goto fail;
 		}
@@ -1515,7 +1682,7 @@
 	 * See if we have to make a binding of some configuration information
 	 * for the client.
 	 */
-	
+
 	/*
 	 * When a delegating router receives a Request message from a
 	 * requesting router that contains an IA_PD option, and the delegating
@@ -1577,7 +1744,7 @@
 			if ((client_conf = create_dynamic_hostconf(&optinfo->clientID,
 				&ifp->pool)) == NULL)
 				dprintf(LOG_NOTICE, FNAME,
-			    	"failed to make host configuration");
+				"failed to make host configuration");
 		}
 		TAILQ_INIT(&conflist);
 
@@ -1591,11 +1758,32 @@
 
 		for (iana = TAILQ_FIRST(&optinfo->iana_list); iana;
 		    iana = TAILQ_NEXT(iana, link)) {
-			/*
-			 * Find an appropriate address for each IA_NA,
-			 * removing the adopted addresses from the list.
-			 * The addresses will be bound to the client.
-			 */
+            /*CD-Router dhcpv6_server_22*/
+            /* RFC 3315, (Section 18.2.1)  */
+            if(!search_ia(iana, client_conf))
+            {
+                if (make_ia_stcode(DHCP6_LISTVAL_IANA,
+                                  iana->val_ia.iaid,
+                                  DH6OPT_STCODE_NOTONLINK,
+                                  &roptinfo.iana_list))
+                {
+                    dprintf(LOG_NOTICE, FNAME, "failed to make an option list");
+                    dhcp6_clear_list(&conflist);
+                    goto fail;
+                }
+
+                (void)server6_send(DH6_REPLY, ifp, dh6, optinfo, from, fromlen,
+                                  &roptinfo, relayinfohead, client_conf);
+
+                dhcp6_clear_list(&conflist);
+                goto end;
+            }
+
+            /*
+             * Find an appropriate address for each IA_NA,
+             * removing the adopted addresses from the list.
+             * The addresses will be bound to the client.
+             */
 			if (make_ia(iana, &conflist, &roptinfo.iana_list,
 			    client_conf, 1) == 0) {
 				if (make_ia_stcode(DHCP6_LISTVAL_IANA,
@@ -1733,7 +1921,7 @@
 		dprintf(LOG_INFO, FNAME, "unexpected unicast message from %s",
 		    addr2str(from));
 		if (dhcp6_add_listval(&roptinfo.stcode_list,
-		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
+		    DHCP6_LISTVAL_STCODE, &stcode, NULL, 0) == NULL) {
 			dprintf(LOG_ERR, FNAME, "failed to add a status code");
 			goto fail;
 		}
@@ -1964,7 +2152,7 @@
 		dprintf(LOG_INFO, FNAME, "unexpected unicast message from %s",
 		    addr2str(from));
 		if (dhcp6_add_listval(&roptinfo.stcode_list,
-		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
+		    DHCP6_LISTVAL_STCODE, &stcode, NULL, 0) == NULL) {
 			dprintf(LOG_ERR, FNAME, "failed to add a status code");
 			goto fail;
 		}
@@ -1995,7 +2183,7 @@
 	 */
 	stcode = DH6OPT_STCODE_SUCCESS;
 	if (dhcp6_add_listval(&roptinfo.stcode_list,
-	    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
+	    DHCP6_LISTVAL_STCODE, &stcode, NULL, 0) == NULL) {
 		dprintf(LOG_NOTICE, FNAME, "failed to add a status code");
 		goto fail;
 	}
@@ -2093,7 +2281,7 @@
 		dprintf(LOG_INFO, FNAME, "unexpected unicast message from %s",
 		    addr2str(from));
 		if (dhcp6_add_listval(&roptinfo.stcode_list,
-		    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
+		    DHCP6_LISTVAL_STCODE, &stcode, NULL, 0) == NULL) {
 			dprintf(LOG_ERR, FNAME, "failed to add a status code");
 			goto fail;
 		}
@@ -2120,7 +2308,7 @@
 	 */
 	stcode = DH6OPT_STCODE_SUCCESS;
 	if (dhcp6_add_listval(&roptinfo.stcode_list,
-	    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL) {
+	    DHCP6_LISTVAL_STCODE, &stcode, NULL, 0) == NULL) {
 		dprintf(LOG_NOTICE, FNAME, "failed to add a status code");
 		goto fail;
 	}
@@ -2170,6 +2358,10 @@
 
 	dhcp6_init_options(&roptinfo);
 
+#ifdef AEI_COVERITY_FIX
+        TAILQ_INIT(&conflist);
+#endif
+
 	/* server identifier option */
 	if (duidcpy(&roptinfo.serverID, &server_duid)) {
 		dprintf(LOG_ERR, FNAME, "failed to copy server ID");
@@ -2199,11 +2391,13 @@
 		if ((client_conf = create_dynamic_hostconf(&optinfo->clientID,
 			&ifp->pool)) == NULL) {
 			dprintf(LOG_NOTICE, FNAME,
-		    	"failed to make host configuration");
+			"failed to make host configuration");
 			goto fail;
 		}
 	}
+#if !defined(AEI_COVERITY_FIX)
 	TAILQ_INIT(&conflist);
+#endif
 	/* make a local copy of the configured addresses */
 	if (dhcp6_copy_list(&conflist, &client_conf->addr_list)) {
 		dprintf(LOG_NOTICE, FNAME,
@@ -2229,18 +2423,22 @@
 		}
 
 		/*
-		 * check whether the confirmed prefix matches 
+		 * check whether the confirmed prefix matches
 		 * the prefix from where the message originates.
 		 * XXX: prefix length is assumed to be 64
 		 */
+		struct sockaddr_in6 *src = (struct sockaddr_in6 *)from;
+		if (!IN6_IS_ADDR_LINKLOCAL(&src->sin6_addr)) {
+			/* CONFIRM is relayed via a DHCP-relay */
 		for (iaaddr = TAILQ_FIRST(&iana->sublist); iaaddr;
 		    iaaddr = TAILQ_NEXT(iaaddr, link)) {
-		
+
 			struct in6_addr *confaddr = &iaaddr->val_statefuladdr6.addr;
 			struct in6_addr *linkaddr;
-			struct sockaddr_in6 *src = (struct sockaddr_in6 *)from;
+			//struct sockaddr_in6 *src = (struct sockaddr_in6 *)from;
 
-			if (!IN6_IS_ADDR_LINKLOCAL(&src->sin6_addr)) {
+			//if (!IN6_IS_ADDR_LINKLOCAL(&src->sin6_addr))
+			{
 				/* CONFIRM is relayed via a DHCP-relay */
 				struct relayinfo *relayinfo;
 
@@ -2253,11 +2451,11 @@
 
 				/* XXX: link-addr is supposed to be a global address */
 				linkaddr = &relayinfo->linkaddr;
-			} else {
-				/* CONFIRM is directly arrived */
-				linkaddr = &ifp->addr;
 			}
-
+//			else {
+//				/* CONFIRM is directly arrived */
+//				linkaddr = &ifp->addr;
+//			}
 			if (memcmp(linkaddr, confaddr, 8) != 0) {
 				dprintf(LOG_INFO, FNAME,
 				    "%s does not seem to belong to %s's link",
@@ -2267,9 +2465,18 @@
 				goto send_reply;
 			}
 		}
+		} else {
+			/* CONFIRM is directly arrived */
+			/*Fix CD-Router dhcpv6_server_30*/
+			if(!search_ia(iana, client_conf))
+			{
+				stcode = DH6OPT_STCODE_NOTONLINK;
+				goto send_reply;
+			}
+		}
 	}
 
-	/* 
+	/*
 	 * even when the given address seems to be on the appropriate link,
 	 * the confirm should be ignore if there's no corrensponding IA-NA
 	 * configuration.
@@ -2286,7 +2493,7 @@
 
 send_reply:
 	if (dhcp6_add_listval(&roptinfo.stcode_list,
-	    DHCP6_LISTVAL_STCODE, &stcode, NULL) == NULL)
+	    DHCP6_LISTVAL_STCODE, &stcode, NULL, 0) == NULL)
 		goto fail;
 	error = server6_send(DH6_REPLY, ifp, dh6, optinfo, from, fromlen,
 			     &roptinfo, relayinfohead, client_conf);
@@ -2446,6 +2653,34 @@
 		struct dhcp6_statefuladdr saddr;
 		struct dhcp6_ia ia;
 
+        if (client_conf == NULL)
+        {
+            struct dhcp6_if *ifp = NULL;
+
+            if(device)
+            {
+                if((ifp = find_ifconfbyname(device)) == NULL)
+                {
+                    dprintf(LOG_ERR, FNAME, "failed to find interface name!");
+                    return (-1);
+                }
+            }
+            else
+            {
+                dprintf(LOG_ERR, FNAME, "Device is NULL!");
+                return (-1);
+            }
+
+            if(ifp->pool.name)
+            {
+                if ((client_conf = create_dynamic_hostconf(&optinfo->clientID, &ifp->pool)) == NULL)
+                {
+                    dprintf(LOG_NOTICE, FNAME, "failed to make host configuration");
+		            return (-1);
+                }
+            }
+        }
+
 		TAILQ_INIT(&ialist);
 		update_binding(binding);
 
@@ -2477,7 +2712,7 @@
 				}
 
 				if (dhcp6_add_listval(&ialist,
-				    DHCP6_LISTVAL_PREFIX6, &prefix, NULL)
+				    DHCP6_LISTVAL_PREFIX6, &prefix, NULL, 0)
 				    == NULL) {
 					dprintf(LOG_NOTICE, FNAME,
 					    "failed  to copy binding info");
@@ -2507,7 +2742,7 @@
 				}
 
 				if (dhcp6_add_listval(&ialist,
-				    DHCP6_LISTVAL_STATEFULADDR6, &saddr, NULL)
+				    DHCP6_LISTVAL_STATEFULADDR6, &saddr, NULL, 0)
 				    == NULL) {
 					dprintf(LOG_NOTICE, FNAME,
 					    "failed  to copy binding info");
@@ -2527,7 +2762,7 @@
 		calc_ia_timo(&ia, &ialist, client_conf);
 
 		if (dhcp6_add_listval(retlist, iap->type,
-		    &ia, &ialist) == NULL) {
+		    &ia, &ialist, 0) == NULL) {
 			dhcp6_clear_list(&ialist);
 			return (-1);
 		}
@@ -2544,6 +2779,9 @@
 	struct dhcp6_optinfo *optinfo;
 {
 	struct dhcp6_binding *binding;
+#ifdef AEI_DHCP6S_SERIALIZE
+    int found = 0;
+#endif
 
 	if ((binding = find_binding(&optinfo->clientID, DHCP6_BINDING_IA,
 	    iap->type, iap->val_ia.iaid)) == NULL) {
@@ -2574,6 +2812,10 @@
 		 */
 		for (lv = TAILQ_FIRST(&iap->sublist); lv;
 		    lv = TAILQ_NEXT(lv, link)) {
+#ifdef AEI_COVERITY_FIX
+          if(binding)
+          {
+#endif
 			if ((lvia = find_binding_ia(lv, binding)) != NULL) {
 				switch (binding->iatype) {
 					case DHCP6_LISTVAL_IAPD:
@@ -2585,7 +2827,10 @@
 						    lvia->val_prefix6.plen);
 						break;
 					case DHCP6_LISTVAL_IANA:
-						release_address(&lvia->val_prefix6.addr);
+#ifdef AEI_DHCP6S_SERIALIZE
+                        found = 1;
+#endif
+                        release_address(&lvia->val_prefix6.addr);
 						dprintf(LOG_DEBUG, FNAME,
 						    "bound address %s "
 						    "has been released",
@@ -2602,10 +2847,19 @@
 					 * stop procedure.
 					 */
 					remove_binding(binding);
-					return (0);
 				}
 			}
+
+#ifdef AEI_COVERITY_FIX
+          }
+#endif
 		}
+#ifdef AEI_DHCP6S_SERIALIZE
+        if(found)
+        {
+            act_serialize_binding();
+        }
+#endif
 	}
 
 	return (0);
@@ -2619,6 +2873,9 @@
 {
 	struct dhcp6_binding *binding;
 	struct dhcp6_listval *lv, *lvia;
+#ifdef AEI_DHCP6S_SERIALIZE
+    int found = 0;
+#endif
 
 	if ((binding = find_binding(&optinfo->clientID, DHCP6_BINDING_IA,
 	    iap->type, iap->val_ia.iaid)) == NULL) {
@@ -2639,13 +2896,17 @@
 	}
 
 	/*
-	 * If the IAs in the message are in a binding for the client and the 
+	 * If the IAs in the message are in a binding for the client and the
 	 * addresses in the IAs have been assigned by the server to those IAs,
 	 * the server deletes the addresses from the IAs and makes the addresses
 	 * available for assignment to other clients. [RFC3315 Section 18.2.7]
 	 */
 	for (lv = TAILQ_FIRST(&iap->sublist); lv;
 	    lv = TAILQ_NEXT(lv, link)) {
+#ifdef AEI_COVERITY_FIX
+      if(binding)
+      {
+#endif
 		if (binding->iatype != DHCP6_LISTVAL_IANA) {
 			/* should never reach here */
 			continue;
@@ -2663,6 +2924,9 @@
 		    in6addr2str(&lvia->val_statefuladdr6.addr, 0));
 		decline_address(&lvia->val_statefuladdr6.addr);
 
+#ifdef AEI_DHCP6S_SERIALIZE
+        found = 1;
+#endif
 		TAILQ_REMOVE(&binding->val_list, lvia, link);
 		dhcp6_clear_listval(lvia);
 		if (TAILQ_EMPTY(&binding->val_list)) {
@@ -2671,10 +2935,19 @@
 			 * stop procedure.
 			 */
 			remove_binding(binding);
-			return (0);
 		}
+#ifdef AEI_COVERITY_FIX
+      }
+#endif
 	}
 
+#ifdef AEI_DHCP6S_SERIALIZE
+    if(found)
+    {
+        act_serialize_binding();
+    }
+#endif
+
 	return (0);
 }
 
@@ -2829,13 +3102,13 @@
 
 	TAILQ_INIT(&stcode_list);
 	if (dhcp6_add_listval(&stcode_list, DHCP6_LISTVAL_STCODE,
-	    &stcode, NULL) == NULL) {
+	    &stcode, NULL, 0) == NULL) {
 		dprintf(LOG_NOTICE, FNAME, "failed to make an option list");
 		return (-1);
 	}
 
 	if (dhcp6_add_listval(retlist, iatype,
-	    &ia_empty, &stcode_list) == NULL) {
+	    &ia_empty, &stcode_list, 0) == NULL) {
 		dprintf(LOG_NOTICE, FNAME, "failed to make an option list");
 		dhcp6_clear_list(&stcode_list);
 		return (-1);
@@ -2869,14 +3142,61 @@
 
 		dprintf(LOG_DEBUG, FNAME, "we have a binding already: %s",
 		    bindingstr(binding));
+#ifdef SUPPORT_DHCP6S_MULTI_ADDRESS
+        int IANA_cnt=dhcp6_count_list(blist);
+
+        dprintf(LOG_DEBUG, FNAME, "we have a binding already: %s,Iana_cnt=%d",
+               bindingstr(binding),IANA_cnt);
+        if(IANA_cnt==1)
+        {
+            if (TAILQ_EMPTY(conflist))
+            {
+                if (spec->type != DHCP6_LISTVAL_IANA || client_conf->pool.name == NULL)
+                {
+                    return (0);
+                }
+            }
+            if(dhcp6_find_listval(blist,DHCP6_LISTVAL_STATEFULADDR6,"fc",MATCHLIST_PREFIXLEN) || dhcp6_find_listval(blist,DHCP6_LISTVAL_STATEFULADDR6,"fd",MATCHLIST_PREFIXLEN))
+            {
+                dprintf(LOG_DEBUG, FNAME, " the GLA was declined") ;
+                //the gla was declined,we need to got new one from pool
+                if(strncmp(client_conf->pool.name, ULA_POOL_NAME, strlen(ULA_POOL_NAME)) != 0)
+                {
+                    dprintf(LOG_DEBUG, FNAME, " the pool is GLA pool ,not ULA pool ");
+                    if (make_iana_from_pool(&client_conf->pool, NULL, blist))
+                    {
+                        found = 1;
+                    }
+                }
+            }
+            else
+            {
+                 dprintf(LOG_DEBUG, FNAME, "the ULA was declined") ;
+
+                 {
+                     struct host_conf client_conf_ula;
+                     memcpy(&client_conf_ula,client_conf,sizeof(client_conf_ula));
+                     client_conf_ula.pool.name = ULA_POOL_NAME;
+                     if (make_iana_from_pool(&client_conf_ula.pool, NULL, blist))
+                     found=1;
+                 }
+            }
+        }
+        else if(IANA_cnt==2)
+            {
+                //check all bounding are leased
+                check_binding_all_leased(binding);
 
+            }
+
+#endif
 		update_binding(binding);
 
 		memset(&ia, 0, sizeof(ia));
 		ia.iaid = spec->val_ia.iaid;
 		/* determine appropriate T1 and T2 */
 		calc_ia_timo(&ia, blist, client_conf);
-		if (dhcp6_add_listval(retlist, spec->type, &ia, blist)
+		if (dhcp6_add_listval(retlist, spec->type, &ia, blist, 0)
 		    == NULL) {
 			dprintf(LOG_NOTICE, FNAME,
 			    "failed to copy binding info");
@@ -2893,6 +3213,13 @@
 			}
 		}
 
+        if(found == 1)
+        {
+            dprintf(LOG_DEBUG, FNAME, "add the extra address");
+#ifdef AEI_DHCP6S_SERIALIZE
+            act_serialize_binding();
+#endif
+        }
 		return (1);
 	}
 
@@ -2920,6 +3247,17 @@
 			client_conf->pool.name != NULL) {
 			if (make_iana_from_pool(&client_conf->pool, specia, &ialist))
 				found++;
+#ifdef SUPPORT_DHCP6S_MULTI_ADDRESS
+			//JEAN, bugfix for ULA duplicated
+			if( strcmp(client_conf->pool.name, ULA_POOL_NAME) != 0 )
+			{
+			struct host_conf client_conf_ula;
+			memcpy(&client_conf_ula,client_conf,sizeof(client_conf_ula));
+			client_conf_ula.pool.name = ULA_POOL_NAME;
+			if (make_iana_from_pool(&client_conf_ula.pool, specia, &ialist))
+				found++;
+			}
+#endif
 		}
 	}
 	if (found == 0) {
@@ -2933,7 +3271,7 @@
 				if (!is_leased(&v->val_statefuladdr6.addr))
 					break;
 			}
-			if (v && dhcp6_add_listval(&ialist, v->type, &v->uv, NULL)) {
+			if (v && dhcp6_add_listval(&ialist, v->type, &v->uv, NULL, 0)) {
 				found = 1;
 				TAILQ_REMOVE(conflist, v, link);
 				dhcp6_clear_listval(v);
@@ -2942,6 +3280,17 @@
 			client_conf->pool.name != NULL) {
 			if (make_iana_from_pool(&client_conf->pool, NULL, &ialist))
 				found = 1;
+#ifdef SUPPORT_DHCP6S_MULTI_ADDRESS
+			//JEAN, bugfix for ULA duplicated
+			if( strcmp(client_conf->pool.name, ULA_POOL_NAME) != 0 )
+			{
+			struct host_conf client_conf_ula;
+			memcpy(&client_conf_ula,client_conf,sizeof(client_conf_ula));
+			client_conf_ula.pool.name = ULA_POOL_NAME;
+			if (make_iana_from_pool(&client_conf_ula.pool, specia, &ialist))
+				found++;
+			}
+#endif
 		}
 	}
 	if (found) {
@@ -2962,7 +3311,7 @@
 		if (found) {
 			/* make an IA for the set */
 			if (dhcp6_add_listval(retlist, spec->type,
-			    &ia, &ialist) == NULL)
+			    &ia, &ialist, 0) == NULL)
 				found = 0;
 		}
 		dhcp6_clear_list(&ialist);
@@ -3006,7 +3355,7 @@
 	 */
 	if (match) {
 		if (dhcp6_add_listval(retlist, match->type,
-		    &match->uv, NULL)) {
+		    &match->uv, NULL, 0)) {
 			matched = 1;
 			TAILQ_REMOVE(conflist, match, link);
 			dhcp6_clear_listval(match);
@@ -3029,6 +3378,7 @@
 
 	dprintf(LOG_DEBUG, FNAME, "called");
 
+    dprintf(LOG_DEBUG, FNAME, "poolspec->name = %s", poolspec->name);
 	if ((pool = find_pool(poolspec->name)) == NULL) {
 		dprintf(LOG_ERR, FNAME, "pool '%s' not found", poolspec->name);
 		return (0);
@@ -3049,10 +3399,24 @@
 		saddr.pltime = poolspec->pltime;
 		saddr.vltime = poolspec->vltime;
 
-		if (!dhcp6_add_listval(retlist, DHCP6_LISTVAL_STATEFULADDR6,
-			&saddr, NULL)) {
+#ifdef SUPPORT_DHCP6S_MULTI_ADDRESS
+        if(strcmp(poolspec->name, ULA_POOL_NAME) == 0)
+        {
+            if (!dhcp6_add_listval(retlist, DHCP6_LISTVAL_STATEFULADDR6,
+			&saddr, NULL, 0))
+	    {
+			return (0);
+		}
+        }
+        else
+#endif
+        {
+            if (!dhcp6_add_listval(retlist, DHCP6_LISTVAL_STATEFULADDR6,
+			&saddr, NULL, 1))
+	    {
 			return (0);
 		}
+        }
 	}
 
 	dprintf(LOG_DEBUG, FNAME, "returns (found=%d)", found);
@@ -3096,14 +3460,65 @@
 		 * We could also set the parameters to 0 if we let the client
 		 * decide the renew timing (not implemented yet).
 		 */
-		if (base == DHCP6_DURATION_INFINITE) {
-			ia->t1 = DHCP6_DURATION_INFINITE;
-			ia->t2 = DHCP6_DURATION_INFINITE;
-		} else {
-			ia->t1 = base / 2;
-			ia->t2 = (base * 4) / 5;
+#ifdef ACTION_TEC_IPV6_CODE_FOR_IOT_T1T2
+	if( t1 & t2 )
+	{
+		ia->t1 = t1;
+		ia->t2 = t2;
+
+		dprintf(LOG_INFO, FNAME, "***DHCP6s set t1 %d t2  %d", t1,t2);
+	}
+	else
+#endif
+	{
+        /*only ula no gua ,t1 = 90s, t2 = 180s*/
+#ifdef SUPPORT_DHCP6S_MULTI_ADDRESS
+        dprintf(LOG_DEBUG, FNAME, "client_conf.pool.name = %s", client_conf->pool.name);
+        if(strncmp(client_conf->pool.name, ULA_POOL_NAME, strlen(ULA_POOL_NAME)) == 0)
+        {
+            ia->t1 = 90;
+            ia->t2 = 180;
+        }
+        else /*only gua/ gua+ula */
+#endif
+        {
+            if (base == DHCP6_DURATION_INFINITE)
+            {
+                ia->t1 = DHCP6_DURATION_INFINITE;
+                ia->t2 = DHCP6_DURATION_INFINITE;
+            }
+            else
+            {
+                ia->t1 = base / 2;
+                ia->t2 = (base * 4) / 5;
+            }
+        }
+        break;
+    }
+    }
+}
+
+static void check_binding_all_leased(binding)
+    struct dhcp6_binding *binding;
+{
+	struct dhcp6_list *ia_list = &binding->val_list;
+	struct dhcp6_listval *iav;
+
+	switch (binding->type) {
+	case DHCP6_BINDING_IA:
+		for (iav = TAILQ_FIRST(ia_list); iav;
+		    iav = TAILQ_NEXT(iav, link)) {
+             dprintf(LOG_DEBUG, FNAME,
+			    "check  %s to binding!!!",in6addr2str(&iav->val_statefuladdr6.addr, 0)) ;
+            lease_address(&iav->val_statefuladdr6.addr);
 		}
+
 		break;
+	default:
+		/* should be internal error. */
+		dprintf(LOG_DEBUG, FNAME, "unknown binding type (%d)",
+		    binding->type);
+		return;
 	}
 }
 
@@ -3252,6 +3667,9 @@
 
 	dprintf(LOG_DEBUG, FNAME, "add a new binding %s", bindingstr(binding));
 
+#ifdef AEI_DHCP6S_SERIALIZE
+        act_serialize_binding();
+#endif
 	return (binding);
 
   fail:
@@ -3394,7 +3812,7 @@
 				    in6addr2str(&iav->val_prefix6.addr, 0),
 				    iav->val_prefix6.plen,
 				    bindingstr(binding));
-				if (binding->iatype == DHCP6_LISTVAL_IANA) 
+				if (binding->iatype == DHCP6_LISTVAL_IANA)
 					release_address(&iav->val_prefix6.addr);
 				TAILQ_REMOVE(ia_list, iav, link);
 				dhcp6_clear_listval(iav);
@@ -3539,7 +3957,7 @@
 				    "authentication information "
 				    "provided in solicit from %s",
 				    clientstr(client_conf,
-				    &optinfo->clientID)); 
+				    &optinfo->clientID));
 				/* accept it anyway. (or discard?) */
 			}
 		} else {
@@ -3679,3 +4097,448 @@
 
 	return (duidstr(duid));
 }
+
+#ifdef AEI_DHCP6S_SERIALIZE
+static void str2duid(str, duid)
+const char* str;
+struct duid* duid;
+{
+    char buf[AHB_MAX_DUID_LEN];
+    char* ptr = NULL;
+    int idx = 0;
+    int value;
+
+    strncpy(buf, str, sizeof(buf)-1);
+    duid->duid_id = malloc(AHB_MAX_DUID_LEN);
+    memset(duid->duid_id, 0, AHB_MAX_DUID_LEN);
+    ptr = strtok(buf, ":");
+    while (ptr)
+    {
+        sscanf(ptr, "%x", &value);
+        duid->duid_id[idx++] = value;
+        ptr = strtok(NULL, ":");
+    }
+    duid->duid_len = idx;
+}
+
+static void act_load_binding(ifname)
+    char *ifname;
+{
+    FILE *fp = NULL;
+    struct dhcp6_binding *binding = NULL;
+    char duid[128] = {0};
+    struct dhcp6_listval lv;
+    struct dhcp6_statefuladdr saddr;
+    char in6addr[128] = {0};
+    char c = 0;
+    int i = 0;
+    int found = 0;
+    int addr_count = 0;
+    struct dhcp6_if *ifp = NULL;
+    int pool_num = 0;
+    int isGUA = 0;
+
+    if((ifp = find_ifconfbyname(ifname))== NULL)
+    {
+        dprintf(LOG_ERR, FNAME, "failed to find interface name!");
+        return;
+    }
+
+    /*if pltime=0 only send msg to lan pc to clear infor before, not need to clear binding infor*/
+    if(ifp->pool.pltime == 0)
+    {
+        dprintf(LOG_ERR, FNAME, "ifp->pool.pltime equal to 0!");
+        return;
+    }
+
+    getPoolNum(&pool_num, &isGUA);
+
+    if(!pool_num)
+    {
+        dprintf(LOG_ERR, FNAME, "No valid pool!");
+        return;
+    }
+
+    if(checkbindinginfor(pool_num, isGUA))
+    {
+        found = 1;
+        goto EXIT_LABEL;
+    }
+
+    if ((fp = fopen(dhcp6sBindFile, "r")) == NULL)
+    {
+        dprintf(LOG_ERR, FNAME, "failed to open %s!", dhcp6sBindFile);
+        return;
+    }
+
+    while((c = fgetc(fp)) !=((char) EOF))
+    {
+        /*init addr count to 0*/
+        addr_count = 0;
+
+        if(c != '\n')
+        {
+            fseek(fp, -1, SEEK_CUR);
+        }
+        if ((binding = malloc(sizeof(*binding))) == NULL) {
+            dprintf(LOG_ERR, FNAME, "failed to allocate memory");
+            fclose(fp);
+            fp = NULL;
+            return ;
+        }
+
+        memset(binding, 0, sizeof(*binding));
+
+        fscanf(fp, "%s", duid);
+        str2duid(duid, &binding->clientid);
+        fscanf(fp, "%d", &binding->type);
+        fscanf(fp, "%d", &binding->iatype);
+        fscanf(fp, "%u", &binding->iaid);
+        fscanf(fp, "%u", &binding->duration);
+        fscanf(fp, "%d", &binding->updatetime);
+
+        TAILQ_INIT(&binding->val_list);
+
+        memset(&saddr, 0, sizeof(saddr));
+        fscanf(fp, "%s", in6addr);
+        fscanf(fp, "%u", &saddr.pltime);
+        fscanf(fp, "%u", &saddr.vltime);
+        inet_pton(AF_INET6, in6addr, &saddr.addr);
+
+        if((ifp->pool.pltime != saddr.pltime)
+            || (ifp->pool.vltime != saddr.vltime))
+        {
+            saddr.pltime = ifp->pool.pltime;
+            saddr.vltime = ifp->pool.vltime;
+            found = 1;
+        }
+
+        if (!is_in_pool(&saddr.addr))
+        {
+
+            dprintf(LOG_ERR, FNAME, "addr %s not in any pool, delete reservations",
+                   in6addr2str(&saddr.addr, 0));
+            found = 1;
+        }
+        else
+        {
+            if (!lease_address(&saddr.addr))
+            {
+                dprintf(LOG_ERR, FNAME,
+                    "cannot lease address %s",
+                    in6addr2str(&saddr.addr, 0));
+                found = 1;
+            }
+            else
+            {
+                dhcp6_add_listval(&binding->val_list, DHCP6_LISTVAL_STATEFULADDR6,
+                                 &saddr, NULL, 0);
+                addr_count++;
+            }
+        }
+
+        if(fgetc(fp) != '\n')
+        {
+            memset(&saddr, 0, sizeof(saddr));
+            fscanf(fp, "%s", in6addr);
+            fscanf(fp, "%u", &saddr.pltime);
+            fscanf(fp, "%u", &saddr.vltime);
+            inet_pton(AF_INET6, in6addr, &saddr.addr);
+
+            if((ifp->pool.pltime != saddr.pltime)
+               || (ifp->pool.vltime != saddr.vltime))
+            {
+                found = 1;
+                saddr.pltime = ifp->pool.pltime;
+                saddr.vltime = ifp->pool.vltime;
+            }
+
+            if (!is_in_pool(&saddr.addr))
+            {
+                dprintf(LOG_ERR, FNAME, "addr %s not in any pool, delete reservations",
+                       in6addr2str(&saddr.addr, 0));
+                found = 1;
+            }
+            else
+            {
+                if (!lease_address(&saddr.addr)) {
+                    dprintf(LOG_ERR, FNAME,
+                        "cannot lease address %s",
+                        in6addr2str(&saddr.addr, 0));
+                    found = 1;
+                }
+                else
+                {
+                    dhcp6_add_listval(&binding->val_list, DHCP6_LISTVAL_STATEFULADDR6,
+                                     &saddr, NULL, 0);
+                    addr_count++;
+                }
+            }
+            /*pass '\n' in the end*/
+            fgetc(fp);
+        }
+
+        if(addr_count == pool_num)
+        {
+            /*binding struct has one addr at least*/
+            /* calculate duration and start timer accordingly */
+            update_binding_duration(binding);
+
+            if (binding->duration != DHCP6_DURATION_INFINITE)
+            {
+                struct timeval timo;
+
+                binding->timer = dhcp6_add_timer(binding_timo, binding);
+                if (binding->timer == NULL) {
+                    dprintf(LOG_ERR, FNAME, "failed to add timer");
+                    if(binding)
+                    {
+                        free(binding);
+                        binding = NULL;
+                    }
+                    if(fp)
+                    {
+                        fclose(fp);
+                        fp = NULL;
+                    }
+                    return;
+                }
+                timo.tv_sec = (long)binding->duration;
+                timo.tv_usec = 0;
+                dhcp6_set_timer(&timo, binding->timer);
+            }
+
+            TAILQ_INSERT_TAIL(&dhcp6_binding_head, binding, link);
+        }
+        else
+        {
+            if(binding)
+            {
+                free(binding);
+                binding = NULL;
+            }
+        }
+    }
+
+    if(fp)
+    {
+        fclose(fp);
+        fp = NULL;
+    }
+
+EXIT_LABEL:
+    if(found)
+    {
+        act_serialize_binding();
+    }
+
+    return;
+}
+
+static void act_serialize_binding(void)
+{
+    struct dhcp6_binding *bp;
+    char* duid = NULL;
+    struct dhcp6_listval *lv;
+    struct dhcp6_list *ia_list = NULL;
+    char* in6addr = NULL;
+    FILE *fp = NULL;
+    FILE *fp1 = NULL;
+
+    /* open a new dhcp6sbinding.conf file */
+    if ((fp = fopen(dhcp6sBindFile, "w")) == NULL)
+    {
+        dprintf(LOG_ERR, FNAME, "failed to open %s", dhcp6sBindFile);
+        return;
+    }
+
+    /* open a new dhcp6sLeaseAddr.txt file */
+    if ((fp1 = fopen(lanDhcp6sBindFile, "w")) == NULL)
+    {
+        dprintf(LOG_ERR, FNAME, "failed to open %s", lanDhcp6sBindFile);
+        fclose(fp);
+        fp = NULL;
+        return;
+    }
+
+    for (bp = TAILQ_FIRST(&dhcp6_binding_head); bp; bp = TAILQ_NEXT(bp, link))
+    {
+        duid = duidstr(&bp->clientid);
+        fprintf(fp, "%128s ", duid);
+        fprintf(fp, "%8d ", bp->type);
+        fprintf(fp, "%8d ", bp->iatype);
+        fprintf(fp, "%8u ", bp->iaid);
+        fprintf(fp, "%8u ", bp->duration);
+        fprintf(fp, "%8d ", bp->updatetime);
+
+        ia_list = &bp->val_list;
+        for (lv = TAILQ_FIRST(ia_list); lv; lv = TAILQ_NEXT(lv, link))
+        {
+            if (lv->type != DHCP6_LISTVAL_STATEFULADDR6) {
+                dprintf(LOG_ERR, FNAME,
+                    "unexpected binding value type(%d)", lv->type);
+                fclose(fp);
+                fclose(fp1);
+                fp = NULL;
+                fp1 = NULL;
+                return;
+            }
+
+            in6addr = in6addr2str(&lv->val_statefuladdr6.addr, 0);
+            fprintf(fp, "%s ", in6addr);
+            fprintf(fp1, "%s ", in6addr);
+            fprintf(fp, "%8u ", lv->val_statefuladdr6.pltime);
+            fprintf(fp, "%8u ", lv->val_statefuladdr6.vltime);
+        }
+        fseek(fp, -1, SEEK_CUR);
+        fseek(fp1, -1, SEEK_CUR);
+        fprintf(fp, "\n");
+        fprintf(fp1, "\n");
+    }
+
+    fclose(fp);
+    fclose(fp1);
+    fp = NULL;
+    fp1 = NULL;
+}
+
+int checkbindinginfor(int pool_num, int isGUA)
+{
+    FILE *fp = NULL;
+    struct dhcp6_binding *binding = NULL;
+    struct dhcp6_statefuladdr saddr;
+    char in6addr[128] = {0};
+    int addr_count = 0;
+    int Ret = 0;
+    char duid[128] = {0};
+    char c = 0;
+
+    if ((fp = fopen(dhcp6sBindFile, "r")) == NULL)
+    {
+        dprintf(LOG_ERR, FNAME, "failed to open %s", dhcp6sBindFile);
+        Ret = -1;
+        goto EXIT_LABEL;
+    }
+
+    if((c = fgetc(fp)) != EOF)
+    {
+        if(c != '\n')
+        {
+            fseek(fp, -1, SEEK_CUR);
+        }
+
+        if ((binding = (struct dhcp6_binding *)malloc(sizeof(*binding))) == NULL)
+        {
+            dprintf(LOG_ERR, FNAME, "failed to allocate memory");
+            Ret = -1;
+            goto EXIT_LABEL;
+        }
+
+        memset(binding, 0, sizeof(*binding));
+
+        fscanf(fp, "%s", duid);
+        str2duid(duid, &binding->clientid);
+        fscanf(fp, "%d", &binding->type);
+        fscanf(fp, "%d", &binding->iatype);
+        fscanf(fp, "%u", &binding->iaid);
+        fscanf(fp, "%u", &binding->duration);
+        fscanf(fp, "%d", &binding->updatetime);
+
+        TAILQ_INIT(&binding->val_list);
+
+        memset(&saddr, 0, sizeof(saddr));
+        fscanf(fp, "%s", in6addr);
+        fscanf(fp, "%u", &saddr.pltime);
+        fscanf(fp, "%u", &saddr.vltime);
+        inet_pton(AF_INET6, in6addr, &saddr.addr);
+
+        dhcp6_add_listval(&binding->val_list, DHCP6_LISTVAL_STATEFULADDR6,
+                         &saddr, NULL, 0);
+        addr_count++;
+
+        if(fgetc(fp) != '\n')
+        {
+            memset(&saddr, 0, sizeof(saddr));
+            fscanf(fp, "%s", in6addr);
+            fscanf(fp, "%u", &saddr.pltime);
+            fscanf(fp, "%u", &saddr.vltime);
+            inet_pton(AF_INET6, in6addr, &saddr.addr);
+            dhcp6_add_listval(&binding->val_list, DHCP6_LISTVAL_STATEFULADDR6,
+                             &saddr, NULL, 0);
+            addr_count++;
+        }
+    }
+    else
+    {
+        dprintf(LOG_ERR, FNAME, "Nothing in %s", dhcp6sBindFile);
+        Ret = -1;
+        goto EXIT_LABEL;
+    }
+
+    if(addr_count == pool_num)
+    {
+        if(addr_count == 1)
+        {
+            if(dhcp6_find_listval(&binding->val_list,DHCP6_LISTVAL_STATEFULADDR6,"fc",MATCHLIST_PREFIXLEN)
+               || dhcp6_find_listval(&binding->val_list,DHCP6_LISTVAL_STATEFULADDR6,"fd",MATCHLIST_PREFIXLEN))
+            {
+                /*binding addr is ula*/
+                if(isGUA)
+                {
+                    /*addr not match pool*/
+                    Ret = -1;
+                    goto EXIT_LABEL;
+                }
+                else
+                {
+                    Ret = 0;
+                    goto EXIT_LABEL;
+                }
+            }
+            else
+            {
+                /*binding addr is gla*/
+                if(isGUA)
+                {
+                    Ret = 0;
+                    goto EXIT_LABEL;
+                }
+                else
+                {
+                    /*addr not match pool*/
+                    Ret = -1;
+                    goto EXIT_LABEL;
+                }
+            }
+        }
+        else
+        {
+            /*binding addr num = 2, pool num = 2*/
+            Ret = 0;
+            goto EXIT_LABEL;
+        }
+    }
+    else
+    {
+        /*addr not match pool*/
+        Ret = -1;
+        goto EXIT_LABEL;
+    }
+
+EXIT_LABEL:
+
+    if(binding)
+    {
+        free(binding);
+        binding = NULL;
+    }
+
+    if(fp)
+    {
+        fclose(fp);
+        fp = NULL;
+    }
+
+    return Ret;
+}
+#endif
diff -Naur dhcpv6-aei/ifaddrs.c dhcpv6-aei-brcm/ifaddrs.c
--- dhcpv6-aei/ifaddrs.c	1969-12-31 20:00:00.000000000 -0400
+++ dhcpv6-aei-brcm/ifaddrs.c	2019-06-13 11:48:57.555012541 -0300
@@ -0,0 +1,901 @@
+/*	$Id: ifaddrs.c,v 1.1.2.1 2011/07/25 01:42:47 lzhang Exp $	*/
+/* 	from USAGI: ifaddrs.c,v 1.20.2.1 2002/12/08 08:22:23 yoshfuji Exp */
+
+/*
+ * Copyright (C)2000 YOSHIFUJI Hideaki
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <string.h>
+#include <time.h>
+#include <malloc.h>
+#include <errno.h>
+#include <unistd.h>
+
+#define __set_errno(x)	errno = (x)
+
+#include <sys/socket.h>
+#include <asm/types.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netpacket/packet.h>
+#include <net/ethernet.h>	/* the L2 protocols */
+#include <sys/uio.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <ifaddrs.h>
+#include <netinet/in.h>
+
+#ifdef _USAGI_LIBINET6
+#include "libc-compat.h"
+#endif
+
+/* ====================================================================== */
+struct nlmsg_list
+{
+  struct nlmsg_list *nlm_next;
+  struct nlmsghdr *nlh;
+  int size;
+  time_t seq;
+};
+
+struct rtmaddr_ifamap
+{
+  void *address;
+  void *local;
+#ifdef IFA_NETMASK
+  void *netmask;
+#endif
+  void *broadcast;
+#ifdef HAVE_IFADDRS_IFA_ANYCAST
+  void *anycast;
+#endif
+  int address_len;
+  int local_len;
+#ifdef IFA_NETMASK
+  int netmask_len;
+#endif
+  int broadcast_len;
+#ifdef HAVE_IFADDRS_IFA_ANYCAST
+  int anycast_len;
+#endif
+};
+
+/* ====================================================================== */
+static size_t
+ifa_sa_len (sa_family_t family, int len)
+{
+  size_t size;
+  switch (family)
+    {
+    case AF_INET:
+      size = sizeof (struct sockaddr_in);
+      break;
+    case AF_INET6:
+      size = sizeof (struct sockaddr_in6);
+      break;
+    case AF_PACKET:
+      size = (size_t) (((struct sockaddr_ll *) NULL)->sll_addr) + len;
+      if (size < sizeof (struct sockaddr_ll))
+	size = sizeof (struct sockaddr_ll);
+      break;
+    default:
+      size = (size_t) (((struct sockaddr *) NULL)->sa_data) + len;
+      if (size < sizeof (struct sockaddr))
+	size = sizeof (struct sockaddr);
+    }
+  return size;
+}
+
+static void
+ifa_make_sockaddr (sa_family_t family,
+		   struct sockaddr *sa,
+		   void *p, size_t len, uint32_t scope, uint32_t scopeid)
+{
+  if (sa == NULL)
+    return;
+  switch (family)
+    {
+    case AF_INET:
+      memcpy (&((struct sockaddr_in *) sa)->sin_addr, (char *) p, len);
+      break;
+    case AF_INET6:
+      memcpy (&((struct sockaddr_in6 *) sa)->sin6_addr, (char *) p, len);
+      if (IN6_IS_ADDR_LINKLOCAL (p) || IN6_IS_ADDR_MC_LINKLOCAL (p))
+	{
+	  ((struct sockaddr_in6 *) sa)->sin6_scope_id = scopeid;
+	}
+      break;
+    case AF_PACKET:
+      memcpy (((struct sockaddr_ll *) sa)->sll_addr, (char *) p, len);
+      ((struct sockaddr_ll *) sa)->sll_halen = len;
+      break;
+    default:
+      memcpy (sa->sa_data, p, len);
+      /*XXX*/ break;
+    }
+  sa->sa_family = family;
+#ifdef HAVE_SOCKADDR_SA_LEN
+  sa->sa_len = ifa_sa_len (family, len);
+#endif
+}
+
+static struct sockaddr *
+ifa_make_sockaddr_mask (sa_family_t family,
+			struct sockaddr *sa, uint32_t prefixlen)
+{
+  int i;
+  char *p = NULL, c;
+  uint32_t max_prefixlen = 0;
+
+  if (sa == NULL)
+    return NULL;
+  switch (family)
+    {
+    case AF_INET:
+      memset (&((struct sockaddr_in *) sa)->sin_addr, 0,
+	      sizeof (((struct sockaddr_in *) sa)->sin_addr));
+      p = (char *) &((struct sockaddr_in *) sa)->sin_addr;
+      max_prefixlen = 32;
+      break;
+    case AF_INET6:
+      memset (&((struct sockaddr_in6 *) sa)->sin6_addr, 0,
+	      sizeof (((struct sockaddr_in6 *) sa)->sin6_addr));
+      p = (char *) &((struct sockaddr_in6 *) sa)->sin6_addr;
+#if 0				/* XXX: fill scope-id? */
+      if (IN6_IS_ADDR_LINKLOCAL (p) || IN6_IS_ADDR_MC_LINKLOCAL (p))
+	{
+	  ((struct sockaddr_in6 *) sa)->sin6_scope_id = scopeid;
+	}
+#endif
+      max_prefixlen = 128;
+      break;
+    default:
+      return NULL;
+    }
+  sa->sa_family = family;
+#ifdef HAVE_SOCKADDR_SA_LEN
+  sa->sa_len = ifa_sa_len (family, len);
+#endif
+  if (p)
+    {
+      if (prefixlen > max_prefixlen)
+	prefixlen = max_prefixlen;
+      for (i = 0; i < (prefixlen / 8); i++)
+	*p++ = 0xff;
+      c = 0xff;
+      c <<= (8 - (prefixlen % 8));
+      *p = c;
+    }
+  return sa;
+}
+
+/* ====================================================================== */
+static int
+nl_sendreq (int sd, int request, int flags, int *seq)
+{
+  char reqbuf[NLMSG_ALIGN (sizeof (struct nlmsghdr)) +
+	      NLMSG_ALIGN (sizeof (struct rtgenmsg))];
+  struct sockaddr_nl nladdr;
+  struct nlmsghdr *req_hdr;
+  struct rtgenmsg *req_msg;
+  time_t t = time (NULL);
+
+  if (seq)
+    *seq = t;
+  memset (&reqbuf, 0, sizeof (reqbuf));
+  req_hdr = (struct nlmsghdr *) reqbuf;
+  req_msg = (struct rtgenmsg *) NLMSG_DATA (req_hdr);
+  req_hdr->nlmsg_len = NLMSG_LENGTH (sizeof (*req_msg));
+  req_hdr->nlmsg_type = request;
+  req_hdr->nlmsg_flags = flags | NLM_F_REQUEST;
+  req_hdr->nlmsg_pid = 0;
+  req_hdr->nlmsg_seq = t;
+  req_msg->rtgen_family = AF_UNSPEC;
+  memset (&nladdr, 0, sizeof (nladdr));
+  nladdr.nl_family = AF_NETLINK;
+  return (sendto (sd, (void *) req_hdr, req_hdr->nlmsg_len, 0,
+		  (struct sockaddr *) &nladdr, sizeof (nladdr)));
+}
+
+static int
+nl_recvmsg (int sd, int request, int seq,
+	    void *buf, size_t buflen, int *flags)
+{
+  struct msghdr msg;
+  struct iovec iov = { buf, buflen };
+  struct sockaddr_nl nladdr;
+  int read_len;
+
+  for (;;)
+    {
+      msg.msg_name = (void *) &nladdr;
+      msg.msg_namelen = sizeof (nladdr);
+      msg.msg_iov = &iov;
+      msg.msg_iovlen = 1;
+      msg.msg_control = NULL;
+      msg.msg_controllen = 0;
+      msg.msg_flags = 0;
+      read_len = recvmsg (sd, &msg, 0);
+      if ((read_len < 0 && errno == EINTR) || (msg.msg_flags & MSG_TRUNC))
+	continue;
+      if (flags)
+	*flags = msg.msg_flags;
+      break;
+    }
+  return read_len;
+}
+
+static int
+nl_getmsg (int sd, int request, int seq, struct nlmsghdr **nlhp, int *done)
+{
+  struct nlmsghdr *nh;
+  size_t bufsize = 65536, lastbufsize = 0;
+  void *buff = NULL;
+  int result = 0, read_size;
+  int msg_flags;
+  pid_t pid = getpid ();
+  void *actual_buff = NULL;
+
+  for (;;)
+    {
+      void *newbuff = realloc (buff, bufsize);
+#ifdef AEI_COVERITY_FIX
+    if (newbuff == NULL)
+    {
+        result = -1;
+        break;
+    }
+    else if(bufsize < lastbufsize)
+         {
+             free(newbuff);
+             result = -1;
+             break;
+         }
+#else
+      if (newbuff == NULL || bufsize < lastbufsize)
+	{
+	  result = -1;
+	  break;
+	}
+#endif
+
+      buff = newbuff;
+      result = read_size =
+	nl_recvmsg (sd, request, seq, buff, bufsize, &msg_flags);
+      if (read_size < 0 || (msg_flags & MSG_TRUNC))
+	{
+	  lastbufsize = bufsize;
+	  bufsize *= 2;
+	  continue;
+	}
+      if (read_size == 0)
+	break;
+      nh = (struct nlmsghdr *) buff;
+      for (nh = (struct nlmsghdr *) buff;
+	   NLMSG_OK (nh, read_size);
+	   nh = (struct nlmsghdr *) NLMSG_NEXT (nh, read_size))
+	{
+	  if (nh->nlmsg_pid != pid || nh->nlmsg_seq != seq)
+	    continue;
+	  if (nh->nlmsg_type == NLMSG_DONE)
+	    {
+	      (*done)++;
+	      break;		/* ok */
+	    }
+	  if (nh->nlmsg_type == NLMSG_ERROR)
+	    {
+	      struct nlmsgerr *nlerr = (struct nlmsgerr *) NLMSG_DATA (nh);
+	      result = -1;
+	      if (nh->nlmsg_len < NLMSG_LENGTH (sizeof (struct nlmsgerr)))
+		__set_errno (EIO);
+	      else
+		__set_errno (-nlerr->error);
+	      break;
+	    }
+	}
+      break;
+    }
+
+	// SW-Bug #7208
+    do{
+    if(result > 0 )
+    {
+        actual_buff = malloc(result);
+        if (NULL == actual_buff)
+        {
+            actual_buff = buff;
+            break;
+        }
+      
+        memcpy(actual_buff, buff,result);
+        free(buff);
+        buff = NULL;
+    }
+
+    }while(0);
+      
+    if (result < 0)
+    if (buff)
+      {
+	int saved_errno = errno;
+	free (buff);
+#ifdef AEI_COVERITY_FIX
+    buff = NULL;
+#endif
+	__set_errno (saved_errno);
+      }
+  *nlhp = (struct nlmsghdr *) actual_buff;
+  return result;
+}
+
+static int
+nl_getlist (int sd, int seq,
+	    int request,
+	    struct nlmsg_list **nlm_list, struct nlmsg_list **nlm_end)
+{
+  struct nlmsghdr *nlh = NULL;
+  int status;
+  int done = 0;
+
+  status = nl_sendreq (sd, request, NLM_F_ROOT | NLM_F_MATCH, &seq);
+  if (status < 0)
+    return status;
+  if (seq == 0)
+    seq = (int) time (NULL);
+  while (!done)
+    {
+      status = nl_getmsg (sd, request, seq, &nlh, &done);
+      if (status < 0)
+	return status;
+      if (nlh)
+	{
+	  struct nlmsg_list *nlm_next =
+	    (struct nlmsg_list *) malloc (sizeof (struct nlmsg_list));
+	  if (nlm_next == NULL)
+	    {
+	      int saved_errno = errno;
+	      free (nlh);
+	      __set_errno (saved_errno);
+	      status = -1;
+	    }
+	  else
+	    {
+	      nlm_next->nlm_next = NULL;
+	      nlm_next->nlh = (struct nlmsghdr *) nlh;
+	      nlm_next->size = status;
+	      nlm_next->seq = seq;
+	      if (*nlm_list == NULL)
+		{
+		  *nlm_list = nlm_next;
+		  *nlm_end = nlm_next;
+		}
+	      else
+		{
+		  (*nlm_end)->nlm_next = nlm_next;
+		  *nlm_end = nlm_next;
+		}
+	    }
+	}
+    }
+  return status >= 0 ? seq : status;
+}
+
+/* ---------------------------------------------------------------------- */
+static void
+free_nlmsglist (struct nlmsg_list *nlm0)
+{
+  struct nlmsg_list *nlm, *nlm_next;
+  int saved_errno;
+  if (!nlm0)
+    return;
+  saved_errno = errno;
+  nlm = nlm0;
+  while (nlm)
+    {
+      if (nlm->nlh)
+	free (nlm->nlh);
+      nlm_next = nlm->nlm_next;
+      free(nlm);
+      nlm = nlm_next;
+    }
+  __set_errno (saved_errno);
+}
+
+static void
+free_data (void *data, void *ifdata)
+{
+  int saved_errno = errno;
+  if (data != NULL)
+    free (data);
+  if (ifdata != NULL)
+    free (ifdata);
+  __set_errno (saved_errno);
+}
+
+/* ---------------------------------------------------------------------- */
+static void
+nl_close (int sd)
+{
+  int saved_errno = errno;
+  if (sd >= 0)
+    //__close (sd);
+    close (sd);
+  __set_errno (saved_errno);
+}
+
+/* ---------------------------------------------------------------------- */
+static int
+nl_open (void)
+{
+  struct sockaddr_nl nladdr;
+  int sd;
+
+  sd = socket (PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+  if (sd < 0)
+    return -1;
+  memset (&nladdr, 0, sizeof (nladdr));
+  nladdr.nl_family = AF_NETLINK;
+  if (bind (sd, (struct sockaddr *) &nladdr, sizeof (nladdr)) < 0)
+    {
+      nl_close (sd);
+      return -1;
+    }
+  return sd;
+}
+
+/* ====================================================================== */
+int
+getifaddrs (struct ifaddrs **ifap)
+{
+  int sd;
+  struct nlmsg_list *nlmsg_list, *nlmsg_end, *nlm;
+  /* - - - - - - - - - - - - - - - */
+  int icnt;
+  size_t dlen, xlen, nlen;
+  uint32_t max_ifindex = 0;
+
+  pid_t pid = getpid ();
+  int seq;
+  int result;
+  int build;			/* 0 or 1 */
+
+/* ---------------------------------- */
+  /* initialize */
+  icnt = dlen = xlen = nlen = 0;
+  nlmsg_list = nlmsg_end = NULL;
+
+  if (ifap)
+    *ifap = NULL;
+
+/* ---------------------------------- */
+  /* open socket and bind */
+  sd = nl_open ();
+  if (sd < 0)
+    return -1;
+
+/* ---------------------------------- */
+  /* gather info */
+  if ((seq = nl_getlist (sd, 0, RTM_GETLINK, &nlmsg_list, &nlmsg_end)) < 0)
+    {
+      free_nlmsglist (nlmsg_list);
+      nl_close (sd);
+      return -1;
+    }
+  if ((seq = nl_getlist (sd, seq + 1, RTM_GETADDR,
+			 &nlmsg_list, &nlmsg_end)) < 0)
+    {
+      free_nlmsglist (nlmsg_list);
+      nl_close (sd);
+      return -1;
+    }
+
+/* ---------------------------------- */
+  /* Estimate size of result buffer and fill it */
+  for (build = 0; build <= 1; build++)
+    {
+      struct ifaddrs *ifl = NULL, *ifa = NULL;
+      struct nlmsghdr *nlh, *nlh0;
+      void *data = NULL, *xdata = NULL, *ifdata = NULL;
+      char *ifname = NULL, **iflist = NULL;
+      uint16_t *ifflist = NULL;
+      struct rtmaddr_ifamap ifamap;
+
+      if (build)
+	{
+	  ifa = data = calloc (1,
+			       NLMSG_ALIGN (sizeof (struct ifaddrs[icnt]))
+			       + dlen + xlen + nlen);
+	  ifdata = calloc (1,
+			   NLMSG_ALIGN (sizeof (char *[max_ifindex + 1]))
+			   +
+			   NLMSG_ALIGN (sizeof (uint16_t[max_ifindex + 1])));
+	  if (ifap != NULL)
+	    *ifap = (ifdata != NULL) ? ifa : NULL;
+	  else
+	    {
+	      free_data (data, ifdata);
+	      result = 0;
+	      break;
+	    }
+	  if (data == NULL || ifdata == NULL)
+	    {
+	      free_data (data, ifdata);
+	      result = -1;
+	      break;
+	    }
+	  ifl = NULL;
+	  data += NLMSG_ALIGN (sizeof (struct ifaddrs)) * icnt;
+	  xdata = data + dlen;
+	  ifname = xdata + xlen;
+	  iflist = ifdata;
+	  ifflist =
+	    ((void *) iflist) +
+	    NLMSG_ALIGN (sizeof (char *[max_ifindex + 1]));
+	}
+
+      for (nlm = nlmsg_list; nlm; nlm = nlm->nlm_next)
+	{
+	  int nlmlen = nlm->size;
+	  if (!(nlh0 = nlm->nlh))
+	    continue;
+	  for (nlh = nlh0;
+	       NLMSG_OK (nlh, nlmlen); nlh = NLMSG_NEXT (nlh, nlmlen))
+	    {
+	      struct ifinfomsg *ifim = NULL;
+	      struct ifaddrmsg *ifam = NULL;
+	      struct rtattr *rta;
+
+	      size_t nlm_struct_size = 0;
+	      sa_family_t nlm_family = 0;
+	      uint32_t nlm_scope = 0, nlm_index = 0;
+#ifndef IFA_NETMASK
+	      size_t sockaddr_size = 0;
+	      uint32_t nlm_prefixlen = 0;
+#endif
+	      size_t rtasize;
+
+	      memset (&ifamap, 0, sizeof (ifamap));
+
+	      /* check if the message is what we want */
+	      if (nlh->nlmsg_pid != pid || nlh->nlmsg_seq != nlm->seq)
+		continue;
+	      if (nlh->nlmsg_type == NLMSG_DONE)
+		{
+		  break;	/* ok */
+		}
+	      switch (nlh->nlmsg_type)
+		{
+		case RTM_NEWLINK:
+		  ifim = (struct ifinfomsg *) NLMSG_DATA (nlh);
+		  nlm_struct_size = sizeof (*ifim);
+		  nlm_family = ifim->ifi_family;
+		  nlm_scope = 0;
+		  nlm_index = ifim->ifi_index;
+		  nlm_prefixlen = 0;
+		  if (build)
+		    ifflist[nlm_index] = ifa->ifa_flags = ifim->ifi_flags;
+		  break;
+		case RTM_NEWADDR:
+		  ifam = (struct ifaddrmsg *) NLMSG_DATA (nlh);
+		  nlm_struct_size = sizeof (*ifam);
+		  nlm_family = ifam->ifa_family;
+		  nlm_scope = ifam->ifa_scope;
+		  nlm_index = ifam->ifa_index;
+		  nlm_prefixlen = ifam->ifa_prefixlen;
+		  if (build)
+		    ifa->ifa_flags = ifflist[nlm_index];
+		  break;
+		default:
+		  continue;
+		}
+
+	      if (!build)
+		{
+		  if (max_ifindex < nlm_index)
+		    max_ifindex = nlm_index;
+		}
+	      else
+		{
+		  if (ifl != NULL)
+		    ifl->ifa_next = ifa;
+		}
+
+	      rtasize = NLMSG_PAYLOAD (nlh, nlm_struct_size);
+	      for (rta =
+		   (struct rtattr *) (((char *) NLMSG_DATA (nlh)) +
+				      NLMSG_ALIGN (nlm_struct_size));
+		   RTA_OK (rta, rtasize); rta = RTA_NEXT (rta, rtasize))
+		{
+		  struct sockaddr **sap = NULL;
+		  void *rtadata = RTA_DATA (rta);
+		  size_t rtapayload = RTA_PAYLOAD (rta);
+		  socklen_t sa_len;
+         
+		  switch (nlh->nlmsg_type)
+		    {
+		    case RTM_NEWLINK:
+		      switch (rta->rta_type)
+			{
+			case IFLA_ADDRESS:
+			case IFLA_BROADCAST:
+			  if (build)
+			    {
+			      sap =
+				(rta->rta_type ==
+				 IFLA_ADDRESS) ? &ifa->ifa_addr : &ifa->
+				ifa_broadaddr;
+			      *sap = (struct sockaddr *) data;
+			    }
+			  sa_len = ifa_sa_len (AF_PACKET, rtapayload);
+			  if (rta->rta_type == IFLA_ADDRESS)
+			    sockaddr_size = NLMSG_ALIGN (sa_len);
+			  if (!build)
+			    {
+			      dlen += NLMSG_ALIGN (sa_len);
+			    }
+			  else
+			    {
+			      memset (*sap, 0, sa_len);
+			      ifa_make_sockaddr (AF_PACKET, *sap, rtadata,
+						 rtapayload, 0, 0);
+			      ((struct sockaddr_ll *) *sap)->sll_ifindex =
+				nlm_index;
+			      ((struct sockaddr_ll *) *sap)->sll_hatype =
+				ifim->ifi_type;
+			      data += NLMSG_ALIGN (sa_len);
+			    }
+			  break;
+			case IFLA_IFNAME:	/* Name of Interface */
+			  if (!build)
+			    nlen += NLMSG_ALIGN (rtapayload + 1);
+			  else
+			    {
+			      ifa->ifa_name = ifname;
+			      if (iflist[nlm_index] == NULL)
+				iflist[nlm_index] = ifa->ifa_name;
+			      strncpy (ifa->ifa_name, rtadata, rtapayload);
+			      ifa->ifa_name[rtapayload] = '\0';
+			      ifname += NLMSG_ALIGN (rtapayload + 1);
+			    }
+			  break;
+			case IFLA_STATS:	/* Statistics of Interface */
+			  if (!build)
+			    xlen += NLMSG_ALIGN (rtapayload);
+			  else
+			    {
+			      ifa->ifa_data = xdata;
+			      memcpy (ifa->ifa_data, rtadata, rtapayload);
+			      xdata += NLMSG_ALIGN (rtapayload);
+			    }
+			  break;
+			case IFLA_UNSPEC:
+			  break;
+			case IFLA_MTU:
+			  break;
+			case IFLA_LINK:
+			  break;
+			case IFLA_QDISC:
+			  break;
+			default:
+				;
+			}
+		      break;
+		    case RTM_NEWADDR:
+		      if (nlm_family == AF_PACKET)
+			break;
+		      switch (rta->rta_type)
+			{
+			case IFA_ADDRESS:
+			  ifamap.address = rtadata;
+			  ifamap.address_len = rtapayload;
+			  break;
+			case IFA_LOCAL:
+			  ifamap.local = rtadata;
+			  ifamap.local_len = rtapayload;
+			  break;
+			case IFA_BROADCAST:
+			  ifamap.broadcast = rtadata;
+			  ifamap.broadcast_len = rtapayload;
+			  break;
+#ifdef HAVE_IFADDRS_IFA_ANYCAST
+			case IFA_ANYCAST:
+			  ifamap.anycast = rtadata;
+			  ifamap.anycast_len = rtapayload;
+			  break;
+#endif
+			case IFA_LABEL:
+			  if (!build)
+			    nlen += NLMSG_ALIGN (rtapayload + 1);
+			  else
+			    {
+			      ifa->ifa_name = ifname;
+			      if (iflist[nlm_index] == NULL)
+				iflist[nlm_index] = ifname;
+			      strncpy (ifa->ifa_name, rtadata, rtapayload);
+			      ifa->ifa_name[rtapayload] = '\0';
+			      ifname += NLMSG_ALIGN (rtapayload + 1);
+			    }
+			  break;
+			case IFA_UNSPEC:
+			  break;
+			case IFA_CACHEINFO:
+			  break;
+			default:
+				;
+			}
+		    }
+		}
+	      if (nlh->nlmsg_type == RTM_NEWADDR && nlm_family != AF_PACKET)
+		{
+		  if (!ifamap.local)
+		    {
+		      ifamap.local = ifamap.address;
+		      ifamap.local_len = ifamap.address_len;
+		    }
+		  if (!ifamap.address)
+		    {
+		      ifamap.address = ifamap.local;
+		      ifamap.address_len = ifamap.local_len;
+		    }
+		  if (ifamap.address_len != ifamap.local_len ||
+		      (ifamap.address != NULL &&
+		       memcmp (ifamap.address, ifamap.local,
+			       ifamap.address_len)))
+		    {
+		      /* p2p; address is peer and local is ours */
+		      ifamap.broadcast = ifamap.address;
+		      ifamap.broadcast_len = ifamap.address_len;
+		      ifamap.address = ifamap.local;
+		      ifamap.address_len = ifamap.local_len;
+		    }
+		  if (ifamap.address)
+		    {
+#ifndef IFA_NETMASK
+		      sockaddr_size =
+			NLMSG_ALIGN (ifa_sa_len
+				     (nlm_family, ifamap.address_len));
+#endif
+		      if (!build)
+			dlen +=
+			  NLMSG_ALIGN (ifa_sa_len
+				       (nlm_family, ifamap.address_len));
+		      else
+			{
+			  ifa->ifa_addr = (struct sockaddr *) data;
+			  ifa_make_sockaddr (nlm_family, ifa->ifa_addr,
+					     ifamap.address,
+					     ifamap.address_len, nlm_scope,
+					     nlm_index);
+			  data +=
+			    NLMSG_ALIGN (ifa_sa_len
+					 (nlm_family, ifamap.address_len));
+			}
+		    }
+#ifdef IFA_NETMASK
+		  if (ifamap.netmask)
+		    {
+		      if (!build)
+			dlen +=
+			  NLMSG_ALIGN (ifa_sa_len
+				       (nlm_family, ifamap.netmask_len));
+		      else
+			{
+			  ifa->ifa_netmask = (struct sockaddr *) data;
+			  ifa_make_sockaddr (nlm_family, ifa->ifa_netmask,
+					     ifamap.netmask,
+					     ifamap.netmask_len, nlm_scope,
+					     nlm_index);
+			  data +=
+			    NLMSG_ALIGN (ifa_sa_len
+					 (nlm_family, ifamap.netmask_len));
+			}
+		    }
+#endif
+		  if (ifamap.broadcast)
+		    {
+		      if (!build)
+			dlen +=
+			  NLMSG_ALIGN (ifa_sa_len
+				       (nlm_family, ifamap.broadcast_len));
+		      else
+			{
+			  ifa->ifa_broadaddr = (struct sockaddr *) data;
+			  ifa_make_sockaddr (nlm_family, ifa->ifa_broadaddr,
+					     ifamap.broadcast,
+					     ifamap.broadcast_len, nlm_scope,
+					     nlm_index);
+			  data +=
+			    NLMSG_ALIGN (ifa_sa_len
+					 (nlm_family, ifamap.broadcast_len));
+			}
+		    }
+#ifdef HAVE_IFADDRS_IFA_ANYCAST
+		  if (ifamap.anycast)
+		    {
+		      if (!build)
+			dlen +=
+			  NLMSG_ALIGN (ifa_sa_len
+				       (nlm_family, ifamap.anycast_len));
+		      else
+			{
+			  ifa->ifa_anycast = (struct sockaddr *) data;
+			  ifa_make_sockaddr (nlm_family, ifa->ifa_anyaddr,
+					     ifamap.anycast,
+					     ifamap.anycast_len, nlm_scope,
+					     nlm_index);
+			  data +=
+			    NLMSG_ALIGN (ifa_sa_len
+					 (nlm_family, ifamap.anycast_len));
+			}
+		    }
+#endif
+		}
+	      if (!build)
+		{
+#ifndef IFA_NETMASK
+		  dlen += sockaddr_size;
+#endif
+		  icnt++;
+		}
+	      else
+		{
+		  if (ifa->ifa_name == NULL)
+		    ifa->ifa_name = iflist[nlm_index];
+#ifndef IFA_NETMASK
+		  if (ifa->ifa_addr &&
+		      ifa->ifa_addr->sa_family != AF_UNSPEC &&
+		      ifa->ifa_addr->sa_family != AF_PACKET)
+		    {
+		      ifa->ifa_netmask = (struct sockaddr *) data;
+		      ifa_make_sockaddr_mask (ifa->ifa_addr->sa_family,
+					      ifa->ifa_netmask,
+					      nlm_prefixlen);
+		    }
+		  data += sockaddr_size;
+#endif
+		  ifl = ifa++;
+		}
+	    }
+	}
+      if (!build)
+	{
+	  if (icnt == 0 && (dlen + nlen + xlen == 0))
+	    {
+	      if (ifap != NULL)
+		*ifap = NULL;
+	      break;		/* cannot found any addresses */
+	    }
+	}
+      else
+	free_data (NULL, ifdata);
+    }
+
+/* ---------------------------------- */
+  /* Finalize */
+  free_nlmsglist (nlmsg_list);
+  nl_close (sd);
+  return 0;
+}
+
+/* ---------------------------------------------------------------------- */
+void
+freeifaddrs (struct ifaddrs *ifa)
+{
+  free (ifa);
+}
diff -Naur dhcpv6-aei/ifaddrs.h dhcpv6-aei-brcm/ifaddrs.h
--- dhcpv6-aei/ifaddrs.h	1969-12-31 20:00:00.000000000 -0400
+++ dhcpv6-aei-brcm/ifaddrs.h	2019-06-13 11:48:57.555012541 -0300
@@ -0,0 +1,63 @@
+/* 	$Id: ifaddrs.h,v 1.1.2.1 2011/07/25 01:42:20 lzhang Exp $	*/
+/*	from USAGI: ifaddrs.h,v 1.1 2001/01/26 07:11:48 yoshfuji Exp	*/
+
+/*
+ * Copyright (c) 1995, 1999
+ *	Berkeley Software Design, Inc.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	BSDI ifaddrs.h,v 2.5 2000/02/23 14:51:59 dab Exp
+ */
+
+#ifndef	_IFADDRS_H
+#define	_IFADDRS_H
+
+struct ifaddrs {
+	struct ifaddrs  *ifa_next;
+	char		*ifa_name;
+	unsigned short	 ifa_flags;
+	struct sockaddr	*ifa_addr;
+	struct sockaddr	*ifa_netmask;
+	union{
+	    struct sockaddr *ifu_broadaddr;
+	    struct sockaddr *ifu_dstaddr;
+	} ifa_ifu;
+	void		*ifa_data;
+};
+
+/*
+ * This may have been defined in <net/if.h>.  Note that if <net/if.h> is
+ * to be included it must be included before this header file.
+ */
+#ifndef	ifa_broadaddr
+#define	ifa_broadaddr	ifa_ifu.ifu_broadaddr	/* broadcast address */
+#endif
+#ifndef	ifa_dstaddr
+#define	ifa_dstaddr	ifa_ifu.ifu_dstaddr	/* other end of link */
+#endif
+
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+extern int getifaddrs __P((struct ifaddrs **));
+extern void freeifaddrs __P((struct ifaddrs *));
+__END_DECLS
+
+#endif	/* _IFADDRS_H */
diff -Naur dhcpv6-aei/lease.c dhcpv6-aei-brcm/lease.c
--- dhcpv6-aei/lease.c	2008-06-15 04:48:43.000000000 -0300
+++ dhcpv6-aei-brcm/lease.c	2019-06-13 11:48:57.555012541 -0300
@@ -2,7 +2,7 @@
 /*
  * Copyright (C) 1998 and 1999 WIDE Project.
  * All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
@@ -14,7 +14,7 @@
  * 3. Neither the name of the project nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -60,12 +60,12 @@
 };
 
 /* marked as declined (e.g. someone has been using the same address) */
-#define	DHCP6_LEASE_DECLINED	0x01	
+#define	DHCP6_LEASE_DECLINED	0x01
 
 LIST_HEAD(hash_head, hash_entry);
 
 typedef unsigned int (*pfn_hash_t)(void *val) ;
-typedef int (*pfh_hash_match_t)(void *val1, void *val2); 
+typedef int (*pfh_hash_match_t)(void *val1, void *val2);
 
 struct hash_table {
 	struct hash_head *table;
@@ -203,7 +203,7 @@
  */
 static int
 hash_table_init(table, size, hash, match)
-	struct hash_table *table; 
+	struct hash_table *table;
 	unsigned int size;
 	pfn_hash_t hash;
 	pfh_hash_match_t match;
@@ -230,7 +230,7 @@
 
 static void
 hash_table_cleanup(table)
-	struct hash_table *table; 
+	struct hash_table *table;
 {
 	int i;
 
@@ -253,7 +253,7 @@
 
 static int
 hash_table_add(table, val, size)
-	struct hash_table *table; 
+	struct hash_table *table;
 	void *val;
 	unsigned int size;
 {
@@ -270,6 +270,10 @@
 	memset(entry, 0, sizeof(*entry));
 
 	if ((entry->val = malloc(size)) == NULL) {
+#ifdef AEI_COVERITY_FIX
+        free(entry);
+        entry = NULL;
+#endif
 		return (-1);
 	}
 	memcpy(entry->val, val, size);
@@ -282,7 +286,7 @@
 
 static int
 hash_table_remove(table, val)
-	struct hash_table *table; 
+	struct hash_table *table;
 	void *val;
 {
 	struct hash_entry *entry;
@@ -305,7 +309,7 @@
 
 static struct hash_entry *
 hash_table_find(table, val)
-	struct hash_table *table; 
+	struct hash_table *table;
 	void *val;
 {
 	struct hash_entry *entry;
@@ -325,4 +329,3 @@
 
 	return (NULL);
 }
-
diff -Naur dhcpv6-aei/Makefile dhcpv6-aei-brcm/Makefile
--- dhcpv6-aei/Makefile	1969-12-31 20:00:00.000000000 -0400
+++ dhcpv6-aei-brcm/Makefile	2019-06-13 11:48:57.543013322 -0300
@@ -0,0 +1,172 @@
+# Copyright (c) 2004 WIDE Project. All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above copyright
+#    notice, this list of conditions and the following disclaimer in the
+#    documentation and/or other materials provided with the distribution.
+# 3. Neither the name of the project nor the names of its contributors
+#    may be used to endorse or promote products derived from this software
+#    without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+# SUCH DAMAGE.
+
+#
+# $Id: Makefile,v 1.1.2.5 2012/02/06 09:43:15 mili Exp $
+# $KAME: Makefile.in,v 1.45 2005/10/16 16:25:38 suz Exp $
+#
+
+prefix=	/usr/local
+srcdir=	.
+##sysconfdir= ${prefix}/etc
+sysconfdir= /etc
+##localdbdir= /var/db
+localdbdir= /var
+user= bin
+group= bin
+#wide-dhcpv6-20080615 default CFLAGS after ./configure
+#CFLAGS= -fomit-frame-pointer -Os -I$(srcdir)  -I./missing -I../../../private/apps/ctl_layer/tr69fw/include -I../../../private/apps/ctl_layer/include -I../../include -I../../include/linux -DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\" -DYYTEXT_POINTER=1 -DHAVE_GETADDRINFO=1 -DHAVE_GETNAMEINFO=1 -DHAVE_GETIFADDRS=1 -DHAVE_IF_NAMETOINDEX=1 -DHAVE_DAEMON=1 -DHAVE_WARNX=1 -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_FCNTL_H=1 -DHAVE_SYS_IOCTL_H=1 -DHAVE_SYS_TIME_H=1 -DHAVE_SYSLOG_H=1 -DHAVE_UNISTD_H=1 -DHAVE_IFADDRS_H=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_STRUCT_TM_TM_ZONE=1 -DHAVE_TM_ZONE=1 -DHAVE_SIG_ATOMIC_T=1 -DGETPGRP_VOID=1 -DSETPGRP_VOID=1 -DRETSIGTYPE=void -DHAVE_MKTIME=1 -DHAVE_SELECT=1 -DHAVE_SOCKET=1 -DHAVE_ANSI_FUNC=1 -DHAVE_TAILQ_FOREACH_REVERSE_OLD=1 -DHAVE_STDARG_H=1 -DSYSCONFDIR=\"${sysconfdir}\" \
+#follow CFLAGS copy from brcm old dhcpv6
+CFLAGS=	-fomit-frame-pointer -Os -I$(srcdir) -I../../../private/apps/ctl_layer/tr69fw/include -I../../../private/apps/ctl_layer/include -I../../include -I../../include/linux -DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\" -DHAVE_GETADDRINFO=1 -DHAVE_GETNAMEINFO=1 -DHAVE_IF_NAMETOINDEX=1 -DHAVE_STRLCPY=1 -DHAVE_STRLCAT=1 -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_FCNTL_H=1 -DHAVE_SYS_IOCTL_H=1 -DHAVE_SYS_TIME_H=1 -DHAVE_SYSLOG_H=1 -DHAVE_UNISTD_H=1 -DTIME_WITH_SYS_TIME=1 -DHAVE_STRUCT_TM_TM_ZONE=1 -DHAVE_TM_ZONE=1 -DRETSIGTYPE=void -DHAVE_MKTIME=1 -DHAVE_SELECT=1 -DHAVE_SOCKET=1 -DHAVE_CLOCK_GETTIME=1 -DHAVE_ANSI_FUNC=1 -DHAVE_STDARG_H=1  -DSYSCONFDIR=\"${sysconfdir}\" \
+	-DLOCALDBDIR=\"${localdbdir}\"
+CFLAGS += -DAEI_CONTROL_LAYER
+CFLAGS += -DACTION_TEC_IPV6_CODE_FOR_IOT
+CFLAGS += -DCDROUTER_TEST_DHCP6C
+CFLAGS += -DAEI_COVERITY_FIX
+CFLAGS += -DAEI_DHCP6S_SERIALIZE
+CFLAGS += -D_GNU_SOURCE -include debug.h
+#CFLAGS += -DIOT_PREVAIL
+CFLAGS += -DCONFIG_IOT_RECONFIGURATION
+CFLAGS += -DACTION_TEC_IPV6_CODE_FOR_DAD
+CFLAGS += -DACTION_TEC_IPV6_CODE_FOR_DECLINE
+CFLAGS += -DACTION_TEC_IPV6_CODE_FOR_REBIND
+#CFLAGS += -DACTION_TEC_IPV6_CODE_FOR_CONFIRM
+CFLAGS += -DSUPPORT_GPL_UNDEFINED
+CFLAGS += -I../../../private/apps/ctl_layer/tr69fw/framework/tr69_lib
+CFLAGS += -I../../../../kernel/linux/include
+LDFLAGS=
+LDFLAGS += -lm
+LIBOBJS= strlcpy$U.o strlcat$U.o arc4random$U.o
+LIBOBJS+= ../../include/libtr69_client.o
+LIBOBJS+= ../../include/tsl_socket.o
+##LIBS=	 -lfl
+ifneq ($(strip $(AEI_CONTROL_LAYER)),)
+LIBS=-Wl,-rpath,/lib:/lib/public -L../../../private/apps/ctl_layer/lib -L$(INSTALL_DIR)/lib -L$(INSTALL_DIR)/lib/public -ldbus -ldbussend_msg -lcms_util -lcms_msg -lcms_boardctl
+else
+LIBS=-Wl,-rpath,/lib:/lib/public -L$(INSTALL_DIR)/lib -L$(INSTALL_DIR)/lib/public -lcms_util -lcms_msg -lcms_boardctl
+endif
+##CC=	gcc
+CC = /opt/toolchains/crosstools-arm-gcc-4.6-linux-3.4-uclibc-0.9.32-binutils-2.21-NPTL/usr/bin/arm-unknown-linux-uclibcgnueabi-gcc
+TARGET=	dhcp6c dhcp6s
+#dhcp6relay dhcp6ctl
+
+INSTALL=/usr/bin/install -c
+INSTALL_PROGRAM=${INSTALL}
+INSTALL_DATA=${INSTALL} -m 644
+prefix=	/usr/local
+exec_prefix=	${prefix}
+bindir=	${exec_prefix}/bin
+sbindir=${exec_prefix}/sbin
+mandir=	${prefix}/man
+
+GENSRCS=cfparse.c cftoken.c
+CLIENTOBJS=	dhcp6c.o common.o config.o prefixconf.o dhcp6c_ia.o timer.o \
+	dhcp6c_script.o if.o base64.o auth.o dhcp6_ctl.o addrconf.o lease.o \
+	ifaddrs.o netlink_dad.o \
+	$(GENSRCS:%.c=%.o)
+SERVOBJS=	dhcp6s.o common.o if.o config.o timer.o lease.o \
+	base64.o auth.o dhcp6_ctl.o ifaddrs.o $(GENSRCS:%.c=%.o)
+RELAYOBJS =	dhcp6relay.o dhcp6relay_script.o common.o timer.o ifaddrs.o
+CTLOBJS= dhcp6_ctlclient.o base64.o auth.o
+CLEANFILES+=	y.tab.h
+
+all:	$(TARGET)
+dhcp6c:	$(CLIENTOBJS) $(LIBOBJS)
+	$(CC) $(LDFLAGS) -o dhcp6c $(CLIENTOBJS) $(LIBOBJS) $(LIBS)
+	install -m 755 dhcp6c $(INSTALL_DIR)/bin
+	$(STRIP) $(INSTALL_DIR)/bin/dhcp6c
+dhcp6s:	$(SERVOBJS) $(LIBOBJS)
+	$(CC) $(LDFLAGS) -o dhcp6s $(SERVOBJS) $(LIBOBJS) $(LIBS)
+	install -m 755 dhcp6s $(INSTALL_DIR)/bin
+	$(STRIP) $(INSTALL_DIR)/bin/dhcp6s
+dhcp6relay: $(RELAYOBJS) $(LIBOBJS)
+	$(CC) $(LDFLAGS) -o $@ $(RELAYOBJS) $(LIBOBJS) $(LIBS)
+	install -m 755 dhcp6relay $(INSTALL_DIR)/bin
+	$(STRIP) $(INSTALL_DIR)/bin/dhcp6relay
+dhcp6ctl: $(CTLOBJS)
+	$(CC) $(LDFLAGS) -o $@ $(CTLOBJS) $(LIBOBJS) $(LIBS)
+	install -m 755 dhcp6ctl $(INSTALL_DIR)/bin
+	$(STRIP) $(INSTALL_DIR)/bin/dhcp6ctl
+
+cfparse.c y.tab.h: cfparse.y
+	bison -y -d cfparse.y
+	mv y.tab.c cfparse.c
+
+cftoken.c: cftoken.l y.tab.h
+	flex cftoken.l
+	mv lex.yy.c $@
+
+getaddrinfo.o:	$(srcdir)/missing/getaddrinfo.c
+	$(CC) -c $(srcdir)/missing/$*.c
+getnameinfo.o:	$(srcdir)/missing/getnameinfo.c
+	$(CC) -c $(srcdir)/missing/$*.c
+strlcat.o:	$(srcdir)/missing/strlcat.c
+	$(CC) -c $(srcdir)/missing/$*.c
+strlcpy.o:	$(srcdir)/missing/strlcpy.c
+	$(CC) -c $(srcdir)/missing/$*.c
+arc4random.o:	$(srcdir)/missing/arc4random.c
+	$(CC) $(CFLAGS) -c $(srcdir)/missing/$*.c
+getifaddrs.o:	$(srcdir)/missing/getifaddrs.c
+	$(CC) -c $(srcdir)/missing/$*.c
+daemon.o:	$(srcdir)/missing/daemon.c
+	$(CC) -c $(srcdir)/missing/$*.c
+warnx.o:	$(srcdir)/missing/warnx.c
+	$(CC) -c $(srcdir)/missing/$*.c
+
+$(srcdir)/ianaopts.h: gentab.pl bootp-dhcp-parameters
+	expand bootp-dhcp-parameters | perl gentab.pl > ianaopts.h
+
+install::
+	-mkdir -p $(sbindir) $(mandir)/man5 $(mandir)/man8
+	$(INSTALL_PROGRAM) -s -o $(user) -g $(group) $(TARGET) $(sbindir)
+	$(INSTALL_DATA) -o $(user) -g $(group) dhcp6c.8 $(mandir)/man8
+	$(INSTALL_DATA) -o $(user) -g $(group) dhcp6s.8 $(mandir)/man8
+	$(INSTALL_DATA) -o $(user) -g $(group) dhcp6relay.8 $(mandir)/man8
+	$(INSTALL_DATA) -o $(user) -g $(group) dhcp6ctl.8 $(mandir)/man8
+	$(INSTALL_DATA) -o $(user) -g $(group) dhcp6c.conf.5 $(mandir)/man5
+	$(INSTALL_DATA) -o $(user) -g $(group) dhcp6s.conf.5 $(mandir)/man5
+
+includes::
+
+clean::
+	/bin/rm -f *.o $(TARGET) $(CLEANFILES) $(GENSRCS)
+
+distclean:: clean
+	/bin/rm -f Makefile config.cache config.log config.status .depend
+
+depend:
+	mkdep ${CFLAGS:M-[ID]*} $(srcdir)/*.c
+
+package:
+	tar -zcvf wide-dhcpv6.tar.gz $(srcdir)/*.[chyl1-8] $(srcdir)/Makefile.in \
+		$(srcdir)/README $(srcdir)/COPYRIGHT $(srcdir)/CHANGES \
+		$(srcdir)/configure $(srcdir)/configure.in \
+		$(srcdir)/install-sh  $(srcdir)/*.sample \
+		$(srcdir)/missing/arc4random.?  $(srcdir)/missing/strlcat.c \
+		$(srcdir)/missing/strlcpy.c $(srcdir)/missing/daemon.c \
+		$(srcdir)/missing/err.h $(srcdir)/missing/warnx.c \
+		$(srcdir)/missing/ifaddrs.h $(srcdir)/missing/getifaddrs.c \
+		$(srcdir)/missing/sys/queue.h
diff -Naur dhcpv6-aei/Makefile.in dhcpv6-aei-brcm/Makefile.in
--- dhcpv6-aei/Makefile.in	2007-03-21 06:52:58.000000000 -0300
+++ dhcpv6-aei-brcm/Makefile.in	2019-06-13 11:48:57.543013322 -0300
@@ -11,7 +11,7 @@
 # 3. Neither the name of the project nor the names of its contributors
 #    may be used to endorse or promote products derived from this software
 #    without specific prior written permission.
-# 
+#
 # THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 # ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -25,7 +25,7 @@
 # SUCH DAMAGE.
 
 #
-# $Id: Makefile.in,v 1.16 2007/02/27 14:47:11 suzsuz Exp $
+# $Id: Makefile.in,v 1.1.2.1 2011/07/25 01:43:53 lzhang Exp $
 # $KAME: Makefile.in,v 1.45 2005/10/16 16:25:38 suz Exp $
 #
 
@@ -79,7 +79,7 @@
 
 cftoken.c: cftoken.l y.tab.h
 	@LEX@ cftoken.l
-	mv lex.yy.c $@	
+	mv lex.yy.c $@
 
 getaddrinfo.o:	$(srcdir)/missing/getaddrinfo.c
 	$(CC) -c $(srcdir)/missing/$*.c
diff -Naur dhcpv6-aei/netlink_dad.c dhcpv6-aei-brcm/netlink_dad.c
--- dhcpv6-aei/netlink_dad.c	1969-12-31 20:00:00.000000000 -0400
+++ dhcpv6-aei-brcm/netlink_dad.c	2019-06-13 11:48:57.555012541 -0300
@@ -0,0 +1,262 @@
+/*
+#include <errno.h>
+#include <error.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <linux/if.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
+#include "dhcp6.h"
+#include "config.h"
+#include "common.h"
+#include "timer.h"
+#include "dhcp6c_ia.h"
+#include "prefixconf.h"
+
+#include "dhcp6.h"
+#include "config.h"
+#include "common.h"
+***/
+#include <sys/types.h>
+#include <time.h>
+#include <sys/socket.h>
+#include <sys/queue.h>
+#include <sys/ioctl.h>
+
+#include <net/if.h>
+#ifdef __FreeBSD__
+jdfjksdfj#include <net/if_var.h>
+#endif
+
+#include <netinet/in.h>
+
+#ifdef __KAME__
+dfsdfsd#include <netinet6/in6_var.h>
+#include <netinet6/nd6.h>
+#endif
+
+#include <errno.h>
+#include <syslog.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
+//#include <util/mgt_client.h>
+
+//#include "ctl_msg.h"
+//#include "dbussend_msg.h"
+//extern CtlDhcp6cStateChangedMsgBody ctldhcp6cMsgBody;
+
+#include "dhcp6.h"
+#include "config.h"
+#include "common.h"
+#include "timer.h"
+#include "dhcp6c_ia.h"
+#include "prefixconf.h"
+
+#include "netlink_dad.h"
+
+static void
+nl_close(int sd)
+{
+    if (sd >= 0) close(sd);
+}
+
+static int
+nl_open(void)
+{
+    struct sockaddr_nl nladdr;
+    int sd;
+
+    sd = socket(PF_NETLINK, SOCK_RAW, NETLINK_DAD);
+    if (sd < 0) return -1;
+    memset(&nladdr, 0, sizeof(nladdr));
+    nladdr.nl_family = AF_NETLINK;
+
+    nladdr.nl_pid = getpid();  /* self pid */
+    /* interested in group 1<<0 */
+    nladdr.nl_groups = 1;
+
+    if (bind(sd, (struct sockaddr*)&nladdr, sizeof(nladdr)) < 0) {
+        nl_close(sd);
+        return -1;
+    }
+    return sd;
+}
+
+int
+netlink_dad_start( int *fd )
+{
+    int status;
+    //int fd;
+    struct msghdr msg;
+    struct sockaddr_nl dest_addr;
+    struct nlmsghdr *nlh;
+    struct iovec iov;
+    struct dad_failed_msg_t *dad_msg;
+
+    *fd = nl_open();
+    if ( *fd < 0) {
+        dprintf(LOG_INFO, FNAME, "nl_open failed\n");
+        perror("Error\n");
+        return 1;
+    }
+
+    return 0;
+}
+
+    int
+netlink_recv( int fd,
+        struct dhcp6_if **pp_if)
+{
+    int status;
+    struct msghdr msg = {0};
+    struct sockaddr_nl dest_addr;
+    struct nlmsghdr *nlh;
+    struct iovec iov;
+    struct dad_failed_msg_t *dad_msg = NULL;
+
+    nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(sizeof(struct dad_failed_msg_t)));
+    if (!nlh) {
+        dprintf(LOG_INFO, FNAME, "malloc failed\n");
+        return 2;
+    }
+    memset(nlh, 0, NLMSG_SPACE(sizeof(struct dad_failed_msg_t)));
+
+    iov.iov_base = (void *)nlh;
+    iov.iov_len = NLMSG_SPACE(sizeof(struct dad_failed_msg_t));
+    msg.msg_name = (void *)&dest_addr;
+    msg.msg_namelen = sizeof(dest_addr);
+    msg.msg_iov = &iov;
+    msg.msg_iovlen = 1;
+
+    dprintf(LOG_INFO, FNAME, "Starting recv,iov length is %d",(int)iov.iov_len);
+
+    status = recvmsg(fd, &msg, 0);
+    if (status < 0) {
+        // close(fd);
+        free(nlh);
+        dprintf(LOG_INFO, FNAME, "recvmsg failed, error: %s", strerror(errno) );
+        return 1;
+    }
+
+    if (iov.iov_len == nlh->nlmsg_len) {
+        dad_msg = (struct dad_failed_msg_t *)NLMSG_DATA(nlh);
+
+#define ADDR_PREFIX_FMT "%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X/%d"
+#define ADDR_PREFIX_PARAM(dad_msg) dad_msg->addr.s6_addr16[0],\
+        dad_msg->addr.s6_addr16[1],\
+        dad_msg->addr.s6_addr16[2],\
+        dad_msg->addr.s6_addr16[3],\
+        dad_msg->addr.s6_addr16[4],\
+        dad_msg->addr.s6_addr16[5],\
+        dad_msg->addr.s6_addr16[6],\
+        dad_msg->addr.s6_addr16[7],\
+        dad_msg->prefix_len
+
+        dprintf(LOG_INFO, FNAME, "DAD failed on interface %s,Address:" ADDR_PREFIX_FMT, dad_msg->name, ADDR_PREFIX_PARAM(dad_msg));
+    }
+
+    free(nlh);
+    // close(fd);
+
+
+    if(dad_msg)
+    {
+        struct dhcp6_if *ifp = NULL;
+        if ((ifp = find_ifconfbyname(dad_msg->name)) == NULL) {
+            dprintf(LOG_INFO, FNAME,
+                    "failed to find interface configuration for %s",
+                    dad_msg->name);
+            return 11;
+        }
+
+        // returned value
+        memcpy( &(ifp->addr.s6_addr32), &(dad_msg->addr.s6_addr32), sizeof( struct in6_addr ) );
+        *pp_if = ifp;
+
+        dprintf(LOG_INFO, FNAME, "Then we should send DH6_DECLINE to: %s", ifp->ifname );
+    }
+
+    return 0;
+}
+
+#if 0
+int
+main(int argc,char **argv)
+{
+    int status;
+    int fd;
+    struct msghdr msg;
+    struct sockaddr_nl dest_addr;
+    struct nlmsghdr *nlh;
+    struct iovec iov;
+    struct dad_failed_msg_t *dad_msg;
+
+    fd = nl_open();
+    if (fd < 0) {
+        perror("Error\n");
+        return -1;
+    }
+
+    nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(sizeof(struct dad_failed_msg_t)));
+    if (!nlh) {
+        perror("Malloc Error\n");
+        return -1;
+    }
+    memset(nlh, 0, NLMSG_SPACE(sizeof(struct dad_failed_msg_t)));
+
+    iov.iov_base = (void *)nlh;
+    iov.iov_len = NLMSG_SPACE(sizeof(struct dad_failed_msg_t));
+    msg.msg_name = (void *)&dest_addr;
+    msg.msg_namelen = sizeof(dest_addr);
+    msg.msg_iov = &iov;
+    msg.msg_iovlen = 1;
+
+    printf("Starting recv,iov length is %d\n",(int)iov.iov_len);
+
+    while (1) {
+        status = recvmsg(fd, &msg, 0);
+
+        if (status < 0) {
+            close(fd);
+            free(nlh);
+            perror("recv");
+            return 1;
+        }
+
+        if (iov.iov_len == nlh->nlmsg_len) {
+            dad_msg = (struct dad_failed_msg_t *)NLMSG_DATA(nlh);
+
+#define ADDR_PREFIX_FMT "%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X/%d"
+#define ADDR_PREFIX_PARAM(dad_msg) dad_msg->addr.s6_addr16[0],\
+            dad_msg->addr.s6_addr16[1],\
+            dad_msg->addr.s6_addr16[2],\
+            dad_msg->addr.s6_addr16[3],\
+            dad_msg->addr.s6_addr16[4],\
+            dad_msg->addr.s6_addr16[5],\
+            dad_msg->addr.s6_addr16[6],\
+            dad_msg->addr.s6_addr16[7],\
+            dad_msg->prefix_len
+
+            printf("DAD failed on interface %s,Address:" ADDR_PREFIX_FMT "\n",
+                   dad_msg->name,ADDR_PREFIX_PARAM(dad_msg));
+        }
+    }
+
+    close(fd);
+    free(nlh);
+
+    return 0;
+}
+#endif
diff -Naur dhcpv6-aei/netlink_dad.h dhcpv6-aei-brcm/netlink_dad.h
--- dhcpv6-aei/netlink_dad.h	1969-12-31 20:00:00.000000000 -0400
+++ dhcpv6-aei-brcm/netlink_dad.h	2019-06-13 11:48:57.555012541 -0300
@@ -0,0 +1,15 @@
+#ifndef NETLINK_DAD_H_
+#define NETLINK_DAD_H_
+
+struct dad_failed_msg_t {
+    struct in6_addr addr;
+    int prefix_len;
+    char name[32];
+};
+
+#define NETLINK_DAD  29
+
+int netlink_dad_start( int *fd );
+int netlink_recv( int fd, struct dhcp6_if ** pp_if );
+
+#endif  //NETLINK_DAD_H_
diff -Naur dhcpv6-aei/prefixconf.c dhcpv6-aei-brcm/prefixconf.c
--- dhcpv6-aei/prefixconf.c	2007-03-21 06:52:55.000000000 -0300
+++ dhcpv6-aei-brcm/prefixconf.c	2019-06-13 11:48:57.555012541 -0300
@@ -59,7 +59,15 @@
 #include "timer.h"
 #include "dhcp6c_ia.h"
 #include "prefixconf.h"
-
+#ifdef AEI_CONTROL_LAYER
+#include "tsl_common.h"
+#include "ctl_msg.h"
+#include "dbussend_msg.h"
+extern dbussend_hdl_st *ctlMsgHandle;
+#ifdef CONFIG_IOT_RECONFIGURATION
+extern int got_valid_ia_pd;
+#endif
+#endif
 TAILQ_HEAD(siteprefix_list, siteprefix);
 struct iactl_pd {
 	struct iactl common;
@@ -118,6 +126,12 @@
 extern struct dhcp6_timer *client6_timo __P((void *));
 static int pd_ifaddrconf __P((ifaddrconf_cmd_t, struct dhcp6_ifprefix *ifpfx));
 
+#ifdef AEI_CONTROL_LAYER
+static void sendPrefixEventMessage __P((ifaddrconf_cmd_t, struct siteprefix *));
+extern CtlDhcp6cStateChangedMsgBody ctldhcp6cMsgBody;
+extern CtlDhcp6cStateChangedMsgBody ctldhcp6cMsgBody_Old;
+#endif
+
 int
 update_prefix(ia, pinfo, pifc, dhcpifp, ctlp, callback)
 	struct ia *ia;
@@ -136,7 +150,7 @@
 	/*
 	 * A client discards any addresses for which the preferred
          * lifetime is greater than the valid lifetime.
-	 * [RFC3315 22.6] 
+	 * [RFC3315 22.6]
 	 */
 	if (pinfo->vltime != DHCP6_DURATION_INFINITE &&
 	    (pinfo->pltime == DHCP6_DURATION_INFINITE ||
@@ -223,10 +237,15 @@
 	 * If the new vltime is 0, this prefix immediately expires.
 	 * Otherwise, set up or update the associated timer.
 	 */
+#ifdef CONFIG_IOT_RECONFIGURATION
+switch (/*sp->prefix.vltime*/sp->prefix.pltime) {
+#else
 	switch (sp->prefix.vltime) {
+#endif
 	case 0:
 		remove_siteprefix(sp);
-		break;
+//		break;
+		return (0);    //brcm
 	case DHCP6_DURATION_INFINITE:
 		if (sp->timer)
 			dhcp6_remove_timer(&sp->timer);
@@ -249,6 +268,10 @@
 		break;
 	}
 
+#if 1 //brcm
+   sendPrefixEventMessage(IFADDRCONF_ADD, sp);
+#endif
+
 	return (0);
 }
 
@@ -282,6 +305,10 @@
 	if (sp->timer)
 		dhcp6_remove_timer(&sp->timer);
 
+#if 1 //brcm
+   sendPrefixEventMessage(IFADDRCONF_REMOVE, sp);
+#endif
+
 	/* remove all interface prefixes */
 	while ((ip = TAILQ_FIRST(&sp->ifprefix_list)) != NULL) {
 		TAILQ_REMOVE(&sp->ifprefix_list, ip, plink);
@@ -339,6 +366,11 @@
 	while ((sp = TAILQ_FIRST(&iac_pd->siteprefix_head)) != NULL) {
 		TAILQ_REMOVE(&iac_pd->siteprefix_head, sp, link);
 		remove_siteprefix(sp);
+        if (memcmp(&ctldhcp6cMsgBody, &ctldhcp6cMsgBody_Old, sizeof(CtlDhcp6cStateChangedMsgBody)))
+        {
+             sendDhcp6cEventMessage();
+             memcpy(&ctldhcp6cMsgBody_Old, &ctldhcp6cMsgBody, sizeof(CtlDhcp6cStateChangedMsgBody));
+        }
 	}
 
 	free(iac);
@@ -358,14 +390,14 @@
 	for (sp = TAILQ_FIRST(&iac_pd->siteprefix_head); sp;
 	    sp = TAILQ_NEXT(sp, link)) {
 		if (dhcp6_add_listval(&pl, DHCP6_LISTVAL_PREFIX6,
-		    &sp->prefix, NULL) == NULL)
+		    &sp->prefix, NULL, 0) == NULL)
 			goto fail;
 	}
 
 	if ((ial = malloc(sizeof(*ial))) == NULL)
 		goto fail;
 	TAILQ_INIT(ial);
-	if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IAPD, iaparam, &pl) == NULL)
+	if (dhcp6_add_listval(ial, DHCP6_LISTVAL_IAPD, iaparam, &pl, 0) == NULL)
 		goto fail;
 	dhcp6_clear_list(&pl);
 
@@ -420,6 +452,14 @@
 
 	remove_siteprefix(sp);
 
+        //when prefix tiomeout need send the message to smd immediately
+       //add by harrison 2012-08-07
+       if (memcmp(&ctldhcp6cMsgBody, &ctldhcp6cMsgBody_Old, sizeof(CtlDhcp6cStateChangedMsgBody)))
+      {
+           sendDhcp6cEventMessage();
+           memcpy(&ctldhcp6cMsgBody_Old, &ctldhcp6cMsgBody, sizeof(CtlDhcp6cStateChangedMsgBody));
+      }
+
 	(*callback)(ia);
 
 	return (NULL);
@@ -485,8 +525,12 @@
 	ifpfx->ifaddr = ifpfx->paddr;
 	for (i = 15; i >= pconf->ifid_len / 8; i--)
 		ifpfx->ifaddr.sin6_addr.s6_addr[i] = pconf->ifid[i];
+
+/*br0 address control by ctl_layer*/
+#if 0
 	if (pd_ifaddrconf(IFADDRCONF_ADD, ifpfx))
 		goto bad;
+#endif
 
 	/* TODO: send a control message for other processes */
 
@@ -512,6 +556,367 @@
 	struct prefix_ifconf *pconf;
 
 	pconf = ifpfx->ifconf;
-	return (ifaddrconf(cmd, pconf->ifname, &ifpfx->ifaddr, ifpfx->plen, 
+	return (ifaddrconf(cmd, pconf->ifname, &ifpfx->ifaddr, ifpfx->plen,
 	    ND6_INFINITE_LIFETIME, ND6_INFINITE_LIFETIME));
 }
+
+#if 1 //brcm
+const char *f_ip6Prefix = "/var/ip6prefix";
+const char *f_radvdConf = "/var/radvd.conf";
+const char *f_radvdPid  = "/var/run/radvd.pid";
+
+const char *radvdConf0 = "\
+interface br0\n\
+{\n\
+  AdvSendAdvert on;\n\
+  MinRtrAdvInterval 3;\n\
+  MaxRtrAdvInterval 10;\n\
+  AdvDefaultPreference low;\n\
+";
+
+const char *radvdConf1 = "\
+  prefix %s\n\
+  {\n\
+    AdvPreferredLifetime %s;\n\
+    AdvValidLifetime %s;\n\
+    AdvOnLink on;\n\
+    AdvAutonomous on;\n\
+    AdvRouterAddr off;\n\
+  };\n\
+";
+
+const char *radvdConf2 = "\
+};\n\
+";
+
+extern char **environ;
+int bcmSystemEx __P((char *, int));
+
+/***************************************************************************
+ * Function:
+ *    int updateRadvdConfFile(ifaddrconf_cmd_t cmd, struct siteprefix *sp)
+ * Description:
+ *    This function creates a radvd.conf file containing the ipv6 prefix
+ *    captured from dhcp6s reply from WAN interface and starts the radvd
+ *    daemon.
+ * Parameters:
+ *    void
+ * Returns:
+ *    0 if SUCCESS otherwise -1
+ ***************************************************************************/
+#if 0
+int updateRadvdConfFile(ifaddrconf_cmd_t cmd, struct siteprefix *sp)
+{
+   FILE     *fp_ip6Prefix, *fp_radvdConf, *fp_radvdPid;
+   char     *token1, *token2, *token3, *token4, *nextToken;
+   char     *addrStr;
+   char     *ltimeStr;
+   char     pltimeStr[12], vltimeStr[12];
+   char     line[84], prefix[84];
+   unsigned short addr;
+   unsigned short subnet = 0;    /* this should be configurable */
+   int      pid;
+   int      pltime;
+   int      vltime;
+   long     curLine;
+   long     addrStrLen, prefixLen;
+
+   /* see if the f_ip6Prefix file already exists */
+   if (access(f_ip6Prefix, F_OK) == 0)
+   {
+      /* open the existing file for update */
+      if ((fp_ip6Prefix = fopen(f_ip6Prefix, "r+")) == NULL)
+      {
+         /* error */
+         dprintf(LOG_ERR, FNAME, "failed to open %s", f_ip6Prefix);
+         return -1;
+      }
+   }
+   else
+   {
+      /* open a new file */
+      if ((fp_ip6Prefix = fopen(f_ip6Prefix, "w+")) == NULL)
+      {
+         /* error */
+         dprintf(LOG_ERR, FNAME, "failed to open %s", f_ip6Prefix);
+         return -1;
+      }
+   }
+   fseek(fp_ip6Prefix, 0L, SEEK_SET);
+
+   addrStr    = in6addr2str(&sp->prefix.addr, 0);
+   addrStrLen = strlen(addrStr);
+
+   if (cmd == IFADDRCONF_ADD)
+   {
+      long blankLine  = 0;
+
+      /* if this is an update of an existing prefix, look for the entry in the file */
+      sprintf(prefix, "%s/%d pltime %d vltime %d", addrStr, sp->prefix.plen, sp->prefix.pltime, sp->prefix.vltime);
+      prefixLen = strlen(prefix);
+
+      /* read the standard prefix from f_ip6Prefix */
+      curLine = ftell(fp_ip6Prefix);
+      while (fgets(line, sizeof(line), fp_ip6Prefix) != NULL)
+      {
+         if (strncmp(line, addrStr, addrStrLen) == 0)
+         {
+            if (strncmp(line, prefix, prefixLen) == 0)
+            {
+               /* nothing changes. just return. */
+               fclose(fp_ip6Prefix);
+               return 0;
+            }
+
+            /* either plen or pltime or vltime has changed.
+             * set the file position to the beginning of the current line, so that
+             * we can over-write this entry.
+             */
+            fseek(fp_ip6Prefix, curLine, SEEK_SET);
+            blankLine = 0;    /* clear any blank line file position */
+            break;
+         }
+         else if (strchr(line, ':') == NULL)
+         {
+            /* save this blank line file position */
+            blankLine = curLine;
+         }
+         curLine = ftell(fp_ip6Prefix);
+      }
+
+      if (blankLine != 0)
+      {
+         /* set the file position to the beginning of the blank line. */
+         fseek(fp_ip6Prefix, blankLine, SEEK_SET);
+      }
+
+      /* write prefix to the file position */
+      fprintf(fp_ip6Prefix, "%-80s\n", prefix);   /* Note: each line must be 80 chars long */
+   }
+   else if (cmd == IFADDRCONF_REMOVE)
+   {
+      curLine = ftell(fp_ip6Prefix);
+      while (fgets(line, sizeof(line), fp_ip6Prefix) != NULL)
+      {
+         if (strncmp(line, addrStr, addrStrLen) == 0)
+         {
+            /* erase the line */
+            fseek(fp_ip6Prefix, curLine, SEEK_SET);
+            fprintf(fp_ip6Prefix, "%-80s\n", " ");  /* Note: each line must be 80 chars long */
+            break;
+         }
+         curLine = ftell(fp_ip6Prefix);
+      }
+   }
+
+   /* open radvd.conf file for write */
+   if ((fp_radvdConf = fopen(f_radvdConf, "w")) == NULL)
+   {
+      /* error */
+      fprintf(stderr, "failed to open %s\n", f_radvdConf);
+      fclose(fp_ip6Prefix);
+      return -1;
+   }
+
+   /* re-write the entire radvd.conf */
+   fprintf(fp_radvdConf, radvdConf0);
+
+   prefix[0] = '\0';
+   fseek(fp_ip6Prefix, 0L, SEEK_SET);
+
+   /* read the standard prefix from f_ip6Prefix */
+   curLine = ftell(fp_ip6Prefix);
+   while (fgets(line, sizeof(line), fp_ip6Prefix) != NULL)
+   {
+      if (strchr(line, ':') == NULL)
+      {
+         curLine = ftell(fp_ip6Prefix);
+         continue;   /* skip blank line */
+      }
+
+      pltime  = 0;
+      vltime  = 0;
+
+      /* get the preferred life time value */
+      if ((ltimeStr = strstr(line, "pltime")) != NULL)
+      {
+         sscanf(ltimeStr, "%*s%d", &pltime);
+      }
+
+      /* get the valid life time value */
+      if ((ltimeStr = strstr(line, "vltime")) != NULL)
+      {
+         sscanf(ltimeStr, "%*s%d", &vltime);
+      }
+
+      /* get the most significant 16bit address segment */
+      token1 = strtok_r(line, ":", &nextToken);
+
+      /* get the next 16bit address segment */
+      token2 = strtok_r(NULL, ":", &nextToken);
+
+      /* get the next 16bit address segment */
+      token3 = strtok_r(NULL, ":", &nextToken);
+
+      /* get the next 16bit address segment */
+      token4 = strtok_r(NULL, ":", &nextToken);
+      addr = 0;
+      if (token4)
+      {
+         addr = (unsigned short)atoi(token4);
+      }
+      addr |= subnet;
+
+      /* format prefix string */
+      sprintf(prefix, "%s:%s:%s:%x::/64",
+              token1?token1:"0", token2?token2:"0", token3?token3:"0", addr);
+
+      /* write to radvd.conf */
+      if (pltime == -1)
+      {
+         strcpy(pltimeStr, "infinity");
+      }
+      else
+      {
+         sprintf(pltimeStr, "%d", pltime);
+      }
+      if (vltime == -1)
+      {
+         strcpy(vltimeStr, "infinity");
+      }
+      else
+      {
+         sprintf(vltimeStr, "%d", vltime);
+      }
+      fprintf(fp_radvdConf, radvdConf1, prefix, pltimeStr, vltimeStr);
+
+      if (vltime == 0)
+      {
+         /* set the file position to the beginning of the current line. */
+         fseek(fp_ip6Prefix, curLine, SEEK_SET);
+         /* erase the line */
+         fprintf(fp_ip6Prefix, "%-80s\n", " "); /* Note: each line must be 80 chars long */
+      }
+
+      curLine = ftell(fp_ip6Prefix);
+   }
+
+   fprintf(fp_radvdConf, radvdConf2);
+   fclose(fp_radvdConf);
+   fclose(fp_ip6Prefix);
+
+   /* kill any existing radvd daemon */
+   if ((fp_radvdPid = fopen(f_radvdPid, "r")) != NULL)
+   {
+      if (fgets(line, sizeof(line), fp_radvdPid) != NULL)
+      {
+         pid = atoi(line);
+         printf("killing radvd %d\n", pid);
+         sprintf(line, "kill -9 %d", pid);
+         bcmSystemEx(line, 1);
+      }
+      fclose(fp_radvdPid);
+      remove(f_radvdPid);
+   }
+
+   /* if a prefix was assigned, start radvd with the new conf file */
+   if (prefix[0] != '\0')
+   {
+      sprintf(line, "radvd -C %s -d 2 &", f_radvdConf);
+      bcmSystemEx(line, 1);
+   }
+
+   return 0;
+
+}  /* End of updateRadvdConfFile() */
+#endif
+
+/***************************************************************************
+// Function Name: bcmSystemEx().
+// Description  : launch shell command in the child process.
+// Parameters   : command - shell command to launch.
+// Returns      : status 0 - OK, -1 - ERROR.
+****************************************************************************/
+int bcmSystemEx(char *command, int printFlag)
+{
+   int pid = 0, status = 0;
+//   char *newCommand = NULL;
+
+   if ( command == 0 )
+      return 1;
+   pid = fork();
+   if ( pid == -1 )
+      return -1;
+
+   if ( pid == 0 ) {
+      char *argv[4];
+      argv[0] = "sh";
+      argv[1] = "-c";
+      argv[2] = command;
+      argv[3] = 0;
+#ifdef BRCM_DEBUG
+      if (printFlag)
+         printf("app: %s\r\n", command);
+#endif
+//      if (printFlag) {
+//        if ((newCommand = strdup(command)) != NULL) {
+//           bcmHidePassword(newCommand);
+//           free(newCommand);
+//        }
+//      }
+
+      execve("/bin/sh", argv, environ);
+      exit(127);
+   }
+
+   /* wait for child process return */
+   do {
+      if ( waitpid(pid, &status, 0) == -1 ) {
+         if ( errno != EINTR )
+            return -1;
+      } else
+         return status;
+   } while ( 1 );
+
+   return status;
+
+}  /* End of bcmSystemEx() */
+
+#ifdef AEI_CONTROL_LAYER
+inline void sendPrefixEventMessage(ifaddrconf_cmd_t cmd, struct siteprefix *sp)
+{
+#ifdef CONFIG_IOT_RECONFIGURATION
+    if(cmd==IFADDRCONF_ADD)
+        {
+            //got_valid_ia_pd++;
+            ctllog_debug(LOG_INFO,FLNAME,LINENUM,FNAME, "add valid ia pd(prefix=%s/%d,pltime=%d,vltime=%d) now,got_valid_ia_pd=%d",
+                in6addr2str(&sp->prefix.addr, 0), sp->prefix.plen,sp->prefix.pltime,sp->prefix.vltime,got_valid_ia_pd);
+
+        }
+       //support remove ia_pd
+       //modify by harrison 2012-08-07
+       else if(cmd==IFADDRCONF_REMOVE)
+       {
+                ctllog_debug(LOG_INFO,FLNAME,LINENUM,FNAME, "remove valid ia pd(prefix=%s/%d,pltime=%d,vltime=%d) now,got_valid_ia_pd=%d",
+                in6addr2str(&sp->prefix.addr, 0), sp->prefix.plen,sp->prefix.pltime,sp->prefix.vltime,got_valid_ia_pd);
+       }
+    /*else if(got_valid_ia_pd >0 )
+        {
+             ctllog_debug(LOG_INFO,FLNAME,LINENUM,FNAME, "got valid ia pd(prefix=%s,pltime=%d,vltime=%d) before,cann't do remove!got_valid_ia_pd=%d",
+                ctldhcp6cMsgBody.sitePrefix,ctldhcp6cMsgBody.prefixPltime,ctldhcp6cMsgBody.prefixVltime,got_valid_ia_pd);
+            return;
+        }*/
+
+#endif
+
+   ctldhcp6cMsgBody.prefixAssigned = TSL_B_TRUE;
+   ctldhcp6cMsgBody.prefixCmd      = cmd;
+   sprintf(ctldhcp6cMsgBody.sitePrefix, "%s/%d", in6addr2str(&sp->prefix.addr, 0), sp->prefix.plen);
+   ctldhcp6cMsgBody.prefixPltime = sp->prefix.pltime;
+   ctldhcp6cMsgBody.prefixVltime = sp->prefix.vltime;
+
+   dprintf(LOG_NOTICE, FNAME, "DHCP6C_PREFIX_CHANGED");
+   return;
+}  /* End of sendPrefixEventMessage() */
+#endif
+#endif
