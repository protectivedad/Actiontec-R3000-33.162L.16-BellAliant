diff -Naur dproxy-nexgen/cache.c dproxy-nexgen-brcm/cache.c
--- dproxy-nexgen/cache.c	2000-03-19 00:05:56.000000000 -0400
+++ dproxy-nexgen-brcm/cache.c	2018-11-23 22:41:44.385484054 -0400
@@ -1,236 +1,476 @@
-/*
-  **
-  ** cache.c - cache handling routines
-  **
-  ** Part of the dproxy package by Matthew Pratt. 
-  **
-  ** Copyright 1999 Matthew Pratt <mattpratt@yahoo.com>
-  **
-  ** This software is licensed under the terms of the GNU General 
-  ** Public License (GPL). Please see the file COPYING for details.
-  ** 
-  **
-*/
-#include <string.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <time.h>
-#include <sys/file.h>
-#include <ctype.h>
-#include <unistd.h>
-
-#include "cache.h"
-#include "conf.h"
-
-/** function prototypes for private functions*/
-static int cache_byname(FILE * , char *, char *);
-
-/*****************************************************************************
- *  search for a host by its name.
- *  
- *    This function first searches the cache for an entry. If the entry 
- *    was not found there, we will look into a dhcp "leases" file.
- * 
- *  @arg name  - name to find.
- *  @arg ip    - pointer to a buffer where to put the ip adress.
- *  
- *  @return 0 if an entry was found, 1 if not.
-*****************************************************************************/
-int cache_lookup_name(char *name, char ip[BUF_SIZE])
-{
-  FILE * fp;
-  
-  debug( "cache_lookup_name(%s)\n", name);
-  
-  /** check the cache */
-  if( (fp = fopen( config.cache_file , "r")) != NULL) {
-	 int result = 0;
-	 result = cache_byname(fp,name, ip); 
-	 fclose(fp);   
-	 if( result > 0 ) {
-		return 1;
-	 }
-  }
-  
-  return 0;
-}
-/*****************************************************************************
- * lookup a hostname in the cache file.
- *
- * This function will not lock the cache ! 
- * 
- *  @arg fp    - open file pointer for the cache file.
- *  @arg name  - name to find.
- *  @arg ip    - pointer to a buffer where to put the ip adress.
- *  
- *  @return 0 if an entry was found, 1 if not.
- *****************************************************************************/
-static int cache_byname(FILE * fp, char *name, char ip[BUF_SIZE])
-{
-
-  char line[BUF_SIZE];
-  char *token;
-  int i = 0;
-
-  ip[0] = 0;
-
-  /** make shure we are at the start of the cache */
-  rewind(fp);
-
-  while( fgets(line, BUF_SIZE, fp) ){
-	 token = strtok( line, " ");
-	 if( !strcasecmp( token, name) ){
-		token = strtok( NULL, " ");
-		while( isalnum(*token) || (*token=='.') )ip[i++] = *token++;
-		ip[i] = 0;
-		return 1;
-	 }
-  }
- 
-  return 0;
-}
-
-/*****************************************************************************/
-int cache_lookup_ip(char *ip, char result[BUF_SIZE])
-{
-  FILE *fp;
-  char line[BUF_SIZE];
-  char *token;
-  int i = 0;
-
-  if( ip[0] == 0 )return 0;
-  result[0] = 0;
-  
-  fp = fopen( config.cache_file , "r");
-  if(!fp)return 0;
-  while( fgets(line, BUF_SIZE, fp) ){
-	 strtok( line, " ");
-	 token = strtok( NULL, " ");
-	 if( !strncasecmp( token, ip, strlen(ip) ) ){
-		while( isalnum(line[i]) || (line[i]=='.') )result[i] = line[i++];
-		result[i] = 0;
-		fclose(fp);
-		return 1;
-	 }
-  }
-  fclose(fp);
-  
-  return 0;
-}
-/*****************************************************************************
-* save the name to the list.
-* 
-*
-*****************************************************************************/
-void cache_name_append(char *name, char *ip)
-{
-
-  FILE *fp;
-  char dummy[BUF_SIZE];
-
-  fp = fopen( config.cache_file, "a");
-  if(!fp){
-	 debug("Could not open cache file '%s' for writing",
-		      config.cache_file);
-	 return;
-  }
-
-  /** check if another process already added this host to the cache */
-  if( cache_byname(fp, name, dummy) != 0 ) {
-	  fclose(fp);
-	  return;
-  }
-
-  /** make shure that we at the end of the file. */
-  fseek(fp,0,SEEK_END);
-
-  /** write new entry */
-  fprintf( fp, "%s %s %ld\n", name, ip, time(NULL) );
-
-  fclose(fp);
-}
-/*****************************************************************************/
-void cache_purge(int older_than)
-{
-  FILE *in_fp, *out_fp;
-  char line[BUF_SIZE];
-  char old_cache[1024];
-  char *name, *ip, *time_made;
-
-  debug("enter cache_purge()\n");
-
-  in_fp = fopen( config.cache_file , "r");
-  if(!in_fp){
-	 debug_perror("Could not open old cache file");
-	 /*return;*/
-  }
-
-  if( in_fp ) {
-
-    sprintf( old_cache, "%s.old", config.cache_file );
-    if( rename( config.cache_file, old_cache ) < 0 ){
-	 debug_perror("Could not move cache file");
-	 fclose(in_fp);
-	 return;
-    }
-  }
-
-  out_fp = fopen( config.cache_file , "w");
-  if(!out_fp){
-	 if( in_fp ) {
-	 	fclose(in_fp);
-	 }
-	 debug_perror("Could not open new cache file");
-	 return;
-  }
-
-  cache_add_hosts_entries(out_fp);
-
-  if( in_fp ) {
-    while( fgets(line, BUF_SIZE, in_fp) ){
-	 name = strtok( line, " ");
-	 ip = strtok( NULL, " ");
-	 time_made = strtok( NULL, " ");
-	 if(!time_made)continue;
-	 if( time(NULL) - atoi( time_made ) < older_than )
-		fprintf( out_fp, "%s %s %s", name, ip, time_made );
-    }
-
-    fclose(in_fp);
-    unlink(old_cache);
-  }
-
-  fclose(out_fp);
-}
-/*****************************************************************************/
-void cache_add_hosts_entries(FILE *cache_file)
-{
-  FILE *hosts_fp;
-  char line[BUF_SIZE];
-  char *ip, *name;
-
-  debug("cache_add_hosts_entreies()\n");
-
-  hosts_fp = fopen( config.hosts_file , "r");
-  if( !hosts_fp ) {
-	debug_perror("can not open 'hosts'-file ");
-	return;
-  }
-
-  while( fgets(line, BUF_SIZE, hosts_fp) ){
-	 line[strlen(line) - 1] = 0; /* get rid of '\n' */
-	 ip = strtok( line, " \t");
-	 if( ip == NULL ) continue;  /* ignore blank lines */
-	 if( ip[0] == '#' )continue; /* ignore comments */
-	 while( (name = strtok( NULL, " \t" )) ){
-	   if(name[0] == '#')break;
-		fprintf( cache_file, "%s %s %ld\n", name, ip, 0L );
-	 }
-	 
-  }
-  fclose(hosts_fp);
-  debug("cache_add_hosts_entreies(): done\n");
-}
-
-
-
+/*
+  **
+  ** cache.c - cache handling routines
+  **
+  ** Part of the dproxy package by Matthew Pratt. 
+  **
+  ** Copyright 1999 Matthew Pratt <mattpratt@yahoo.com>
+  **
+  ** This software is licensed under the terms of the GNU General 
+  ** Public License (GPL). Please see the file COPYING for details.
+  ** 
+  **
+*/
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+#include <sys/file.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <signal.h>
+       
+
+
+#include "cache.h"
+#include "conf.h"
+
+/** function prototypes for private functions*/
+static int cache_byname(FILE * , char *, char *);
+
+/*****************************************************************************
+ *  search for a host by its name.
+ *  
+ *    This function first searches the cache for an entry. If the entry 
+ *    was not found there, we will look into a dhcp "leases" file.
+ * 
+ *  @arg name  - name to find.
+ *  @arg ip    - pointer to a buffer where to put the ip adress.
+ *  
+ *  @return 0 if an entry was found, 1 if not.
+*****************************************************************************/
+int cache_lookup_name(char *name, char ip[BUF_SIZE])
+{
+  FILE * fp;
+  
+  debug( "cache_lookup_name(%s)\n", name);
+  
+  /** check the cache */
+  if( (fp = fopen( config.cache_file , "r")) != NULL) {
+	 int result = 0;
+	 result = cache_byname(fp,name, ip); 
+	 fclose(fp);   
+	 if( result > 0 ) {
+		return 1;
+	 }
+  }
+  
+  return 0;
+}
+/*****************************************************************************
+ * lookup a hostname in the cache file.
+ *
+ * This function will not lock the cache ! 
+ * 
+ *  @arg fp    - open file pointer for the cache file.
+ *  @arg name  - name to find.
+ *  @arg ip    - pointer to a buffer where to put the ip adress.
+ *  
+ *  @return 0 if an entry was found, 1 if not.
+ *****************************************************************************/
+static int cache_byname(FILE * fp, char *name, char ip[BUF_SIZE])
+{
+
+  char line[BUF_SIZE];
+  char *token;
+  int i = 0;
+
+  ip[0] = 0;
+
+  /** make shure we are at the start of the cache */
+  rewind(fp);
+
+  while( fgets(line, BUF_SIZE, fp) ){
+	 token = strtok( line, " ");
+	 if( !strcasecmp( token, name) ){
+		token = strtok( NULL, " ");
+#ifdef AEI_CONTROL_LAYER
+		while( (isalnum(*token) || (*token=='.')||(*token==':')) && (i<BUF_SIZE-1) ) ip[i++] = *token++;
+#else
+		while( (isalnum(*token) || (*token=='.')) && (i<BUF_SIZE-1) ) ip[i++] = *token++;
+#endif
+		ip[i] = 0;  /* here, i is at most BUF_SIZE-1 */
+		return 1;
+	 }
+  }
+ 
+  return 0;
+}
+
+/*****************************************************************************/
+int cache_lookup_ip(char *ip, char result[BUF_SIZE])
+{
+  FILE *fp;
+  char line[BUF_SIZE];
+  char *token;
+  int i = 0;
+
+  if( ip[0] == 0 )return 0;
+  result[0] = 0;
+  
+  fp = fopen( config.cache_file , "r");
+  if(!fp)return 0;
+  while( fgets(line, BUF_SIZE, fp) ){
+	 strtok( line, " ");
+	 token = strtok( NULL, " ");
+	 if( !strncasecmp( token, ip, strlen(ip) ) ){
+		while( isalnum(line[i]) || (line[i]=='.') || (line[i] == '-'))
+		{
+		    result[i] = line[i];
+		    i++;
+		}
+		result[i] = 0;
+		fclose(fp);
+		return 1;
+	 }
+  }
+  fclose(fp);
+  
+  return 0;
+}
+
+#if 0
+/*****************************************************************************
+* save the name to the list.
+* 
+*
+*****************************************************************************/
+void cache_name_append(char *name, char *ip)
+{
+
+  FILE *fp;
+  char dummy[BUF_SIZE];
+
+  fp = fopen( config.cache_file, "a");
+  if(!fp){
+	 debug("Could not open cache file '%s' for writing",
+		      config.cache_file);
+	 return;
+  }
+
+  /** check if another process already added this host to the cache */
+  if( cache_byname(fp, name, dummy) != 0 ) {
+	  fclose(fp);
+	  return;
+  }
+
+  /** make shure that we at the end of the file. */
+  fseek(fp,0,SEEK_END);
+
+  /** write new entry */
+  fprintf( fp, "%s %s %ld\n", name, ip, time(NULL) );
+
+  fclose(fp);
+}
+#endif
+
+/*****************************************************************************/
+void cache_purge(int older_than)
+{
+  FILE /**in_fp, */*out_fp;
+//  char line[BUF_SIZE];
+//  char old_cache[1024];
+//  char *name, *ip, *time_made;
+
+  debug("enter cache_purge()\n");
+
+#if 0 //BRCM
+  in_fp = fopen( config.cache_file , "r");
+  if(!in_fp){
+	 debug_perror("Could not open old cache file");
+	 /*return;*/
+  }
+
+  if( in_fp ) {
+    sprintf( old_cache, "%s.old", config.cache_file );
+    if( rename( config.cache_file, old_cache ) < 0 ){
+	 debug_perror("Could not move cache file");
+	 fclose(in_fp);
+	 return;
+    }
+  }
+#endif
+
+  out_fp = fopen( config.cache_file , "w");
+  if(!out_fp){
+#if 0 //BRCM
+	 if( in_fp ) {
+	 	fclose(in_fp);
+	 }
+#endif
+	 debug_perror("Could not open new cache file");
+	 return;
+  }
+
+  cache_add_hosts_entries(out_fp);
+
+  /* No need to add dhcp entries any more, It seems that all dhcp
+   * entries now will be added to the host entries */
+#if !defined(AEI_VDSL_DNS_CACHE)
+  cache_add_dhcp_entries(out_fp);
+#endif
+
+#if 0 //BRCM
+  if( in_fp ) {
+    while( fgets(line, BUF_SIZE, in_fp) ){
+	 name = strtok( line, " ");
+	 ip = strtok( NULL, " ");
+	 time_made = strtok( NULL, " ");
+	 if(!time_made)continue;
+	 if( time(NULL) - atoi( time_made ) < older_than )
+		fprintf( out_fp, "%s %s %s", name, ip, time_made );
+    }
+
+    fclose(in_fp);
+    unlink(old_cache);
+  }
+#endif
+
+  fclose(out_fp);
+}
+
+/*****************************************************************************/
+void cache_add_hosts_entries(FILE *cache_file)
+{
+  FILE *hosts_fp;
+  char line[BUF_SIZE];
+  char *ip, *name;
+
+  debug("cache_add_hosts_entreies()\n");
+
+  hosts_fp = fopen( config.hosts_file , "r");
+  if( !hosts_fp ) {
+	debug_perror("can not open 'hosts'-file ");
+	return;
+  }
+
+  while( fgets(line, BUF_SIZE, hosts_fp) ){
+	 line[strlen(line) - 1] = 0; /* get rid of '\n' */
+	 ip = strtok( line, " \t");
+	 if( ip == NULL ) continue;  /* ignore blank lines */
+	 if( ip[0] == '#' )continue; /* ignore comments */
+	 while( (name = strtok( NULL, " \t" )) ){
+	   if(name[0] == '#')break;
+
+#if 0//defined(AEI_VDSL_CUSTOMER_NCS)
+           if(strstr(name,config.domain_name)==NULL)
+                fprintf( cache_file, "%s.%s %s %ld\n", name,config.domain_name, ip, 0L );
+           else
+#endif
+		fprintf( cache_file, "%s %s %ld\n", name, ip, 0L );
+	 }
+	 
+  }
+  fclose(hosts_fp);
+  debug("cache_add_hosts_entreies(): done\n");
+}
+
+#if !defined(AEI_VDSL_DHCP_LEASE)
+static void remove_delimitor( char *s)
+{
+    char *p1, *p2;
+
+    p1 = p2 = s;
+    while ( *p1 != '\0' || *(p1+1) != '\0') {
+        if (*p1 != '\0') {
+           *p2 = *p1;
+           p2++;
+         }
+         p1++;
+    }
+    *p2='\0';
+
+}
+
+/* find_pid_by_name()
+ *
+ *  This finds the pid of the specified process.
+ *  Currently, it's implemented by rummaging through
+ *  the proc filesystem.
+ *
+ *  Returns a list of all matching PIDs
+ */
+#define READ_BUF_SIZE 128
+static pid_t* find_pid_by_name( char* pidName)
+{
+        DIR *dir;
+        struct dirent *next;
+        pid_t* pidList=NULL;
+        int i=0;
+
+        /*FILE *status */
+        FILE *cmdline;
+        char filename[READ_BUF_SIZE];
+        char buffer[READ_BUF_SIZE];
+        /* char name[READ_BUF_SIZE]; */
+                
+        dir = opendir("/proc");
+        if (!dir) {
+                debug("Cannot open /proc");
+                return NULL;
+        }
+
+        while ((next = readdir(dir)) != NULL) {
+                /* re-initialize buffers */
+                memset(filename, 0, sizeof(filename));
+                memset(buffer, 0, sizeof(buffer));  
+
+                /* Must skip ".." since that is outside /proc */
+                if (strcmp(next->d_name, "..") == 0)
+                        continue;
+
+                /* If it isn't a number, we don't want it */
+                if (!isdigit(*next->d_name))
+                        continue;
+
+                /* sprintf(filename, "/proc/%s/status", next->d_name); */
+                /* read /porc/<pid>/cmdline instead to get full cmd line */
+                sprintf(filename, "/proc/%s/cmdline", next->d_name);
+                if (! (cmdline = fopen(filename, "r")) ) {
+                        continue;
+                }
+                if (fgets(buffer, READ_BUF_SIZE-1, cmdline) == NULL) {
+                        fclose(cmdline);
+                        continue;
+                }
+                fclose(cmdline);
+
+                /* Buffer should contain a string like "Name:   binary_name" */
+                /*sscanf(buffer, "%*s %s", name);*/
+                /* buffer contains full commandline params separted by '\0' */
+                remove_delimitor(buffer);
+                if (strstr(buffer, pidName) != NULL) {
+                        pidList=realloc( pidList, sizeof(pid_t) * (i+2));
+                        if (!pidList) {
+                            debug("Out of memeory!\n");
+			                closedir(dir);
+                            return NULL;
+                        }
+                        pidList[i++]=strtol(next->d_name, NULL, 0);
+                }
+        }
+        closedir(dir);
+
+        if (pidList)
+                pidList[i]=0;
+        else if ( strcmp(pidName, "init")==0) {
+                /* If we found nothing and they were trying to kill "init",
+                 * guess PID 1 and call it good...  Perhaps we should simply
+                 * exit if /proc isn't mounted, but this will do for now. */
+                pidList=realloc( pidList, sizeof(pid_t));
+                if (!pidList) {
+                        debug("Out of memeory!\n");
+                        return NULL;
+                }
+                pidList[0]=1;
+        } else {
+                pidList=realloc( pidList, sizeof(pid_t));
+                if (!pidList) {
+                        debug("Out of memeory!\n");
+                        return NULL;
+                }
+                pidList[0]=-1;
+        }
+        return pidList;
+}
+
+static int bcmGetPid(char * command)
+{
+    char cmdline[128], *p1, *p2;
+    pid_t *pid = NULL;
+    int ret = 0;
+
+    p1 = command;
+    p2 = cmdline;
+    while ( *p1 != '\0') {
+        if (*p1 != ' ') {
+           *p2 = *p1;
+           p2++;
+         }
+         p1++;
+    }
+    *p2='\0';
+
+    pid = find_pid_by_name(cmdline);
+    if ( pid != NULL ) {
+       ret = (int)(*pid);
+       free(pid);
+    }
+
+    return ret;
+}
+#endif
+
+struct lease_t {
+   unsigned char chaddr[16];
+   u_int32_t yiaddr;
+   u_int32_t expires;
+   char hostname[64];
+#if defined(AEI_VDSL_DHCP_LEASE)
+   char layer2Interface[32];
+   u_int32_t is_stb;
+#if defined(SUPPORT_GPL_UNDEFINED)
+    char oui[8];
+    char serialNumber[64];
+    char productClass[64];
+#endif
+#endif
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+    char vendorid[256];
+#endif
+};
+
+#define ETHER_ISNULLADDR(ea) ((((char *)(ea))[0] |     \
+                ((char *)(ea))[1] |        \
+                ((char *)(ea))[2] |        \
+                ((char *)(ea))[3] |        \
+                ((char *)(ea))[4] |        \
+                ((char *)(ea))[5]) == 0)
+
+
+void cache_add_dhcp_entries(FILE *cache_file)
+{
+  FILE *dhcpleases_fp;
+//  char line[BUF_SIZE];
+//  char *ip, *name;
+  struct lease_t lease;
+  struct in_addr ipAddr;
+
+  debug("cache_add_dhcp_entreies()\n");
+
+/* if AEI_VDSL_DHCP_LEASE is defined, dhcpd will write lease file
+ * every 1 minute, so no need to send signal SIGUSR1 to dhcpd */
+#if !defined(AEI_VDSL_DHCP_LEASE)
+  int dpid = bcmGetPid("dhcpd");
+  if (dpid == -1) { // dhcp server not running
+      return;
+  }
+  
+  kill(dpid, SIGUSR1);
+#endif
+
+  dhcpleases_fp = fopen( config.dhcp_lease_file , "r");
+  if( !dhcpleases_fp ) {
+	debug_perror("can not open 'udhcpd_leases'-file ");
+	return;
+  }
+
+  while (fread(&lease, sizeof(lease), 1, dhcpleases_fp)){
+	 /* Do not display reserved leases */
+#if defined(AEI_VDSL_DNS_CACHE)
+      if (ETHER_ISNULLADDR(lease.chaddr) ||
+          lease.hostname[0] == '\0') {
+#else
+      if (ETHER_ISNULLADDR(lease.chaddr)) {
+#endif
+	     continue;
+      }
+      ipAddr.s_addr = lease.yiaddr;
+      fprintf( cache_file, "%s.%s %s %ld\n", lease.hostname, config.domain_name, inet_ntoa(ipAddr), 0L );	 
+  }
+  fclose(dhcpleases_fp);
+  debug("cache_add_dhcp_entreies(): done\n");
+}
+
diff -Naur dproxy-nexgen/cache.h dproxy-nexgen-brcm/cache.h
--- dproxy-nexgen/cache.h	2000-03-17 04:25:42.000000000 -0400
+++ dproxy-nexgen-brcm/cache.h	2018-11-23 22:41:44.385484054 -0400
@@ -1,54 +1,56 @@
-/*
-  **
-  ** cache.h - function prototypes for the cache handling routines
-  **
-  ** Part of the drpoxy package by Matthew Pratt. 
-  **
-  ** Copyright 1999 Matthew Pratt <mattpratt@yahoo.com>
-  **
-  ** This software is licensed under the terms of the GNU General 
-  ** Public License (GPL). Please see the file COPYING for details.
-  ** 
-  **
-*/
-
-#include "dproxy.h" /* for BUF_SIZE */
-
-/* We assume cache entries are in the follwing form:
-
-<name> <ip> <time_created>
-
-Where "time_created" in the time the entry was created (seconds since 1/1/1970)
-*/
-
-/*
- * Search the cache "filename" for the first entry with name in the first field
- * Copies the corresponding IP into the char array "ip".
- * RETURNS: 0 if matching entry not found else 1.
- */
-int cache_lookup_name(char *name, char ip[BUF_SIZE]);
-
-/*
- * Search the cache "filename" for the first entry with ip in the second field.
- * Copies the corresponding Name into the char array "result".
- * RETURNS: 0 if matching entry not found else 1.
- */
-int cache_lookup_ip(char *ip, char result[BUF_SIZE]);
-/*
- * Appends the "name" and "ip" as well as the current time (seconds 
- * since 1/1/1970), to the cache file "filename".
- */
-void cache_name_append(char *name, char *ip);
-/*
- * Scans the cache file "filename" for entries whose time_created fields
- * is greater than the current time minus the time they were created, and
- * removes them from the cache.
- */
-void cache_purge(int older_than);
-/*
- * Reads the hosts file given by HOSTS_FILE and add any entries in standard
- * cache file format to the cache_file stream.
- */
-void cache_add_hosts_entries(FILE *cache_file);
-
-/* EOF */
+/*
+  **
+  ** cache.h - function prototypes for the cache handling routines
+  **
+  ** Part of the drpoxy package by Matthew Pratt. 
+  **
+  ** Copyright 1999 Matthew Pratt <mattpratt@yahoo.com>
+  **
+  ** This software is licensed under the terms of the GNU General 
+  ** Public License (GPL). Please see the file COPYING for details.
+  ** 
+  **
+*/
+
+#include "dproxy.h" /* for BUF_SIZE */
+
+/* We assume cache entries are in the follwing form:
+
+<name> <ip> <time_created>
+
+Where "time_created" in the time the entry was created (seconds since 1/1/1970)
+*/
+
+/*
+ * Search the cache "filename" for the first entry with name in the first field
+ * Copies the corresponding IP into the char array "ip".
+ * RETURNS: 0 if matching entry not found else 1.
+ */
+int cache_lookup_name(char *name, char ip[BUF_SIZE]);
+
+/*
+ * Search the cache "filename" for the first entry with ip in the second field.
+ * Copies the corresponding Name into the char array "result".
+ * RETURNS: 0 if matching entry not found else 1.
+ */
+int cache_lookup_ip(char *ip, char result[BUF_SIZE]);
+/*
+ * Appends the "name" and "ip" as well as the current time (seconds 
+ * since 1/1/1970), to the cache file "filename".
+ */
+void cache_name_append(char *name, char *ip);
+/*
+ * Scans the cache file "filename" for entries whose time_created fields
+ * is greater than the current time minus the time they were created, and
+ * removes them from the cache.
+ */
+void cache_purge(int older_than);
+/*
+ * Reads the hosts file given by HOSTS_FILE and add any entries in standard
+ * cache file format to the cache_file stream.
+ */
+void cache_add_hosts_entries(FILE *cache_file);
+
+void cache_add_dhcp_entries(FILE *cache_file);
+
+/* EOF */
diff -Naur dproxy-nexgen/conf.c dproxy-nexgen-brcm/conf.c
--- dproxy-nexgen/conf.c	2000-03-17 04:25:44.000000000 -0400
+++ dproxy-nexgen-brcm/conf.c	2018-11-23 22:41:44.385484054 -0400
@@ -1,311 +1,317 @@
-/*
-  **
-  ** conf.c
-  **
-  ** Part of the drpoxy package by Matthew Pratt. 
-  **
-  ** Copyright 1999 Jeroen Vreeken (pe1rxq@chello.nl)
-  **
-  ** This software is licensed under the terms of the GNU General 
-  ** Public License (GPL). Please see the file COPYING for details.
-  ** 
-  **
-*/
-
-/*
-  **
-  ** History:
-  **
-  **   changes by Jeroen Vreeken (pe1rxq@chello.nl)
-  **       - Created conf_load, conf_defaults and got them working.
-  **       - Added cmdparse and bool functions.
-  **       - Added connected
-  **       - Added purge time
-  **       - Added deny file
-  **
-*/
-
-/**
- * How to add a config option :
- *   1. add a #define for a default value at 'dproxy.h'. Don't
- *      forget that #ifdef ... #endif stuff there.
- *      
- *   2. add a field to 'struct config' in 'config.h'
- *
- *   3. add a default value to initialisation of 
- *      'config_defaults' below.
- *      
- *   4. add a entry to the config_params array below, if your
- *      option should be configurable by the config file.
- */ 
-#include <string.h>
-#include "conf.h"
-
-struct config config;  
-struct config config_defaults = {
-  NAME_SERVER_DEFAULT,
-  1 ,
-  PPP_DETECT_DEFAULT ,
-  PURGE_TIME_DEFAULT ,
-  CONFIG_FILE_DEFAULT, 
-  DENY_FILE_DEFAULT ,
-  CACHE_FILE_DEFAULT, 
-  HOSTS_FILE_DEFAULT, 
-  PPP_DEV_DEFAULT, 
-  DHCP_LEASES_DEFAULT, 
-  DEBUG_FILE_DEFAULT, 
-};
-
-static void copy_bool(char *, void *);
-static void print_bool(FILE * fd , void * value ) ;
-static void init_int(char *, void *);
-static void copy_int(char *, void *);
-static void print_int(FILE * fd , void * value ) ;
-static void copy_string(char *, void *);
-static void print_string(FILE * fd , void * value ) ;
-
-config_param config_params[] = {
-  { 
-     "name_server" ,
-     "# This is the IP of the upstream nameserver that dproxy queries\n",
-     &config.name_server,
-     &config_defaults.name_server,
-     copy_string ,
-     copy_string ,
-     print_string
-  } ,
-   { 
-     "ppp_detect" ,
-     "# Do you want to check for a connection?\n"
-     "# Set this only if you are using a ppp or isdn connection!\n",
-     &config.ppp_detect ,
-     &config_defaults.ppp_detect ,
-     init_int,
-     copy_bool ,
-     print_bool 
-  } ,
-   { 
-     "purge_time" ,
-     "# This will set the purge time, the time for a cached lookup\n"
-     "# become invalid (in seconds)\n",
-     &config.purge_time,
-     &config_defaults.purge_time,
-     init_int,
-     copy_int ,
-     print_int
-  } ,
-  { 
-     "deny_file" ,
-     "# Edit this file if you want some sites blocked....\n",
-     &config.deny_file,
-     &config_defaults.deny_file,
-     copy_string ,
-     copy_string ,
-     print_string
-  } ,
-  { 
-     "cache_file" ,
-     "# Location of the cache file\n",
-     &config.cache_file,
-     &config_defaults.cache_file,
-     copy_string ,
-     copy_string ,
-     print_string
-  } ,
-  { 
-     "hosts_file" ,
-     "# Location of the hosts file.\n",
-     &config.hosts_file,
-     &config_defaults.hosts_file,
-     copy_string ,
-     copy_string ,
-     print_string
-  } ,
-  { 
-     "dhcp_lease_file" ,
-     "# If you use dhcp, set this to tell dproxy where to find\n"
-     "# the dhcp leases.\n",
-     &config.dhcp_lease_file,
-     &config_defaults.dhcp_lease_file,
-     copy_string ,
-     copy_string ,
-     print_string
-  } ,
-  { 
-     "ppp_dev" ,
-     "# dproxy monitors this file to determine when the machine is\n"
-     "# connected to the net\n", 
-     &config.ppp_device_file,
-     &config_defaults.ppp_device_file,
-     copy_string ,
-     copy_string ,
-     print_string
-  } ,
-  { 
-     "debug_file" ,
-     "# Debug info log file\n" 
-     "# If you want dproxy to log debug info specify a file here.\n",
-     &config.debug_file,
-     &config_defaults.debug_file,
-     copy_string ,
-     copy_string ,
-     print_string
-  } ,
-  /*
-   * end-of-array indicator, must be present and everything below
-   * this line will be ignored.
-   */
-  { NULL , NULL , NULL, NULL, NULL , NULL }
-};
-
-/**************************************************************************
-    Main function, called from dproxy.c
-*/
-int conf_load (char *conf_file)
-{
-  FILE *fp;
-  char line[256], *cmd = NULL, *arg1 = NULL;
-  
-  conf_defaults();	/* load default settings first */
-  
-  fp = fopen (conf_file, "r");
-  if (!fp) {	/* specified file does not exist... try default file */
-	 fp = fopen (config.config_file, "r");
-	 if (!fp) {	/* there is no config file.... use defaults */
-		perror("no config file");
-		return 0;
-	 }
-  } else {
-	 strcpy(config.config_file, conf_file);
-  }
-  while (fgets(line, 256, fp)) {
-	 if (!(line[0]=='#')) {	/* skip lines with comment */
-		line[strlen(line) - 1] = 0; /* kill '\n' */
-		cmd = strtok( line, " =" );
-		arg1 = strtok( NULL, " =");
-		conf_cmdparse(cmd, arg1);
-	 }
-  }
-  fclose(fp);
-  return 0;
-}
-/*****************************************************************************/
-void conf_cmdparse(char *cmd, char *arg1)
-{
-  int i = 0;
-
-  if( !cmd )return;
-  if( !arg1 )return;
-  
-  while( config_params[i].param_name != NULL ) {
-	if(!strncasecmp(cmd, config_params[i].param_name , 
-			CONF_PATH_LEN + 50)) 
-	{
-	    config_params[i].copy( arg1, config_params[i].conf_value );
-	    return;
-	}
-	i++;
-  }
-
-  fprintf( stderr, "Unkown config option: \"%s\"\n", cmd ); 
-  return;
-
-}
-
-/************************************************************************
- * copy functions 
- *
- *   copy_bool   - convert a bool representation to int
- *   copy_int    - convert a string to int
- *   copy_string - just a string copy
- *   
- * @param str -   A char *, pointing to a string representation of the
- *                value.
- * @param value - points to the place where to store the value. 
-************************************************************************/
-static void copy_bool (char *str, void * val)
-{
-	if ( !strcmp(str, "1") || 
-	     !strcasecmp(str, "yes") || 
-	     !strcasecmp(str,"on")) 
-	{
-		*((int *)val) = 1;
-	}else
-	  *((int *)val) = 0;
-}
-static void copy_int(char *str, void * val) {
-	*((int *)val) = atoi(str);
-}
-static void copy_string(char *str, void * val) {
-	strncpy((char *)val, str , CONF_PATH_LEN );
-}
-static void init_int(char *str, void * val) {
-	*((int *)val) = *((int *)str);
-}
-/************************************************************************
- * print functions  -
- *
- * Take a config value, convert it to human readable form 
- * and print it out.
- *
- *   print_bool   -  print a boolean value
- *   print_int    -  print a string
- *   print_string - print a string value
- *   
- * @param fd - File descriptor for output.
- * @param value - pointer to the config value.
-************************************************************************/
-static void print_bool(FILE * fd , void * value ) {
-  if( *((int *)value) ) {
-    fprintf(fd,"yes");
-  } else {
-    fprintf(fd,"no");
-  }
-}
-static void print_int(FILE * fd , void * value ) {
-    fprintf(fd,"%d", *((int *) value) );
-}
-static void print_string(FILE * fd, void * value) {
-    fprintf(fd,"%s", ((char *)value) );
-}
-/************************************************************************
- * print the configuration on stdout.
-************************************************************************/
-void conf_print() {
-   int i = 0;
-   FILE * fd;
-
-   fd = stdout;
-   while( config_params[i].param_name != NULL ) {
-	fprintf(fd,"# param %s \n" , config_params[i].param_name );
-	fprintf(fd, config_params[i].comment);
-	fprintf(fd, "#\n");
-	fprintf(fd, "# Default : " );
-	config_params[i].print(fd,config_params[i].def_value );
-	fprintf(fd, "\n#\n");
-	fprintf(fd, "%s = " , config_params[i].param_name );
-	config_params[i].print(fd,config_params[i].conf_value );
-	fprintf(fd, "\n\n");
-
-	i++;
-   }
-}
-/************************************************************************
-    Load default settings first
-*/
-void conf_defaults (void)
-{
-  int i = 0;
-  while( config_params[i].param_name != NULL ) {
-	config_params[i].init( config_params[i].def_value,
-			       config_params[i].conf_value );
-	i++;
-  }
-
-  config.daemon_mode = 1;
-  config.dhcp_lease_file[0] = 0;
-  config.debug_file[0] = 0;
-  return;
-
-}
-
+/*
+  **
+  ** conf.c
+  **
+  ** Part of the drpoxy package by Matthew Pratt. 
+  **
+  ** Copyright 1999 Jeroen Vreeken (pe1rxq@chello.nl)
+  **
+  ** This software is licensed under the terms of the GNU General 
+  ** Public License (GPL). Please see the file COPYING for details.
+  ** 
+  **
+*/
+
+/*
+  **
+  ** History:
+  **
+  **   changes by Jeroen Vreeken (pe1rxq@chello.nl)
+  **       - Created conf_load, conf_defaults and got them working.
+  **       - Added cmdparse and bool functions.
+  **       - Added connected
+  **       - Added purge time
+  **       - Added deny file
+  **
+*/
+
+/**
+ * How to add a config option :
+ *   1. add a #define for a default value at 'dproxy.h'. Don't
+ *      forget that #ifdef ... #endif stuff there.
+ *      
+ *   2. add a field to 'struct config' in 'config.h'
+ *
+ *   3. add a default value to initialisation of 
+ *      'config_defaults' below.
+ *      
+ *   4. add a entry to the config_params array below, if your
+ *      option should be configurable by the config file.
+ */ 
+#include <string.h>
+#include "conf.h"
+
+struct config config;  
+struct config config_defaults = {
+  NAME_SERVER_DEFAULT,
+  1 ,
+  PPP_DETECT_DEFAULT ,
+  PURGE_TIME_DEFAULT ,
+  CONFIG_FILE_DEFAULT, 
+  DENY_FILE_DEFAULT ,
+  CACHE_FILE_DEFAULT, 
+  HOSTS_FILE_DEFAULT, 
+  PPP_DEV_DEFAULT, 
+  DHCP_LEASES_DEFAULT, 
+  DEBUG_FILE_DEFAULT,
+  DOMAIN_NAME_DEFAULT
+};
+
+static void copy_bool(char *, void *);
+static void print_bool(FILE * fd , void * value ) ;
+static void init_int(char *, void *);
+static void copy_int(char *, void *);
+static void print_int(FILE * fd , void * value ) ;
+static void copy_string(char *, void *);
+static void print_string(FILE * fd , void * value ) ;
+
+config_param config_params[] = {
+  { 
+     "name_server" ,
+     "# This is the IP of the upstream nameserver that dproxy queries\n",
+     &config.name_server,
+     &config_defaults.name_server,
+     copy_string ,
+     copy_string ,
+     print_string
+  } ,
+   { 
+     "ppp_detect" ,
+     "# Do you want to check for a connection?\n"
+     "# Set this only if you are using a ppp or isdn connection!\n",
+     &config.ppp_detect ,
+     &config_defaults.ppp_detect ,
+     init_int,
+     copy_bool ,
+     print_bool 
+  } ,
+   { 
+     "purge_time" ,
+     "# This will set the purge time, the time for a cached lookup\n"
+     "# become invalid (in seconds)\n",
+     &config.purge_time,
+     &config_defaults.purge_time,
+     init_int,
+     copy_int ,
+     print_int
+  } ,
+  { 
+     "deny_file" ,
+     "# Edit this file if you want some sites blocked....\n",
+     &config.deny_file,
+     &config_defaults.deny_file,
+     copy_string ,
+     copy_string ,
+     print_string
+  } ,
+  { 
+     "cache_file" ,
+     "# Location of the cache file\n",
+     &config.cache_file,
+     &config_defaults.cache_file,
+     copy_string ,
+     copy_string ,
+     print_string
+  } ,
+  { 
+     "hosts_file" ,
+     "# Location of the hosts file.\n",
+     &config.hosts_file,
+     &config_defaults.hosts_file,
+     copy_string ,
+     copy_string ,
+     print_string
+  } ,
+  { 
+     "dhcp_lease_file" ,
+     "# If you use dhcp, set this to tell dproxy where to find\n"
+     "# the dhcp leases.\n",
+     &config.dhcp_lease_file,
+     &config_defaults.dhcp_lease_file,
+     copy_string ,
+     copy_string ,
+     print_string
+  } ,
+  { 
+     "ppp_dev" ,
+     "# dproxy monitors this file to determine when the machine is\n"
+     "# connected to the net\n", 
+     &config.ppp_device_file,
+     &config_defaults.ppp_device_file,
+     copy_string ,
+     copy_string ,
+     print_string
+  } ,
+  { 
+     "debug_file" ,
+     "# Debug info log file\n" 
+     "# If you want dproxy to log debug info specify a file here.\n",
+     &config.debug_file,
+     &config_defaults.debug_file,
+     copy_string ,
+     copy_string ,
+     print_string
+  } ,
+  /*
+   * end-of-array indicator, must be present and everything below
+   * this line will be ignored.
+   */
+  { NULL , NULL , NULL, NULL, NULL , NULL }
+};
+
+/**************************************************************************
+    Main function, called from dproxy.c
+*/
+int conf_load (char *conf_file)
+{
+  FILE *fp;
+  char line[256], *cmd = NULL, *arg1 = NULL;
+  
+  conf_defaults();	/* load default settings first */
+  
+  fp = fopen (conf_file, "r");
+  if (!fp) {	/* specified file does not exist... try default file */
+	 fp = fopen (config.config_file, "r");
+	 if (!fp) {	/* there is no config file.... use defaults */
+		perror("no config file");
+		return 0;
+	 }
+  } else {
+#if defined(AEI_COVERITY_FIX)
+      /*CID 12229: Copy into fixed size buffer*/
+      strlcpy(config.config_file, conf_file, sizeof(config.config_file));
+#else
+	 strcpy(config.config_file, conf_file);
+#endif
+  }
+  while (fgets(line, 256, fp)) {
+	 if (!(line[0]=='#')) {	/* skip lines with comment */
+		line[strlen(line) - 1] = 0; /* kill '\n' */
+		cmd = strtok( line, " =" );
+		arg1 = strtok( NULL, " =");
+		conf_cmdparse(cmd, arg1);
+	 }
+  }
+  fclose(fp);
+  return 0;
+}
+/*****************************************************************************/
+void conf_cmdparse(char *cmd, char *arg1)
+{
+  int i = 0;
+
+  if( !cmd )return;
+  if( !arg1 )return;
+  
+  while( config_params[i].param_name != NULL ) {
+	if(!strncasecmp(cmd, config_params[i].param_name , 
+			CONF_PATH_LEN + 50)) 
+	{
+	    config_params[i].copy( arg1, config_params[i].conf_value );
+	    return;
+	}
+	i++;
+  }
+
+  fprintf( stderr, "Unkown config option: \"%s\"\n", cmd ); 
+  return;
+
+}
+
+/************************************************************************
+ * copy functions 
+ *
+ *   copy_bool   - convert a bool representation to int
+ *   copy_int    - convert a string to int
+ *   copy_string - just a string copy
+ *   
+ * @param str -   A char *, pointing to a string representation of the
+ *                value.
+ * @param value - points to the place where to store the value. 
+************************************************************************/
+static void copy_bool (char *str, void * val)
+{
+	if ( !strcmp(str, "1") || 
+	     !strcasecmp(str, "yes") || 
+	     !strcasecmp(str,"on")) 
+	{
+		*((int *)val) = 1;
+	}else
+	  *((int *)val) = 0;
+}
+static void copy_int(char *str, void * val) {
+	*((int *)val) = atoi(str);
+}
+static void copy_string(char *str, void * val) {
+	strncpy((char *)val, str , CONF_PATH_LEN );
+}
+static void init_int(char *str, void * val) {
+	*((int *)val) = *((int *)str);
+}
+/************************************************************************
+ * print functions  -
+ *
+ * Take a config value, convert it to human readable form 
+ * and print it out.
+ *
+ *   print_bool   -  print a boolean value
+ *   print_int    -  print a string
+ *   print_string - print a string value
+ *   
+ * @param fd - File descriptor for output.
+ * @param value - pointer to the config value.
+************************************************************************/
+static void print_bool(FILE * fd , void * value ) {
+  if( *((int *)value) ) {
+    fprintf(fd,"yes");
+  } else {
+    fprintf(fd,"no");
+  }
+}
+static void print_int(FILE * fd , void * value ) {
+    fprintf(fd,"%d", *((int *) value) );
+}
+static void print_string(FILE * fd, void * value) {
+    fprintf(fd,"%s", ((char *)value) );
+}
+/************************************************************************
+ * print the configuration on stdout.
+************************************************************************/
+void conf_print() {
+   int i = 0;
+   FILE * fd;
+
+   fd = stdout;
+   while( config_params[i].param_name != NULL ) {
+	fprintf(fd,"# param %s \n" , config_params[i].param_name );
+	fprintf(fd, config_params[i].comment);
+	fprintf(fd, "#\n");
+	fprintf(fd, "# Default : " );
+	config_params[i].print(fd,config_params[i].def_value );
+	fprintf(fd, "\n#\n");
+	fprintf(fd, "%s = " , config_params[i].param_name );
+	config_params[i].print(fd,config_params[i].conf_value );
+	fprintf(fd, "\n\n");
+
+	i++;
+   }
+}
+/************************************************************************
+    Load default settings first
+*/
+void conf_defaults (void)
+{
+  int i = 0;
+  while( config_params[i].param_name != NULL ) {
+	config_params[i].init( config_params[i].def_value,
+			       config_params[i].conf_value );
+	i++;
+  }
+
+  config.daemon_mode = 1;
+  //config.dhcp_lease_file[0] = 0; //BRCM
+  config.debug_file[0] = 0;
+  return;
+
+}
+
diff -Naur dproxy-nexgen/conf.h dproxy-nexgen-brcm/conf.h
--- dproxy-nexgen/conf.h	2000-03-17 04:25:44.000000000 -0400
+++ dproxy-nexgen-brcm/conf.h	2018-11-23 22:41:44.385484054 -0400
@@ -1,63 +1,67 @@
-/*
-  **
-  ** conf.h - function prototypes for the config handling routines
-  **
-  ** Part of the drpoxy package by Matthew Pratt.
-  **
-  ** Copyright 2000 Jeroen Vreeken (pe1rxq@chello.nl)
-  **
-  ** This software is licensed under the terms of the GNU General
-  ** Public License (GPL). Please see the file COPYING for details.
-  **
-  **
-*/
-#include <stdlib.h>
-#include <stdio.h>
-#include "dproxy.h"
-
-#define CONF_PATH_LEN 256
-/* 
-    more parameters may be added later.
- */
-struct config {
-  char name_server[CONF_PATH_LEN];
-  int daemon_mode;
-  int ppp_detect;
-  int purge_time;
-  char config_file[CONF_PATH_LEN];
-  char deny_file[CONF_PATH_LEN];
-  char cache_file[CONF_PATH_LEN];
-  char hosts_file[CONF_PATH_LEN];
-  char ppp_device_file[CONF_PATH_LEN];
-  char dhcp_lease_file[CONF_PATH_LEN];
-  char debug_file[CONF_PATH_LEN];
-};
-
-/** 
- * typedef for a param copy function. 
- */
-typedef void (* conf_copy_func)(char *, void *);
-typedef void (* conf_print_func)(FILE * fp, void *);
-
-/**
- * description for parameters in the config file
- */
-typedef struct {
-  char * param_name;         /* name for this parameter             */
-  char * comment;            /* a comment for this parameter        */
-  void * conf_value;         /* pointer to a field in struct config */
-  void * def_value;
-  conf_copy_func  init;      /* a function to set the value in 'config'*/
-  conf_copy_func  copy;      /* a function to set the value in 'config'*/
-  conf_print_func print;     /* a function to print the value from 'config'*/
-} config_param; 
-
-
-extern struct config config;                      
-int conf_load (char *conf_file);
-void conf_defaults (void);
-void conf_cmdparse(char *cmd, char *arg1);
-int conf_bool (char *val);
-
-void conf_print();
-
+/*
+  **
+  ** conf.h - function prototypes for the config handling routines
+  **
+  ** Part of the drpoxy package by Matthew Pratt.
+  **
+  ** Copyright 2000 Jeroen Vreeken (pe1rxq@chello.nl)
+  **
+  ** This software is licensed under the terms of the GNU General
+  ** Public License (GPL). Please see the file COPYING for details.
+  **
+  **
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "dproxy.h"
+
+#define CONF_PATH_LEN 256
+/* 
+ *  more parameters may be added later.
+ */
+
+extern char *name_server;
+
+struct config {
+  char name_server[CONF_PATH_LEN];
+  int daemon_mode;
+  int ppp_detect;
+  int purge_time;
+  char config_file[CONF_PATH_LEN];
+  char deny_file[CONF_PATH_LEN];
+  char cache_file[CONF_PATH_LEN];
+  char hosts_file[CONF_PATH_LEN];
+  char ppp_device_file[CONF_PATH_LEN];
+  char dhcp_lease_file[CONF_PATH_LEN];
+  char debug_file[CONF_PATH_LEN];
+  char domain_name[256];
+};
+
+/** 
+ * typedef for a param copy function. 
+ */
+typedef void (* conf_copy_func)(char *, void *);
+typedef void (* conf_print_func)(FILE * fp, void *);
+
+/**
+ * description for parameters in the config file
+ */
+typedef struct {
+  char * param_name;         /* name for this parameter             */
+  char * comment;            /* a comment for this parameter        */
+  void * conf_value;         /* pointer to a field in struct config */
+  void * def_value;
+  conf_copy_func  init;      /* a function to set the value in 'config'*/
+  conf_copy_func  copy;      /* a function to set the value in 'config'*/
+  conf_print_func print;     /* a function to print the value from 'config'*/
+} config_param; 
+
+
+extern struct config config;                      
+int conf_load (char *conf_file);
+void conf_defaults (void);
+void conf_cmdparse(char *cmd, char *arg1);
+int conf_bool (char *val);
+
+void conf_print();
+
diff -Naur dproxy-nexgen/dns_construct.c dproxy-nexgen-brcm/dns_construct.c
--- dproxy-nexgen/dns_construct.c	2000-03-19 01:02:26.000000000 -0400
+++ dproxy-nexgen-brcm/dns_construct.c	2018-11-23 22:41:44.385484054 -0400
@@ -1,95 +1,184 @@
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include "dns_construct.h"
-
-#define SET_UINT16_TO_N(buf, val, count) *(uint16*)buf = htons(val);count += 2; buf += 2
-#define SET_UINT32_TO_N(buf, val, count) *(uint32*)buf = htonl(val);count += 4; buf += 4
-/*****************************************************************************/
-/* this function encode the plain string in name to the domain name encoding 
- * see decode_domain_name for more details on what this function does. */
-int dns_construct_name(char *name, char *encoded_name)
-{
-  int i,j,k,n;
-
-  k = 0; /* k is the index to temp */
-  i = 0; /* i is the index to name */
-  while( name[i] ){
-
-	 /* find the dist to the next '.' or the end of the string and add it*/
-	 for( j = 0; name[i+j] && name[i+j] != '.'; j++);
-	 encoded_name[k++] = j;
-
-	 /* now copy the text till the next dot */
-	 for( n = 0; n < j; n++)
-		encoded_name[k++] = name[i+n];
-	
-	 /* now move to the next dot */ 
-	 i += j + 1;
-
-	 /* check to see if last dot was not the end of the string */
-	 if(!name[i-1])break;
-  }
-  encoded_name[k++] = 0;
-  return k;
-}
-/*****************************************************************************/
-int dns_construct_header(dns_request_t *m)
-{
-  char *ptr = m->original_buf;
-  int dummy;
-
-  SET_UINT16_TO_N( ptr, m->message.header.id, dummy );
-  SET_UINT16_TO_N( ptr, m->message.header.flags.flags, dummy );
-  SET_UINT16_TO_N( ptr, m->message.header.qdcount, dummy );
-  SET_UINT16_TO_N( ptr, m->message.header.ancount, dummy );
-  SET_UINT16_TO_N( ptr, m->message.header.nscount, dummy );
-  SET_UINT16_TO_N( ptr, m->message.header.arcount, dummy );
-  
-  return 0;
-}
-/*****************************************************************************/
-void dns_construct_reply( dns_request_t *m )
-{
-  int len;
-
-  /* point to end of orginal packet */ 
-  m->here = &m->original_buf[m->numread];
-
-  m->message.header.ancount = 1;
-  m->message.header.flags.f.question = 1;
-  dns_construct_header( m );
-
-  if( m->message.question[0].type == A ){
-    /* standard lookup so return and IP */
-    struct in_addr in;
-
-    inet_aton( m->ip, &in );
-    SET_UINT16_TO_N( m->here, 0xc00c, m->numread ); /* pointer to name */
-    SET_UINT16_TO_N( m->here, A, m->numread );      /* type */
-    SET_UINT16_TO_N( m->here, IN, m->numread );     /* class */
-    SET_UINT32_TO_N( m->here, 10000, m->numread );  /* ttl */
-    SET_UINT16_TO_N( m->here, 4, m->numread );      /* datalen */
-    memcpy( m->here, &in.s_addr, sizeof(in.s_addr) ); /* data */
-    m->numread += sizeof( in.s_addr);
-  }else if ( m->message.question[0].type == PTR ){
-    /* reverse look up so we are returning a name */
-    SET_UINT16_TO_N( m->here, 0xc00c, m->numread ); /* pointer to name */
-    SET_UINT16_TO_N( m->here, PTR, m->numread );    /* type */
-    SET_UINT16_TO_N( m->here, IN, m->numread );     /* class */
-    SET_UINT32_TO_N( m->here, 10000, m->numread );  /* ttl */
-    len = dns_construct_name( m->cname, m->here + 2 );
-    SET_UINT16_TO_N( m->here, len, m->numread );      /* datalen */
-    m->numread += len;
-  }
-}
-/*****************************************************************************/
-void dns_construct_error_reply(dns_request_t *m)
-{
-  /* point to end of orginal packet */ 
-  m->here = m->original_buf;
-
-  m->message.header.flags.f.question = 1;
-  m->message.header.flags.f.rcode = 2;
-  dns_construct_header( m );
-}
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include "dns_construct.h"
+
+#define SET_UINT16_TO_N(buf, val, count) *(uint16*)buf = htons(val);count += 2; buf += 2
+#define SET_UINT32_TO_N(buf, val, count) *(uint32*)buf = htonl(val);count += 4; buf += 4
+/*****************************************************************************/
+/* this function encode the plain string in name to the domain name encoding 
+ * see decode_domain_name for more details on what this function does. */
+int dns_construct_name(char *name, char *encoded_name)
+{
+  int i,j,k,n;
+
+  k = 0; /* k is the index to temp */
+  i = 0; /* i is the index to name */
+  while( name[i] ){
+
+	 /* find the dist to the next '.' or the end of the string and add it*/
+	 for( j = 0; name[i+j] && name[i+j] != '.'; j++);
+	 encoded_name[k++] = j;
+
+	 /* now copy the text till the next dot */
+	 for( n = 0; n < j; n++)
+		encoded_name[k++] = name[i+n];
+	
+	 /* now move to the next dot */ 
+	 i += j + 1;
+
+	 /* check to see if last dot was not the end of the string */
+	 if(!name[i-1])break;
+  }
+  encoded_name[k++] = 0;
+  return k;
+}
+/*****************************************************************************/
+int dns_construct_header(dns_request_t *m)
+{
+  char *ptr = m->original_buf;
+  int dummy = 0;
+#ifdef AEI_CONTROL_LAYER
+  if (m->message.question[0].type == AAA)
+	m->message.header.flags.flags = 0x8180;
+  else
+	m->message.header.flags.flags = 0x8000;
+#else
+    m->message.header.flags.flags = 0x8000; //response
+#endif
+  SET_UINT16_TO_N( ptr, m->message.header.id, dummy );
+  SET_UINT16_TO_N( ptr, m->message.header.flags.flags, dummy );
+  SET_UINT16_TO_N( ptr, m->message.header.qdcount, dummy );
+  SET_UINT16_TO_N( ptr, m->message.header.ancount, dummy );
+  SET_UINT16_TO_N( ptr, m->message.header.nscount, dummy );
+  SET_UINT16_TO_N( ptr, m->message.header.arcount, dummy );
+  
+  return 0;
+}
+/*****************************************************************************/
+#ifdef AEI_CONTROL_LAYER
+void dns_construct_reject_reply(dns_request_t *m)
+{
+    int len;
+
+  /* point to end of orginal packet */
+  m->here = &m->original_buf[m->numread];
+
+  m->message.header.ancount = 1;
+  m->message.header.flags.f.question = 1;
+  dns_construct_header( m );
+  if( m->message.question[0].type == A ){
+      SET_UINT16_TO_N( m->here, 0xc00c, m->numread ); /* pointer to name */
+      SET_UINT16_TO_N( m->here, CNAME, m->numread );      /* type */
+      SET_UINT16_TO_N( m->here, IN, m->numread ); /* class */
+	  if(m->ttl > 0) {
+      SET_UINT32_TO_N( m->here, m->ttl, m->numread );  /* ttl */
+    }
+    else {
+      SET_UINT32_TO_N( m->here, 10000, m->numread );  /* ttl */
+    }
+    len = dns_construct_name( m->cname, m->here + 2 );
+	SET_UINT16_TO_N( m->here, len, m->numread );
+	m->numread += len;
+  }
+}
+#endif
+
+/*****************************************************************************/
+
+void dns_construct_reply( dns_request_t *m )
+{
+  int len;
+
+  /* point to end of orginal packet */ 
+  m->here = &m->original_buf[m->numread];
+#ifdef AEI_CONTROL_LAYER
+  if(m->message.question[0].type == AAA)
+	m->message.header.ancount = 2;
+  else
+	m->message.header.ancount = 1;
+#else
+    m->message.header.ancount = 1;
+#endif
+
+  m->message.header.flags.f.question = 1;
+  dns_construct_header( m );
+
+  if( m->message.question[0].type == A ){
+      /* standard lookup so return and IP */
+      struct in_addr in;  
+      inet_pton( AF_INET, m->ip, &in );
+      SET_UINT16_TO_N( m->here, 0xc00c, m->numread ); /* pointer to name */
+      SET_UINT16_TO_N( m->here, A, m->numread );      /* type */
+      SET_UINT16_TO_N( m->here, IN, m->numread );     /* class */
+    if(m->ttl > 0) {
+      SET_UINT32_TO_N( m->here, m->ttl, m->numread );  /* ttl */
+    }
+    else {
+      SET_UINT32_TO_N( m->here, 10000, m->numread );  /* ttl */
+    }
+      SET_UINT16_TO_N( m->here, 4, m->numread );      /* datalen */
+      memcpy( m->here, &in.s_addr, sizeof(in.s_addr) ); /* data */
+      m->numread += sizeof( in.s_addr);
+  }else if ( m->message.question[0].type == PTR ){
+      /* reverse look up so we are returning a name */
+      SET_UINT16_TO_N( m->here, 0xc00c, m->numread ); /* pointer to name */
+      SET_UINT16_TO_N( m->here, PTR, m->numread );    /* type */
+      SET_UINT16_TO_N( m->here, IN, m->numread );     /* class */
+    if(m->ttl > 0) {
+      SET_UINT32_TO_N( m->here, m->ttl, m->numread );  /* ttl */
+    }
+    else {
+      SET_UINT32_TO_N( m->here, 10000, m->numread );  /* ttl */
+    }
+      len = dns_construct_name( m->cname, m->here + 2 );
+      SET_UINT16_TO_N( m->here, len, m->numread );      /* datalen */
+      m->numread += len;
+	}
+ #ifdef AEI_CONTROL_LAYER
+	/*added by libby function:support IPV6 hostname  dns */
+  else if(m->message.question[0].type == AAA ){
+	 struct in6_addr in6;
+	 inet_pton(AF_INET6, m->ip, &in6);
+
+	  SET_UINT16_TO_N( m->here, 0xc00c, m->numread ); /* pointer to name */
+      SET_UINT16_TO_N( m->here, CNAME, m->numread );      /* type */
+      SET_UINT16_TO_N( m->here, IN, m->numread ); /* class */
+	  if(m->ttl > 0) {
+      SET_UINT32_TO_N( m->here, m->ttl, m->numread );  /* ttl */
+    }
+    else {
+      SET_UINT32_TO_N( m->here, 10000, m->numread );  /* ttl */
+    }
+    len = dns_construct_name( m->cname, m->here + 2 );
+	SET_UINT16_TO_N( m->here, len, m->numread );
+	m->numread += len;
+	/*add the second objiect addr informations*/
+	 m->here +=len;
+	 SET_UINT16_TO_N( m->here, 0xc02d, m->numread );
+	 SET_UINT16_TO_N( m->here, AAA, m->numread );
+	 SET_UINT16_TO_N( m->here, IN, m->numread );
+	 if(m->ttl > 0) {
+       SET_UINT32_TO_N( m->here, m->ttl, m->numread );  /* ttl */
+     }
+     else {
+       SET_UINT32_TO_N( m->here, 10000, m->numread );  /* ttl */
+     }
+     SET_UINT16_TO_N( m->here, sizeof(in6.s6_addr), m->numread );
+	 memcpy( m->here, &in6.s6_addr, sizeof(in6.s6_addr) );
+	 m->numread += sizeof( in6.s6_addr);
+  }
+#endif
+
+  }
+/*****************************************************************************/
+
+void dns_construct_error_reply(dns_request_t *m)
+{
+     /* point to end of orginal packet */ 
+     m->here = m->original_buf;
+
+     m->message.header.flags.f.question = 1;
+     m->message.header.flags.f.rcode = 2;
+     dns_construct_header( m );
+}
diff -Naur dproxy-nexgen/dns_construct.h dproxy-nexgen-brcm/dns_construct.h
--- dproxy-nexgen/dns_construct.h	2000-03-17 04:25:44.000000000 -0400
+++ dproxy-nexgen-brcm/dns_construct.h	2018-11-23 22:41:44.385484054 -0400
@@ -2,3 +2,6 @@
 
 void dns_construct_reply( dns_request_t *m );
 void dns_construct_error_reply(dns_request_t *m);
+#ifdef AEI_CONTROL_LAYER
+void dns_construct_reject_reply(dns_request_t * m);
+#endif
diff -Naur dproxy-nexgen/dns_decode.c dproxy-nexgen-brcm/dns_decode.c
--- dproxy-nexgen/dns_decode.c	2000-03-19 00:18:56.000000000 -0400
+++ dproxy-nexgen-brcm/dns_decode.c	2018-11-23 22:41:44.385484054 -0400
@@ -1,188 +1,221 @@
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <string.h>
-
-#include "dns_decode.h"
-
-/*
- * The following macros set num to the host version of the number pointed to 
- * by buf and increment the buff (usually a pointer) and count (usually and 
- * int counter)
- */
-#define SET_UINT16( num, buff) num = htons(*(uint16*)*buff); *buff += 2
-#define SET_UINT32( num, buff) num = htonl(*(uint32*)*buff); *buff += 4
-/*****************************************************************************/
-/* reverse lookups encode the IP in reverse, so we need to turn it around
- * example 2.0.168.192.in-addr.arpa => 192.168.0.2
- * this function only returns the first four numbers in the IP
- *  NOTE: it assumes that name points to a buffer BUF_SIZE long
- */
-void dns_decode_reverse_name(char *name)
-{
-  char temp[NAME_SIZE];
-  int i,j,k;
-  
-  k = 0;
-  
-  for( j = 0, i = 0; j<3; i++) if( name[i] == '.' )j++;
-  for( ; name[i] != '.'; i++) temp[k++] = name[i];
-  temp[k++] = '.';
-
-  name[i] = 0;
-
-  for( j = 0, i = 0; j<2; i++) if( name[i] == '.' )j++;
-  for( ; name[i] != '.'; i++) temp[k++] = name[i];
-  temp[k++] = '.';
-
-  for( j = 0, i = 0; j<1; i++) if( name[i] == '.' )j++;
-  for( ; name[i] != '.'; i++) temp[k++] = name[i];
-  temp[k++] = '.';
-
-  for( i = 0; name[i] != '.'; i++) temp[k++] = name[i];
-  
-  temp[k] = 0;
-
-  strcpy( name, temp );
-}
-/*****************************************************************************/
-/* Queries are encoded such that there is and integer specifying how long 
- * the next block of text will be before the actuall text. For eaxmple:
- *             www.linux.com => \03www\05linux\03com\0
- * This function assumes that buf points to an encoded name.
- * The name is decoded into name. Name should be at least 255 bytes long.
- */
-void dns_decode_name(char *name, char **buf)
-{
-  int i, k, len, j;
-
-  i = k = 0;
-  while( **buf ){
-         len = *(*buf)++;
-         for( j = 0; j<len ; j++)
-	      name[k++] = *(*buf)++;
-         name[k++] = '.';
-  }
-  name[k-1] = *(*buf)++;
-}
-/*****************************************************************************/
-/* Decodes the raw packet in buf to create a rr. Assumes buf points to the 
- * start of a rr. 
- * Note: Question rrs dont have rdatalen or rdata. Set is_question when
- * decoding question rrs, else clear is_question
- */
-void dns_decode_rr(struct dns_rr *rr, char **buf, int is_question,char *header)
-{
-  /* if the first two bits the of the name are set, then the message has been
-     compressed and so the next byte is an offset from the start of the message
-     pointing to the start of the name */
-  if( **buf & 0xC0 ){
-    (*buf)++;
-    header += *(*buf)++;
-    dns_decode_name( rr->name, &header );
-  }else{
-    /* ordinary decode name */
-    dns_decode_name( rr->name, buf );
-  }  
-
-  SET_UINT16( rr->type, buf );
-  SET_UINT16( rr->class, buf);
-
-  if( is_question != 1 ){
-    SET_UINT32( rr->ttl, buf );
-    SET_UINT16( rr->rdatalen, buf );
-
-    memcpy( rr->data, *buf, rr->rdatalen );
-    *buf += rr->rdatalen;
-    /*
-    for(i = 0; i < rr->rdatalen; i+=4 )
-      SET_UINT32( (uint32)rr->data[i], buf );
-    */
-  }
-
-  if( rr->type == PTR ){ /* reverse lookup */
-    dns_decode_reverse_name( rr->name );
-  }
-
-}
-/*****************************************************************************/
-/* A raw packet pointed to by buf is decoded in the assumed to be alloced 
- * dns_message structure.
- * RETURNS: 0
- */
-int dns_decode_message(struct dns_message *m, char **buf)
-{
-  int i;
-  char *header_start = *buf;
-
-  SET_UINT16( m->header.id, buf );
-  SET_UINT16( m->header.flags.flags, buf );
-  SET_UINT16( m->header.qdcount, buf );
-  SET_UINT16( m->header.ancount, buf );
-  SET_UINT16( m->header.nscount, buf );
-  SET_UINT16( m->header.arcount, buf );
-
-  if( m->header.ancount > 1 ){
-    printf("Lotsa answers\n");
-  }
-
-  /* decode all the question rrs */
-  for( i = 0; i < m->header.qdcount && i < NUM_RRS; i++){
-    dns_decode_rr( &m->question[i], buf, 1, header_start );
-  }  
-  /* decode all the answer rrs */
-  for( i = 0; i < m->header.ancount && i < NUM_RRS; i++){
-    dns_decode_rr( &m->answer[i], buf, 0, header_start );
-  }  
-
-  return 0;
-}
-/*****************************************************************************/
-void dns_decode_request(dns_request_t *m)
-{
-  struct in_addr *addr;
-  char *ptr;
-  int i;
-
-  m->here = m->original_buf;
-
-  dns_decode_message( &m->message, &m->here );
-
-  
-  if( m->message.question[0].type == PTR ){
-    strncpy( m->ip, m->message.question[0].name, 20 );
-  }else if ( m->message.question[0].type == A || 
-	     m->message.question[0].type == AAA){ 
-    strncpy( m->cname, m->message.question[0].name, NAME_SIZE );
-  }
-
-  /* set according to the answer */
-  for( i = 0; i < m->message.header.ancount && i < NUM_RRS; i++){
-
-    /* make sure we ge the same type as the query incase there are multiple
-       and unrelated answers */
-    if( m->message.question[0].type == m->message.answer[i].type ){
-
-      if( m->message.answer[i].type == A
-	  || m->message.answer[i].type == AAA ){
-	/* Standard lookup so convert data to an IP */
-	addr = (struct in_addr *)m->message.answer[i].data;
-	strncpy( m->ip, inet_ntoa( addr[0] ), 20 );
-	break;
-	
-      }else if( m->message.answer[i].type == PTR ){
-	/* Reverse lookup so convert data to a nume */
-	ptr = m->message.answer[i].data;
-	dns_decode_name( m->cname, &ptr );
-	strncpy( m->ip, m->message.answer[i].name, 20 );
-	break;
-      }
-
-    } /* if( question == answer ) */
-  } /* for */
-}
-
-
-
-
-
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+
+#include "dns_decode.h"
+
+/*
+ * The following macros set num to the host version of the number pointed to 
+ * by buf and increment the buff (usually a pointer) and count (usually and 
+ * int counter)
+ */
+#define SET_UINT16( num, buff) num = htons(*(uint16*)*buff); *buff += 2
+#define SET_UINT32( num, buff) num = htonl(*(uint32*)*buff); *buff += 4
+/*****************************************************************************/
+/* reverse lookups encode the IP in reverse, so we need to turn it around
+ * example 2.0.168.192.in-addr.arpa => 192.168.0.2
+ * this function only returns the first four numbers in the IP
+ *  NOTE: it assumes that name points to a buffer NAME_SIZE long
+ */
+void dns_decode_reverse_name(char *name)
+{
+    char temp[NAME_SIZE];
+    int i,j,k;
+
+    k = 0;
+
+    /*
+     * Verify there are at least 3 dots in the first NAME_SIZE-2 bytes
+     * of the name string.  The "-2" comes from the fact that after the
+     * third dot, there should be at least 2 more bytes:
+     * one char, and one terminating null or dot.
+     */
+    for( j = 0, i = 0; j<3 && name[i] != 0 && i<NAME_SIZE-2; i++) if( name[i] == '.' )j++;
+    if (j < 3) return;
+
+    for( ; name[i] != '.' && name[i] != 0 && k<NAME_SIZE-1; i++) temp[k++] = name[i];
+    if (k < NAME_SIZE-1) temp[k++] = '.';
+
+    if (name[i] == '.') name[i] = 0;
+
+    for( j = 0, i = 0; j<2; i++) if( name[i] == '.' )j++;
+    for( ; name[i] != '.' && k<NAME_SIZE-1; i++) temp[k++] = name[i];
+    if (k < NAME_SIZE-1) temp[k++] = '.';
+
+    for( j = 0, i = 0; j<1; i++) if( name[i] == '.' )j++;
+    for( ; name[i] != '.' && k<NAME_SIZE-1; i++) temp[k++] = name[i];
+    if (k < NAME_SIZE-1) temp[k++] = '.';
+
+    for( i = 0; name[i] != '.' && k<NAME_SIZE-1; i++) temp[k++] = name[i];
+
+    /* when we reach here, k is at most NAME_SIZE-1 */
+    temp[k] = 0;
+
+    strcpy( name, temp );
+}
+/*****************************************************************************/
+/* Queries are encoded such that there is and integer specifying how long 
+ * the next block of text will be before the actuall text. For eaxmple:
+ *             www.linux.com => \03www\05linux\03com\0
+ * This function assumes that buf points to an encoded name.
+ * The name is decoded into name. Name should be at least NAME_SIZE bytes long.
+ */
+void dns_decode_name(char *name, char **buf)
+{
+  int k, len, j;
+  unsigned char ulen;
+
+  k = 0;
+  while( **buf ){
+         ulen = *(*buf)++;
+         len = ulen;
+
+         for( j = 0; j<len && k<NAME_SIZE; j++)
+             name[k++] = *(*buf)++;
+
+         if (k<NAME_SIZE) name[k++] = '.';
+  }
+
+  (*buf)++;
+
+  /* end of name string terminated with a 0, not with a dot */
+  /* when we reach here, k is at most NAME_SIZE */
+  if( k > 0 ){
+    name[k-1] = 0x00;
+  }else{
+    name[0] = 0x00;
+  }
+}
+/*****************************************************************************/
+/* Decodes the raw packet in buf to create a rr. Assumes buf points to the 
+ * start of a rr. 
+ * Note: Question rrs dont have rdatalen or rdata. Set is_question when
+ * decoding question rrs, else clear is_question
+ */
+void dns_decode_rr(struct dns_rr *rr, char **buf, int is_question,char *header, char *buf_start, struct dns_message *m)
+{
+  /* if the first two bits the of the name are set, then the message has been
+     compressed and so the next byte is an offset from the start of the message
+     pointing to the start of the name */
+  if( **buf & 0xC0 ){
+    (*buf)++;
+    header += *(*buf)++;
+    dns_decode_name( rr->name, &header );
+  }else{
+    /* ordinary decode name */
+    dns_decode_name( rr->name, buf );
+  }  
+
+  SET_UINT16( rr->type, buf );
+  SET_UINT16( rr->class, buf);
+
+  if( is_question != 1 ){
+    SET_UINT32( rr->ttl, buf );
+    SET_UINT16( rr->rdatalen, buf );
+    
+    /* BRCM message format wrong. drop it */
+    if(((*buf - buf_start) >= MAX_PACKET_SIZE) ||
+       (((*buf - buf_start) + rr->rdatalen) >= MAX_PACKET_SIZE) ||
+       (rr->rdatalen >= MAX_PACKET_SIZE/2))
+    {
+      m->header.ancount = 0;
+      return;
+    }
+    memcpy( rr->data, *buf, rr->rdatalen );
+    *buf += rr->rdatalen;
+    /*
+    for(i = 0; i < rr->rdatalen; i+=4 )
+      SET_UINT32( (uint32)rr->data[i], buf );
+    */
+  }
+
+  if( rr->type == PTR ){ /* reverse lookup */
+    dns_decode_reverse_name( rr->name );
+  }
+}
+/*****************************************************************************/
+/* A raw packet pointed to by buf is decoded in the assumed to be alloced 
+ * dns_message structure.
+ * RETURNS: 0
+ */
+int dns_decode_message(struct dns_message *m, char **buf)
+{
+  int i;
+  char *header_start = *buf;
+  char *buf_start = *buf;
+
+  //BRCM: just decode id and header
+  SET_UINT16( m->header.id, buf );  
+  SET_UINT16( m->header.flags.flags, buf );
+  
+  SET_UINT16( m->header.qdcount, buf );
+  SET_UINT16( m->header.ancount, buf );
+  SET_UINT16( m->header.nscount, buf );
+  SET_UINT16( m->header.arcount, buf );
+
+  #if 0 //BRCM
+  if( m->header.ancount > 1 ){
+    printf("Lotsa answers\n");
+  }
+  #endif
+
+  /* decode all the question rrs */
+  for( i = 0; i < m->header.qdcount && i < NUM_RRS; i++){
+    dns_decode_rr( &m->question[i], buf, 1, header_start, buf_start, m);
+  }  
+  /* decode all the answer rrs */
+  for( i = 0; i < m->header.ancount && i < NUM_RRS; i++){
+    dns_decode_rr( &m->answer[i], buf, 0, header_start, buf_start, m);
+  }
+
+  return 0;
+}
+/*****************************************************************************/
+void dns_decode_request(dns_request_t *m)
+{
+  char *addr, *ptr;
+  int i;
+
+  m->here = m->original_buf;
+  dns_decode_message( &m->message, &m->here);
+ 
+  if( m->message.question[0].type == PTR ){
+    strncpy( m->ip, m->message.question[0].name, sizeof(m->ip)-1);
+  } else if ( m->message.question[0].type == A ||
+              m->message.question[0].type == AAA ||
+              m->message.question[0].type == SRVRR ) {
+    strncpy( m->cname, m->message.question[0].name, sizeof(m->cname)-1 );
+  }
+
+  /* set according to the answer */
+  for( i = 0; i < m->message.header.ancount && i < NUM_RRS; i++){
+
+     m->ttl = m->message.answer[i].ttl;
+     /* make sure we ge the same type as the query incase there are multiple
+        and unrelated answers */
+     if( m->message.question[0].type == m->message.answer[i].type ){
+         if( (m->message.answer[i].type == A) ||
+             (m->message.answer[i].type == AAA) ){
+             /* Standard lookup so convert data to an IP */
+             addr = m->message.answer[i].data;
+             inet_ntop((m->message.answer[i].type == A)?AF_INET:AF_INET6, 
+                       (void *)addr, m->ip, INET6_ADDRSTRLEN);
+             break;
+         }
+         else if( m->message.answer[i].type == PTR )
+         {
+             /* Reverse lookup so convert data to a nume */
+             ptr = m->message.answer[i].data;
+             dns_decode_name( m->cname, &ptr );
+#if defined(AEI_COVERITY_FIX)
+             /*CID 12230:Copy into fixed size buffer*/
+             strlcpy( m->ip, m->message.answer[i].name, sizeof(m->ip));
+#else
+             strcpy( m->ip, m->message.answer[i].name);
+#endif
+             break;
+         }
+     } /* if( question == answer ) */
+  } /* for */
+}
diff -Naur dproxy-nexgen/dns_decode.h dproxy-nexgen-brcm/dns_decode.h
--- dproxy-nexgen/dns_decode.h	2000-03-17 04:25:44.000000000 -0400
+++ dproxy-nexgen-brcm/dns_decode.h	2018-11-23 22:41:44.385484054 -0400
@@ -1,36 +1,36 @@
-#include "dproxy.h"
-
-/*
- * Queries are encoded such that there is and integer specifying how long 
- * the next block of text will be before the actuall text. For eaxmple:
- *             www.linux.com => \03www\05linux\03com\0
- * This function assumes that buf points to an encoded name.
- * The name is decoded into name. Name should be at least 255 bytes long.
- * RETURNS: The length of the string including the '\0' terminator.
- */
-void dns_decode_name(char *name, char **buf);
-/*
- * Decodes the raw packet in buf to create a rr. Assumes buf points to the 
- * start of a rr. 
- * Note: Question rrs dont have rdatalen or rdata. Set is_question when
- * decoding question rrs, else clear is_question
- * RETURNS: the amount that buf should be incremented
- */
-void dns_decode_rr(struct dns_rr *rr, char **buf,int is_question,char *header);
-
-/*
- * A raw packet pointed to by buf is decoded in the assumed to be alloced 
- * dns_message structure.
- * RETURNS: 0
- */
-int dns_decode_message(struct dns_message *m, char **buf);
-
-/* 
- * 
- */
-void dns_decode_request(dns_request_t *m);
-
-
-
-
-
+#include "dproxy.h"
+
+/*
+ * Queries are encoded such that there is and integer specifying how long 
+ * the next block of text will be before the actuall text. For eaxmple:
+ *             www.linux.com => \03www\05linux\03com\0
+ * This function assumes that buf points to an encoded name.
+ * The name is decoded into name. Name should be at least 255 bytes long.
+ * RETURNS: The length of the string including the '\0' terminator.
+ */
+void dns_decode_name(char *name, char **buf);
+/*
+ * Decodes the raw packet in buf to create a rr. Assumes buf points to the 
+ * start of a rr. 
+ * Note: Question rrs dont have rdatalen or rdata. Set is_question when
+ * decoding question rrs, else clear is_question
+ * RETURNS: the amount that buf should be incremented
+ */
+void dns_decode_rr(struct dns_rr *rr, char **buf,int is_question,char *header, char *buf_start, struct dns_message *m);
+
+/*
+ * A raw packet pointed to by buf is decoded in the assumed to be alloced 
+ * dns_message structure.
+ * RETURNS: 0
+ */
+int dns_decode_message(struct dns_message *m, char **buf);
+
+/* 
+ * 
+ */
+void dns_decode_request(dns_request_t *m);
+
+
+
+
+
diff -Naur dproxy-nexgen/dns_dyn_cache.c dproxy-nexgen-brcm/dns_dyn_cache.c
--- dproxy-nexgen/dns_dyn_cache.c	1969-12-31 20:00:00.000000000 -0400
+++ dproxy-nexgen-brcm/dns_dyn_cache.c	2018-11-23 22:41:44.385484054 -0400
@@ -0,0 +1,342 @@
+#include <time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include "dproxy.h"
+#include "conf.h"
+#include "dns_decode.h"
+#include "dns_construct.h"
+#include "dns_io.h"
+#include "dns_dyn_cache.h"
+
+#ifdef DNS_DYN_CACHE
+dns_dyn_list_t *dns_dyn_hosts;
+//dns_dyn_list_t *dns_dyn_leases;
+dns_dyn_list_t *dns_dyn_cache;
+int dns_dyn_cache_count;
+
+/*****************************************************************************/
+dns_dyn_list_t *dns_dyn_list_find(dns_dyn_list_t *list, char *cname,
+				  struct in_addr *addr)
+{
+  dns_dyn_list_t *ent;
+
+  for(ent = list; ent; ent = ent->next) {
+    if (cname && strcasecmp(ent->cname, cname))
+      continue;
+    if (addr && addr->s_addr != ent->addr.s_addr)
+      continue;
+    return ent;
+  }
+
+  return NULL;
+}
+
+/*****************************************************************************/
+dns_dyn_list_t *dns_dyn_find(dns_request_t *m)
+{
+  char *cname = NULL;
+  struct in_addr addr, *paddr = NULL;
+  dns_dyn_list_t *ret = NULL;
+
+  if(m->message.question[0].type == A) {
+    cname = m->cname;
+  } else if(m->message.question[0].type == PTR) {
+    inet_aton(m->ip, &addr);
+    paddr = &addr;
+  }
+
+  /* Search order: hosts, cache */
+
+  while((ret = dns_dyn_list_find(dns_dyn_hosts, cname, paddr))) {
+      goto found;
+  }
+
+  while((ret = dns_dyn_list_find(dns_dyn_cache, cname, paddr))) {
+    if (ret->expiry > time(NULL))
+      goto found;
+    dns_dyn_list_remove(&dns_dyn_cache, ret);
+  }
+
+found:
+  return ret;
+}
+
+/*****************************************************************************/
+int dns_dyn_list_add(dns_dyn_list_t **list, char *cname, char *ip, int expiry)
+{
+  dns_dyn_list_t *new;
+  struct in_addr addr;
+
+  debug("dyn_list_add: entered for cname=%s\n", cname);
+
+  /* Convert IP address */
+  if(!inet_aton(ip, &addr)) {
+    debug("invalid IP address %s", ip);
+    return 0;
+  }
+  
+  /* Already exist? */
+  if (dns_dyn_list_find(*list, cname, &addr)) {
+    debug("%s already in list\n", cname);
+    return 0;
+  }
+
+  if ((new = malloc(sizeof(dns_dyn_list_t) + strlen(cname) + 1)) == NULL) {
+    debug("malloc() failed");
+    return 0;
+  }
+
+  new->prev = NULL;
+  new->next = *list;
+  new->expiry = expiry;
+  new->addr = addr;
+  strcpy(new->cname, cname);
+  if (*list)
+    (*list)->prev = new;
+  *list = new;
+
+  debug("dyn_list_add: new entry at %p, prev=%p next=%p\n", new, new->prev, new->next);
+
+  return 1;
+}
+
+/*****************************************************************************/
+int dns_dyn_cache_add(dns_request_t *m)
+{
+  int ret;
+
+  debug("dyn_cache_add: entered with cache_count=%d dns_dyn_cache=%p",
+        dns_dyn_cache_count, dns_dyn_cache);
+
+  /* remove some entries if max limit on entries reached */
+  if(dns_dyn_cache_count >= DNS_DYN_CACHE_MAX_ENTRIES) {
+    if ((ret = dns_dyn_cache_timeout()) == 0) {
+      /* Force to remove one */
+      ret = dns_dyn_list_remove(&dns_dyn_cache, dns_dyn_cache);
+    }
+    dns_dyn_cache_count -= ret;
+  }
+
+  ret = dns_dyn_list_add(&dns_dyn_cache, m->cname, m->ip, m->ttl + time(NULL));
+  dns_dyn_cache_count += ret;
+
+  debug("dyn_cache_add: returning %d (cache_count=%d dns_dyn_cache=%p)\n",
+        ret, dns_dyn_cache_count, dns_dyn_cache);
+  return ret;
+}
+
+/*****************************************************************************/
+int dns_dyn_hosts_add(void)
+{
+  FILE *fp;
+  char line[BUF_SIZE];
+  char *ip, *name;
+  int count = 0;
+
+  debug("dns_dyn_hosts_add()");
+
+  /* Eliminate all hosts entries */
+  dns_dyn_list_purge(&dns_dyn_hosts);
+
+  if (!(fp = fopen(config.hosts_file, "r"))) {
+    debug("can not open file %s", config.hosts_file);
+    return 0;
+  }
+
+  while(fgets(line, BUF_SIZE, fp)){
+    line[strlen(line) - 1] = 0; /* get rid of '\n' */
+    ip = strtok( line, " \t");
+    if(ip == NULL) /* ignore blank lines */
+      continue;
+    if(ip[0] == '#') /* ignore comments */
+      continue;
+    while((name = strtok( NULL, " \t" ))){
+      if(name[0] == '#')
+	break;
+      count += dns_dyn_list_add(&dns_dyn_hosts, name, ip, -1);
+    }
+  }
+  fclose(fp);
+
+  debug("added %d entries from hosts file", count);
+  return count;
+}
+
+#if 0
+struct lease_t {
+   unsigned char chaddr[16];
+   u_int32_t yiaddr;
+   u_int32_t expires;
+   char hostname[64];
+};
+
+#define ETHER_ISNULLADDR(ea) ((((char *)(ea))[0] |     \
+                ((char *)(ea))[1] |        \
+                ((char *)(ea))[2] |        \
+                ((char *)(ea))[3] |        \
+                ((char *)(ea))[4] |        \
+                ((char *)(ea))[5]) == 0)
+
+/*****************************************************************************/
+int dns_dyn_dhcp_leases_add(void)
+{
+  FILE *fp;
+  struct lease_t lease;
+  struct in_addr addr;
+  char cname[BUF_SIZE];
+  char ip[16];
+  int count = 0;
+
+  debug("cache_add_dhcp_entreies()\n");
+
+  /* Eliminate all dhcp leases entries */
+  dns_dyn_list_purge(&dns_dyn_dhcp_leases);
+
+  /* If dhcpd is not running, we won't read it's leases file */
+  ret = system("killall -0 dhcpd 2>/dev/null");
+  if (ret != -1) 
+    ret = WEXITSTATUS(ret);
+  if (ret != 0) { /* dhcpd is not running */
+      debug("dhcpd is not running");
+      return;
+  }
+  
+  /* Signal dhcpd to flush leases to file */
+  system("killall -SIGUSR1 dhcpd");
+
+  if (!(fp = fopen(config.dhcp_lease_file , "r"))) {
+    debug_perror("can not open dhcp leases file");
+    return;
+  }
+
+  while(fread(&lease, sizeof(lease), 1, fp)){
+    /* Do not display reserved leases */
+    if(ETHER_ISNULLADDR(lease.chaddr))
+      continue;
+    addr.s_addr = lease.yiaddr;
+    strcpy(ip, inet_ntoa(addr));
+    strcpy(cname, lease.hostname);
+    /* Add entry of hostname */
+    count += dns_dyn_list_add(&dns_dyn_dhcp_leases, cname, ip, -1);
+    if (config.domain_name[0]) {
+      strcat(cname, ".");
+      strcat(cname, config.domain_name);
+      /* Add another entry of hostname.domain */
+      count += dns_dyn_list_add(&dns_dyn_dhcp_leases, cname, ip, -1);
+    }
+  }
+  fclose(fp);
+
+  debug("added %d dhcp leases entries", count);
+  return count;
+}
+#endif
+
+/*****************************************************************************/
+int dns_dyn_list_remove(dns_dyn_list_t **list, dns_dyn_list_t *ent)
+{
+  if (list == NULL || *list == NULL || ent == NULL) {
+     debug_perror("list or ent is NULL\n");
+     return 0;
+  }
+
+  debug("dyn_list_remove: removing ent=%p from list=%p\n", ent, *list);
+
+  if (*list == ent)
+    *list = ent->next;
+  else
+    ent->prev->next = ent->next;
+  if (ent->next)
+    ent->next->prev = ent->prev;
+  free(ent);
+
+  return 1;
+}
+
+/*****************************************************************************/
+void dns_dyn_list_purge(dns_dyn_list_t **list)
+{
+  dns_dyn_list_t *ent = *list;
+  dns_dyn_list_t *next;
+
+  while(ent) {
+    next = ent->next;
+    free(ent);
+    ent = next;
+  }
+  *list = NULL;
+}
+
+/*****************************************************************************/
+int dns_dyn_cache_timeout(void)
+{
+  time_t now = time(NULL);
+  dns_dyn_list_t *ent = dns_dyn_cache;
+  dns_dyn_list_t *tmp;
+  int count = 0;
+
+  debug("dyn_cache_timeout: time now=%d head=%p dns_dyn_cache_count=%d", now, dns_dyn_cache, dns_dyn_cache_count);
+
+  while(ent) {
+    debug("dyn_cache_timeout: ent=%p ent->prev=%p ent->next=%p expiry=%d\n",
+          ent, ent->prev, ent->next, ent->expiry);
+
+    if (ent->expiry <= now) {
+      debug("dyn_cache_timeout: ent=%p is expired====\n", ent);
+      if (ent == dns_dyn_cache) /* The head */
+        dns_dyn_cache = ent->next;
+      else
+        ent->prev->next = ent->next;
+      if (ent->next)
+        ent->next->prev = ent->prev;
+      tmp = ent;
+      ent = ent->next;
+      free(tmp);
+      count++;
+      continue;
+    }
+    ent = ent->next;
+  }
+
+  debug("dyn_cache_timeout: returning %d (dns_dyn_cache=%p)\n", count, dns_dyn_cache);
+  return count;
+}
+
+/*****************************************************************************/
+void dns_dyn_list_print(dns_dyn_list_t *list)
+{
+#ifdef CMS_LOG3
+  time_t now = time(NULL);
+#endif
+  dns_dyn_list_t *ent;
+
+  for(ent = list; ent; ent = ent->next) {
+    debug("    ID: %p Name: %s IP: %s TTL %d\n", ent,
+	  ent->cname, inet_ntoa(ent->addr), ent->expiry == -1 ? ent->expiry : (ent->expiry - now));
+  }
+}
+
+/*****************************************************************************/
+void dns_dyn_print(void)
+{
+  debug("    ----------");
+  debug("    /var/hosts");
+  debug("    ----------");
+  dns_dyn_list_print(dns_dyn_hosts);
+
+#if 0
+  debug("    ----------------");
+  debug("    /var/dhcp leases");
+  debug("    ----------------");
+  dns_dyn_list_print(dns_dyn_dhcp_leases);
+#endif
+
+  debug("    -----");
+  debug("    cache");
+  debug("    -----");
+  dns_dyn_list_print(dns_dyn_cache);
+}
+
+#endif
diff -Naur dproxy-nexgen/dns_dyn_cache.h dproxy-nexgen-brcm/dns_dyn_cache.h
--- dproxy-nexgen/dns_dyn_cache.h	1969-12-31 20:00:00.000000000 -0400
+++ dproxy-nexgen-brcm/dns_dyn_cache.h	2018-11-23 22:41:44.385484054 -0400
@@ -0,0 +1,57 @@
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+#define DNS_DYN_CACHE_MAX_ENTRIES 100
+
+typedef struct dns_dyn_list_struct
+{
+  struct dns_dyn_list_struct *prev;
+  struct dns_dyn_list_struct *next;
+  time_t expiry;
+  struct in_addr addr;
+  char cname[0];
+} dns_dyn_list_t;
+
+/* Entries from /var/hosts */
+extern dns_dyn_list_t *dns_dyn_hosts;
+/* Entries from dhcpd leases */
+extern dns_dyn_list_t *dns_dyn_dhcp_leases;
+/* Cahced responses */
+extern dns_dyn_list_t *dns_dyn_cache;
+extern int dns_dyn_cache_count;
+
+/* Look up a list entry by CNAME and/or IP address in specified list */
+dns_dyn_list_t *dns_dyn_list_find(dns_dyn_list_t *list, char *cname,
+				  struct in_addr *addr);
+
+/* Look up a list entry by CNAME and/or IP address in all lists. The search
+ * order is hosts, DHCP leases, and cache */
+dns_dyn_list_t *dns_dyn_find(dns_request_t *m);
+
+/* Add an entry to specified list. -1 of expiry means infinite (for hosts) */
+int dns_dyn_list_add(dns_dyn_list_t **list, char *cname, char *ip, int expiry);
+
+/* Add a response to cache list */
+int dns_dyn_cache_add(dns_request_t *m);
+
+/* Add entries in /var/hosts to hosts list */
+int dns_dyn_hosts_add(void);
+
+/* Add entries in /var/udhcpd/udhcpd.leases to dhcp leases list */ 
+//int dns_dyn_dhcp_leases_add(void);
+
+/* Remove an entry from a specified list */
+int dns_dyn_list_remove(dns_dyn_list_t **list, dns_dyn_list_t *entry);
+
+/* Purge a list */
+void dns_dyn_list_purge(dns_dyn_list_t **list);
+
+/* Remove timeouted entries in the cache list */
+int dns_dyn_cache_timeout(void);
+
+/* Print out a list */
+void dns_dyn_list_print(dns_dyn_list_t *list);
+
+/* Print out all lists */
+void dns_dyn_print(void);
+
diff -Naur dproxy-nexgen/dns.h dproxy-nexgen-brcm/dns.h
--- dproxy-nexgen/dns.h	2000-03-19 00:13:00.000000000 -0400
+++ dproxy-nexgen-brcm/dns.h	2018-11-23 22:41:44.385484054 -0400
@@ -1,100 +1,105 @@
-
-
-#define NUM_RRS 5
-/*****************************************************************************/
-struct dns_rr{
-  char name[NAME_SIZE];
-  uint16 type;
-  uint16 class;
-  uint32 ttl;
-  uint16 rdatalen;
-  char data[NAME_SIZE];
-};
-/*****************************************************************************/
-union header_flags {
-  uint16 flags;
-  
-  struct {
-    unsigned short int rcode:4;
-    unsigned short int unused:3;
-    unsigned short int recursion_avail:1;
-    unsigned short int want_recursion:1;
-    unsigned short int truncated:1;
-    unsigned short int authorative:1;
-    unsigned short int opcode:4;
-    unsigned short int question:1;
-  } f;
-};
-/*****************************************************************************/
-struct dns_header_s{
-  uint16 id;
-  union header_flags flags;
-  uint16 qdcount;
-  uint16 ancount;
-  uint16 nscount;
-  uint16 arcount;
-};
-/*****************************************************************************/
-struct dns_message{
-  struct dns_header_s header;
-  struct dns_rr question[NUM_RRS];
-  struct dns_rr answer[NUM_RRS];
-};
-/*****************************************************************************/
-typedef struct dns_request_s{
-  char cname[NAME_SIZE];
-  char ip[20];
-  int ttl;
-  int time_pending; /* request age in seconds */
-
-  /* the actual dns request that was recieved */
-  struct dns_message message;
-
-  /* where the request came from */
-  struct in_addr src_addr;
-  int src_port;
-
-  /* the orginal packet */
-  char original_buf[MAX_PACKET_SIZE];
-  int numread;
-  char *here;
-
-  /* next node in list */
-  struct dns_request_s *next;
-}dns_request_t;
-/*****************************************************************************/
-/* TYPE values */
-enum{ A = 1,      /* a host address */
-	NS,       /* an authoritative name server */
-	MD,       /* a mail destination (Obsolete - use MX) */
-	MF,       /* */
-	CNAME,    /* the canonical name for an alias */
-	SOA,      /* marks the start of a zone of authority  */
-	MB,       /* a mailbox domain name (EXPERIMENTAL) */
-	MG,       /* */
-	MR,       /* */
-	NUL,      /* */
-	WKS,      /* a well known service description */
-	PTR,      /* a domain name pointer */
-	HINFO,    /* host information */
-	MINFO,    /* mailbox or mail list information */
-	MX,       /* mail exchange */
-	TXT,      /* text strings */
-
-	AAA = 0x1c /* IPv6 A */
-	};
-
-/* CLASS values */
-enum{
-  IN = 1,         /* the Internet */
-    CS,
-    CH,
-    HS
-};
-
-/* OPCODE values */
-enum{
-  QUERY,
-    IQUERY,
-    STATUS
-};
+#include "cms.h"
+
+#define NUM_RRS 5
+/*****************************************************************************/
+struct dns_rr{
+  char name[NAME_SIZE];
+  uint16 type;
+  uint16 class;
+  uint32 ttl;
+  uint16 rdatalen;
+  char data[NAME_SIZE];
+};
+/*****************************************************************************/
+union header_flags {
+  uint16 flags;
+  
+  struct {
+    unsigned short int rcode:4;
+    unsigned short int unused:3;
+    unsigned short int recursion_avail:1;
+    unsigned short int want_recursion:1;
+    unsigned short int truncated:1;
+    unsigned short int authorative:1;
+    unsigned short int opcode:4;
+    unsigned short int question:1;
+  } f;
+};
+/*****************************************************************************/
+struct dns_header_s{
+  uint16 id;
+  union header_flags flags;
+  uint16 qdcount;
+  uint16 ancount;
+  uint16 nscount;
+  uint16 arcount;
+};
+/*****************************************************************************/
+struct dns_message{
+  struct dns_header_s header;
+  struct dns_rr question[NUM_RRS];
+  struct dns_rr answer[NUM_RRS];
+};
+/*****************************************************************************/
+typedef struct dns_request_s{
+  char cname[NAME_SIZE];
+  char ip[INET6_ADDRSTRLEN];
+  int ttl;
+  //BRCM
+  int switch_on_timeout;  /* if this request times out, switch to secondary server */
+  int retx_count;   /* number of times this request has been retransmitted */
+  time_t expiry; /* Time to expire */
+
+  /* the actual dns request that was recieved */
+  struct dns_message message;
+
+  /* where the request came from */
+  struct sockaddr_storage src_info;
+
+  /* the orginal packet */
+  char original_buf[MAX_PACKET_SIZE];
+  int numread;
+  char *here;
+
+  /* previous node in list */
+  struct dns_request_s *prev;
+  /* next node in list */
+  struct dns_request_s *next;
+}dns_request_t;
+/*****************************************************************************/
+/* TYPE values */
+enum{ A = 1,      /* a host address */
+	NS,       /* an authoritative name server */
+	MD,       /* a mail destination (Obsolete - use MX) */
+	MF,       /* */
+	CNAME,    /* the canonical name for an alias */
+	SOA,      /* marks the start of a zone of authority  */
+	MB,       /* a mailbox domain name (EXPERIMENTAL) */
+	MG,       /* */
+	MR,       /* */
+	NUL,      /* */
+	WKS,      /* a well known service description */
+	PTR,      /* a domain name pointer */
+	HINFO,    /* host information */
+	MINFO,    /* mailbox or mail list information */
+	MX,       /* mail exchange */
+	TXT,      /* text strings */
+
+	AAA = 0x1c, /* IPv6 A */
+	SRVRR = 0x21  /* RFC 2782: location of services */
+	};
+
+/* CLASS values */
+enum{
+  IN = 1,         /* the Internet */
+    CS,
+    CH,
+    HS
+};
+
+/* OPCODE values */
+enum{
+  QUERY,
+    IQUERY,
+    STATUS
+};
diff -Naur dproxy-nexgen/dns_io.c dproxy-nexgen-brcm/dns_io.c
--- dproxy-nexgen/dns_io.c	2000-03-19 20:50:12.000000000 -0400
+++ dproxy-nexgen-brcm/dns_io.c	2018-11-23 22:41:44.385484054 -0400
@@ -1,64 +1,82 @@
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include "dns_io.h"
-
-/*****************************************************************************/
-int dns_read_packet(int sock, dns_request_t *m)
-{
-  struct sockaddr_in sa;
-  int salen;
-  
-  /* Read in the actual packet */
-  salen = sizeof(sa);
-  
-  m->numread = recvfrom(sock, m->original_buf, sizeof(m->original_buf), 0,
-		     (struct sockaddr *)&sa, &salen);
-  
-  if ( m->numread < 0) {
-    debug_perror("dns_read_packet: recvfrom\n");
-    return -1;
-  }
-  
-  /* TODO: check source addr against list of allowed hosts */
-
-  /* record where it came from */
-  memcpy( (void *)&m->src_addr, (void *)&sa.sin_addr, sizeof(struct in_addr));
-  m->src_port = ntohs( sa.sin_port );
-
-  /* check that the message is long enough */
-  if( m->numread < sizeof (m->message.header) ){
-    debug("dns_read_packet: packet from '%s' to short to be dns packet", 
-	  inet_ntoa (sa.sin_addr) );
-    return -1;
-  }
-
-  /* pass on for full decode */
-  dns_decode_request( m );
-
-  return 0;
-}
-/*****************************************************************************/
-int dns_write_packet(int sock, struct in_addr in, int port, dns_request_t *m)
-{
-  struct sockaddr_in sa;
-  int retval;
-
-  /* Zero it out */
-  memset((void *)&sa, 0, sizeof(sa));
-
-  /* Fill in the information */
-  //inet_aton( "203.12.160.35", &in );
-  memcpy( &sa.sin_addr.s_addr, &in, sizeof(in) );
-  sa.sin_port = htons(port);
-  sa.sin_family = AF_INET;
-
-  retval = sendto(sock, m->original_buf, m->numread, 0, 
-		(struct sockaddr *)&sa, sizeof(sa));
-  
-  if( retval < 0 ){
-    debug_perror("dns_write_packet: sendto");
-  }
-
-  return retval;
-}
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <linux/sockios.h>
+#include <linux/if.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include "dns_io.h"
+#include "dns_decode.h"
+
+/*****************************************************************************/
+void *get_in_addr( struct sockaddr_storage *sa )
+{
+   if (sa->ss_family == AF_INET)
+      return &(((struct sockaddr_in *)sa)->sin_addr);
+
+   return &(((struct sockaddr_in6 *)sa)->sin6_addr);
+}
+
+int dns_read_packet(int sock, dns_request_t *m)
+{
+  struct sockaddr_storage sa;
+  socklen_t salen;
+  char remoteIP[INET6_ADDRSTRLEN];
+  
+  /* Read in the actual packet */
+  salen = sizeof(sa);
+  
+  m->numread = recvfrom(sock, m->original_buf, sizeof(m->original_buf), 0,
+		     (struct sockaddr *)&sa, &salen);
+  
+  if ( m->numread < 0) {
+    debug_perror("dns_read_packet: recvfrom\n");
+    return -1;
+  }
+  
+  /* TODO: check source addr against list of allowed hosts */
+
+  /* record where it came from */
+  memcpy( (void *)&m->src_info, (void *)&sa, sizeof(sa));
+  inet_ntop(sa.ss_family, get_in_addr(&sa), 
+            remoteIP, INET6_ADDRSTRLEN);
+  debug("received pkt from %s:%d len %d", 
+        remoteIP, ((struct sockaddr_in *)&sa)->sin_port, m->numread);
+
+  /* check that the message is long enough */
+  if( m->numread < sizeof (m->message.header) )
+  {
+    debug("dns_read_packet: packet too short to be dns packet");
+    return -1;
+  }
+
+  /* pass on for full decode */
+  dns_decode_request( m );
+
+  return 0;
+}
+/*****************************************************************************/
+int dns_write_packet(int sock, struct sockaddr_storage *sa, dns_request_t *m)
+{
+  int retval;
+  char dstIp[INET6_ADDRSTRLEN];
+
+  inet_ntop(sa->ss_family, get_in_addr(sa), dstIp, INET6_ADDRSTRLEN);
+
+  if (sa->ss_family == AF_INET)
+  {
+    retval = sendto(sock, m->original_buf, m->numread, 0, 
+                    (struct sockaddr *)sa, sizeof(struct sockaddr_in));
+  }
+  else
+  {
+    retval = sendto(sock, m->original_buf, m->numread, 0, 
+                    (struct sockaddr *)sa, sizeof(struct sockaddr_in6));
+  }
+  
+  if( retval < 0 )
+  {
+    debug_perror("dns_write_packet: sendto");
+  }
+
+  return retval;
+}
diff -Naur dproxy-nexgen/dns_io.h dproxy-nexgen-brcm/dns_io.h
--- dproxy-nexgen/dns_io.h	2000-03-19 20:49:38.000000000 -0400
+++ dproxy-nexgen-brcm/dns_io.h	2018-11-23 22:41:44.385484054 -0400
@@ -1,4 +1,5 @@
-#include "dproxy.h"
-
-int dns_read_packet(int sock, dns_request_t *m);
-int dns_write_packet(int sock, struct in_addr in, int port, dns_request_t *m);
+#include "dproxy.h"
+
+void *get_in_addr(struct sockaddr_storage *sa);
+int dns_read_packet(int sock, dns_request_t *m);
+int dns_write_packet(int sock, struct sockaddr_storage *in, dns_request_t *m);
diff -Naur dproxy-nexgen/dns_list.c dproxy-nexgen-brcm/dns_list.c
--- dproxy-nexgen/dns_list.c	2000-03-18 00:03:08.000000000 -0400
+++ dproxy-nexgen-brcm/dns_list.c	2018-11-23 22:41:44.385484054 -0400
@@ -1,74 +1,163 @@
-#include <stdlib.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "dns_list.h"
-
-/*****************************************************************************/
-dns_request_t *dns_list_add(dns_request_t *list, dns_request_t *m)
-{
-  dns_request_t *new_node;
-
-  new_node = (dns_request_t *)malloc( sizeof(dns_request_t) * 10 );
-  if( !new_node) return list;
-
-  debug( "Addr: %x\n", new_node);
-
-  memcpy( new_node, m, sizeof (*m) );
-
-  new_node->next = list;
-  return new_node;
-}
-/*****************************************************************************/
-dns_request_t *dns_list_find_by_id(dns_request_t *list, dns_request_t *m)
-{
-  dns_list_print( list );
-  
-  while( list != NULL){
-    debug("1. Name: %s  ....  %d  --- 2. %d\n", list->message.question[0].name,
-	  list->message.header.id, m->message.header.id );
-    if( list->message.header.id == m->message.header.id )
-      return list;
-    list = list->next;
-  }
-  return NULL;
-}
-/*****************************************************************************/
-dns_request_t *dns_list_remove(dns_request_t *list, dns_request_t *m )
-{
-  dns_request_t *prev, *retval;
-
-  if( !m )return list;
-
-  prev = list;
-  while (prev){
-    if( prev->next == m)break;
-    prev = prev->next;
-  }
-
-  if( !prev ){ //must be at start of list
-    retval = m->next;
-    free( m );
-  }else{
-    prev->next = m->next;
-    retval = list;
-    free( m );
-  }
-  return retval;
-}
-/*****************************************************************************/
-void dns_list_print(dns_request_t *list)
-{
-  debug("Dumping list:\n");
-
-  while(list){
-    debug("    ID: %d ... Name: %s ---- IP: %s\n", list->message.header.id,
-	  list->cname, list->ip );
-    list = list->next;
-  }
-
-}
-
-
-
-
+#include <time.h>
+#include <stdlib.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "dns_list.h"
+#include "dns_io.h"
+#include "dns_mapping.h"
+
+dns_request_t *dns_request_list;
+/* Last request in dns_request_list */
+dns_request_t *dns_request_last;
+static int dns_list_count=0;
+
+/*****************************************************************************/
+int dns_list_add(dns_request_t *r)
+{
+  dns_request_t *new;
+
+  if (NULL == r) {
+    debug("null request passed in!");
+    return 0;
+  }
+
+  if (!(new = malloc(sizeof(*new)))) {
+    debug("malloc() failed");
+    return 0;
+  }
+
+  memcpy(new, r, sizeof(*r));
+  new->expiry = time(NULL) + DNS_TIMEOUT;
+  new->retx_count = 0;
+  new->prev = NULL;
+  new->next = dns_request_list;
+
+  if (dns_request_list)
+    dns_request_list->prev = new;
+  if (dns_request_last == NULL)
+    dns_request_last = new;
+  dns_request_list = new;
+
+  dns_list_count++;
+  return 1;
+}
+
+/*****************************************************************************/
+dns_request_t *dns_list_find_by_id(dns_request_t *req)
+{ 
+  dns_request_t *r;
+
+  if (NULL == req) {
+     debug("null request passed in!");
+     return NULL;
+  }
+
+  for(r = dns_request_list; r; r = r->next){
+     if(req->message.header.id == r->message.header.id)
+         return r;
+  }
+  return NULL;
+}
+
+
+
+
+/*****************************************************************************/
+int dns_list_remove(dns_request_t *r)
+{
+  if (NULL == r) {
+    debug("null request passed in!");
+    return 0;
+  }
+
+  if (r == dns_request_list)
+    dns_request_list = r->next;
+  else
+    r->prev->next = r->next;
+
+  if (r == dns_request_last)
+    dns_request_last = r->prev;
+  else
+    r->next->prev = r->prev;
+ 
+  free(r);
+
+  dns_list_count--;
+  return 1;
+}
+
+
+/*****************************************************************************/
+int dns_list_remove_related_requests_and_swap(dns_request_t *r)
+{
+  UBOOL8 dnsSwapNeeded = FALSE;
+  char dnsUsed[INET6_ADDRSTRLEN]={0};
+  dns_request_t *headPtr, *next;
+  
+  if (NULL == r) {
+    debug("null request passed in!");
+    return 0;
+  }
+
+  /* For the first time call dns_mapping_is_dns_swap_needed, dnsUsed is null
+  * and if dnsSwapNeeded TRUE, the subsequent calls will use dnsUsde to match
+  * for the requests with the same dns for removing them in the request list.
+  */
+  dnsSwapNeeded = dns_mapping_is_dns_swap_needed(r, dnsUsed);
+  if (dnsSwapNeeded)
+  {
+    dns_list_remove(r);  
+    headPtr = dns_request_list;
+    while (headPtr) {
+       next = headPtr->next;
+       cmsLog_notice("next request, dnsUsed %s", dnsUsed);
+       if (dns_mapping_is_dns_swap_needed(headPtr, dnsUsed)) {
+          dns_list_remove(headPtr);  
+       }        
+       headPtr = next;
+    }
+  }
+
+  if (dnsSwapNeeded) {
+    dns_mapping_do_dns_swap(dnsUsed);
+  }
+  
+  return 1;
+}
+
+/*****************************************************************************/
+void dns_list_print(void)
+{
+  dns_request_t *r;
+
+  printf("\n===========Dumping request list (time=%d):\n", (int) time(NULL));
+  printf("dns_request_list=%p dns_request_last=%p dns_list_count=%d\n",
+         dns_request_list, dns_request_last, dns_list_count);
+
+  for (r = dns_request_list; r; r = r->next) {
+     printf("    (%p) ID: 0x%x type=%u Name=%s IP=%s "
+            "expiry=%d switch_on_timeout=%d retx_count=%d next=%p prev=%p\n",
+            r, r->message.header.id,
+            (unsigned int) r->message.question[0].type,
+            r->cname, r->ip, (int) r->expiry,
+            r->switch_on_timeout, r->retx_count, r->next, r->prev);
+  }
+
+  printf("=============================================\n\n");
+}
+
+/*****************************************************************************/
+int dns_list_next_time(void)
+{
+  int timeout = 0;
+
+  if (dns_request_last) {
+    timeout = dns_request_last->expiry - time(NULL);
+    if (timeout < 1)
+      timeout = 1;
+  }
+  return timeout;
+}
+
+
diff -Naur dproxy-nexgen/dns_list.h dproxy-nexgen-brcm/dns_list.h
--- dproxy-nexgen/dns_list.h	2000-03-19 20:51:44.000000000 -0400
+++ dproxy-nexgen-brcm/dns_list.h	2018-11-23 22:41:44.385484054 -0400
@@ -1,21 +1,43 @@
-#include "dproxy.h"
-
-/*
- * Add a node to the list pointed to by 'list'. Copy 'm' into that node.
- * RETURNS: pointer to start of list 
- */
-dns_request_t *dns_list_add(dns_request_t *list, dns_request_t *m);
-/*
- * Scans each node in the list pointed to by 'list' and compare the id field
- * of each node with that of the id fields of 'm'.
- * RETURNS: pointer to the first node that matches else NULL.
- */
-dns_request_t *dns_list_find_by_id(dns_request_t *list, dns_request_t *m);
-/*
- * Removes and frees the node pointed to by m
- */
-dns_request_t *dns_list_remove(dns_request_t *list, dns_request_t *m );
-/*
- * Print out the list for debuging purposes
- */
-void dns_list_print(dns_request_t *list);
+#include "dproxy.h"
+
+/*
+ * Add a request to dns_request_list.
+ * RETURNS: 1 for success, 0 for failure 
+ */
+int dns_list_add(dns_request_t *r);
+
+/*
+ * Scans dns_request_list and compare the id field
+ * of each node with that of the id fields of 'r'.
+ * RETURNS: pointer to the first node that matches else NULL.
+ */
+dns_request_t *dns_list_find_by_id(dns_request_t *r);
+
+
+/*
+ * Removes and frees the node pointed to by r
+ * RETURNS: 1 for success, 0 for failure
+ */
+int dns_list_remove(dns_request_t *r);
+
+/*
+ * Removes and frees the nodes shared the same dns ip and then 
+ * swap dns1 and dns1 in the linked list
+ * RETURNS: 1 for success, 0 for failure
+ */
+int dns_list_remove_related_requests_and_swap(dns_request_t *r);
+
+/*
+ * Print out dns_request_list for debuging purposes
+ */
+void dns_list_print(void);
+
+/*
+ * Return the how many seconds left to expire the oldest request
+ * RETURNS: seconds
+ */
+int dns_list_next_time(void);
+
+extern dns_request_t *dns_request_list;
+/* Last request in dns_request_list */
+extern dns_request_t *dns_request_last;
diff -Naur dproxy-nexgen/dns_mapping.c dproxy-nexgen-brcm/dns_mapping.c
--- dproxy-nexgen/dns_mapping.c	1969-12-31 20:00:00.000000000 -0400
+++ dproxy-nexgen-brcm/dns_mapping.c	2018-11-23 22:41:44.385484054 -0400
@@ -0,0 +1,1083 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <linux/sockios.h>
+#include <netinet/in.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <syslog.h>
+#include <linux/if.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include "errno.h"
+#include <sys/stat.h>
+
+#include "dproxy.h"
+#include "dns_decode.h"
+#include "conf.h"
+#include "dns_list.h"
+#include "dns_construct.h"
+#include "dns_io.h"
+#include "dns_dyn_cache.h"
+#include "prctl.h"
+#include "cms.h"
+#include "cms_util.h"
+
+/* Used for the interface grouping where the incoming lan ip will be  used to check against 
+ * the lanSubnet/lanMask for the correct dns.  Currently, only the dns1 will be used 
+ */
+typedef struct _DNSInfoEntry
+{
+   /* LAN IPv4 subnet */
+   struct in_addr lanSubnet;
+   struct in_addr lanMask;
+   /* LAN IPv6 subnet */
+   char lanIpv6Subnet[2][INET6_ADDRSTRLEN];
+   /* IPv6 address */
+   char *ipv4_dns1;
+   char *ipv4_dns2;
+   char *ipv6_dns1;
+   char *ipv6_dns2;
+   char *processNameList;
+   struct _DNSInfoEntry *next;
+} DNSInfoEntry;
+
+static DNSInfoEntry *head = NULL;
+
+
+
+static UBOOL8 IsValidEphemeralPort(int srcPort)
+{
+   static int portBegin = 0;
+   static int portEnd = 0;
+   UBOOL8 found = FALSE;
+   
+   /* For IPv4, ephemeral port range is in proc/sys/net/ipv4/ip_local_port_range: should be 32768 to 61000
+   * and this is also shared by IPv6.
+   */
+
+   if (!portBegin)
+   {
+      char filename[BUFLEN_128];
+      FILE *fp;
+
+      cmsUtl_strncpy(filename, "proc/sys/net/ipv4/ip_local_port_range", sizeof(filename)-1);
+      
+      if ((fp = fopen(filename, "r")) == NULL)
+      {
+        cmsLog_error("could not open %s", filename);
+        return found;
+      }
+
+#if defined(AEI_COVERITY_FIX)
+      /*Coverity CID 31670: Other violation (CHECKED_RETURN)*/
+      if((fscanf(fp, "%d   %d", &portBegin, &portEnd))!=2)
+      {
+          fclose(fp);
+          return found;
+      }
+      /*Coverity CID 32258: Resource leak (RESOURCE_LEAK)*/
+      fclose(fp);
+#else
+      fscanf(fp, "%d   %d", &portBegin, &portEnd);
+      fclose(fp);
+#endif
+      debug("port range [%d-%d]", portBegin, portEnd);
+   }
+   
+   if (srcPort < portBegin || srcPort > portEnd)
+   {
+      cmsLog_error("Invalid src port %d. Should be in range[%d-%d]", srcPort, portBegin, portEnd);
+   }
+   else
+   {
+      found = TRUE;
+   }
+
+   return found;
+
+}
+
+static UBOOL8 isProcessMatchInode(const char *processName, unsigned long long inode)
+{
+   int pid = 0;
+   UBOOL8 found = FALSE;
+   struct dirent  *dp;
+   struct stat statbuf;
+   DIR *dir;   
+   char fileName[BUFLEN_128]={0};
+   char processFdDir[BUFLEN_128]={0};
+
+   debug("%s", processName);
+    
+   if ((pid = prctl_getPidByName(processName)) == 0)
+   {
+      debug("Process %s is not in the system", processName);
+      return found;
+   }
+
+   snprintf(processFdDir, sizeof(processFdDir), "/proc/%d/fd", pid);
+   
+   dir = opendir(processFdDir);
+#if defined(AEI_COVERITY_FIX)
+   /*Coverity CID 31719: Dereference null return value (NULL_RETURNS)*/
+   if(dir == NULL)
+       return found;
+#endif
+
+   /* Need to go over socket with a symbolic link file descriptor
+   * to find the related source port
+   */
+   while (!found && (dp = readdir(dir)) != NULL) 
+   {
+      /* Get entry's information. */
+      snprintf(fileName, sizeof(processFdDir),  "%s/%s", processFdDir, dp->d_name);
+
+      /* use stat to get file stat buffer for later processing */
+      if (stat(fileName, &statbuf) == -1)
+      {
+          perror("opendir");
+          continue;
+      }
+
+      /* Only interested in symbolly link and socket */           
+      if (dp->d_type == DT_LNK && S_ISSOCK(statbuf.st_mode))
+      {
+         if ((unsigned long long)statbuf.st_ino == inode)
+         {
+            debug("inode match");
+            found = TRUE;
+         }
+      }
+   }   
+
+   closedir(dir);       
+
+   debug("Found=%d", found);
+   
+   return found;
+   
+}
+
+
+/* To Find the inode from udp src port in IPV4:
+*
+* cat /proc/net/udp, the following will be displayed:
+* sl    local_address rem_address   st tx_queue rx_queue tr tm->when retrnsmt      uid  timeout   inode ref pointer drops
+* 15: 7F000001:E492 7F000001:0035 01 00000000:00000000 00:00000000 00000000     0        0 18143 2 8fa4e5b0 0
+*
+* Need to find the match with the local_address which is ip:7F00001 (127.0.0.1) and srcPort A890 here and get inode 18143
+* from this line.
+*/
+
+
+/* To Find the inode from udp src port in IPV6:
+*
+* cat /proc/net/udp6, the following will be displayed:
+*   sl  local_address                                                 remote_address                                             st  tx_queue  rx_queue   tr  tm->when retrnsmt   uid  timeout inode    ref pointer    drops
+* 16: 00000000000000000000000000000001:A310 00000000000000000000000000000001:0035 01 00000000:00000000 00:00000000  00000000 0        0       101264 2   8cf3c050 0
+*
+* Need to find the match with the local_address which is ip:1 (::1) and srcPort 0035 here and get inode 101264
+* from this line.
+*/
+static unsigned long long getInodeFromSrcPort(int srcPort, UBOOL8 isIpv4)
+{
+   char filename[BUFLEN_128];
+   UBOOL8 found = FALSE;
+   FILE *fp = NULL;
+   unsigned long long inode = 0;
+   char line[BUFLEN_256];
+   char scanfFormat[BUFLEN_128];
+   SINT32 loopbackAddr = 0;
+   
+   if (isIpv4)
+   {
+      snprintf(filename, sizeof(filename), "/proc/net/udp");
+      cmsUtl_strncpy(scanfFormat, "%d: %08X:%04X %08X:%04X %02X %08X:%08X %02X:%08X %08X %05X %08X %llu", sizeof(scanfFormat)-1);
+      loopbackAddr = INADDR_LOOPBACK;
+   }
+   else
+   {
+      snprintf(filename, sizeof(filename), "/proc/net/udp6");
+      cmsUtl_strncpy(scanfFormat, "%d: %32d:%04X %32d:%04X %02X %08X:%08X %02X:%08X %08X %05X %08X %llu", sizeof(scanfFormat)-1);
+      loopbackAddr = 1;       /* cannot seems to find any defines ? */
+   }
+
+  debug("open file %s to find src port %X, loopback=%x", filename, srcPort, loopbackAddr);
+
+   
+   if ((fp = fopen(filename, "r")) == NULL)
+   {
+      cmsLog_error("could not open %s", filename);
+      return found;
+   }
+
+   while (!found && (fgets(line,sizeof(line), fp) != NULL))
+   {
+      int sl, udp_ip, udp_srcport, rem_addr1, rem_addr2, st, txq, rxq, tr, tm, retrn, uid, timeout;
+
+      sscanf(line, scanfFormat, &sl, &udp_ip, &udp_srcport, &rem_addr1, &rem_addr2, &st, &txq, &rxq, &tr, &tm, &retrn, &uid, &timeout, &inode);
+
+      if (udp_ip == loopbackAddr && udp_srcport == srcPort)
+      {
+         found = TRUE;
+         debug("FOUND in line=%s", line);         
+      }
+   }
+
+   fclose(fp);
+   
+   debug("Found =%d, inode=%llu", found, inode);
+
+   return inode;
+   
+}                
+
+
+
+
+static UBOOL8 isSourcePortMatchProcess(int srcPort, char *processNameList, UBOOL8 isIpv4)
+{
+   UBOOL8 found = FALSE;
+   char tmpProcessNameList[BUFLEN_256]={0};
+   char processName[BUFLEN_128]={0};
+   unsigned long long inode = 0;
+   char *curPtr = NULL;
+   char *nullPtr = NULL;
+   
+   debug("Enter. srcPort=%0X, processNameList=%s", srcPort, processNameList);
+   
+   if (processNameList == NULL || !cmsUtl_strcmp(processNameList, ""))
+   {
+      debug("No need to check.");
+      return found;      
+   }
+   
+   if (!IsValidEphemeralPort(srcPort))
+   {
+      cmsLog_error("Invalid source port %d", srcPort);
+      return found;
+   }
+
+   /* Try to find the inode from udp source port */
+   if ((inode = getInodeFromSrcPort(srcPort, isIpv4)) == 0)
+   {
+      cmsLog_error("Cannot find the indoe for this srcPort=%d", srcPort);
+      return found;      
+   }   
+
+   cmsUtl_strncpy(tmpProcessNameList,  processNameList, sizeof(tmpProcessNameList)-1);
+
+   if (strchr(tmpProcessNameList, ',') == NULL) 
+   {
+      /* for only one process name in the process name list */
+      if (isProcessMatchInode(tmpProcessNameList, inode))
+      {
+         found = TRUE;
+      }
+   }
+   else
+   {
+      /* If more than one process is the process name list, need try them all */
+      curPtr = tmpProcessNameList;
+      
+      while (!found && (nullPtr = strchr(curPtr, ',')) != NULL)
+      {
+         *nullPtr = '\0';
+         cmsUtl_strncpy(processName, curPtr, sizeof(processName)-1);
+         if (isProcessMatchInode(processName, inode))
+         {
+            found = TRUE;
+         }
+         curPtr = nullPtr + 1;
+      }
+   }
+   
+   debug("Found=%d", found);
+   
+   return found;
+   
+}
+
+
+static UBOOL8 findDnsServerAddress(DNSInfoEntry *curr, int queryType, 
+                                   char *dns1, int *proto)
+{
+   UBOOL8 found = FALSE;
+
+   if (queryType == AAA)
+   {
+      /*
+       * AAAA query: If IPv6 DNS server exists, return the IPv6 DNS
+       * server address. Otherwise, return the IPv4 DNS server 
+       * address if available.
+       */
+      if (curr->ipv6_dns1)
+      {
+         strcpy(dns1, curr->ipv6_dns1);
+         *proto = AF_INET6;
+         found = TRUE;
+      }
+      else if (curr->ipv4_dns1)
+      {
+         strcpy(dns1, curr->ipv4_dns1);
+         *proto = AF_INET;
+         found = TRUE;
+      }
+   }
+   else
+   {
+      /*
+       * A query: If IPv4 DNS server exists, return the IPv4 DNS 
+       * server address. Otherwise, return the IPv6 DNS server 
+       * address if available.
+       */
+      if (curr->ipv4_dns1)
+      {
+         strcpy(dns1, curr->ipv4_dns1);
+         *proto = AF_INET;
+         found = TRUE;
+      }
+      else if (curr->ipv6_dns1)
+      {
+         strcpy(dns1, curr->ipv6_dns1);
+         *proto = AF_INET6;
+         found = TRUE;
+      }
+   }
+
+   return found;
+}
+
+
+void updateIpv4Ipv6Ptr( char *strList, char **curPtr, char **nullPtr )
+{
+   if (strList == NULL)
+   {
+      *curPtr = NULL;
+      *nullPtr = NULL;
+      return;
+   }
+
+   *curPtr = strstr(strList, ":");
+   if (*curPtr == NULL)
+   {
+      debug("no IPv6 info\n");
+      *curPtr = strList;
+      *nullPtr = NULL;
+   }
+   else
+   {
+      do
+      {
+         (*curPtr)--;
+         if ((*curPtr) == strList)
+         {
+            debug("no IPv4 info\n");
+
+            /* 
+             * if there is no IPv4 info, the info file may still 
+             * put an extra ',' in front of IPv6 info
+             */
+            if (**curPtr == ',')
+            {
+               *nullPtr = *curPtr + 1;
+            }
+            else
+            {
+               *nullPtr = strList;
+            }
+            *curPtr = NULL;
+
+            break;
+         }
+
+         if (**curPtr == ',')
+         {
+            debug("IPv4 and IPv6 info are found\n");
+            **curPtr = '\0';
+            *nullPtr = *curPtr + 1;
+            *curPtr = strList;
+            break;
+         }
+      }
+      while (1);
+   }
+}
+
+
+UBOOL8 createDnsInfoEntry( DNSInfoEntry **ptr, 
+                           struct in_addr *lanSubnet, struct in_addr *lanMask, 
+                           char *ipv6prefix,
+                           char *ipv4_dns1, char *ipv4_dns2, 
+                           char *ipv6_dns1, char *ipv6_dns2, 
+                           char *applicationBuf )
+{
+   UBOOL8 ret = FALSE;
+   DNSInfoEntry *curr = NULL;
+   UINT32 v4Dns = FALSE, v6Dns = FALSE;
+
+   debug("create DnsInfoEntry: v4dns1<%s> v6dns1<%s>", 
+                ipv4_dns1, ipv6_dns1);
+
+   if ((lanSubnet == NULL) && (ipv6prefix == NULL))
+   {
+      cmsLog_error("No subnet info for IPv4 and IPv6");
+      *ptr = NULL;
+      ret = TRUE;
+      goto end;
+   }
+
+   curr = cmsMem_alloc(sizeof(DNSInfoEntry), ALLOC_ZEROIZE);
+   *ptr = curr;
+   if (curr == NULL)
+   {
+      cmsLog_error("Failed to allocate memory.");
+      ret = TRUE;
+      goto end;
+   }
+
+   if (lanSubnet != NULL)
+   {
+      curr->lanSubnet  = *lanSubnet;
+   }
+
+   if (lanMask != NULL)
+   {
+      curr->lanMask = *lanMask;
+   }
+
+   curr->next = NULL;
+
+   /* update IPv4 DNS server if available */
+   if (!IS_EMPTY_STRING(ipv4_dns1) && cmsUtl_strcmp(ipv4_dns1, "0.0.0.0"))
+   {
+      curr->ipv4_dns1 = cmsMem_strdup(ipv4_dns1);
+      curr->ipv4_dns2 = cmsMem_strdup(ipv4_dns2);
+      v4Dns = TRUE;
+   }
+   else
+   {
+      debug("No IPv4 DNS server");
+   }
+
+   /* update IPv6 DNS server if available */
+   if ( !IS_EMPTY_STRING(ipv6_dns1) && 
+        cmsUtl_isValidIpAddress(AF_INET6, ipv6_dns1) )
+   {
+      curr->ipv6_dns1 = cmsMem_strdup(ipv6_dns1);
+      curr->ipv6_dns2 = cmsMem_strdup(ipv6_dns2);
+      v6Dns = TRUE;
+   }
+   else
+   {
+      debug("No IPv6 DNS server");
+   }
+
+   if (!v4Dns && !v6Dns)
+   {
+      cmsLog_error("NO DNS servers associated with DNSEntry");
+      ret = TRUE;
+      goto end;
+   }
+
+   if (ipv6prefix != NULL)
+   {
+      cmsUtl_strncpy( curr->lanIpv6Subnet[0], ipv6prefix, 
+                      sizeof(curr->lanIpv6Subnet[0])-1 );
+   }
+
+   if (!IS_EMPTY_STRING(applicationBuf))
+   {
+      curr->processNameList = cmsMem_strdup(applicationBuf);
+   }
+
+   /* append the new node to the end of the linked list */
+   if (head == NULL)
+   {
+      head = curr;
+   }
+   else
+   {
+      DNSInfoEntry *tmp = head;
+      while (tmp->next != NULL)
+      {
+         tmp = tmp->next;
+      }
+      tmp->next = curr;
+   }
+
+end:
+   return ret;
+}
+
+
+/* Initialize the global DNSInfoEntry linked list by parsing the information in \var\dnsinfo.conf created by CMS when there
+* are wan connection status changes. 
+*/
+void dns_mapping_conifg_init(void)
+{
+   FILE *fp;
+   char wanIfName[CMS_IFNAME_LENGTH] = {0};
+   char subnetCidr[INET6_ADDRSTRLEN] = {0};
+   char dnsList[5 * INET6_ADDRSTRLEN] = {0};   /* make space for 5 dns entries in case  they have that many */
+   char ipv4_dns1[CMS_IPADDR_LENGTH];
+   char ipv4_dns2[CMS_IPADDR_LENGTH];
+   char ipv6_dns1[INET6_ADDRSTRLEN];
+   char ipv6_dns2[INET6_ADDRSTRLEN];
+   char line[BUFLEN_128];
+   char applicationBuf[BUFLEN_64];
+   DNSInfoEntry *curr = NULL;
+   DNSInfoEntry *curr_tmp = NULL;
+   UBOOL8 done = FALSE;
+   struct in_addr lanSubnet;
+   struct in_addr lanMask;
+   char *curPtr;
+   char *nullPtr;
+   
+   if ((fp = fopen(DNSINFO_CONF, "r")) == NULL)
+   {
+      cmsLog_notice(" %s does not exist.", DNSINFO_CONF);
+      return;
+   }
+
+   debug("Enter!!");   
+   /* First free the linked list */
+   curr = head;
+   while (curr)
+   {
+      cmsLog_notice("Free subnet=%X, mask=%X, ipv4_dns1=%s, ipv4_dns2=%s"
+                    "ipv6_dns1=%s, ipv6_dns2=%s",
+                    curr->lanSubnet, curr->lanMask, curr->ipv4_dns1, 
+                    curr->ipv4_dns2, curr->ipv6_dns1, curr->ipv6_dns2);
+      cmsMem_free(curr->ipv4_dns1);
+      cmsMem_free(curr->ipv4_dns2);
+      cmsMem_free(curr->ipv6_dns1);
+      cmsMem_free(curr->ipv6_dns2);
+      cmsMem_free(curr->processNameList);
+      curr_tmp = curr;
+      curr = curr->next;
+      cmsMem_free(curr_tmp);
+   }
+   head = NULL;
+   
+   while (!done &&  fgets(line, sizeof(line), fp))
+   {
+      UBOOL8 v4Dns = FALSE, v6Dns = FALSE;
+
+      curPtr = line;
+      ipv4_dns1[0] = '\0';
+      ipv4_dns2[0] = '\0';      
+      ipv6_dns1[0] = '\0';
+      ipv6_dns2[0] = '\0';
+      lanSubnet.s_addr = 0;
+      lanMask.s_addr = 0;
+      
+      /* get rid of '\n' at the end if there is any */
+      if (line[strlen(line) -1] == '\n')
+      {
+         line[strlen(line) - 1] = '\0';
+      }
+
+      /* 1) get Wan IfName */
+      if ((nullPtr = strchr(curPtr, ';')) != NULL)
+      {
+         *nullPtr = '\0';
+#if defined(AEI_COVERITY_FIX)
+         /*Coverity CID 31788: Destination buffer too small (STRING_OVERFLOW)*/
+         cmsUtl_strncpy(wanIfName, curPtr, sizeof(wanIfName));
+#else
+         strcpy(wanIfName, curPtr);
+#endif
+         curPtr = nullPtr + 1;         
+      }
+
+      /* 2) get subnet in cidr format */
+      if ((nullPtr = strchr(curPtr, ';')) != NULL)
+      {
+         *nullPtr = '\0';
+#if defined(AEI_COVERITY_FIX)
+         /*Coverity CID 31788: Destination buffer too small (STRING_OVERFLOW)*/
+         cmsUtl_strncpy(subnetCidr, curPtr, sizeof(subnetCidr));
+#else
+         strcpy(subnetCidr, curPtr);
+#endif
+         curPtr = nullPtr + 1;         
+      }
+
+      /* 3)  get dns list separated by ',' */
+      if ((nullPtr = strchr(curPtr, ';')) != NULL)
+      {
+         *nullPtr = '\0';
+#if defined(AEI_COVERITY_FIX)
+         /*Coverity CID 31788: Destination buffer too small (STRING_OVERFLOW)*/
+         cmsUtl_strncpy(dnsList, curPtr, sizeof(dnsList));
+#else
+         strcpy(dnsList, curPtr);
+#endif
+         curPtr = nullPtr + 1;         
+      }
+
+      /* 4) get apps list separated by ','
+       * more than 1 applications such as "...;tr69c,voipd", etc on the WAN interface.
+       */
+      cmsUtl_strncpy(applicationBuf, curPtr, sizeof(applicationBuf)-1);
+
+      
+      cmsLog_notice("wanif=%s, subnetCidr=%s, dnsList=%s, processNameList=%s", 
+                    wanIfName,  subnetCidr, dnsList, applicationBuf);
+
+      /* 
+       * process DNS part: curPtr points to the IPv4 DNS servers and nullPtr 
+       * points to the IPv6 DNS servers
+       */
+      updateIpv4Ipv6Ptr(dnsList, &curPtr, &nullPtr);
+
+      if (curPtr)
+      {
+         if (cmsUtl_parseDNS(curPtr,ipv4_dns1,ipv4_dns2,TRUE) != CMSRET_SUCCESS)
+         {
+            cmsLog_error("Failed to parse IPv4 dns list %s", dnsList);
+         }
+         else
+         {
+            v4Dns = TRUE;
+         }
+      }
+
+      if (nullPtr)
+      {
+         if (cmsUtl_parseDNS(nullPtr,ipv6_dns1,ipv6_dns2,FALSE)!=CMSRET_SUCCESS)
+         {
+            cmsLog_error("Failed to parse IPv6 dns list %s", dnsList);
+         }
+         else
+         {
+            v6Dns = TRUE;
+         }
+      }
+
+      if (!v4Dns && !v6Dns)
+      {
+         cmsLog_error("No DNS server info for DnsInfoEntry!!");
+         fclose(fp);
+         return;
+      }
+
+      /* 
+       * process subnet part: curPtr points to the IPv4 subnet and nullPtr 
+       * points to the IPv6 subnet
+       *
+       * IPv4 and IPv6 subnet may not exist concurrently. However, one of them
+       * must be present! We have to update the DNSEntry with valid IPv4 AND
+       * IPv6 DNS server info whenever a subnet is seen.
+       */
+      if (!IS_EMPTY_STRING(subnetCidr))
+      {
+         updateIpv4Ipv6Ptr(subnetCidr, &curPtr, &nullPtr);
+
+         debug("v4Subnet<%s>  v6Subnet<%s>", curPtr, nullPtr);
+         /*
+          * Here we make an assumption: The configuration file must be 
+          * correct. There will be no duplicate subnet in different entries.
+          */
+         if (curPtr)
+         {
+            /* case of IPv4 subnet */
+            cmsNet_inet_cidrton(curPtr, &lanSubnet, &lanMask);
+            if (lanSubnet.s_addr != 0 && lanMask.s_addr != 0)
+            {
+               done = createDnsInfoEntry(&curr, &lanSubnet, &lanMask, NULL,
+                                         ipv4_dns1, ipv4_dns2, 
+                                         ipv6_dns1, ipv6_dns2, applicationBuf);
+
+               if (done)
+               {
+                  if ( curr )
+                  {
+                     cmsMem_free(curr);
+                  }
+
+                  fclose(fp);
+                  return;
+               }
+            }
+            else
+            {
+               cmsLog_error("Failed to convert LAN IPv4 subnet/mask from %s.", 
+                            curPtr);
+               done = TRUE;
+            }
+         }
+         else
+         {
+            debug("No LAN IPv4 subnet/mask found.");
+         }
+
+         if (!done && nullPtr)
+         {
+            UINT32 plen;
+            char addr[INET6_ADDRSTRLEN];
+            char *tmp;
+
+            /* 
+             * Currently, we only support at most 2 IPv6 subnets associated
+             * with one DnsInfoEntry. In the future, if we want to increase
+             * the number, modification will be needed.
+             */
+            tmp = strstr(nullPtr, ",");
+
+            if (tmp != NULL)
+            {
+               *tmp = '\0';
+               tmp++;
+            }
+
+            if (cmsUtl_parsePrefixAddress(nullPtr,addr,&plen) == CMSRET_SUCCESS)
+            {
+               debug("ipv6 prefix=%s plen=%d", addr, plen);
+
+               if (curr == NULL)   /* No entry is created by IPv4 */
+               {
+                  done = createDnsInfoEntry(&curr, NULL, NULL, nullPtr,
+                                          ipv4_dns1, ipv4_dns2, 
+                                          ipv6_dns1, ipv6_dns2, applicationBuf);
+
+                  if (done)
+                  {
+                     if ( curr )
+                     {
+                        cmsMem_free(curr);
+                     }
+
+                     fclose(fp);
+                     return;
+                  }
+                  else
+                  {
+                     /* update second ipv6 subnet if exists */
+                     if ( cmsUtl_parsePrefixAddress(tmp, addr, &plen) == 
+                          CMSRET_SUCCESS )
+                     {
+                        cmsUtl_strncpy( curr->lanIpv6Subnet[1], tmp, 
+                                        sizeof(curr->lanIpv6Subnet[0])-1 );
+                     }
+                  }
+               }
+               else
+               {
+                  /* 
+                   * An entry is created already by IPv4. Therefore, all info
+                   * must be configured except for ipv6 subnet info
+                   */
+                  cmsUtl_strncpy( curr->lanIpv6Subnet[0], nullPtr, 
+                                  sizeof(curr->lanIpv6Subnet[0])-1 );
+
+                  if ( cmsUtl_parsePrefixAddress(tmp, addr, &plen) == 
+                       CMSRET_SUCCESS )
+                  {
+                     cmsUtl_strncpy( curr->lanIpv6Subnet[1], tmp, 
+                                     sizeof(curr->lanIpv6Subnet[0])-1 );
+                  }
+               }
+            }
+            else
+            {
+               cmsLog_error("Failed to convert LAN IPv6 subnet/mask from %s.", 
+                            nullPtr);
+               done = TRUE;
+            }
+         }
+         else
+         {
+            debug("No LAN IPv6 prefix found.");
+         }
+      }
+      else
+      {
+         cmsLog_error("No subnet info associated with a DNSEntry");
+         done = TRUE;
+      }
+
+      wanIfName[0] = '\0';
+      subnetCidr[0]= '\0';
+      dnsList[0] = '\0';
+   }
+
+   curr = head;
+   while (curr != NULL)
+   {
+      cmsLog_notice("subnet=%s", inet_ntoa(curr->lanSubnet));
+      cmsLog_notice("mask=%s, dns1=%s, dns2=%s, processNameList=%s"
+                    "v6prefix1=%s, v6prefix2=%s, v6dns1=%s, v6dns2=%s", 
+                    inet_ntoa(curr->lanMask), curr->ipv4_dns1, curr->ipv4_dns2,
+                    curr->processNameList, curr->lanIpv6Subnet[0], 
+                    curr->lanIpv6Subnet[1], curr->ipv6_dns1, curr->ipv6_dns2);
+      curr = curr->next;
+   }
+
+   fclose(fp);
+}
+
+
+/* 
+*  From lan ip and source port of the dns query, maps a correct wan dns ip for it.
+*  Map a wan dns with the following steps:
+* 1). If not loopback 127.0.0.1 and lan subnet matched, such as default and interface groups wan connections.
+* 2). If local generated dns querry (tr69c, voip, etc.  the lan ip will be 127.0.0.1), use the source port and
+*      process name to find out if the query is from this process or not.
+* 3). If not match found, use the default dns (the first in the linked list).
+*/
+UBOOL8 dns_mapping_find_dns_ip(struct sockaddr_storage *lanInfo, int queryType, char *dns1, int *proto)
+{
+   UBOOL8 found = FALSE;
+   DNSInfoEntry *curr = head;
+   char lanIP[INET6_ADDRSTRLEN];
+   void *addr;
+   int srcPort;
+   
+   if (dns1 == NULL)
+   {
+      cmsLog_error("Invalid dns1 parameter");
+      return found;
+   }
+
+   addr = get_in_addr(lanInfo);
+   srcPort = ((struct sockaddr_in *)lanInfo)->sin_port;
+   inet_ntop(lanInfo->ss_family, addr, lanIP, INET6_ADDRSTRLEN);
+   debug("lanIP=%s, srcPort=%d", lanIP, srcPort);
+
+   while (!found && curr)
+   {
+      if (lanInfo->ss_family == AF_INET )
+      {
+         if (((struct in_addr *)addr)->s_addr != INADDR_LOOPBACK) 
+         {
+            if ( (((struct in_addr *)addr)->s_addr & curr->lanMask.s_addr) == 
+                 curr->lanSubnet.s_addr )
+            {
+               /* 1).  Not loopback and same subnet found and need to get the 
+                * dns1 (primary dns) 
+                */
+               found = findDnsServerAddress(curr, queryType, dns1, proto);
+               if (!found)
+               {
+                  cmsLog_error( "1). No IPv4/IPv6 dns server associate "
+                                "with the entry" );
+                  return found;
+               }
+
+               debug("1).  Found dns %s for subnet %s", dns1, lanIP);
+            }            
+         }
+         else if (((struct in_addr *)addr)->s_addr == INADDR_LOOPBACK)
+         {
+           /* For applications such as tr69c, etc. which uses a specific 
+            * routed wan service with an process
+            * name associated with the wan connection in /var/dnsinfo.conf
+            */
+            if (isSourcePortMatchProcess(srcPort, curr->processNameList, TRUE))
+            {
+               found = findDnsServerAddress(curr, queryType, dns1, proto);
+               if (!found)
+               {
+                  cmsLog_error( "1). No IPv4/IPv6 dns server associate "
+                                "with the entry" );
+                  return found;
+               }
+
+               debug("2). Found the dns %s for the application", dns1);
+            }
+         }
+         else
+         {
+            cmsLog_error("Invalid lanIP %s", lanIP);
+         }
+      }
+      else /* AF_INET6 */
+      {
+         if ( !IN6_ARE_ADDR_EQUAL(addr, &in6addr_loopback) )
+         {
+            if ( cmsNet_isHostInSameSubnet(lanIP, curr->lanIpv6Subnet[0]) ||
+                 cmsNet_isHostInSameSubnet(lanIP, curr->lanIpv6Subnet[1]) )
+            {
+               /* 1).  Not loopback and same subnet found and need to get the 
+                * dns1 (primary dns) 
+                */
+               found = findDnsServerAddress(curr, queryType, dns1, proto);
+               if (!found)
+               {
+                  cmsLog_error( "1). No IPv4/IPv6 dns server associate "
+                                "with the entry" );
+                  return found;
+               }
+
+               debug("1).  Found dns %s for subnet %s", dns1, lanIP);
+            }
+         }
+         else if ( IN6_ARE_ADDR_EQUAL(addr, &in6addr_loopback) )
+         {
+           /* For applications such as tr69c, etc. which uses a specific 
+            * routed wan service with an process
+            * name associated with the wan connection in /var/dnsinfo.conf
+            */
+            if (isSourcePortMatchProcess(srcPort, curr->processNameList, FALSE))
+            {
+               found = findDnsServerAddress(curr, queryType, dns1, proto);
+               if (!found)
+               {
+                  cmsLog_error( "1). No IPv4/IPv6 dns server associate "
+                                "with the entry" );
+                  return found;
+               }
+
+               debug("2). Found the dns %s for the application", dns1);
+            }
+         }
+         else
+         {
+            cmsLog_error("Invalid lanIP %s", lanIP);
+         }
+      }
+
+      if (!found)
+      {
+         curr = curr->next;
+         debug("Not found. get next one");
+      }         
+   }
+
+   if (!found)
+   {
+      /* If not found in the above while loop, use the default system dns (the first one in the linked list) */
+      curr = head;
+      if (curr)
+      {
+         found = findDnsServerAddress(curr, queryType, dns1, proto);
+         debug("3).  Use the default dns.");
+      }
+   }
+
+   return found;
+   
+ }
+
+UBOOL8 dns_mapping_is_dns_swap_needed(dns_request_t *r, char *dnsUsed)
+{
+   DNSInfoEntry *curr = head;
+   char currDns[INET6_ADDRSTRLEN];
+   int proto;
+   UBOOL8 isSwapNeeded = FALSE;
+
+  
+  if (NULL == r || dnsUsed == NULL) 
+  {
+     cmsLog_error("null request passed in!");
+     return isSwapNeeded;
+  }
+
+   cmsLog_notice("Enter dnsUsed %s", dnsUsed);
+   
+   if (!dns_mapping_find_dns_ip(&(r->src_info), r->message.question[0].type, currDns, &proto))
+   {
+      cmsLog_notice("Cannot find the dns ip used for the query.  Just remove this request.");
+      isSwapNeeded = TRUE;
+      return isSwapNeeded;
+   }
+
+   while (curr && !isSwapNeeded)
+   {
+      /* Both dns1 and dns2 need to be present and curr->ipv4_dns1 is always used */
+      if (proto == AF_INET && curr->ipv4_dns1 && curr->ipv4_dns2)
+      {
+         if (!cmsUtl_strcmp(currDns, curr->ipv4_dns1))
+         { 
+            if (IS_EMPTY_STRING(dnsUsed))
+            {
+               strcpy(dnsUsed, curr->ipv4_dns1);
+               isSwapNeeded = TRUE;
+            }               
+            else if (!cmsUtl_strcmp(curr->ipv4_dns1, dnsUsed))
+            {
+                isSwapNeeded = TRUE;
+            }
+            else
+            {
+               cmsLog_notice("Different dns1 used for the query so skip removal");
+            }
+         }
+      }
+      else if (proto == AF_INET6 && curr->ipv6_dns1 && curr->ipv6_dns2)
+      {
+         /* Both dns1 and dns2 need to be present and curr->ipv6_dns1 is always used */      
+         if (!cmsUtl_strcmp(currDns, curr->ipv6_dns1))
+         {             
+            if (IS_EMPTY_STRING(dnsUsed))
+            {
+               strcpy(dnsUsed, curr->ipv6_dns1);
+               isSwapNeeded = TRUE;
+            }               
+            else if (!cmsUtl_strcmp(curr->ipv6_dns1, dnsUsed))
+            {
+                isSwapNeeded = TRUE;
+            }
+            else
+            {
+               cmsLog_notice("Different dns1 used for the query so skip removal");
+            }
+         }
+      }
+      
+      curr = curr->next;
+   }
+
+   return isSwapNeeded;
+   
+}
+
+
+void dns_mapping_do_dns_swap(char *dnsUsed)
+{
+   DNSInfoEntry *curr = head;
+   UBOOL8 swapDone = FALSE;
+   char tmpDns1[INET6_ADDRSTRLEN];
+   
+   while (curr && !swapDone)
+   {
+      if (curr->ipv4_dns1 && curr->ipv4_dns2 && !cmsUtl_strcmp(dnsUsed, curr->ipv4_dns1))
+      {
+#if defined(AEI_COVERITY_FIX)
+         /*Coverity CID 31789: Destination buffer too small (STRING_OVERFLOW)*/
+         cmsUtl_strncpy(tmpDns1, curr->ipv4_dns1, sizeof(tmpDns1));
+#else
+         strcpy(tmpDns1, curr->ipv4_dns1);
+#endif
+         CMSMEM_REPLACE_STRING(curr->ipv4_dns1, curr->ipv4_dns2);
+         CMSMEM_REPLACE_STRING(curr->ipv4_dns2, tmpDns1);
+         swapDone = TRUE;
+         cmsLog_notice("After swap, swap ipv4_dns1=%s, ipv4_dns2=%s", curr->ipv4_dns1,  curr->ipv4_dns2);
+      }
+      else if ( curr->ipv6_dns1 && curr->ipv6_dns2 && !cmsUtl_strcmp(dnsUsed, curr->ipv6_dns1))
+      {
+#if defined(AEI_COVERITY_FIX)
+         /*Coverity CID 31789: Destination buffer too small (STRING_OVERFLOW)*/
+         cmsUtl_strncpy(tmpDns1, curr->ipv6_dns1, sizeof(tmpDns1));
+#else
+         strcpy(tmpDns1, curr->ipv6_dns1);
+#endif
+         CMSMEM_REPLACE_STRING(curr->ipv6_dns1, curr->ipv6_dns2);
+         CMSMEM_REPLACE_STRING(curr->ipv6_dns2, tmpDns1);
+         swapDone = TRUE;
+         cmsLog_notice("After swap, ipv6_dns1=%s, ipv6_dns2=%s", curr->ipv6_dns1, curr->ipv6_dns2);
+      }
+      curr = curr->next;
+   }
+
+}
+ 
diff -Naur dproxy-nexgen/dns_mapping.h dproxy-nexgen-brcm/dns_mapping.h
--- dproxy-nexgen/dns_mapping.h	1969-12-31 20:00:00.000000000 -0400
+++ dproxy-nexgen-brcm/dns_mapping.h	2018-11-23 22:41:44.385484054 -0400
@@ -0,0 +1,41 @@
+#ifndef __DNS_MAPPING_
+#define __DNS_MAPPING_
+
+/*
+ * Read  "/var/dnsinfo.conf" and put the dns mapping info into a linked list.
+ * Is called whenever the dnsinfo.conf changes (caused by  WAN connection status change)
+ */
+void dns_mapping_conifg_init(void);
+
+
+/*
+ * Find a WAN side dns ip from the lan Ip and source port.
+ *  
+ *
+ * @param lanInfo     (IN) LAN ip of the dns query
+ * @param queryType   (IN) Source port of the dns query 
+ * @param dns1        (OUT) the primary dns ip
+ * @param proto       (OUT) layer 3 protocol (IPv4 or IPv6)
+ *
+ */
+UBOOL8 dns_mapping_find_dns_ip(struct sockaddr_storage *lanInfo,
+                               int queryType, char *dns1, int *proto);
+
+
+/*
+ * Find out if the dns request has a dns2 to be swapped with dns 1
+ *  
+ *
+ * @param r     (IN) a timed out request
+ * @param dnsUsed   (IN/OUT) First time call, it is null and subsequent and then gets filled. Later calls it is used for comparison.
+ */
+UBOOL8 dns_mapping_is_dns_swap_needed(dns_request_t *r, char *dnsUsed);
+
+/*
+ * Swap the dns1 and dns2 in the linked list
+ * @param dnsUsed     (IN) dnsUsed in the request
+ *
+ */
+void dns_mapping_do_dns_swap(char *dnsUsed);
+
+#endif
diff -Naur dproxy-nexgen/dns_probe.c dproxy-nexgen-brcm/dns_probe.c
--- dproxy-nexgen/dns_probe.c	1969-12-31 20:00:00.000000000 -0400
+++ dproxy-nexgen-brcm/dns_probe.c	2018-11-23 22:41:44.385484054 -0400
@@ -0,0 +1,346 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <cms_params.h>
+
+#include "dproxy.h"
+#include "conf.h"
+#include "dns_list.h"
+#include "dns_probe.h"
+
+#ifdef DESKTOP_LINUX
+#define REAL_DNS_FYI_FILENAME   "./dns.real"
+#else
+#define REAL_DNS_FYI_FILENAME   "/var/fyi/sys/dns.real"
+#endif
+
+extern int dns_wanup;
+extern int dns_querysock;
+static char primary_ns[CMS_IPADDR_LENGTH];
+static char secondary_ns[CMS_IPADDR_LENGTH];
+static struct sockaddr_in probe_addr;
+#ifdef DNS_PROBE
+static time_t probe_next_time;
+static int probe_tried;
+static time_t probe_timeout;
+static uint16_t probe_id;
+#ifdef AEI_VDSL_CUSTOMER_NCS
+static char probe_pkt[35] =
+	{0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+	 0x3, 'w','w','w', 0x9, 'm', 'i', 'c', 'r', 'o', 's','o','f','t', 0x3, 'c', 'o',
+	 'm',  0x0, 0x0, 0x1, 0x0, 0x1, };
+#else
+static char probe_pkt[36] =
+	{0x0, 0x0, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+	 0x1, 'a', 0xc, 'r', 'o', 'o', 't', '-', 's', 'e', 'r', 'v',
+	 'e', 'r', 's', 0x3, 'n', 'e', 't', 0x0, 0x0, 0x1, 0x0, 0x1, };
+#endif
+#else
+time_t dns_recover_time;
+#endif
+
+/* Load name servers' addresses from /etc/resolv.conf */
+static int load_brcm_name_servers(void)
+{
+	FILE * fp;
+	char line[256];
+	char addr[CMS_IPADDR_LENGTH];
+	char domain[256];
+
+	memset(primary_ns, 0, sizeof(primary_ns));
+	memset(secondary_ns, 0, sizeof(secondary_ns));
+
+    //name server of resolv.conf is 127.0.0.1, it redirects ont dns query
+    //to dns proxy to record dns query failed of ipHost PM
+	if((fp = fopen(REAL_DNS_FYI_FILENAME, "r")) == NULL) {
+		debug("Opend %s failed", REAL_DNS_FYI_FILENAME);
+        // if dns.real does not exist, open /etc/resolv.conf
+    	if((fp = fopen("/etc/resolv.conf", "r")) == NULL) {
+	    	debug("Opend /etc/resolv.conf failed");
+		    return 0;
+	    }
+	}
+
+	while(fgets(line, sizeof(line), fp)) {
+		if (sscanf(line, "nameserver %15s", addr) == 1) {
+			if ( strcmp( addr, "0.0.0.0") && strcmp( addr, "127.0.0.1")) {
+				if (primary_ns[0] == 0) {
+					strncpy(primary_ns, addr, sizeof(primary_ns)-1);
+				} else if (secondary_ns[0] == 0) {
+					strncpy(secondary_ns, addr, sizeof(secondary_ns)-1);
+				} else {
+					printf("dnsproxy supports a max of two name servers.  "
+							"Additional name servers are ignored.\n");
+				}
+			}
+		} else if (sscanf(line, "domain %s", domain) == 1) {
+			strncpy(config.domain_name, domain, sizeof(config.domain_name)-1);
+		}
+	}
+	fclose(fp);
+
+	debug("dproxy: load nameserver %s %s", primary_ns, secondary_ns);
+	debug("dproxy: load domain %s", config.domain_name);
+
+	if (primary_ns[0] == 0)  /* not even a single valid nameserver found */
+		return 0;
+	return 1;
+}
+
+/* Initialization before probing */
+int dns_probe_init(void)
+{
+	int ret;
+	
+	debug("dns_probe_init");
+
+	/* Try to read name servers from /var/fyi/sys/dns */
+	if ((ret = load_brcm_name_servers())) {
+		strcpy(config.name_server, primary_ns);
+	} else {
+      /*
+       * ret == 0 means wan is not up. 
+       * BRCM: Use the magic ppp on demand address.
+       */
+      debug("wan is not up, set name_server to 128.9.0.107");
+		strcpy(config.name_server, "128.9.0.107");
+   }
+
+	/* Set primary server as the probing address */
+	memset(&probe_addr, 0, sizeof(probe_addr));
+	probe_addr.sin_family = AF_INET;
+	inet_aton(primary_ns, &probe_addr.sin_addr);
+	probe_addr.sin_port = ntohs(PORT);
+
+#ifdef DNS_PROBE
+	/* Initialize request id */
+	srandom(time(NULL));
+	probe_id = (uint16_t)random();
+	probe_next_time = 0;
+	probe_tried = 0;
+	probe_timeout = 0;
+#endif
+	return ret;
+}
+
+#if defined(DNS_PROBE) && defined(AEI_VDSL_DNS_PROBE)
+void dns_probe_time_init(void)
+{
+	if(!probe_tried) {
+		probe_next_time = 0;
+		probe_tried = 0;
+		probe_timeout = 0;
+	}
+}
+#endif
+
+/* Send, resend probing request, check timeout, and switch name servers */
+int dns_probe(void)
+{
+	int ret = 0;
+	time_t now = time(NULL);
+#ifndef DNS_PROBE
+	debug("dns_probe: entered, dns_wanup=%d now=%d dns_recover_time=%d\n",
+	      dns_wanup, now, dns_recover_time);
+#endif
+	if (!dns_wanup) { /* No need to probe if no WAN interface */
+		return ret;
+	}
+
+#ifdef DNS_PROBE
+	if (probe_tried) { /* Probing */
+		if (now >= probe_timeout) { /* Timed out */
+			if (probe_tried >= DNS_PROBE_MAX_TRY) {
+				/* Probe failed */
+				debug("dproxy: probing failed\n");
+				if (secondary_ns[0] &&
+				    strcmp(config.name_server, secondary_ns)) {
+					printf("Primary DNS server Is Down... "
+					       "Switching To Secondary DNS "
+					       "server \n");
+					strcpy(config.name_server,
+					       secondary_ns);
+				}
+				probe_tried = 0;
+				probe_next_time = now + DNS_PROBE_INTERVAL;
+				ret = DNS_PROBE_INTERVAL;
+			} else { /* Retry */
+				sendto(dns_querysock, probe_pkt, sizeof(probe_pkt),
+				       0, (struct sockaddr*)&probe_addr,
+				       sizeof(probe_addr));
+				probe_timeout = now + DNS_PROBE_TIMEOUT;
+				probe_tried++;
+				ret = DNS_PROBE_TIMEOUT;
+			}
+		} else {
+			ret = probe_timeout - now;
+		}
+	} else if (now >= probe_next_time) { /* Time to probe */
+		*((uint16_t*)probe_pkt) = htons(++probe_id);
+		sendto(dns_querysock, probe_pkt, sizeof(probe_pkt), 0,
+		       (struct sockaddr*)&probe_addr, sizeof(probe_addr));
+		probe_tried = 1;
+		probe_timeout = now + DNS_PROBE_TIMEOUT;
+		ret = DNS_PROBE_TIMEOUT;
+	} else {
+		ret = probe_next_time - now;
+	}
+#else
+	if (dns_recover_time) { /* Recovering */
+		if (now >= dns_recover_time)
+			dns_probe_switchback();
+		else
+			ret = dns_recover_time - now;
+	}
+
+#endif
+
+	debug("dns_probe: done, ret=%d\n", ret);
+
+	return ret;
+}
+
+#ifndef DNS_PROBE
+int dns_probe_is_primary_up(void)
+{
+	if (dns_recover_time == 0)
+		return 1;
+	else
+		return 0;
+}
+
+void dns_probe_set_recover_time(void)
+{
+
+   if (dns_recover_time) {
+      /* We are currently using the secondary nameserver.  Do nothing */
+      debug("still using secondary_ns, dns_recover_time=%d\n",
+            dns_recover_time);
+      return;
+   }
+
+   /* Only switch to the 2nd dns server when it is configured */
+   if (secondary_ns[0]) {
+     char date_time_buf[DATE_TIME_BUFLEN];
+     get_date_time_str(date_time_buf, sizeof(date_time_buf));
+
+     printf("%s Primary DNS server (%s) Is Down..."
+          "Switching To Secondary DNS server (%s) "
+          "for %d seconds.  \n",
+          date_time_buf, primary_ns, secondary_ns, DNS_RECOVER_TIMEOUT);
+
+     strncpy(config.name_server, secondary_ns, sizeof(config.name_server)-1);
+     dns_recover_time = time(NULL) + DNS_RECOVER_TIMEOUT;
+     dns_list_unarm_all_requests();
+   }
+   else
+   {
+      debug("no valid secondary_ns to switch to.\n");
+   }
+}
+#endif
+
+/* Switch back to primary server */
+void dns_probe_switchback(void)
+{
+	char date_time_buf[DATE_TIME_BUFLEN];
+
+#ifdef DNS_PROBE
+	static int first_time = 1;
+#else
+	dns_recover_time = 0;
+#endif
+
+	debug("config.name_server=%s primary_ns=%s",
+	      config.name_server, primary_ns);
+
+	if (!strcmp(config.name_server, primary_ns))
+	{
+		debug("dns_probe_switchback called even though primary is already up!\n");
+		return;
+	}
+
+#ifdef DNS_PROBE
+	if (first_time)
+		first_time = 0;
+	else
+#endif
+
+	get_date_time_str(date_time_buf, sizeof(date_time_buf));
+	printf("%s Switching back to primary dns server (%s).\n",
+	       date_time_buf, primary_ns);
+
+	strncpy(config.name_server, primary_ns, sizeof(config.name_server)-1);
+	dns_list_unarm_all_requests();
+}
+
+/* Activate primary server */
+int dns_probe_activate(uint32_t name_server)
+{
+       debug("name_server=0x%x probe_addr=0x%x\n", name_server, probe_addr.sin_addr.s_addr);
+#if defined(DMP_X_BROADCOM_COM_IPV6_1) || defined(AEI_CONTROL_LAYER)
+        char i=0;
+        u_int8_t *u6_addr8 ;
+        u6_addr8 = (u_int8_t *) name_server;
+        u_int32_t  tmp=probe_addr.sin_addr.s_addr;
+
+        if(u6_addr8[10]==0xff && u6_addr8[11]==0xff)
+        for(i=0;i< 4;i++)
+        {
+            if(u6_addr8[15-i] != ((tmp>>(i*8))&0xff))
+                return 0;
+        }
+        else
+            return 0;
+
+
+#else
+	if (name_server != probe_addr.sin_addr.s_addr)
+		return 0;
+#endif
+
+#ifdef DNS_PROBE
+	probe_tried = 0;
+	probe_next_time = time(NULL) + DNS_PROBE_INTERVAL;
+#endif
+
+	dns_probe_switchback();
+	debug("probe_activate: done\n");
+	return 1;
+}
+
+/* Activate name server if it's the response for probing request */
+int dns_probe_response(dns_request_t *m)
+{
+#ifdef DNS_PROBE
+	if (m->message.header.flags.flags & 0x8000 &&
+	    m->message.header.id != probe_id)
+		return 0;
+
+
+#if defined(DMP_X_BROADCOM_COM_IPV6_1) || defined(AEI_CONTROL_LAYER)
+          /* mwang: this is clearly wrong, need ipv6-review here */
+		  return dns_probe_activate((uint32) m->src_addr.s6_addr);
+#else
+		  return dns_probe_activate(m->src_addr.s_addr);
+#endif
+#else
+	return 0;
+#endif
+}
+
+#ifdef SUPPORT_DEBUG_TOOLS
+void dns_probe_print(void)
+{
+   printf("primary_ns=%s secondary_ns=%s\n", primary_ns, secondary_ns);
+#ifndef DNS_PROBE
+   printf("dns_recover_time=%d\n", (int) dns_recover_time);
+#endif
+}
+#endif  /* SUPPORT_DEBUG_TOOLS */
diff -Naur dproxy-nexgen/dns_probe.h dproxy-nexgen-brcm/dns_probe.h
--- dproxy-nexgen/dns_probe.h	1969-12-31 20:00:00.000000000 -0400
+++ dproxy-nexgen-brcm/dns_probe.h	2018-11-23 22:41:44.389484024 -0400
@@ -0,0 +1,20 @@
+#ifndef _DNS_PROBE_H_
+#define _DNS_PROBE_H_
+
+/* Passive mode macros */
+#define DNS_RECOVER_TIMEOUT 30
+
+extern int dns_probe(void);
+extern int dns_probe_init(void);
+extern int dns_probe_is_primary_up(void);
+extern void dns_probe_switchback(void);
+extern int dns_probe_response(dns_request_t *m);
+extern int dns_probe_activate(uint32_t name_server);
+#ifndef DNS_PROBE
+extern void dns_probe_set_recover_time(void);
+#endif
+#if defined(DNS_PROBE) && defined(AEI_VDSL_DNS_PROBE)
+extern void dns_probe_time_init(void);
+#endif
+
+#endif /* _DNS_PROBE_H_ */
diff -Naur dproxy-nexgen/dns_subnet.c dproxy-nexgen-brcm/dns_subnet.c
--- dproxy-nexgen/dns_subnet.c	1969-12-31 20:00:00.000000000 -0400
+++ dproxy-nexgen-brcm/dns_subnet.c	2018-11-23 22:41:44.389484024 -0400
@@ -0,0 +1,243 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <linux/sockios.h>
+#include <netinet/in.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <syslog.h>
+#include <linux/if.h>
+#include "dproxy.h"
+#include "dns_decode.h"
+#include "conf.h"
+#include "dns_list.h"
+#include "dns_construct.h"
+#include "dns_io.h"
+#include "dns_dyn_cache.h"
+#include "dns_probe.h"
+
+
+
+/* Used for the interface grouping where the incoming lan ip will be  used to check against 
+ * the lanSubnet/lanMask for the correct dns.  Currently, only the dns1 will be used which means
+ * dnsprobe will only work on the default WAN connection (dns from /etc/resolv.conf)
+ */
+typedef struct _SubnetDnsPair
+{
+    /* LAN IPv4 address */
+   struct in_addr lanSubnet;
+   struct in_addr lanMask;
+   char *dns1;
+   char *dns2;
+   struct _SubnetDnsPair *next;
+} SubnetDnsPair;
+
+static SubnetDnsPair *head = NULL;
+
+
+void dns_sunbet_init(void)
+{
+   FILE *fp;
+   char wanIfName[CMS_IFNAME_LENGTH] = {0};
+   char subnetCidr[CMS_IPADDR_LENGTH] = {0};
+   char dnsList[5 * CMS_IPADDR_LENGTH] = {0};   /* make space for 5 dns entries in case  they have that many */
+   char dns1[CMS_IPADDR_LENGTH];
+   char dns2[CMS_IPADDR_LENGTH];
+   char line[BUFLEN_128];
+   SubnetDnsPair *curr = NULL;
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+   SubnetDnsPair *next = NULL;
+#endif
+   UBOOL8 done = FALSE;
+   struct in_addr lanSubnet;
+   struct in_addr lanMask;
+   char *curPtr;
+   char *nullPtr;
+   
+   if ((fp = fopen(WAN_DNS_SUBNET_FILE, "r")) == NULL)
+   {
+      cmsLog_notice(" %s does not exist.", WAN_DNS_SUBNET_FILE);
+      return;
+   }
+
+   /* First free the linked list */
+   curr = head;
+   while (curr)
+   {
+      cmsLog_notice("Free subnet=%X, mask=%X, dns1=%s, dns2=%s",
+                    curr->lanSubnet,  curr->lanMask,
+                    curr->dns1, curr->dns2);
+      cmsMem_free(curr->dns1);
+      cmsMem_free(curr->dns2);
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+/*QA-Bug #101962 fix,'head' is not freed clean*/
+      next = curr->next;
+      cmsMem_free(curr);
+      curr = next;
+#else
+      curr = curr->next;
+      cmsMem_free(curr);
+#endif
+   }
+   head = NULL;
+   
+   while (!done &&  fgets(line, sizeof(line), fp))
+   {
+      curPtr = line;
+      if ((nullPtr = strchr(curPtr, ';')) != NULL)
+      {
+         *nullPtr = '\0';
+#if defined(AEI_COVERITY_FIX)
+         /*CID 12231: Destination buffer too small*/
+         strlcpy(wanIfName, curPtr, sizeof(wanIfName));
+#else
+         strcpy(wanIfName, curPtr);
+#endif
+         curPtr = nullPtr + 1;         
+      }
+      
+      if ((nullPtr = strchr(curPtr, ';')) != NULL)
+      {
+         *nullPtr = '\0';
+         strcpy(subnetCidr, curPtr);
+         curPtr = nullPtr + 1;         
+      }
+      
+      sprintf(dnsList, "%s", curPtr);
+
+      /* get rid of '\n' */
+#if defined(AEI_COVERITY_FIX)
+      /*CID 12157:Stray semicolon*/
+      if (dnsList[strlen(dnsList) -1] == '\n')
+#else
+      if (dnsList[strlen(dnsList) -1] == '\n');
+#endif
+      {
+         dnsList[strlen(dnsList) - 1] = '\0';
+      }
+      
+      cmsLog_notice("wanif=%s, subnetCidr=%s, dnsList=%s", wanIfName,  subnetCidr, dnsList);
+
+      if (cmsUtl_parseDNS(dnsList, dns1, dns2, TRUE) != CMSRET_SUCCESS)
+      {
+         /* fix resource leak, coverity id 11833 */
+#if defined(AEI_COVERITY_FIX)
+         fclose(fp);
+#endif
+         cmsLog_error("Failed to parse dns list %s", dnsList);
+         return;
+      }
+
+      if (!IS_EMPTY_STRING(subnetCidr))
+      {
+         cmsNet_inet_cidrton(subnetCidr, &lanSubnet, &lanMask);
+         if (lanSubnet.s_addr != 0 && lanMask.s_addr != 0)
+         {
+            if ((cmsUtl_parseDNS(dnsList, dns1, dns2, TRUE)) == CMSRET_SUCCESS)
+            {
+               if ((curr = cmsMem_alloc(sizeof(SubnetDnsPair), ALLOC_ZEROIZE)) != NULL)
+               {
+                  curr->dns1 = cmsMem_strdup(dns1);
+                  curr->dns2 = cmsMem_strdup(dns2);
+                  curr->lanSubnet  = lanSubnet;
+                  curr->lanMask = lanMask;
+                  curr->next = head;
+                  head = curr;
+               }
+               else
+               {
+                  cmsLog_error("Failed to allocate memory.");
+                  done = TRUE;
+               }              
+            }
+            else
+            {
+               cmsLog_error("Failed to parse dns list %s.", dnsList);
+               done = TRUE;
+            }
+
+         }
+         else
+         {
+            cmsLog_error("Failed to convert LAN subnet/mask from %s.", subnetCidr);
+            done = TRUE;
+         }
+      }
+      wanIfName[0] = '\0';
+      subnetCidr[0]= '\0';
+      dnsList[0] = '\0';
+      
+   }
+
+   curr = head;
+   while (curr)
+   {
+      cmsLog_notice("subnet=%s", inet_ntoa(curr->lanSubnet));
+      cmsLog_notice("mask=%s, dns1=%s, dns2=%s",
+                    inet_ntoa(curr->lanMask), curr->dns1, curr->dns2);
+      curr = curr->next;
+   }
+
+   fclose(fp);
+}
+
+#if defined(DMP_X_BROADCOM_COM_IPV6_1) || defined(AEI_CONTROL_LAYER)
+UBOOL8 dns_subnet_map(struct in6_addr *lanIp, char *dns1)
+#else
+UBOOL8 dns_subnet_map(struct in_addr *lanIp, char *dns1)
+#endif
+ {
+   UBOOL8 found = FALSE;
+   SubnetDnsPair *curr = head;
+   
+   if (dns1 == NULL)
+   {
+      cmsLog_error("Invalid dns1 parameter");
+      return found;
+   }
+
+   while (!found && curr)
+   {
+
+#if defined(DMP_X_BROADCOM_COM_IPV6_1) || defined(AEI_CONTROL_LAYER)
+	   /* need ipv6-review, for now fail compare */
+	  if (0)
+#else
+      if ( (lanIp->s_addr & curr->lanMask.s_addr) == curr->lanSubnet.s_addr)
+#endif
+      {
+         /* same subnet found and need to get the dns1 */
+         found = TRUE;
+         strcpy(dns1, curr->dns1);
+         /* todo: currently probe only supported for the default wan interface (dns from /etc/resolv.con)
+         * and if probing is needed for other wan interface, dns2 need to be used 
+         */
+#ifndef DMP_X_BROADCOM_COM_IPV6_1
+         /* need ipv6-review */
+#ifndef AEI_CONTROL_LAYER
+         cmsLog_notice("Found dns %s for subnet %s", dns1, inet_ntoa(*lanIp));
+#endif
+#endif
+      }
+      else
+      {
+         curr = curr->next;
+         cmsLog_notice("Not found. get next one");
+      }
+   }
+
+   return found;
+   
+ }
+
+
+
+
+
+
diff -Naur dproxy-nexgen/dproxy.c dproxy-nexgen-brcm/dproxy.c
--- dproxy-nexgen/dproxy.c	2000-03-19 20:50:50.000000000 -0400
+++ dproxy-nexgen-brcm/dproxy.c	2018-11-23 22:41:44.389484024 -0400
@@ -1,328 +1,1111 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <string.h>
-#include <arpa/inet.h>
-#include <errno.h>
-#include <stdarg.h>
-#include <signal.h>
-#include <syslog.h>
-
-#include "dproxy.h"
-#include "dns_decode.h"
-#include "cache.h"
-#include "conf.h"
-#include "dns_list.h"
-#include "dns_construct.h"
-#include "dns_io.h"
-/*****************************************************************************/
-/*****************************************************************************/
-int dns_main_quit;
-int dns_sock;
-fd_set rfds;
-dns_request_t *dns_request_list;
-/*****************************************************************************/
-int is_connected()
-{
-  FILE *fp;
-
-  if(!config.ppp_detect)return 1;
-
-  fp = fopen( config.ppp_device_file, "r" );
-  if(!fp)return 0;
-  fclose(fp);
-  return 1;
-}
-/*****************************************************************************/
-int dns_init()
-{
-  struct sockaddr_in sa;
-  struct in_addr ip;
-
-  /* Clear it out */
-  memset((void *)&sa, 0, sizeof(sa));
-    
-  dns_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
-
-  /* Error */
-  if( dns_sock < 0 ){
-	 debug_perror("Could not create socket");
-	 exit(1);
-  } 
-
-  ip.s_addr = INADDR_ANY;
-  sa.sin_family = AF_INET;
-  memcpy((void *)&sa.sin_addr, (void *)&ip, sizeof(struct in_addr));
-  sa.sin_port = htons(PORT);
-  
-  /* bind() the socket to the interface */
-  if (bind(dns_sock, (struct sockaddr *)&sa, sizeof(struct sockaddr)) < 0){
-	 debug_perror("dns_init: bind: Could not bind to port");
-	 exit(1);
-  }
-
-  dns_main_quit = 0;
-
-  FD_ZERO( &rfds );
-  FD_SET( dns_sock, &rfds );
-
-  dns_request_list = NULL;
-
-  cache_purge( config.purge_time );
-  
-  return 1;
-}
-/*****************************************************************************/
-void dns_handle_new_query(dns_request_t *m)
-{
-  struct in_addr in;
-  int retval = -1;
-
-  if( m->message.question[0].type == A || m->message.question[0].type == AAA){
-    /* standard query */
-    retval = cache_lookup_name( m->cname, m->ip );
-  }else if( m->message.question[0].type == PTR ){
-    /* reverse lookup */
-    retval = cache_lookup_ip( m->ip, m->cname );
-  }
-
-  debug(".......... %s ---- %s\n", m->cname, m->ip );
-  
-  switch( retval )
-    {
-    case 0:
-      if( is_connected() ){
-	debug("Adding to list-> id: %d\n", m->message.header.id);
-	dns_request_list = dns_list_add( dns_request_list, m );
-	/* relay the query untouched */
-	inet_aton( config.name_server, &in );
-	dns_write_packet( dns_sock, in, PORT, m );
-      }else{
-	debug("Not connected **\n");
-	dns_construct_error_reply(m);
-	dns_write_packet( dns_sock, m->src_addr, m->src_port, m );
-      }
-      break;
-    case 1:
-      dns_construct_reply( m );
-      dns_write_packet( dns_sock, m->src_addr, m->src_port, m );
-      debug("Cache hit\n");
-      break;
-    default:
-      debug("Unknown query type: %d\n", m->message.question[0].type );
-    }
-
-}
-/*****************************************************************************/
-void dns_handle_request(dns_request_t *m)
-{
-  dns_request_t *ptr = NULL;
-
-  /* request may be a new query or a answer from the upstream server */
-  ptr = dns_list_find_by_id( dns_request_list, m );
-
-  if( ptr != NULL ){
-    debug("Found query in list\n");
-    /* message may be a response */
-    if( m->message.header.flags.f.question == 1 ){
-      dns_write_packet( dns_sock, ptr->src_addr, ptr->src_port, m );
-      debug("Replying with answer from %s\n", inet_ntoa( m->src_addr ));
-      dns_request_list = dns_list_remove( dns_request_list, ptr );
-      if( m->message.header.flags.f.rcode == 0 ){ // lookup was succesful
-	debug("Cache append: %s ----> %s\n", m->cname, m->ip );
-	cache_name_append( m->cname, m->ip );
-      }
-    }else{
-      debug("Duplicate query\n");
-    }
-  }else{
-    dns_handle_new_query( m );
-  }
-
-}
-/*****************************************************************************/
-int dns_main_loop()
-{
-  struct timeval tv;
-  fd_set active_rfds;
-  int retval;
-  dns_request_t m;
-  dns_request_t *ptr, *next;
-  int purge_time = config.purge_time / 60;
-
-  while( !dns_main_quit ){
-
-    /* set the one second time out */
-    tv.tv_sec = 1;
-    tv.tv_usec = 0;
-
-    /* now copy the main rfds in the active one as it gets modified by select*/
-    active_rfds = rfds;
-
-    retval = select( FD_SETSIZE, &active_rfds, NULL, NULL, &tv );
-
-    if (retval){
-      /* data is now available */
-      dns_read_packet( dns_sock, &m );
-      dns_handle_request( &m );
-    }else{
-      /* select time out */
-      ptr = dns_request_list;
-      while( ptr ){
-	next = ptr->next;
-	ptr->time_pending++;
-	if( ptr->time_pending > DNS_TIMEOUT ){
-	  debug("Request timed out\n");
-	  /* send error back */
-	  dns_construct_error_reply(ptr);
-	  dns_write_packet( dns_sock, ptr->src_addr, ptr->src_port, ptr );
-	  dns_request_list = dns_list_remove( dns_request_list, ptr );
-	}
-	ptr = next;
-      } /* while(ptr) */
-
-      /* purge cache */
-      purge_time--;
-      if( !purge_time ){
-	cache_purge( config.purge_time );
-	purge_time = config.purge_time / 60;
-      } 
-
-    } /* if (retval) */
-  }  
-  return 0;
-}
-/*****************************************************************************/
-void debug_perror( char * msg ) {
-	debug( "%s : %s\n" , msg , strerror(errno) );
-}
-/*****************************************************************************/
-void debug(char *fmt, ...)
-{
-#define MAX_MESG_LEN 1024
-  
-  va_list args;
-  char text[ MAX_MESG_LEN ];
-  
-  sprintf( text, "[ %d ]: ", getpid());
-  va_start (args, fmt);
-  vsnprintf( &text[strlen(text)], MAX_MESG_LEN - strlen(text), fmt, args);
-  va_end (args);
-  
-  if( config.debug_file[0] ){
-    FILE *fp;
-    fp = fopen( config.debug_file, "a");
-    if(!fp){
-      syslog( LOG_ERR, "could not open log file %m" );
-      return;
-    }
-    fprintf( fp, "%s", text);
-    fclose(fp);
-  }
-  
-  /** if not in daemon-mode stderr was not closed, use it. */
-  if( ! config.daemon_mode ) {
-    fprintf( stderr, "%s", text);
-  }
-}
-/*****************************************************************************
- * print usage informations to stderr.
- * 
- *****************************************************************************/
-void usage(char * program , char * message ) {
-  fprintf(stderr,"%s\n" , message );
-  fprintf(stderr,"usage : %s [-c <config-file>] [-d] [-h] [-P]\n", program );
-  fprintf(stderr,"\t-c <config-file>\tread configuration from <config-file>\n");
-  fprintf(stderr,"\t-d \t\trun in debug (=non-daemon) mode.\n");
-  fprintf(stderr,"\t-P \t\tprint configuration on stdout and exit.\n");
-  fprintf(stderr,"\t-h \t\tthis message.\n");
-}
-/*****************************************************************************
- * get commandline options.
- * 
- * @return 0 on success, < 0 on error.
- *****************************************************************************/
-int get_options( int argc, char ** argv ) 
-{
-  char c = 0;
-  int not_daemon = 0;
-  int want_printout = 0;
-  char * progname = argv[0];
-
-  conf_defaults();
-
-  while( (c = getopt( argc, argv, "c:dhP")) != EOF ) {
-    switch(c) {
-	 case 'c':
-  		conf_load(optarg);
-		break;
-	 case 'd':
-		not_daemon = 1;
-		break;
-	 case 'h':
-		usage(progname,"");
-		return -1;
-	 case 'P':
-		want_printout = 1;
-		break;
-	 default:
-		usage(progname,"");
-		return -1;
-    }
-  }
-  
-  /** unset daemon-mode if -d was given. */
-  if( not_daemon ) {
-	 config.daemon_mode = 0;
-  }
-  
-  if( want_printout ) {
-	 conf_print();
-	 exit(0);
-  }
-  return 0;
-}
-/*****************************************************************************/
-void sig_hup (int signo)
-{
-  signal(SIGHUP, sig_hup); /* set this for the next sighup */
-  conf_load (config.config_file);
-}
-/*****************************************************************************/
-int main(int argc, char **argv)
-{
-
-  /* get commandline options, load config if needed. */
-  if(get_options( argc, argv ) < 0 ) {
-	  exit(1);
-  }
-
-  signal(SIGHUP, sig_hup);
-
-  dns_init();
-
-  if (config.daemon_mode) {
-    /* Standard fork and background code */
-    switch (fork()) {
-	 case -1:	/* Oh shit, something went wrong */
-		debug_perror("fork");
-		exit(-1);
-	 case 0:	/* Child: close off stdout, stdin and stderr */
-		close(0);
-		close(1);
-		close(2);
-		break;
-	 default:	/* Parent: Just exit */
-		exit(0);
-    }
-  }
-
-  dns_main_loop();
-
-  return 0;
-}
-
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <netdb.h>
+#include <sys/socket.h>
+#include <linux/sockios.h>
+#include <netinet/in.h>
+#include <string.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <signal.h>
+#include <syslog.h>
+#include <linux/if.h>
+#include <sys/stat.h>
+#include "dproxy.h"
+#include "dns_decode.h"
+#include "cache.h"
+#include "conf.h"
+#include "dns_list.h"
+#include "dns_construct.h"
+#include "dns_io.h"
+#include "dns_dyn_cache.h"
+#include "dns_mapping.h"
+#include "prctl.h"
+
+/*****************************************************************************/
+/*****************************************************************************/
+int dns_main_quit;
+int dns_sock[2]={-1, -1};
+fd_set rfds;
+
+#if defined(DMP_X_BROADCOM_COM_IPV6_1) || defined(AEI_CONTROL_LAYER) /*added by libby 2012-04-25*/
+char *name_server_ipv6;
+#endif
+
+//BRCM
+int dns_querysock[2]={-1, -1};
+#ifdef DMP_X_ITU_ORG_GPON_1
+static unsigned int dns_query_error = 0;
+#endif
+
+/* CMS message handle */
+void *msgHandle=NULL;
+int msg_fd;
+
+#ifdef SUPPORT_GPL_UNDEFINED
+static int isWebsiteBlock(char *dnsName,char *dnsIp);
+static void get_lanip (char *ip, int len);
+#endif
+
+#if defined(AEI_VDSL_DNS_CACHE)
+time_t syn_time=0;
+int enable_dns_cache=0;
+
+int dns_cache_enabled()
+{
+   time_t t=time(NULL);
+   if (t-syn_time>3)
+   {
+	syn_time=t;
+	struct stat stats;
+	if(stat("/var/dns_cache", &stats) == 0)
+	  enable_dns_cache=1;
+	else
+	  enable_dns_cache=0;
+   }
+   return enable_dns_cache;
+
+}
+#endif
+
+/*****************************************************************************/
+int dns_init()
+{
+  struct addrinfo hints, *res, *p;
+  int errcode;
+  int ret, i, on=1;
+
+  memset(&hints, 0, sizeof (hints));
+  hints.ai_family = AF_UNSPEC;
+  hints.ai_socktype = SOCK_DGRAM;
+  hints.ai_flags = AI_PASSIVE;
+
+  /*
+   * BRCM:
+   * Open sockets to receive DNS queries from LAN.
+   * dns_sock[0] is used for DNS queries over IPv4
+   * dns_sock[1] is used for DNS queries over IPv6
+   */
+  errcode = getaddrinfo(NULL, PORT_STR, &hints, &res);
+  if (errcode != 0)
+  {
+     debug("gai err %d %s", errcode, gai_strerror(errcode));
+     exit(1) ;
+  }
+
+  p = res;
+  while (p)
+  {
+     if ( p->ai_family == AF_INET )   i = 0;
+     else if ( p->ai_family == AF_INET6 )   i = 1;
+     else {
+        debug_perror("Unknown protocol!!\n");
+        goto next_lan;
+     }
+
+     dns_sock[i] = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
+
+     if (dns_sock[i] < 0)
+     {
+        debug("Could not create dns_sock[%d]", i);
+        goto next_lan;
+     }
+
+#ifdef IPV6_V6ONLY
+     if ( (p->ai_family == AF_INET6) && 
+          (setsockopt(dns_sock[i], IPPROTO_IPV6, IPV6_V6ONLY, 
+                      &on, sizeof(on)) < 0) )
+     {
+        debug_perror("Could not set IPv6 only option for LAN");
+        close(dns_sock[i]);
+        goto next_lan;
+     }
+#endif
+
+     /* bind() the socket to the interface */
+     if (bind(dns_sock[i], p->ai_addr, p->ai_addrlen) < 0){
+        debug("dns_init: bind: dns_sock[%d] can't bind to port", i);
+        close(dns_sock[i]);
+     }
+
+next_lan:
+     p = p->ai_next;
+  }
+
+  freeaddrinfo(res);
+
+  if ( (dns_sock[0] < 0) && (dns_sock[1] < 0) )
+  {
+     debug_perror("Cannot create sockets for LAN");
+     exit(1) ;
+  }
+
+  /*
+   * BRCM:
+   * use different sockets to send queries to WAN so we can use ephemeral port
+   * dns_querysock[0] is used for DNS queries sent over IPv4
+   * dns_querysock[1] is used for DNS queries sent over IPv6
+   */
+  errcode = getaddrinfo(NULL, "0", &hints, &res);
+  if (errcode != 0)
+  {
+     debug("gai err %d %s", errcode, gai_strerror(errcode));
+     exit(1) ;
+  }
+
+  p = res;
+  while (p)
+  {
+     if ( p->ai_family == AF_INET )   i = 0;
+     else if ( p->ai_family == AF_INET6 )   i = 1;
+     else
+     {
+        debug_perror("Unknown protocol!!\n");
+        goto next_wan;
+     }
+
+     dns_querysock[i] = socket(p->ai_family, p->ai_socktype, 
+                               p->ai_protocol);
+
+     if (dns_querysock[i] < 0)
+     {
+        debug("Could not create dns_querysock[%d]", i);
+        goto next_wan;
+     }
+
+#ifdef IPV6_V6ONLY
+     if ( (p->ai_family == AF_INET6) && 
+          (setsockopt(dns_querysock[i], IPPROTO_IPV6, IPV6_V6ONLY, 
+                     &on, sizeof(on)) < 0) )
+     {
+        debug_perror("Could not set IPv6 only option for WAN");
+        close(dns_querysock[i]);
+        goto next_wan;
+     }
+#endif
+
+     /* bind() the socket to the interface */
+     if (bind(dns_querysock[i], p->ai_addr, p->ai_addrlen) < 0){
+        debug("dns_init: bind: dns_querysock[%d] can't bind to port", i);
+        close(dns_querysock[i]);
+     }
+
+next_wan:
+     p = p->ai_next;
+  }
+
+  freeaddrinfo(res);
+
+  if ( (dns_querysock[0] < 0) && (dns_querysock[1] < 0) )
+  {
+     debug_perror("Cannot create sockets for WAN");
+     exit(1) ;
+  }
+
+  // BRCM: Connect to ssk
+  if ((ret = cmsMsg_initWithFlags(EID_DNSPROXY, 0, &msgHandle)) != CMSRET_SUCCESS) {
+  	debug_perror("dns_init: cmsMsg_init() failed");
+	exit(1);
+  }
+  cmsMsg_getEventHandle(msgHandle, &msg_fd);
+
+  dns_main_quit = 0;
+
+  FD_ZERO( &rfds );
+  if (dns_sock[0] > 0)
+     FD_SET( dns_sock[0], &rfds );
+  if (dns_sock[1] > 0)  
+     FD_SET( dns_sock[1], &rfds );
+  if (dns_querysock[0] > 0)  
+     FD_SET( dns_querysock[0], &rfds );
+  if (dns_querysock[1] > 0)  
+     FD_SET( dns_querysock[1], &rfds );
+
+  FD_SET( msg_fd, &rfds );
+
+#ifdef DNS_DYN_CACHE
+  dns_dyn_hosts_add();
+#endif
+
+#if defined(AEI_VDSL_DNS_CACHE)
+  cache_purge( config.purge_time );
+#endif
+
+  return 1;
+}
+
+
+/*****************************************************************************/
+void dns_handle_new_query(dns_request_t *m)
+{
+   int retval = -1;
+   dns_dyn_list_t *dns_entry;
+   char srcIP[INET6_ADDRSTRLEN];
+   int query_type = m->message.question[0].type;
+
+   if( query_type == A )
+   {
+      retval = 0;         
+#ifdef DNS_DYN_CACHE
+#if defined(AEI_VDSL_DNS_CACHE)
+    retval = cache_lookup_name( m->cname, m->ip );
+#ifdef AEI_CONTROL_LAYER
+    if (0==retval)
+    {
+        char name_app[128] = {0};
+        snprintf( name_app, sizeof(name_app)-1, "[%s]", m->cname );
+        retval = cache_lookup_name( name_app, m->ip );
+        if (retval==1)
+            retval= 5;
+    }
+#endif
+
+    if(0 == retval)
+    {
+        if(!dns_cache_enabled())
+            retval = 0;
+        else
+        {
+#endif
+      if ((dns_entry = dns_dyn_find(m))) 
+      {
+#if defined(AEI_COVERITY_FIX)
+          /*CID 12232: Copy into fixed size buffer*/
+          strlcpy(m->ip, inet_ntoa(dns_entry->addr), sizeof(m->ip));
+#else
+         strcpy(m->ip, inet_ntoa(dns_entry->addr));
+#endif
+         m->ttl = abs(dns_entry->expiry - time(NULL));
+         retval = 1;
+#ifndef AEI_CONTROL_LAYER
+         debug(".... %s, srcPort=%d, retval=%d\n", m->cname, ((struct sockaddr_in *)&m->src_info)->sin_port, retval); 
+#endif
+      }
+#if defined(AEI_VDSL_DNS_CACHE)
+        }
+    }
+#endif
+#endif      
+   }
+   else if( query_type == AAA)
+   { /* IPv6 todo */
+#if defined(AEI_CONTROL_LAYER)
+		/*modify by libby support IPV6*/
+#ifdef AEI_VDSL_DNS_CACHE
+		char name_app[128] = {0};
+		snprintf( name_app, sizeof(name_app)-1, "[%s]", m->cname );
+		retval = cache_lookup_name( name_app, m->ip );
+		//strcpy(m->cname,name_app);
+		if( 1 != retval )
+#endif
+#endif
+
+// To support query to WAN IPv6 DNS server (retval == 6),
+// must implement CMS_MSG_DNSPROXY_IPV6_CHANGED to notice IPv6 DNS server info change.
+#if defined(AEI_CONTROL_LAYER)
+		{
+			debug(" remote ipv6 dns server address is %s\n", name_server_ipv6 );
+			if(name_server_ipv6)
+			{
+				retval = 6;
+			}
+			else
+			{
+				retval = 0;
+			}
+		}
+#else
+     retval = 0;
+#endif
+   }
+   else if( query_type == PTR ) 
+   {
+      retval = 0;   
+      /* reverse lookup */
+#ifdef DNS_DYN_CACHE
+#ifdef AEI_VDSL_DNS_CACHE
+        if(!dns_cache_enabled())
+            retval = 0;
+        else
+        {
+#endif
+      if ((dns_entry = dns_dyn_find(m))) 
+      {
+#if defined(AEI_COVERITY_FIX)
+          /*CID 12232: Copy into fixed size buffer*/
+          strlcpy(m->cname, dns_entry->cname, sizeof(m->cname));
+#else
+         strcpy(m->cname, dns_entry->cname);
+#endif
+         m->ttl = abs(dns_entry->expiry - time(NULL));
+         retval = 1;
+#ifndef AEI_CONTROL_LAYER
+         debug("TYPE==PTR.... %s, srcPort=%d, retval=%d\n", m->cname,  ((struct sockaddr_in *)&m->src_info)->sin_port, retval); 
+#endif
+         
+      }
+#ifdef AEI_VDSL_DNS_CACHE
+        }
+#endif
+#endif
+   }  
+   else /* BRCM:  For all other query_type including TXT, SPF... */
+   {
+       retval = 0;
+   }
+   
+   inet_ntop( m->src_info.ss_family, 
+              get_in_addr(&m->src_info), 
+              srcIP, INET6_ADDRSTRLEN );
+   cmsLog_notice("dns_handle_new_query: %s %s, srcPort=%d, retval=%d\n", 
+                  m->cname, srcIP, 
+                  ((struct sockaddr_in *)&m->src_info)->sin_port, 
+                  retval);
+   
+  switch( retval )
+  {
+     case 0:
+     {
+        char dns1[INET6_ADDRSTRLEN];
+        int proto;
+
+        if (dns_mapping_find_dns_ip(&(m->src_info), query_type, 
+                                    dns1, &proto) == TRUE)
+        {
+           struct sockaddr_storage sa;
+           int sock;
+
+           cmsLog_notice("Found dns %s for subnet %s", dns1, srcIP);
+           dns_list_add(m);
+
+           if (proto == AF_INET)
+           {
+              sock = dns_querysock[0];
+              ((struct sockaddr_in *)&sa)->sin_port = htons(PORT);
+              inet_pton(proto, dns1, &(((struct sockaddr_in *)&sa)->sin_addr));
+           }
+           else
+           {
+              sock = dns_querysock[1];
+              ((struct sockaddr_in6 *)&sa)->sin6_port = htons(PORT);
+              inet_pton( proto, dns1, 
+                         &(((struct sockaddr_in6 *)&sa)->sin6_addr) );
+           }
+           sa.ss_family = proto;
+           dns_write_packet( sock, &sa, m );
+        }
+        else
+        {
+            cmsLog_debug("No dns service.");
+        }   
+        break;
+     }
+
+     case 1:
+        dns_construct_reply( m );
+        /* Only IPv4 can support caching now */
+        dns_write_packet(dns_sock[0], &m->src_info, m);
+        break;
+
+     default:
+        debug("Unknown query type: %d\n", query_type);
+   }
+}
+/*****************************************************************************/
+void dns_handle_request(dns_request_t *m)
+{
+  dns_request_t *ptr = NULL;
+
+  /* request may be a new query or a answer from the upstream server */
+  ptr = dns_list_find_by_id(m);
+
+  if( ptr != NULL ){
+      debug("Found query in list; id 0x%04x flags 0x%04x\n ip %s - cname %s\n", 
+             m->message.header.id, m->message.header.flags.flags, 
+             m->ip, m->cname);
+
+      /* message may be a response */
+      if( m->message.header.flags.flags & 0x8000)
+      {
+          int sock;
+          char srcIP[INET6_ADDRSTRLEN];
+
+          if (ptr->src_info.ss_family == AF_INET)
+             sock = dns_sock[0];
+          else
+             sock = dns_sock[1];
+
+          inet_ntop( m->src_info.ss_family, 
+                     get_in_addr(&m->src_info), 
+                     srcIP, INET6_ADDRSTRLEN );
+   
+          debug("Replying with answer from %s, id 0x%04x\n", 
+                 srcIP, m->message.header.id);
+          dns_write_packet( sock, &ptr->src_info, m );
+          dns_list_remove( ptr );         
+          
+#ifdef DMP_X_ITU_ORG_GPON_1
+          if( m->message.header.flags.f.rcode != 0 ){ // lookup failed
+              dns_query_error++;
+              debug("dns_query_error = %u\n", dns_query_error);
+          }
+#endif
+
+#ifdef DNS_DYN_CACHE
+#ifdef AEI_VDSL_DNS_CACHE
+      if(dns_cache_enabled())
+#endif
+          if( m->message.question[0].type != AAA) /* No cache for IPv6 */
+          {
+             dns_dyn_cache_add(m);
+          }
+#endif
+      }
+      else
+      {
+         debug( "Duplicate query to %s (retx_count=%d)", 
+                m->cname, ptr->retx_count );
+
+         if (ptr->retx_count < MAX_RETX_COUNT)
+         {
+            char dns1[INET6_ADDRSTRLEN];
+            int proto;
+
+            debug("=>send again\n");
+            ptr->retx_count++;
+            cmsLog_debug("retx_count=%d", ptr->retx_count);
+
+            if (dns_mapping_find_dns_ip(&(m->src_info), 
+                                        m->message.question[0].type, 
+                                        dns1, &proto) == TRUE)
+            {
+               struct sockaddr_storage sa;
+               int sock;
+
+               if (proto == AF_INET)
+               {
+                  sock = dns_querysock[0];
+                  ((struct sockaddr_in *)&sa)->sin_port = PORT;
+                  inet_pton( proto, dns1, 
+                             &(((struct sockaddr_in *)&sa)->sin_addr) );
+               }
+               else
+               {
+                  sock = dns_querysock[1];
+                  ((struct sockaddr_in6 *)&sa)->sin6_port = PORT;
+                  inet_pton( proto, dns1, 
+                             &(((struct sockaddr_in6 *)&sa)->sin6_addr) );
+               }
+               sa.ss_family = proto;
+               dns_write_packet( sock, &sa, m );
+            }
+            else
+            {
+               cmsLog_debug("No dns service for duplicate query??");
+            }   
+         }
+         else
+         {
+            debug("=>drop! retx limit reached.\n");
+         }
+      }
+  }
+  else
+  {
+      dns_handle_new_query( m );
+  }
+
+  debug("dns_handle_request: done\n\n");
+}
+
+/*****************************************************************************/
+static void processCmsMsg(void)
+{
+#ifdef AEI_COVERITY_FIX
+   /*Coverity CID 12493: Use of untrusted scalar value (TAINTED_SCALAR)*/
+   CmsMsgHeader *msg = NULL;
+#else
+  CmsMsgHeader *msg;
+#endif
+  CmsRet ret;
+
+  while( (ret = cmsMsg_receiveWithTimeout(msgHandle, &msg, 0)) == CMSRET_SUCCESS) {
+    switch(msg->type) {
+    case CMS_MSG_SET_LOG_LEVEL:
+      cmsLog_debug("got set log level to %d", msg->wordData);
+      cmsLog_setLevel(msg->wordData);
+      if ((ret = cmsMsg_sendReply(msgHandle, msg, CMSRET_SUCCESS)) != CMSRET_SUCCESS) {
+        cmsLog_error("send response for msg 0x%x failed, ret=%d", msg->type, ret);
+      }
+      break;
+    case CMS_MSG_SET_LOG_DESTINATION:
+      cmsLog_debug("got set log destination to %d", msg->wordData);
+      cmsLog_setDestination(msg->wordData);
+      if ((ret = cmsMsg_sendReply(msgHandle, msg, CMSRET_SUCCESS)) != CMSRET_SUCCESS) {
+        cmsLog_error("send response for msg 0x%x failed, ret=%d", msg->type, ret);
+      }
+      break;
+
+    case CMS_MSG_DNSPROXY_RELOAD:
+      cmsLog_debug("received CMS_MSG_DNSPROXY_RELOAD\n");
+      /* Reload config file */
+#ifdef DNS_DYN_CACHE
+      dns_dyn_hosts_add();
+#endif
+
+      /* load the /var/dnsinfo.conf into the linked list for determining
+      * which dns ip to use for the dns query.
+      */
+      dns_mapping_conifg_init();
+     
+      /*
+       * During CDRouter dhcp scaling tests, this message is sent a lot to dnsproxy.
+       * To make things more efficient/light weight, the sender of the message does
+       * not expect a reply.
+       */
+      break;
+
+#ifdef SUPPORT_DEBUG_TOOLS
+
+    case CMS_MSG_DNSPROXY_DUMP_STATUS:
+       printf("\n============= Dump dnsproxy status=====\n\n");
+       printf("WAN interface; LAN IP/MASK; Primary DNS IP,Secondary DNS IP;\n");
+       prctl_runCommandInShellBlocking("cat /var/dnsinfo.conf");
+       dns_list_print();
+       dns_dyn_print();
+       break;
+
+    case CMS_MSG_DNSPROXY_DUMP_STATS:
+       printf("stats dump not implemented yet\n");
+       break;
+
+#endif /* SUPPORT_DEBUG_TOOLS */
+
+#ifdef DMP_X_ITU_ORG_GPON_1
+    case CMS_MSG_DNSPROXY_GET_STATS:
+    {
+        char buf[sizeof(CmsMsgHeader) + sizeof(DnsGetStatsMsgBody)]={0};
+        CmsMsgHeader *replyMsgPtr = (CmsMsgHeader *) buf;
+        DnsGetStatsMsgBody *dnsStats = (DnsGetStatsMsgBody *) (replyMsgPtr+1);
+
+
+        // Setup response message.
+        replyMsgPtr->type = msg->type;
+        replyMsgPtr->dst = msg->src;
+        replyMsgPtr->src = EID_DNSPROXY;
+        replyMsgPtr->flags.all = 0;
+        replyMsgPtr->flags_response = 1;
+        //set dns query error counter 
+        replyMsgPtr->dataLength = sizeof(DnsGetStatsMsgBody);
+        dnsStats->dnsErrors = dns_query_error;
+
+        cmsLog_notice("dns query error is %d", dns_query_error);
+        // Attempt to send CMS response message & test result.
+        ret = cmsMsg_send(msgHandle, replyMsgPtr);
+        if (ret != CMSRET_SUCCESS)
+        {
+           // Log error.
+           cmsLog_error("Send message failure, cmsReturn: %d", ret);
+        }
+    }
+    break;
+#endif
+
+    default:
+      cmsLog_error("unrecognized msg 0x%x", msg->type);
+      break;
+    }
+    CMSMEM_FREE_BUF_AND_NULL_PTR(msg);
+  }
+  
+  if (ret == CMSRET_DISCONNECTED) {
+    if (!cmsFil_isFilePresent(SMD_SHUTDOWN_IN_PROGRESS)) {
+      cmsLog_error("lost connection to smd, exiting now.");
+    }
+    dns_main_quit = 1;
+  }
+}
+
+/*****************************************************************************/
+int dns_main_loop()
+{
+    struct timeval tv, *ptv;
+    fd_set active_rfds;
+    int retval;
+    dns_request_t m;
+    dns_request_t *ptr, *next;
+
+    while( !dns_main_quit )
+    {
+
+      int next_request_time = dns_list_next_time();
+      
+      if (next_request_time == 1) {
+          tv.tv_sec = next_request_time;
+          tv.tv_usec = 0;
+          ptv = &tv;
+          cmsLog_notice("select timeout = %lu seconds", tv.tv_sec);          
+       } else {
+         ptv = NULL;
+         cmsLog_debug("\n\n =============select will wait indefinitely============");          
+       }
+
+
+      /* copy the main rfds in the active one as it gets modified by select*/
+      active_rfds = rfds;
+      retval = select( FD_SETSIZE, &active_rfds, NULL, NULL, ptv );
+
+      if (retval){
+         debug("received something");
+
+         if (FD_ISSET(msg_fd, &active_rfds)) { /* message from ssk */
+            debug("received cms message");
+            processCmsMsg();
+         } else if ((dns_sock[0] > 0) && FD_ISSET(dns_sock[0], &active_rfds)) {
+            debug("received DNS message (LAN side IPv4)");
+            /* data is now available */
+            bzero(&m, sizeof(dns_request_t));
+            //BRCM                
+            if (dns_read_packet(dns_sock[0], &m) == 0) {
+/*
+ * For frontier requirement,website block use dns.so if the dns package from lan side ,then 
+ * check the request hostname whether is in the block url list, if so ,construct a response package with 
+ * ip with lan ip, and src addr with lan ip to the request's client  
+ */
+#ifdef SUPPORT_GPL_UNDEFINED               
+               char ipaddr[64]={0};
+               inet_ntop( m.src_info.ss_family,get_in_addr(&m.src_info),ipaddr, INET6_ADDRSTRLEN );               
+               //strcpy(ipaddr,inet_ntoa(m.src_addr)); 
+               if(isWebsiteBlock(m.cname,ipaddr))
+               {
+                  char lan_ip[64]={0};
+                  memset (lan_ip, 0, sizeof(lan_ip));
+                  get_lanip(lan_ip, sizeof(lan_ip)-1);
+                  if (strlen (lan_ip) == 0)
+                      strcpy(lan_ip,"192.168.254.254");
+                  strncpy(m.ip,lan_ip,sizeof(m.ip)-1);
+                  inet_pton(AF_INET, ipaddr, &(((struct sockaddr_in *)&m.src_info)->sin_addr));
+                  m.src_info.ss_family = AF_INET;
+                  dns_construct_reply( &m );
+                  dns_write_packet( dns_sock[0], &m.src_info, &m );            
+               }else
+#endif   
+               dns_handle_request( &m );
+            }
+         } else if ((dns_sock[1] > 0) && FD_ISSET(dns_sock[1], &active_rfds)) {
+            debug("received DNS message (LAN side IPv6)");
+            /* data is now available */
+            bzero(&m, sizeof(dns_request_t));
+            //BRCM
+            if (dns_read_packet(dns_sock[1], &m) == 0) {
+               dns_handle_request( &m );
+            }
+         } else if ((dns_querysock[0] > 0) && 
+                    FD_ISSET(dns_querysock[0], &active_rfds)) {
+            debug("received DNS response (WAN side IPv4)");
+            bzero(&m, sizeof(dns_request_t));
+            if (dns_read_packet(dns_querysock[0], &m) == 0)
+               dns_handle_request( &m );
+         } else if ((dns_querysock[1] > 0) && 
+                    FD_ISSET(dns_querysock[1], &active_rfds)) {
+            debug("received DNS response (WAN side IPv6)");
+            bzero(&m, sizeof(dns_request_t));
+            if (dns_read_packet(dns_querysock[1], &m) == 0)
+               dns_handle_request( &m );
+         }
+      } else { /* select time out */
+         time_t now = time(NULL);
+         ptr = dns_request_list;
+         while (ptr) {
+            next = ptr->next;
+            if (ptr->expiry <= now) {
+               char date_time_buf[DATE_TIME_BUFLEN];
+               get_date_time_str(date_time_buf, sizeof(date_time_buf));
+
+               debug("removing expired request %p\n", ptr);
+               cmsLog_notice("%s dnsproxy: query for %s timed out after %d secs (type=%d retx_count=%d)",  
+                  date_time_buf, ptr->cname, DNS_TIMEOUT, (unsigned int) ptr->message.question[0].type, ptr->retx_count);
+
+               /*  dns1 and dns2 will be swapped if possible in dns_list_remove_related_requests_and_swap call */
+               if (dns_list_remove_related_requests_and_swap(ptr)) {
+                  /* reset to the header since dns_list_remove_related_requests_and_swap may free the dns requests with 
+                  * the using the same dns ip
+                  */
+                  ptr = dns_request_list;
+                  continue;
+               }
+               
+            }
+
+            ptr = next;
+         }
+
+      } /* if (retval) */
+
+    }  /* while (!dns_main_quit) */
+   return 0;
+}
+
+
+/*
+ * Return a buffer which contains the current date/time.
+ */
+void get_date_time_str(char *buf, unsigned int buflen)
+{
+	time_t t;
+	struct tm *tmp;
+
+	memset(buf, 0, buflen);
+
+	t = time(NULL);
+	tmp = localtime(&t);
+	if (tmp == NULL) {
+		debug_perror("could not get localtime");
+		return;
+	}
+
+	strftime(buf, buflen, "[%F %k:%M:%S]", tmp);
+
+}
+
+#ifdef SUPPORT_GPL_UNDEFINED
+/*
+ * if find out the hostname and ip match the url list ,then return 1, else return 0
+ */
+#define MAX_WEB_LEN	40
+#define MAX_FOLDER_LEN	56
+static int isWebsiteBlock(char *dnsName,char *dnsIp)
+{
+    char temp[MAX_WEB_LEN + MAX_FOLDER_LEN], *temp1, *temp2, web[MAX_WEB_LEN], folder[MAX_FOLDER_LEN];
+#if defined(DMP_X_BROADCOM_COM_IPV6_1) || defined(AEI_CONTROL_LAYER)
+	char *Ip=NULL;		
+#endif    
+	FILE *f = fopen("/var/url_list", "r");
+	if (f != NULL){
+	   while (fgets(temp,96, f))
+	   {
+           char lanIP[16] = { 0 };
+           char *pos = NULL;
+           char *pe = NULL;
+           if ((pos = strchr(temp, ';')) != NULL) {
+               *pos++ = '\0';
+               if (*pos == '\0')
+                   strcpy(lanIP, "\0");
+               else {
+                   pe = strrchr(pos, '\n');
+                   if(pe)
+                       *pe = '\0';
+                }
+#if defined(AEI_COVERITY_FIX)
+               //CID 33160: Copy into fixed size buffer(STRING_OVERFLOW)
+               strlcpy(lanIP, pos, sizeof(lanIP));
+#else               
+               strcpy(lanIP, pos);
+#endif                
+           }
+            
+		   if (temp[0]=='h' && temp[1]=='t' && temp[2]=='t' && 
+		    	temp[3]=='p' && temp[4]==':' && temp[5]=='/' && temp[6]=='/')
+		   {
+			   temp1 = temp + 7;	
+		   }
+		   else
+		   {
+		       temp1 = temp;	
+		   }
+
+		   if ((*temp1=='w') && (*(temp1+1)=='w') && (*(temp1+2)=='w') && (*(temp1+3)=='.'))
+		   {
+			   temp1 = temp1 + 4;
+		   }
+
+		   if ((temp2 = strchr(temp1, '\n')))
+		   {
+			   *temp2 = '\0';
+		   }
+		       
+		   sscanf(temp1, "%[^/]", web);	
+		   temp1 = strchr(temp1, '/');
+		   if (temp1 == NULL)
+		   {
+			   strcpy(folder, "\0");
+		   }
+		   else
+		   {
+			   strcpy(folder, ++temp1);		
+		   }           
+//if defined ipv6, then the ip contain prefix "::ffff:", so need parse out the ipv4 address           
+#if defined(DMP_X_BROADCOM_COM_IPV6_1) || defined(AEI_CONTROL_LAYER)           
+          Ip = strtok(dnsIp,":");
+          if(Ip==NULL)
+              break;
+          while(Ip!=NULL)
+          {
+              Ip=strtok(NULL,":");
+          }
+#endif          
+          if(cmsUtl_strstr(dnsName,web)!=NULL)
+          {
+#if defined(DMP_X_BROADCOM_COM_IPV6_1) || defined(AEI_CONTROL_LAYER)              
+              if(cmsUtl_strstr(lanIP,Ip)!=NULL)
+#else
+              if(cmsUtl_strstr(lanIP,dnsIp)!=NULL)
+#endif                  
+              {
+                  fclose(f);
+                  return 1;
+              }
+              if(cmsUtl_strstr(lanIP,"all")!=NULL)
+              {
+                  fclose(f);
+                  return 1;
+              }
+          }
+	   }
+	   fclose(f);
+	}
+	else {
+	   debug("/var/url_list isn't presented.\n");
+	   return 0;
+	}
+	return 0;
+}
+
+static void get_lanip (char *ip, int len)
+{
+  FILE *fp;
+  char buffer[BUFLEN_256] = {0};
+  char host_name[BUFLEN_128] = {0};
+  char ip_address[BUFLEN_32] = {0};
+  int  i =0;
+
+  fp = fopen("/var/hosts", "r");
+  if (!fp)
+     return;
+
+  memset (buffer, 0, sizeof(buffer));
+  while (fgets(buffer, sizeof(buffer)-1, fp) != NULL) 
+  {  
+     i++;
+     memset(ip_address, 0, sizeof(ip_address));
+     memset(host_name, 0, sizeof(host_name));    
+     sscanf(buffer, "%s %s", ip_address, host_name);
+     if (i == 2)
+     {
+         if ( (strlen (host_name) > 0) && (strlen(ip_address) > 0) )
+         {
+             strncpy (ip, ip_address, len);
+         }
+         break;
+     }
+     memset (buffer, 0, sizeof(buffer));
+  }
+  fclose (fp);
+  return;
+}
+
+#endif
+/*****************************************************************************/
+void debug_perror( char * msg ) {
+	debug( "%s : %s\n" , msg , strerror(errno) );
+}
+
+#if 0 //BRCM: Mask the debug() function. It's redefined by cmsLog_debug()
+#ifdef DPROXY_DEBUG
+/*****************************************************************************/
+void debug(char *fmt, ...)
+{
+#define MAX_MESG_LEN 1024
+  
+  va_list args;
+  char text[ MAX_MESG_LEN ];
+  
+  sprintf( text, "[ %d ]: ", getpid());
+  va_start (args, fmt);
+  vsnprintf( &text[strlen(text)], MAX_MESG_LEN - strlen(text), fmt, args);	 
+  va_end (args);
+  
+  printf(text);
+#if 0 //BRCM 
+  if( config.debug_file[0] ){
+	 FILE *fp;
+	 fp = fopen( config.debug_file, "a");
+	 if(!fp){
+		syslog( LOG_ERR, "could not open log file %m" );
+		return;
+	 }
+	 fprintf( fp, "%s", text);
+	 fclose(fp);
+  }
+  
+
+  /** if not in daemon-mode stderr was not closed, use it. */
+  if( ! config.daemon_mode ) {
+	 fprintf( stderr, "%s", text);
+  }
+#endif
+}
+
+#endif
+#endif
+/*****************************************************************************
+ * print usage informations to stderr.
+ * 
+ *****************************************************************************/
+void usage(char * program , char * message ) {
+  fprintf(stderr,"%s\n" , message );
+  fprintf(stderr,"usage : %s [-c <config-file>] [-d] [-h] [-P]\n", program );
+  fprintf(stderr,"\t-c <config-file>\tread configuration from <config-file>\n");
+  fprintf(stderr,"\t-d \t\trun in debug (=non-daemon) mode.\n");
+  fprintf(stderr,"\t-D \t\tDomain Name\n");
+  fprintf(stderr,"\t-P \t\tprint configuration on stdout and exit.\n");
+  fprintf(stderr,"\t-v \t\tset verbosity, where num==0 is LOG_ERROR, 1 is LOG_NOTICE, all others is LOG_DEBUG\n");
+  fprintf(stderr,"\t-h \t\tthis message.\n");
+}
+/*****************************************************************************
+ * get commandline options.
+ * 
+ * @return 0 on success, < 0 on error.
+ *****************************************************************************/
+int get_options( int argc, char ** argv ) 
+{
+  int c = 0;
+  char * progname = argv[0];
+  SINT32 logLevelNum;
+  CmsLogLevel logLevel=DEFAULT_LOG_LEVEL;
+  //UBOOL8 useConfiguredLogLevel=TRUE;
+
+  cmsLog_initWithName(EID_DNSPROXY, argv[0]);
+
+  conf_defaults();
+#if 1 
+  while( (c = getopt( argc, argv, "cD:dhPv:")) != EOF ) {
+    switch(c) {
+	 case 'c':
+  		conf_load(optarg);
+		break;
+	 case 'd':
+		break;
+     case 'D':
+#if defined(AEI_COVERITY_FIX)
+         /*CID 12233: Copy into fixed size buffer*/
+         strlcpy(config.domain_name, optarg, sizeof(config.domain_name));
+#else
+        strcpy(config.domain_name, optarg);
+#endif
+        break;
+	 case 'h':
+		usage(progname,"");
+		return -1;
+	 case 'P':
+		break;
+         case 'v':
+         	logLevelNum = atoi(optarg);
+         	if (logLevelNum == 0)
+         	{
+            		logLevel = LOG_LEVEL_ERR;
+         	}
+         	else if (logLevelNum == 1)
+         	{
+            		logLevel = LOG_LEVEL_NOTICE;
+         	}
+         	else
+         	{
+            		logLevel = LOG_LEVEL_DEBUG;
+         	}
+         	cmsLog_setLevel(logLevel);
+         	//useConfiguredLogLevel = FALSE;
+         	break;
+	 default:
+		usage(progname,"");
+		return -1;
+    }
+  }
+#endif
+
+#if 0  
+  /** unset daemon-mode if -d was given. */
+  if( not_daemon ) {
+	 config.daemon_mode = 0;
+  }
+  
+  if( want_printout ) {
+	 conf_print();
+	 exit(0);
+  }
+#endif 
+
+  return 0;
+}
+/*****************************************************************************/
+void sig_hup (int signo)
+{
+  signal(SIGHUP, sig_hup); /* set this for the next sighup */
+  conf_load (config.config_file);
+}
+/*****************************************************************************/
+int main(int argc, char **argv)
+{
+
+  /* get commandline options, load config if needed. */
+  if(get_options( argc, argv ) < 0 ) {
+	  exit(1);
+  }
+
+  /* detach from terminal and detach from smd session group. */
+  if (setsid() < 0)
+  {
+    cmsLog_error("could not detach from terminal");
+    exit(-1);
+  }
+
+  /* ignore some common, problematic signals */
+  signal(SIGINT, SIG_IGN);
+  signal(SIGPIPE, SIG_IGN);
+
+  signal(SIGHUP, sig_hup);
+  dns_init();
+
+//BRCM: Don't fork a task again!
+#if 0 
+  if (config.daemon_mode) {
+    /* Standard fork and background code */
+    switch (fork()) {
+	 case -1:	/* Oh shit, something went wrong */
+		debug_perror("fork");
+		exit(-1);
+	 case 0:	/* Child: close off stdout, stdin and stderr */
+		close(0);
+		close(1);
+		close(2);
+		break;
+	 default:	/* Parent: Just exit */
+		exit(0);
+    }
+  }
+#endif
+  dns_main_loop();
+
+  return 0;
+}
+
diff -Naur dproxy-nexgen/dproxy.h dproxy-nexgen-brcm/dproxy.h
--- dproxy-nexgen/dproxy.h	2000-03-17 18:10:50.000000000 -0400
+++ dproxy-nexgen-brcm/dproxy.h	2018-11-23 22:41:44.389484024 -0400
@@ -1,55 +1,102 @@
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-
-#ifndef DPROXY_H
-#define DPROXY_H
-
-#define PORT 53
-#define NAME_SIZE 255
-#define MAX_PACKET_SIZE 512
-#define BUF_SIZE NAME_SIZE
-
-typedef u_int16_t uint16;
-typedef u_int32_t uint32;
-
-#include "dns.h"
-
-#ifndef DNS_TIMEOUT 
-#define DNS_TIMEOUT 240
-#endif
-#ifndef NAME_SERVER_DEFAULT
-#define NAME_SERVER_DEFAULT "198.95.251.10"
-#endif
-#ifndef CONFIG_FILE_DEFAULT 
-#define CONFIG_FILE_DEFAULT "/etc/dproxy.conf"
-#endif
-#ifndef DENY_FILE_DEFAULT 
-#define DENY_FILE_DEFAULT "/etc/dproxy.deny"
-#endif
-#ifndef CACHE_FILE_DEFAULT 
-#define CACHE_FILE_DEFAULT "/var/cache/dproxy.cache"
-#endif
-#ifndef HOSTS_FILE_DEFAULT 
-#define HOSTS_FILE_DEFAULT "/etc/hosts"
-#endif
-#ifndef PURGE_TIME_DEFAULT 
-#define PURGE_TIME_DEFAULT 48 * 60 * 60
-#endif
-#ifndef PPP_DEV_DEFAULT 
-#define PPP_DEV_DEFAULT "/var/run/ppp0.pid"
-#endif
-#ifndef DHCP_LEASES_DEFAULT 
-#define DHCP_LEASES_DEFAULT "/var/state/dhcp/dhcpd.leases"
-#endif
-#ifndef PPP_DETECT_DEFAULT 
-#define PPP_DETECT_DEFAULT 1
-#endif
-#ifndef DEBUG_FILE_DEFAULT 
-#define DEBUG_FILE_DEFAULT "/var/log/dproxy.debug.log"
-#endif
-
-void debug_perror( char * msg );
-void debug(char *fmt, ...);
-
-#endif
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+#ifndef DPROXY_H
+#define DPROXY_H
+
+#define PORT 53
+#define PORT_STR "53"
+#define NAME_SIZE 255
+#define MAX_PACKET_SIZE 512
+#define BUF_SIZE NAME_SIZE
+
+typedef u_int16_t uint16;
+typedef u_int32_t uint32;
+
+#include "dns.h"
+
+#ifndef DNS_TIMEOUT 
+#if defined(AEI_VDSL_DNS_PROBE)
+#define DNS_TIMEOUT 2
+#else
+#if defined(SUPPORT_GPL_UNDEFINED)
+#define DNS_TIMEOUT 7
+#else
+#define DNS_TIMEOUT 30
+#endif
+#endif
+#endif
+
+#define MAX_RETX_COUNT  100
+
+#ifndef NAME_SERVER_DEFAULT
+#define NAME_SERVER_DEFAULT "0.0.0.0"
+#endif
+#ifndef CONFIG_FILE_DEFAULT 
+#define CONFIG_FILE_DEFAULT "/etc/dproxy.conf"
+#endif
+#ifndef DENY_FILE_DEFAULT 
+#define DENY_FILE_DEFAULT "/var/cache/dproxy.deny"
+#endif
+#ifndef CACHE_FILE_DEFAULT 
+#define CACHE_FILE_DEFAULT "/var/cache/dproxy.cache"
+#endif
+#ifndef HOSTS_FILE_DEFAULT 
+//BRCM
+//#define HOSTS_FILE_DEFAULT "/etc/hosts"
+#define HOSTS_FILE_DEFAULT "/var/hosts"
+#endif
+#ifndef PURGE_TIME_DEFAULT 
+#define PURGE_TIME_DEFAULT 48 * 60 * 60
+#endif
+#ifndef PPP_DEV_DEFAULT 
+#define PPP_DEV_DEFAULT "/var/run/ppp0.pid"
+#endif
+#ifndef DHCP_LEASES_DEFAULT 
+//BRCM
+//#define DHCP_LEASES_DEFAULT "/var/state/dhcp/dhcpd.leases"
+#define DHCP_LEASES_DEFAULT "/var/udhcpd/udhcpd.leases"
+#endif
+#ifndef PPP_DETECT_DEFAULT 
+#define PPP_DETECT_DEFAULT 1
+#endif
+#ifndef DEBUG_FILE_DEFAULT 
+#define DEBUG_FILE_DEFAULT "/var/log/dproxy.debug.log"
+#endif
+
+#ifndef DOMAIN_NAME_DEFAULT
+#define DOMAIN_NAME_DEFAULT "Home"
+#endif
+
+//BRCM
+#define STATIC_DNS_FILE_DEFAULT "/var/fyi/sys/dns"
+
+#if 0
+#ifdef DPROXY_DEBUG
+void debug_perror( char *msg );
+void debug(char *fmt, ...);
+#else
+#define debug_perror(msg) 
+#define debug(fmt,arg...)
+#endif
+#endif
+#include "cms.h"
+#include "cms_eid.h"
+#include "cms_util.h"
+#include "cms_msg.h"
+void debug_perror( char *msg );
+#define debug cmsLog_debug
+
+extern void get_date_time_str(char *buf, unsigned int buflen);
+#define DATE_TIME_BUFLEN    256
+
+#define PRIMARY_SERVER      1
+#define SECONDARY_SERVER    2
+#if defined(AEI_VDSL_DNS_CACHE)
+#define PURGE_TIMEOUT       5
+#else
+#define PURGE_TIMEOUT       30
+#endif
+
+#endif
diff -Naur dproxy-nexgen/Makefile dproxy-nexgen-brcm/Makefile
--- dproxy-nexgen/Makefile	2000-03-19 20:48:48.000000000 -0400
+++ dproxy-nexgen-brcm/Makefile	2018-11-23 22:41:44.385484054 -0400
@@ -1,115 +1,84 @@
-# compiler flags
-CC = gcc
-CFLAGS =-Wall -g -O2
-M4= m4
-
-BIN_DIR=/sbin
-CONFIG_DIR=/etc
-
-SLACKWARE_SCRIPT=/etc/rc.d/rc.inet2
-##############################################
-# uncoment the following if you have REDHAT 
-DIST= -DREDHAT
-CACHE_DIR=/var/cache
-DHCP_LEASES=/var/state/dhcp.leases
-RC_SCRIPT_DIR=/etc/rc.d/init.d
-
-##############################################
-# uncoment the following if you have DEBIAN
-#DIST= -DDEBIAN
-#CACHE_DIR=/var/cache
-# not shure where the dhcp stuff is
-#DHCP_LEASES=/var/state/dhcp.leases
-#RC_SCRIPT_DIR=/etc/rc.d/init.d
-
-##############################################
-# uncoment the following if you have SUSE
-#DIST= -DSUSE
-#CACHE_DIR=/var/dproxy
-# not shure where the dhcp stuff is
-#DHCP_LEASES=/var/dhcpd/dhcp.leases
-#RC_SCRIPT_DIR=/sbin/init.d
-
-##############################################
-# uncoment the following if you have SLACKWARE
-#DIST= -DSLACK
-#CACHE_DIR=/var/cache
-#DHCP_LEASES=/var/state/dhcp.leases
-######## END OF CONFIGURABLE OPTIONS #########
-
-CACHE_FILE=$(CACHE_DIR)/dproxy.cache
-CONFIG_FILE=$(CONFIG_DIR)/dproxy.conf
-
-DEFAULTS= -DCACHE_FILE_DEFAULT=\"$(CACHE_FILE)\" \
-	  -DDHCP_LEASES_DEFAULT=\"$(DHCP_LEASES)\" \
-	  -DCONFIG_FILE_DEFAULT=\"$(CONFIG_FILE)\"
-
-RCDEFS= $(DIST) -DBIN_DIR="$(BIN_DIR)" -DCONFIG_DIR="$(CONFIG_DIR)" 
-
-# install stuf
-INSTALL=install
-
-OBJS=dproxy.o dns_decode.o dns_list.o cache.o conf.o dns_construct.o dns_io.o
-
-all: dproxy dproxy.rc dproxy.conf
-
-dproxy: $(OBJS)
-	$(CC) $(CFLAGS) -o $@ $(OBJS)
-
-%.o : %.c Makefile
-	$(CC) -c $(DEFAULTS) $(CFLAGS) $<
-
-dproxy.rc:  dproxy.rc.m4 Makefile
-	$(M4) $(RCDEFS) $< >$@
-
-dproxy.conf:  dproxy
-	@./dproxy -P > dproxy.conf
-
-clean:
-	rm -f *.o *~ core dproxy dproxy.rc dproxy.conf
-
-install: all 
-	$(INSTALL) -s dproxy $(BIN_DIR)/dproxy
-	$(INSTALL) -d $(CACHE_DIR)
-
-ifeq ($(DIST), -DSLACK)
-	@echo "Attempting Slackware install";
-	@if [ -f $(SLACKWARE_SCRIPT) ] && ! grep -e dproxy $(SLACKWARE_SCRIPT) >/dev/null; then \
-		echo 'Adding dproxy to $(SLACKWARE_SCRIPT)'; \
-      echo '# dproxy (DNS caching proxy)' >>$(SLACKWARE_SCRIPT); \
-      echo 'if [ -x $(BIN_DIR)/dproxy ]; then' >>$(SLACKWARE_SCRIPT); \
-      echo '  echo "Starting dproxy"' >>$(SLACKWARE_SCRIPT); \
-      echo '  $(BIN_DIR)/dproxy -c$(CONFIG_DIR)/dproxy.conf' >>$(SLACKWARE_SCRIPT); \
-      echo 'fi' >>$(SLACKWARE_SCRIPT); \
-		echo "success."; \
-	else \
-		echo "Slackware install failed, could not find script '$(SLACKWARE_SCRIPT)' or dproxy was already enabled within"; \
-	fi	
-
-else
-	$(INSTALL) dproxy.rc $(RC_SCRIPT_DIR)/dproxy
-endif
-
-	@if [ -f $(CONFIG_DIR)/dproxy.conf ] ; \
-	then \
-	   mv $(CONFIG_DIR)/dproxy.conf $(CONFIG_DIR)/dproxy.conf.saved ; \
-	   echo "*******************************************************";\
-	   echo "NOTE : your old dproxy configuration has been moved to"; \
-	   echo "  $(CONFIG_DIR)/dproxy.conf.saved " ; \
-	   echo "you may want to restore it before you restart dproxy." ; \
-	   echo "*******************************************************";\
-	fi
-	$(INSTALL) dproxy.conf $(CONFIG_DIR)/dproxy.conf
-
-uninstall:
-	rm -f $(BIN_DIR)/dproxy
-	rm -f $(CACHE_DIR)/dproxy.cache $(CACHE_DIR)/dproxy.
-	rm -f $(RC_SCRIPT_DIR)/dproxy
-	rm -f $(CONFIG_DIR)/dproxy.conf
-
-dproxy.o: dproxy.c dproxy.h dns.h cache.h conf.h
-cache.o: cache.c cache.h dproxy.h dns.h conf.h
-conf.o: conf.c conf.h dproxy.h dns.h
-dns_decode.o: dns_decode.c dns_decode.h dproxy.h
-dns_list.o: dns_list.c dns_list.h dproxy.h
-dns_construct.o: dns_construct.c dns_construct.h dproxy.h
+#
+# In most cases, you only need to modify this first section.
+#
+EXE=dnsproxy
+OBJS=dproxy.o dns_decode.o dns_list.o conf.o dns_construct.o dns_io.o dns_dyn_cache.o dns_mapping.o cache.o
+LIBS=-lcms_msg $(CMS_COMMON_LIBS)
+CUSTOM_CFLAGS=-DDNS_DYN_CACHE
+
+all dynamic install: sanity_check $(EXE) generic_exe_install
+
+clean: generic_clean
+	rm -f $(INSTALL_DIR)/bin/$(EXE)
+
+
+
+#
+# Set our CommEngine directory (by splitting the pwd into two words
+# at /userspace and taking the first word only).
+# Then include the common defines under CommEngine.
+#
+CURR_DIR := $(shell pwd)
+BUILD_DIR:=$(subst /userspace, /userspace,$(CURR_DIR))
+BUILD_DIR:=$(word 1, $(BUILD_DIR))
+
+include $(BUILD_DIR)/make.common
+
+ifneq ($(strip $(BUILD_VODSL)),)
+include $(BUILD_DIR)/make.voice
+endif
+
+
+
+#
+# Private apps and libs are allowed to include header files from the
+# private and public directories.
+#
+# WARNING: Do not modify this section unless you understand the
+# license implications of what you are doing.
+#
+ALLOWED_INCLUDE_PATHS := -I.\
+                         -I$(BUILD_DIR)/userspace/gpl/include  \
+                         -I$(BUILD_DIR)/userspace/gpl/include/$(OALDIR) \
+                         -I$(BUILD_DIR)/userspace/public/include  \
+                         -I$(BUILD_DIR)/userspace/public/include/$(OALDIR)
+
+
+
+#
+# Private apps and libs are allowed to link with libraries from the
+# private and public directories.
+#
+# WARNING: Do not modify this section unless you understand the
+# license implications of what you are doing.
+#
+ALLOWED_LIB_DIRS := /lib:/lib/gpl:/lib/public
+
+
+# treat all warnings as errors
+CUSTOM_CFLAGS += -Werror -Wfatal-errors
+
+
+#
+# Implicit rule will make the .c into a .o
+# Implicit rule is $(CC) -c $(CPPFLAGS) $(CFLAGS)
+# See Section 10.2 of Gnu Make manual
+# 
+$(EXE): $(OBJS)
+	$(CC) -o $@ $(OBJS) -Wl,-rpath,$(CMS_LIB_RPATH) $(CMS_LIB_PATH) $(LIBS)
+
+
+
+#
+# Include the rule for making dependency files.
+# The '-' in front of the second include suppresses
+# error messages when make cannot find the .d files.
+# It will just regenerate them.
+# See Section 4.14 of Gnu Make.
+#
+
+include $(BUILD_DIR)/make.deprules
+
+-include $(OBJS:.o=.d)
+
+
