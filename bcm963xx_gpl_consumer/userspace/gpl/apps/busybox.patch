diff -Naur busybox/config.d/10bcm.conf busybox-brcm/config.d/10bcm.conf
--- busybox/config.d/10bcm.conf	1969-12-31 20:00:00.000000000 -0400
+++ busybox-brcm/config.d/10bcm.conf	2018-11-24 13:44:16.322012975 -0400
@@ -0,0 +1,52 @@
+#!/usr/bin/env perl
+
+#
+# DO NOT EDIT THIS FILE
+#
+# This file reads .config, makes changes, and writes it back
+# if you need to make further changes, COPY this file to another
+# executable file in the config.d directory with a .conf extension 
+# and replace the ACTIONS section with your own
+#
+
+use strict;
+use warnings;
+use BRCM::GenConfig;
+
+my $g = new BRCM::GenConfig('.config');
+
+# ACTIONS start here
+
+$g->set( "CONFIG_PREFIX", qq["$ENV{INSTALL_DIR}"] );
+
+if ( $ENV{BUILD_WGET_HTTPS} eq 'y' ) {
+    $g->set( "CONFIG_FEATURE_WGET_HTTPS",          "y" );
+    $g->set( "CONFIG_FEATURE_WGET_AUTHENTICATION", "y" );
+}
+if ( $ENV{BUILD_BUSYBOX_GUNZIP} eq 'y' ) {
+    $g->set( "CONFIG_GUNZIP",                      "y" );
+}
+if ( $ENV{BUILD_BUSYBOX_GZIP} eq 'y' ) {
+    $g->set( "CONFIG_GZIP",                        "y" );
+}
+if ( $ENV{BUILD_BUSYBOX_UNTAR} eq 'y' ) {
+    $g->set( "CONFIG_TAR",                         "y" );
+}
+if ( $ENV{BUILD_BUSYBOX_TAR} eq 'y' ) {
+    $g->set( "CONFIG_TAR",                         "y" );
+    $g->set( "CONFIG_FEATURE_TAR_CREATE",          "y" );
+}
+if ( $ENV{BUILD_GPONCTL} ne '' ) {
+    $g->set( "CONFIG_TRACEROUTE",                  "y" );
+    $g->set( "CONFIG_TRACEROUTE6",                 "y" );
+    $g->set( "CONFIG_FEATURE_TRACEROUTE_USE_ICMP", "y" );
+}
+if ( $ENV{BRCM_NFS_MOUNT_EN} eq 'y' ) {
+    $g->set( "CONFIG_FEATURE_MOUNT_NFS", "y" );
+}
+
+# ACTIONS end here
+
+$g->write();
+
+
diff -Naur busybox/config.d/20bcm_lite.conf busybox-brcm/config.d/20bcm_lite.conf
--- busybox/config.d/20bcm_lite.conf	1969-12-31 20:00:00.000000000 -0400
+++ busybox-brcm/config.d/20bcm_lite.conf	2018-11-24 13:44:16.322012975 -0400
@@ -0,0 +1,61 @@
+#!/usr/bin/env perl
+
+#
+# DO NOT EDIT THIS FILE
+#
+# This file reads .config, makes changes, and writes it back
+# if you need to make further changes, COPY this file to another
+# executable file in the config.d directory with a .conf extension 
+# and replace the ACTIONS section with your own
+#
+
+use strict;
+use warnings;
+use BRCM::GenConfig;
+
+my $g = new BRCM::GenConfig('.config');
+
+# ACTIONS start here
+
+$g->set( "CONFIG_PREFIX", qq["$ENV{INSTALL_DIR}"] );
+
+if ( $ENV{BUILD_BUSYBOX_BRCM_LITE} eq 'y' ) {
+    $g->unset( "CONFIG_FEATURE_VERBOSE_USAGE");
+    $g->unset( "CONFIG_FEATURE_FANCY_SLEEP");
+    $g->unset( "CONFIG_STTY");
+    $g->unset( "CONFIG_TTY");
+    $g->unset( "CONFIG_GREP");
+    $g->unset( "CONFIG_FEATURE_INIT_COREDUMPS");
+    $g->unset( "CONFIG_DELUSER");
+    $g->unset( "CONFIG_DMESG");
+    $g->unset( "CONFIG_CHRT");
+    $g->unset( "CONFIG_FLASH_ERASEALL");
+    $g->unset( "CONFIG_SYSINFO");
+    $g->unset( "CONFIG_FEATURE_IPV6");
+    $g->unset( "CONFIG_FEATURE_PREFER_IPV4_ADDRESS");
+    $g->unset( "CONFIG_FTPGET");
+    $g->unset( "CONFIG_PING6");
+    $g->unset( "CONFIG_FEATURE_FANCY_PING");
+    $g->unset( "CONFIG_TFTP");
+    $g->unset( "CONFIG_TFTPD");
+    $g->unset( "CONFIG_BRCMTFTPD");
+    $g->unset( "CONFIG_FEATURE_TFTP_GET");
+    $g->unset( "CONFIG_FEATURE_TFTP_PUT");
+    $g->unset( "CONFIG_VCONFIG");
+    $g->unset( "CONFIG_WGET");
+    $g->unset( "CONFIG_SYSLOGD");
+    $g->unset( "CONFIG_FEATURE_REMOTE_LOG");
+    $g->unset( "CONFIG_FEATURE_SYSLOGD_DUP");
+    $g->set( "CONFIG_FEATURE_SYSLOGD_READ_BUFFER_SIZE", 0);
+    $g->unset( "CONFIG_FEATURE_IPC_SYSLOG");
+    $g->set( "CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE, 0");
+    $g->unset( "CONFIG_LOGREAD");
+    $g->unset( "CONFIG_KLOGD");
+    $g->unset( "CONFIG_LOGGER");
+}
+
+# ACTIONS end here
+
+$g->write();
+
+
diff -Naur busybox/config.d/20editors.conf busybox-brcm/config.d/20editors.conf
--- busybox/config.d/20editors.conf	1969-12-31 20:00:00.000000000 -0400
+++ busybox-brcm/config.d/20editors.conf	2018-11-24 13:44:16.322012975 -0400
@@ -0,0 +1,42 @@
+#!/usr/bin/env perl
+
+#
+# This file reads .config, makes changes, and writes it back
+# if you need to make further changes, COPY this file to another
+# executable file in the config.d directory with a .conf extension
+# and replace the ACTIONS section with your own
+#
+
+use strict;
+use warnings;
+use BRCM::GenConfig;
+
+my $g = new BRCM::GenConfig('.config');
+
+# LOGIC STARTS HERE
+
+if ( $ENV{BUILD_BUSYBOX_VI} eq 'y' ) {
+    $g->set( 'CONFIG_FEATURE_VI_MAX_LEN', 4096 );
+    $g->set( [
+        qw[
+          CONFIG_VI
+          CONFIG_FEATURE_VI_COLON
+          CONFIG_FEATURE_VI_YANKMARK
+          CONFIG_FEATURE_VI_SEARCH
+          CONFIG_FEATURE_VI_USE_SIGNALS
+          CONFIG_FEATURE_VI_DOT_CMD
+          CONFIG_FEATURE_VI_READONLY
+          CONFIG_FEATURE_VI_SETOPTS
+          CONFIG_FEATURE_VI_SET
+          CONFIG_FEATURE_VI_ASK_TERMINAL
+          CONFIG_FEATURE_VI_OPTIMIZE_CURSOR
+          CONFIG_FEATURE_ALLOW_EXEC
+          ]], 'y'
+    );
+
+}
+
+# LOGIC ENDS HERE
+
+$g->write();
+
diff -Naur busybox/config.d/90vanilla.conf busybox-brcm/config.d/90vanilla.conf
--- busybox/config.d/90vanilla.conf	1969-12-31 20:00:00.000000000 -0400
+++ busybox-brcm/config.d/90vanilla.conf	2018-11-24 13:44:16.322012975 -0400
@@ -0,0 +1,33 @@
+#!/usr/bin/env perl
+
+#
+# This file reads .config, makes changes, and writes it back
+# if you need to make further changes, COPY this file to another
+# executable file in the config.d directory with a .conf extension
+# and replace the ACTIONS section with your own
+#
+
+use strict;
+use warnings;
+use BRCM::GenConfig;
+
+my $g = new BRCM::GenConfig('.config');
+
+# LOGIC STARTS HERE
+
+if ( $ENV{"BUILD_BUSYBOX_BRCM_VANILLA"} eq 'y' ) {
+
+    $g->set(
+        [
+            qw[CONFIG_IFCONFIG CONFIG_NC CONFIG_SENDARP
+              CONFIG_PING CONFIG_ROUTE
+              ]
+        ],
+        undef
+    );
+}
+
+# LOGIC ENDS HERE
+
+$g->write();
+
diff -Naur busybox/ikos.config busybox-brcm/ikos.config
--- busybox/ikos.config	1969-12-31 20:00:00.000000000 -0400
+++ busybox-brcm/ikos.config	2018-11-24 13:44:16.369966884 -0400
@@ -0,0 +1,963 @@
+#
+# Automatically generated make config: don't edit
+# Busybox version: 1.17.2
+# Thu Oct 14 09:42:22 2010
+#
+CONFIG_HAVE_DOT_CONFIG=y
+
+#
+# Busybox Settings
+#
+
+#
+# General Configuration
+#
+# CONFIG_DESKTOP is not set
+# CONFIG_EXTRA_COMPAT is not set
+# CONFIG_INCLUDE_SUSv2 is not set
+# CONFIG_USE_PORTABLE_CODE is not set
+CONFIG_FEATURE_BUFFERS_USE_MALLOC=y
+# CONFIG_FEATURE_BUFFERS_GO_ON_STACK is not set
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_SHOW_USAGE=y
+CONFIG_FEATURE_VERBOSE_USAGE=y
+# CONFIG_FEATURE_COMPRESS_USAGE is not set
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+# CONFIG_UNICODE_SUPPORT is not set
+# CONFIG_UNICODE_USING_LOCALE is not set
+# CONFIG_FEATURE_CHECK_UNICODE_IN_ENV is not set
+CONFIG_SUBST_WCHAR=0
+CONFIG_LAST_SUPPORTED_WCHAR=0
+# CONFIG_UNICODE_COMBINING_WCHARS is not set
+# CONFIG_UNICODE_WIDE_WCHARS is not set
+# CONFIG_UNICODE_BIDI_SUPPORT is not set
+# CONFIG_UNICODE_NEUTRAL_TABLE is not set
+# CONFIG_UNICODE_PRESERVE_BROKEN is not set
+# CONFIG_LONG_OPTS is not set
+# CONFIG_FEATURE_DEVPTS is not set
+# CONFIG_FEATURE_CLEAN_UP is not set
+# CONFIG_FEATURE_UTMP is not set
+# CONFIG_FEATURE_WTMP is not set
+# CONFIG_FEATURE_PIDFILE is not set
+# CONFIG_FEATURE_SUID is not set
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_FEATURE_SUID_CONFIG_QUIET is not set
+# CONFIG_SELINUX is not set
+# CONFIG_FEATURE_PREFER_APPLETS is not set
+CONFIG_BUSYBOX_EXEC_PATH="/proc/self/exe"
+# CONFIG_FEATURE_SYSLOG is not set
+# CONFIG_FEATURE_HAVE_RPC is not set
+
+#
+# Build Options
+#
+# CONFIG_STATIC is not set
+# CONFIG_PIE is not set
+# CONFIG_NOMMU is not set
+# CONFIG_BUILD_LIBBUSYBOX is not set
+# CONFIG_FEATURE_INDIVIDUAL is not set
+# CONFIG_FEATURE_SHARED_BUSYBOX is not set
+CONFIG_LFS=y
+CONFIG_CROSS_COMPILER_PREFIX="crosscompile_does_not_matter_here"
+CONFIG_EXTRA_CFLAGS=""
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
+# CONFIG_DEBUG_PESSIMIZE is not set
+# CONFIG_WERROR is not set
+CONFIG_NO_DEBUG_LIB=y
+# CONFIG_DMALLOC is not set
+# CONFIG_EFENCE is not set
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+CONFIG_INSTALL_APPLET_SYMLINKS=y
+# CONFIG_INSTALL_APPLET_HARDLINKS is not set
+# CONFIG_INSTALL_APPLET_SCRIPT_WRAPPERS is not set
+# CONFIG_INSTALL_APPLET_DONT is not set
+# CONFIG_INSTALL_SH_APPLET_SYMLINK is not set
+# CONFIG_INSTALL_SH_APPLET_HARDLINK is not set
+# CONFIG_INSTALL_SH_APPLET_SCRIPT_WRAPPER is not set
+CONFIG_PREFIX set by gendotconfig
+
+#
+# Busybox Library Tuning
+#
+CONFIG_PASSWORD_MINLEN=6
+CONFIG_MD5_SIZE_VS_SPEED=2
+CONFIG_FEATURE_FAST_TOP=y
+# CONFIG_FEATURE_ETC_NETWORKS is not set
+CONFIG_FEATURE_EDITING=y
+CONFIG_FEATURE_EDITING_MAX_LEN=1024
+# CONFIG_FEATURE_EDITING_VI is not set
+CONFIG_FEATURE_EDITING_HISTORY=10
+# CONFIG_FEATURE_EDITING_SAVEHISTORY is not set
+CONFIG_FEATURE_TAB_COMPLETION=y
+# CONFIG_FEATURE_USERNAME_COMPLETION is not set
+# CONFIG_FEATURE_EDITING_FANCY_PROMPT is not set
+# CONFIG_FEATURE_EDITING_ASK_TERMINAL is not set
+# CONFIG_FEATURE_NON_POSIX_CP is not set
+# CONFIG_FEATURE_VERBOSE_CP_MESSAGE is not set
+CONFIG_FEATURE_COPYBUF_KB=4
+# CONFIG_MONOTONIC_SYSCALL is not set
+# CONFIG_IOCTL_HEX2STR_ERROR is not set
+# CONFIG_FEATURE_HWIB is not set
+
+#
+# Applets
+#
+
+#
+# Archival Utilities
+#
+# CONFIG_FEATURE_SEAMLESS_XZ is not set
+# CONFIG_FEATURE_SEAMLESS_LZMA is not set
+# CONFIG_FEATURE_SEAMLESS_BZ2 is not set
+# CONFIG_FEATURE_SEAMLESS_GZ is not set
+# CONFIG_FEATURE_SEAMLESS_Z is not set
+# CONFIG_AR is not set
+# CONFIG_FEATURE_AR_LONG_FILENAMES is not set
+# CONFIG_FEATURE_AR_CREATE is not set
+# CONFIG_BUNZIP2 is not set
+# CONFIG_BZIP2 is not set
+# CONFIG_CPIO is not set
+# CONFIG_FEATURE_CPIO_O is not set
+# CONFIG_FEATURE_CPIO_P is not set
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_FEATURE_DPKG_DEB_EXTRACT_ONLY is not set
+# CONFIG_GUNZIP is not set
+# CONFIG_GZIP is not set
+# CONFIG_FEATURE_GZIP_LONG_OPTIONS is not set
+# CONFIG_LZOP is not set
+# CONFIG_LZOP_COMPR_HIGH is not set
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+# CONFIG_TAR is not set
+# CONFIG_FEATURE_TAR_CREATE is not set
+# CONFIG_FEATURE_TAR_AUTODETECT is not set
+# CONFIG_FEATURE_TAR_FROM is not set
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATIBILITY is not set
+# CONFIG_FEATURE_TAR_OLDSUN_COMPATIBILITY is not set
+# CONFIG_FEATURE_TAR_GNU_EXTENSIONS is not set
+# CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# CONFIG_FEATURE_TAR_TO_COMMAND is not set
+# CONFIG_FEATURE_TAR_UNAME_GNAME is not set
+# CONFIG_FEATURE_TAR_NOPRESERVE_TIME is not set
+# CONFIG_FEATURE_TAR_SELINUX is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNLZMA is not set
+# CONFIG_FEATURE_LZMA_FAST is not set
+# CONFIG_LZMA is not set
+# CONFIG_UNXZ is not set
+# CONFIG_XZ is not set
+# CONFIG_UNZIP is not set
+
+#
+# Coreutils
+#
+# CONFIG_BASENAME is not set
+CONFIG_CAT=y
+# CONFIG_DATE is not set
+# CONFIG_FEATURE_DATE_ISOFMT is not set
+# CONFIG_FEATURE_DATE_NANO is not set
+# CONFIG_FEATURE_DATE_COMPAT is not set
+# CONFIG_TEST is not set
+# CONFIG_FEATURE_TEST_64 is not set
+# CONFIG_TR is not set
+# CONFIG_FEATURE_TR_CLASSES is not set
+# CONFIG_FEATURE_TR_EQUIV is not set
+# CONFIG_CAL is not set
+# CONFIG_CATV is not set
+# CONFIG_CHGRP is not set
+# CONFIG_CHMOD is not set
+# CONFIG_CHOWN is not set
+# CONFIG_FEATURE_CHOWN_LONG_OPTIONS is not set
+# CONFIG_CHROOT is not set
+# CONFIG_CKSUM is not set
+# CONFIG_COMM is not set
+# CONFIG_CP is not set
+# CONFIG_FEATURE_CP_LONG_OPTIONS is not set
+# CONFIG_CUT is not set
+# CONFIG_DD is not set
+# CONFIG_FEATURE_DD_SIGNAL_HANDLING is not set
+# CONFIG_FEATURE_DD_THIRD_STATUS_LINE is not set
+# CONFIG_FEATURE_DD_IBS_OBS is not set
+# CONFIG_DF is not set
+# CONFIG_FEATURE_DF_FANCY is not set
+# CONFIG_DIRNAME is not set
+# CONFIG_DOS2UNIX is not set
+# CONFIG_UNIX2DOS is not set
+# CONFIG_DU is not set
+# CONFIG_FEATURE_DU_DEFAULT_BLOCKSIZE_1K is not set
+CONFIG_ECHO=y
+# CONFIG_FEATURE_FANCY_ECHO is not set
+# CONFIG_ENV is not set
+# CONFIG_FEATURE_ENV_LONG_OPTIONS is not set
+# CONFIG_EXPAND is not set
+# CONFIG_FEATURE_EXPAND_LONG_OPTIONS is not set
+# CONFIG_EXPR is not set
+# CONFIG_EXPR_MATH_SUPPORT_64 is not set
+# CONFIG_FALSE is not set
+# CONFIG_FOLD is not set
+# CONFIG_FSYNC is not set
+# CONFIG_HEAD is not set
+# CONFIG_FEATURE_FANCY_HEAD is not set
+# CONFIG_HOSTID is not set
+# CONFIG_ID is not set
+# CONFIG_INSTALL is not set
+# CONFIG_FEATURE_INSTALL_LONG_OPTIONS is not set
+# CONFIG_LENGTH is not set
+# CONFIG_LN is not set
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+CONFIG_FEATURE_LS_SORTFILES=y
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+CONFIG_FEATURE_LS_USERNAME=y
+# CONFIG_FEATURE_LS_COLOR is not set
+# CONFIG_FEATURE_LS_COLOR_IS_DEFAULT is not set
+# CONFIG_MD5SUM is not set
+# CONFIG_MKDIR is not set
+# CONFIG_FEATURE_MKDIR_LONG_OPTIONS is not set
+# CONFIG_MKFIFO is not set
+# CONFIG_MKNOD is not set
+# CONFIG_MV is not set
+# CONFIG_FEATURE_MV_LONG_OPTIONS is not set
+# CONFIG_NICE is not set
+# CONFIG_NOHUP is not set
+# CONFIG_OD is not set
+# CONFIG_PRINTENV is not set
+# CONFIG_PRINTF is not set
+# CONFIG_PWD is not set
+# CONFIG_READLINK is not set
+# CONFIG_FEATURE_READLINK_FOLLOW is not set
+# CONFIG_REALPATH is not set
+# CONFIG_RM is not set
+# CONFIG_RMDIR is not set
+# CONFIG_FEATURE_RMDIR_LONG_OPTIONS is not set
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+# CONFIG_SHA256SUM is not set
+# CONFIG_SHA512SUM is not set
+# CONFIG_SLEEP is not set
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+# CONFIG_FEATURE_FLOAT_SLEEP is not set
+# CONFIG_SORT is not set
+# CONFIG_FEATURE_SORT_BIG is not set
+# CONFIG_SPLIT is not set
+# CONFIG_FEATURE_SPLIT_FANCY is not set
+# CONFIG_STAT is not set
+# CONFIG_FEATURE_STAT_FORMAT is not set
+# CONFIG_STTY is not set
+# CONFIG_SUM is not set
+# CONFIG_SYNC is not set
+# CONFIG_TAC is not set
+# CONFIG_TAIL is not set
+# CONFIG_FEATURE_FANCY_TAIL is not set
+# CONFIG_TEE is not set
+# CONFIG_FEATURE_TEE_USE_BLOCK_IO is not set
+# CONFIG_TOUCH is not set
+# CONFIG_TRUE is not set
+# CONFIG_TTY is not set
+# CONFIG_UNAME is not set
+# CONFIG_UNEXPAND is not set
+# CONFIG_FEATURE_UNEXPAND_LONG_OPTIONS is not set
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WC is not set
+# CONFIG_FEATURE_WC_LARGE is not set
+# CONFIG_WHO is not set
+# CONFIG_WHOAMI is not set
+# CONFIG_YES is not set
+
+#
+# Common options for cp and mv
+#
+# CONFIG_FEATURE_PRESERVE_HARDLINKS is not set
+
+#
+# Common options for ls, more and telnet
+#
+# CONFIG_FEATURE_AUTOWIDTH is not set
+
+#
+# Common options for df, du, ls
+#
+# CONFIG_FEATURE_HUMAN_READABLE is not set
+# CONFIG_FEATURE_MD5_SHA1_SUM_CHECK is not set
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+# CONFIG_FGCONSOLE is not set
+# CONFIG_CLEAR is not set
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_KBD_MODE is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_RESIZE is not set
+# CONFIG_FEATURE_RESIZE_PRINT is not set
+# CONFIG_SETCONSOLE is not set
+# CONFIG_FEATURE_SETCONSOLE_LONG_OPTIONS is not set
+# CONFIG_SETFONT is not set
+# CONFIG_FEATURE_SETFONT_TEXTUAL_MAP is not set
+CONFIG_DEFAULT_SETFONT_DIR=""
+# CONFIG_SETKEYCODES is not set
+# CONFIG_SETLOGCONS is not set
+# CONFIG_SHOWKEY is not set
+# CONFIG_FEATURE_LOADFONT_PSF2 is not set
+# CONFIG_FEATURE_LOADFONT_RAW is not set
+
+#
+# Debian Utilities
+#
+# CONFIG_MKTEMP is not set
+# CONFIG_PIPE_PROGRESS is not set
+# CONFIG_RUN_PARTS is not set
+# CONFIG_FEATURE_RUN_PARTS_LONG_OPTIONS is not set
+# CONFIG_FEATURE_RUN_PARTS_FANCY is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_FEATURE_START_STOP_DAEMON_FANCY is not set
+# CONFIG_FEATURE_START_STOP_DAEMON_LONG_OPTIONS is not set
+# CONFIG_WHICH is not set
+
+#
+# Editors
+#
+# CONFIG_AWK is not set
+# CONFIG_FEATURE_AWK_LIBM is not set
+# CONFIG_CMP is not set
+# CONFIG_DIFF is not set
+# CONFIG_FEATURE_DIFF_LONG_OPTIONS is not set
+# CONFIG_FEATURE_DIFF_DIR is not set
+# CONFIG_ED is not set
+# CONFIG_PATCH is not set
+# CONFIG_SED is not set
+# CONFIG_VI is not set
+CONFIG_FEATURE_VI_MAX_LEN=0
+# CONFIG_FEATURE_VI_8BIT is not set
+# CONFIG_FEATURE_VI_COLON is not set
+# CONFIG_FEATURE_VI_YANKMARK is not set
+# CONFIG_FEATURE_VI_SEARCH is not set
+# CONFIG_FEATURE_VI_USE_SIGNALS is not set
+# CONFIG_FEATURE_VI_DOT_CMD is not set
+# CONFIG_FEATURE_VI_READONLY is not set
+# CONFIG_FEATURE_VI_SETOPTS is not set
+# CONFIG_FEATURE_VI_SET is not set
+# CONFIG_FEATURE_VI_WIN_RESIZE is not set
+# CONFIG_FEATURE_VI_ASK_TERMINAL is not set
+# CONFIG_FEATURE_VI_OPTIMIZE_CURSOR is not set
+# CONFIG_FEATURE_ALLOW_EXEC is not set
+
+#
+# Finding Utilities
+#
+# CONFIG_FIND is not set
+# CONFIG_FEATURE_FIND_PRINT0 is not set
+# CONFIG_FEATURE_FIND_MTIME is not set
+# CONFIG_FEATURE_FIND_MMIN is not set
+# CONFIG_FEATURE_FIND_PERM is not set
+# CONFIG_FEATURE_FIND_TYPE is not set
+# CONFIG_FEATURE_FIND_XDEV is not set
+# CONFIG_FEATURE_FIND_MAXDEPTH is not set
+# CONFIG_FEATURE_FIND_NEWER is not set
+# CONFIG_FEATURE_FIND_INUM is not set
+# CONFIG_FEATURE_FIND_EXEC is not set
+# CONFIG_FEATURE_FIND_USER is not set
+# CONFIG_FEATURE_FIND_GROUP is not set
+# CONFIG_FEATURE_FIND_NOT is not set
+# CONFIG_FEATURE_FIND_DEPTH is not set
+# CONFIG_FEATURE_FIND_PAREN is not set
+# CONFIG_FEATURE_FIND_SIZE is not set
+# CONFIG_FEATURE_FIND_PRUNE is not set
+# CONFIG_FEATURE_FIND_DELETE is not set
+# CONFIG_FEATURE_FIND_PATH is not set
+# CONFIG_FEATURE_FIND_REGEX is not set
+# CONFIG_FEATURE_FIND_CONTEXT is not set
+# CONFIG_FEATURE_FIND_LINKS is not set
+# CONFIG_GREP is not set
+# CONFIG_FEATURE_GREP_EGREP_ALIAS is not set
+# CONFIG_FEATURE_GREP_FGREP_ALIAS is not set
+# CONFIG_FEATURE_GREP_CONTEXT is not set
+# CONFIG_XARGS is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_QUOTES is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM is not set
+
+#
+# Init Utilities
+#
+# CONFIG_BOOTCHARTD is not set
+# CONFIG_FEATURE_BOOTCHARTD_BLOATED_HEADER is not set
+# CONFIG_FEATURE_BOOTCHARTD_CONFIG_FILE is not set
+CONFIG_INIT=y
+CONFIG_FEATURE_USE_INITTAB=y
+# CONFIG_FEATURE_KILL_REMOVED is not set
+CONFIG_FEATURE_KILL_DELAY=0
+CONFIG_FEATURE_INIT_SCTTY=y
+# CONFIG_FEATURE_INIT_SYSLOG is not set
+# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+CONFIG_FEATURE_INITRD=y
+CONFIG_HALT=y
+# CONFIG_FEATURE_CALL_TELINIT is not set
+CONFIG_TELINIT_PATH=""
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+# CONFIG_FEATURE_SHADOWPASSWDS is not set
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_USE_BB_SHADOW is not set
+# CONFIG_USE_BB_CRYPT is not set
+# CONFIG_USE_BB_CRYPT_SHA is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_FEATURE_ADDGROUP_LONG_OPTIONS is not set
+# CONFIG_FEATURE_ADDUSER_TO_GROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_FEATURE_DEL_USER_FROM_GROUP is not set
+# CONFIG_FEATURE_CHECK_NAMES is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_FEATURE_ADDUSER_LONG_OPTIONS is not set
+CONFIG_FIRST_SYSTEM_ID=0
+CONFIG_LAST_SYSTEM_ID=0
+# CONFIG_DELUSER is not set
+# CONFIG_GETTY is not set
+# CONFIG_LOGIN is not set
+# CONFIG_PAM is not set
+# CONFIG_LOGIN_SCRIPTS is not set
+# CONFIG_FEATURE_NOLOGIN is not set
+# CONFIG_FEATURE_SECURETTY is not set
+# CONFIG_PASSWD is not set
+# CONFIG_FEATURE_PASSWD_WEAK_CHECK is not set
+# CONFIG_CRYPTPW is not set
+# CONFIG_CHPASSWD is not set
+# CONFIG_SU is not set
+# CONFIG_FEATURE_SU_SYSLOG is not set
+# CONFIG_FEATURE_SU_CHECKS_SHELLS is not set
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Linux Ext2 FS Progs
+#
+# CONFIG_CHATTR is not set
+# CONFIG_FSCK is not set
+# CONFIG_LSATTR is not set
+# CONFIG_TUNE2FS is not set
+
+#
+# Linux Module Utilities
+#
+# CONFIG_MODINFO is not set
+# CONFIG_MODPROBE_SMALL is not set
+# CONFIG_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE is not set
+# CONFIG_FEATURE_MODPROBE_SMALL_CHECK_ALREADY_LOADED is not set
+# CONFIG_INSMOD is not set
+# CONFIG_RMMOD is not set
+# CONFIG_LSMOD is not set
+# CONFIG_FEATURE_LSMOD_PRETTY_2_6_OUTPUT is not set
+# CONFIG_MODPROBE is not set
+# CONFIG_FEATURE_MODPROBE_BLACKLIST is not set
+# CONFIG_DEPMOD is not set
+
+#
+# Options common to multiple modutils
+#
+# CONFIG_FEATURE_2_4_MODULES is not set
+# CONFIG_FEATURE_INSMOD_TRY_MMAP is not set
+# CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
+# CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
+# CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
+# CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
+# CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL is not set
+# CONFIG_FEATURE_CHECK_TAINTED_MODULE is not set
+# CONFIG_FEATURE_MODUTILS_ALIAS is not set
+# CONFIG_FEATURE_MODUTILS_SYMBOLS is not set
+CONFIG_DEFAULT_MODULES_DIR="/lib/modules"
+CONFIG_DEFAULT_DEPMOD_FILE=""
+
+#
+# Linux System Utilities
+#
+# CONFIG_REV is not set
+# CONFIG_ACPID is not set
+# CONFIG_FEATURE_ACPID_COMPAT is not set
+# CONFIG_BLKID is not set
+# CONFIG_DMESG is not set
+# CONFIG_FEATURE_DMESG_PRETTY is not set
+# CONFIG_FBSET is not set
+# CONFIG_FEATURE_FBSET_FANCY is not set
+# CONFIG_FEATURE_FBSET_READMODE is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+# CONFIG_FDISK is not set
+# CONFIG_FDISK_SUPPORT_LARGE_DISKS is not set
+# CONFIG_FEATURE_FDISK_WRITABLE is not set
+# CONFIG_FEATURE_AIX_LABEL is not set
+# CONFIG_FEATURE_SGI_LABEL is not set
+# CONFIG_FEATURE_SUN_LABEL is not set
+# CONFIG_FEATURE_OSF_LABEL is not set
+# CONFIG_FEATURE_FDISK_ADVANCED is not set
+# CONFIG_FINDFS is not set
+# CONFIG_FLOCK is not set
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_EXT2 is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_FEATURE_MINIX2 is not set
+# CONFIG_MKFS_REISER is not set
+# CONFIG_MKFS_VFAT is not set
+# CONFIG_GETOPT is not set
+# CONFIG_FEATURE_GETOPT_LONG is not set
+# CONFIG_HEXDUMP is not set
+# CONFIG_FEATURE_HEXDUMP_REVERSE is not set
+# CONFIG_HD is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_FEATURE_HWCLOCK_LONG_OPTIONS is not set
+# CONFIG_FEATURE_HWCLOCK_ADJTIME_FHS is not set
+# CONFIG_IPCRM is not set
+# CONFIG_IPCS is not set
+# CONFIG_LOSETUP is not set
+# CONFIG_LSPCI is not set
+# CONFIG_LSUSB is not set
+# CONFIG_MDEV is not set
+# CONFIG_FEATURE_MDEV_CONF is not set
+# CONFIG_FEATURE_MDEV_RENAME is not set
+# CONFIG_FEATURE_MDEV_RENAME_REGEXP is not set
+# CONFIG_FEATURE_MDEV_EXEC is not set
+# CONFIG_FEATURE_MDEV_LOAD_FIRMWARE is not set
+# CONFIG_MKSWAP is not set
+# CONFIG_FEATURE_MKSWAP_UUID is not set
+# CONFIG_MORE is not set
+CONFIG_FEATURE_USE_TERMIOS=y
+CONFIG_MOUNT=y
+# CONFIG_FEATURE_MOUNT_FAKE is not set
+# CONFIG_FEATURE_MOUNT_VERBOSE is not set
+# CONFIG_FEATURE_MOUNT_HELPERS is not set
+# CONFIG_FEATURE_MOUNT_LABEL is not set
+# CONFIG_FEATURE_MOUNT_NFS is not set
+# CONFIG_FEATURE_MOUNT_CIFS is not set
+# CONFIG_FEATURE_MOUNT_FLAGS is not set
+# CONFIG_FEATURE_MOUNT_FSTAB is not set
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_RDEV is not set
+# CONFIG_READPROFILE is not set
+# CONFIG_RTCWAKE is not set
+# CONFIG_SCRIPT is not set
+# CONFIG_SCRIPTREPLAY is not set
+# CONFIG_SETARCH is not set
+# CONFIG_SWAPONOFF is not set
+# CONFIG_FEATURE_SWAPON_PRI is not set
+# CONFIG_SWITCH_ROOT is not set
+CONFIG_UMOUNT=y
+CONFIG_FEATURE_UMOUNT_ALL=y
+
+#
+# Common options for mount/umount
+#
+# CONFIG_FEATURE_MOUNT_LOOP is not set
+# CONFIG_FEATURE_MOUNT_LOOP_CREATE is not set
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+# CONFIG_VOLUMEID is not set
+# CONFIG_FEATURE_VOLUMEID_EXT is not set
+# CONFIG_FEATURE_VOLUMEID_BTRFS is not set
+# CONFIG_FEATURE_VOLUMEID_REISERFS is not set
+# CONFIG_FEATURE_VOLUMEID_FAT is not set
+# CONFIG_FEATURE_VOLUMEID_HFS is not set
+# CONFIG_FEATURE_VOLUMEID_JFS is not set
+# CONFIG_FEATURE_VOLUMEID_XFS is not set
+# CONFIG_FEATURE_VOLUMEID_NTFS is not set
+# CONFIG_FEATURE_VOLUMEID_ISO9660 is not set
+# CONFIG_FEATURE_VOLUMEID_UDF is not set
+# CONFIG_FEATURE_VOLUMEID_LUKS is not set
+# CONFIG_FEATURE_VOLUMEID_LINUXSWAP is not set
+# CONFIG_FEATURE_VOLUMEID_CRAMFS is not set
+# CONFIG_FEATURE_VOLUMEID_ROMFS is not set
+# CONFIG_FEATURE_VOLUMEID_SYSV is not set
+# CONFIG_FEATURE_VOLUMEID_OCFS2 is not set
+# CONFIG_FEATURE_VOLUMEID_LINUXRAID is not set
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_CONSPY is not set
+# CONFIG_UBIATTACH is not set
+# CONFIG_UBIDETACH is not set
+# CONFIG_ADJTIMEX is not set
+# CONFIG_BBCONFIG is not set
+# CONFIG_BEEP is not set
+CONFIG_FEATURE_BEEP_FREQ=0
+CONFIG_FEATURE_BEEP_LENGTH_MS=0
+# CONFIG_CHAT is not set
+# CONFIG_FEATURE_CHAT_NOFAIL is not set
+# CONFIG_FEATURE_CHAT_TTY_HIFI is not set
+# CONFIG_FEATURE_CHAT_IMPLICIT_CR is not set
+# CONFIG_FEATURE_CHAT_SWALLOW_OPTS is not set
+# CONFIG_FEATURE_CHAT_SEND_ESCAPES is not set
+# CONFIG_FEATURE_CHAT_VAR_ABORT_LEN is not set
+# CONFIG_FEATURE_CHAT_CLR_ABORT is not set
+# CONFIG_CHRT is not set
+# CONFIG_CROND is not set
+# CONFIG_FEATURE_CROND_D is not set
+# CONFIG_FEATURE_CROND_CALL_SENDMAIL is not set
+CONFIG_FEATURE_CROND_DIR=""
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_FEATURE_DC_LIBM is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_DEVFSD_MODLOAD is not set
+# CONFIG_DEVFSD_FG_NP is not set
+# CONFIG_DEVFSD_VERBOSE is not set
+# CONFIG_FEATURE_DEVFS is not set
+# CONFIG_DEVMEM is not set
+# CONFIG_EJECT is not set
+# CONFIG_FEATURE_EJECT_SCSI is not set
+# CONFIG_FBSPLASH is not set
+# CONFIG_FLASHCP is not set
+# CONFIG_FLASH_LOCK is not set
+# CONFIG_FLASH_UNLOCK is not set
+# CONFIG_FLASH_ERASEALL is not set
+# CONFIG_IONICE is not set
+# CONFIG_INOTIFYD is not set
+# CONFIG_LAST is not set
+# CONFIG_FEATURE_LAST_SMALL is not set
+# CONFIG_FEATURE_LAST_FANCY is not set
+# CONFIG_LESS is not set
+CONFIG_FEATURE_LESS_MAXLINES=0
+# CONFIG_FEATURE_LESS_BRACKETS is not set
+# CONFIG_FEATURE_LESS_FLAGS is not set
+# CONFIG_FEATURE_LESS_MARKS is not set
+# CONFIG_FEATURE_LESS_REGEXP is not set
+# CONFIG_FEATURE_LESS_WINCH is not set
+# CONFIG_FEATURE_LESS_DASHCMD is not set
+# CONFIG_FEATURE_LESS_LINENUMS is not set
+# CONFIG_HDPARM is not set
+# CONFIG_FEATURE_HDPARM_GET_IDENTITY is not set
+# CONFIG_FEATURE_HDPARM_HDIO_SCAN_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_DRIVE_RESET is not set
+# CONFIG_FEATURE_HDPARM_HDIO_TRISTATE_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_GETSET_DMA is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_FEATURE_MAKEDEVS_LEAF is not set
+# CONFIG_FEATURE_MAKEDEVS_TABLE is not set
+# CONFIG_MAN is not set
+# CONFIG_MICROCOM is not set
+# CONFIG_MOUNTPOINT is not set
+# CONFIG_MT is not set
+# CONFIG_RAIDAUTORUN is not set
+# CONFIG_READAHEAD is not set
+# CONFIG_RFKILL is not set
+# CONFIG_RUNLEVEL is not set
+# CONFIG_RX is not set
+# CONFIG_SETSID is not set
+# CONFIG_STRINGS is not set
+# CONFIG_TASKSET is not set
+# CONFIG_FEATURE_TASKSET_FANCY is not set
+# CONFIG_TIME is not set
+# CONFIG_TIMEOUT is not set
+# CONFIG_TTYSIZE is not set
+# CONFIG_VOLNAME is not set
+# CONFIG_WALL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SYSINFO=y
+
+#
+# Networking Utilities
+#
+# CONFIG_NC is not set
+# CONFIG_NC_SERVER is not set
+# CONFIG_NC_EXTRA is not set
+# CONFIG_NC_110_COMPAT is not set
+# CONFIG_FEATURE_IPV6 is not set
+# CONFIG_FEATURE_UNIX_LOCAL is not set
+# CONFIG_FEATURE_PREFER_IPV4_ADDRESS is not set
+# CONFIG_VERBOSE_RESOLUTION_ERRORS is not set
+# CONFIG_ARP is not set
+# CONFIG_ARPING is not set
+# CONFIG_SENDARP is not set
+# CONFIG_BRCTL is not set
+# CONFIG_FEATURE_BRCTL_FANCY is not set
+# CONFIG_FEATURE_BRCTL_SHOW is not set
+# CONFIG_DNSD is not set
+# CONFIG_ETHER_WAKE is not set
+# CONFIG_FAKEIDENTD is not set
+# CONFIG_FTPD is not set
+# CONFIG_FEATURE_FTP_WRITE is not set
+# CONFIG_FEATURE_FTPD_ACCEPT_BROKEN_LIST is not set
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_FEATURE_FTPGETPUT_LONG_OPTIONS is not set
+# CONFIG_HOSTNAME is not set
+# CONFIG_HTTPD is not set
+# CONFIG_FEATURE_HTTPD_RANGES is not set
+# CONFIG_FEATURE_HTTPD_USE_SENDFILE is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_BASIC_AUTH is not set
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_CGI is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR is not set
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+# CONFIG_FEATURE_HTTPD_ENCODE_URL_STR is not set
+# CONFIG_FEATURE_HTTPD_ERROR_PAGES is not set
+# CONFIG_FEATURE_HTTPD_PROXY is not set
+# CONFIG_IFCONFIG is not set
+# CONFIG_FEATURE_IFCONFIG_STATUS is not set
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+# CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ is not set
+# CONFIG_FEATURE_IFCONFIG_HW is not set
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFENSLAVE is not set
+# CONFIG_IFPLUGD is not set
+# CONFIG_IFUPDOWN is not set
+CONFIG_IFUPDOWN_IFSTATE_PATH=""
+# CONFIG_FEATURE_IFUPDOWN_IP is not set
+# CONFIG_FEATURE_IFUPDOWN_IP_BUILTIN is not set
+# CONFIG_FEATURE_IFUPDOWN_IFCONFIG_BUILTIN is not set
+# CONFIG_FEATURE_IFUPDOWN_IPV4 is not set
+# CONFIG_FEATURE_IFUPDOWN_IPV6 is not set
+# CONFIG_FEATURE_IFUPDOWN_MAPPING is not set
+# CONFIG_FEATURE_IFUPDOWN_EXTERNAL_DHCP is not set
+# CONFIG_INETD is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_ECHO is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_TIME is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN is not set
+# CONFIG_FEATURE_INETD_RPC is not set
+# CONFIG_IP is not set
+# CONFIG_FEATURE_IP_ADDRESS is not set
+# CONFIG_FEATURE_IP_LINK is not set
+# CONFIG_FEATURE_IP_ROUTE is not set
+# CONFIG_FEATURE_IP_TUNNEL is not set
+# CONFIG_FEATURE_IP_RULE is not set
+# CONFIG_FEATURE_IP_SHORT_FORMS is not set
+# CONFIG_FEATURE_IP_RARE_PROTOCOLS is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+# CONFIG_IPROUTE is not set
+# CONFIG_IPTUNNEL is not set
+# CONFIG_IPRULE is not set
+# CONFIG_IPCALC is not set
+# CONFIG_FEATURE_IPCALC_FANCY is not set
+# CONFIG_FEATURE_IPCALC_LONG_OPTIONS is not set
+# CONFIG_NAMEIF is not set
+# CONFIG_FEATURE_NAMEIF_EXTENDED is not set
+# CONFIG_NETSTAT is not set
+# CONFIG_FEATURE_NETSTAT_WIDE is not set
+# CONFIG_FEATURE_NETSTAT_PRG is not set
+# CONFIG_NSLOOKUP is not set
+# CONFIG_NTPD is not set
+# CONFIG_FEATURE_NTPD_SERVER is not set
+# CONFIG_PING is not set
+# CONFIG_PING6 is not set
+# CONFIG_FEATURE_FANCY_PING is not set
+# CONFIG_PSCAN is not set
+# CONFIG_ROUTE is not set
+# CONFIG_SLATTACH is not set
+# CONFIG_TCPSVD is not set
+# CONFIG_TELNET is not set
+# CONFIG_FEATURE_TELNET_TTYPE is not set
+# CONFIG_FEATURE_TELNET_AUTOLOGIN is not set
+# CONFIG_TELNETD is not set
+# CONFIG_FEATURE_TELNETD_STANDALONE is not set
+# CONFIG_FEATURE_TELNETD_INETD_WAIT is not set
+# CONFIG_TFTP is not set
+# CONFIG_TFTPD is not set
+# CONFIG_BRCMTFTPD is not set
+
+#
+# Common options for tftp/tftpd
+#
+# CONFIG_FEATURE_TFTP_GET is not set
+# CONFIG_FEATURE_TFTP_PUT is not set
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_FEATURE_TFTP_PROGRESS_BAR is not set
+# CONFIG_TFTP_DEBUG is not set
+# CONFIG_TRACEROUTE is not set
+# CONFIG_TRACEROUTE6 is not set
+# CONFIG_FEATURE_TRACEROUTE_VERBOSE is not set
+# CONFIG_FEATURE_TRACEROUTE_SOURCE_ROUTE is not set
+# CONFIG_FEATURE_TRACEROUTE_USE_ICMP is not set
+# CONFIG_TUNCTL is not set
+# CONFIG_FEATURE_TUNCTL_UG is not set
+# CONFIG_UDHCPD is not set
+# CONFIG_DHCPRELAY is not set
+# CONFIG_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCPD_WRITE_LEASES_EARLY is not set
+CONFIG_DHCPD_LEASES_FILE=""
+# CONFIG_UDHCPC is not set
+# CONFIG_FEATURE_UDHCPC_ARPING is not set
+# CONFIG_FEATURE_UDHCP_PORT is not set
+CONFIG_UDHCP_DEBUG=0
+# CONFIG_FEATURE_UDHCP_RFC3397 is not set
+CONFIG_UDHCPC_DEFAULT_SCRIPT=""
+CONFIG_UDHCPC_SLACK_FOR_BUGGY_SERVERS=0
+CONFIG_IFUPDOWN_UDHCPC_CMD_OPTIONS=""
+# CONFIG_UDPSVD is not set
+# CONFIG_VCONFIG is not set
+# CONFIG_WGET is not set
+# CONFIG_FEATURE_WGET_STATUSBAR is not set
+# CONFIG_FEATURE_WGET_AUTHENTICATION is not set
+# CONFIG_FEATURE_WGET_LONG_OPTIONS is not set
+# CONFIG_FEATURE_WGET_HTTPS is not set
+# CONFIG_ZCIP is not set
+
+#
+# Print Utilities
+#
+# CONFIG_LPD is not set
+# CONFIG_LPR is not set
+# CONFIG_LPQ is not set
+
+#
+# Mail Utilities
+#
+# CONFIG_MAKEMIME is not set
+CONFIG_FEATURE_MIME_CHARSET=""
+# CONFIG_POPMAILDIR is not set
+# CONFIG_FEATURE_POPMAILDIR_DELIVERY is not set
+# CONFIG_REFORMIME is not set
+# CONFIG_FEATURE_REFORMIME_COMPAT is not set
+# CONFIG_SENDMAIL is not set
+
+#
+# Process Utilities
+#
+# CONFIG_SMEMCAP is not set
+# CONFIG_FREE is not set
+# CONFIG_FUSER is not set
+# CONFIG_KILL is not set
+# CONFIG_KILLALL is not set
+# CONFIG_KILLALL5 is not set
+# CONFIG_NMETER is not set
+# CONFIG_PGREP is not set
+# CONFIG_PIDOF is not set
+# CONFIG_FEATURE_PIDOF_SINGLE is not set
+# CONFIG_FEATURE_PIDOF_OMIT is not set
+# CONFIG_PKILL is not set
+CONFIG_PS=y
+# CONFIG_FEATURE_PS_WIDE is not set
+# CONFIG_FEATURE_PS_TIME is not set
+# CONFIG_FEATURE_PS_ADDITIONAL_COLUMNS is not set
+# CONFIG_FEATURE_PS_UNUSUAL_SYSTEMS is not set
+# CONFIG_RENICE is not set
+# CONFIG_BB_SYSCTL is not set
+# CONFIG_TOP is not set
+# CONFIG_FEATURE_TOP_CPU_USAGE_PERCENTAGE is not set
+# CONFIG_FEATURE_TOP_CPU_GLOBAL_PERCENTS is not set
+# CONFIG_FEATURE_TOP_SMP_CPU is not set
+# CONFIG_FEATURE_TOP_DECIMALS is not set
+# CONFIG_FEATURE_TOP_SMP_PROCESS is not set
+# CONFIG_FEATURE_TOPMEM is not set
+# CONFIG_FEATURE_SHOW_THREADS is not set
+# CONFIG_UPTIME is not set
+# CONFIG_WATCH is not set
+
+#
+# Runit Utilities
+#
+# CONFIG_RUNSV is not set
+# CONFIG_RUNSVDIR is not set
+# CONFIG_FEATURE_RUNSVDIR_LOG is not set
+# CONFIG_SV is not set
+CONFIG_SV_DEFAULT_SERVICE_DIR=""
+# CONFIG_SVLOGD is not set
+# CONFIG_CHPST is not set
+# CONFIG_SETUIDGID is not set
+# CONFIG_ENVUIDGID is not set
+# CONFIG_ENVDIR is not set
+# CONFIG_SOFTLIMIT is not set
+# CONFIG_CHCON is not set
+# CONFIG_FEATURE_CHCON_LONG_OPTIONS is not set
+# CONFIG_GETENFORCE is not set
+# CONFIG_GETSEBOOL is not set
+# CONFIG_LOAD_POLICY is not set
+# CONFIG_MATCHPATHCON is not set
+# CONFIG_RESTORECON is not set
+# CONFIG_RUNCON is not set
+# CONFIG_FEATURE_RUNCON_LONG_OPTIONS is not set
+# CONFIG_SELINUXENABLED is not set
+# CONFIG_SETENFORCE is not set
+# CONFIG_SETFILES is not set
+# CONFIG_FEATURE_SETFILES_CHECK_OPTION is not set
+# CONFIG_SETSEBOOL is not set
+# CONFIG_SESTATUS is not set
+
+#
+# Shells
+#
+CONFIG_ASH=y
+CONFIG_ASH_BASH_COMPAT=y
+# CONFIG_ASH_JOB_CONTROL is not set
+CONFIG_ASH_ALIAS=y
+# CONFIG_ASH_GETOPTS is not set
+# CONFIG_ASH_BUILTIN_ECHO is not set
+# CONFIG_ASH_BUILTIN_PRINTF is not set
+# CONFIG_ASH_BUILTIN_TEST is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_ASH_EXPAND_PRMT is not set
+# CONFIG_HUSH is not set
+# CONFIG_HUSH_BASH_COMPAT is not set
+# CONFIG_HUSH_HELP is not set
+# CONFIG_HUSH_INTERACTIVE is not set
+# CONFIG_HUSH_JOB is not set
+# CONFIG_HUSH_TICK is not set
+# CONFIG_HUSH_IF is not set
+# CONFIG_HUSH_LOOPS is not set
+# CONFIG_HUSH_CASE is not set
+# CONFIG_HUSH_FUNCTIONS is not set
+# CONFIG_HUSH_LOCAL is not set
+# CONFIG_HUSH_EXPORT_N is not set
+# CONFIG_HUSH_RANDOM_SUPPORT is not set
+CONFIG_FEATURE_SH_IS_ASH=y
+# CONFIG_FEATURE_SH_IS_HUSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+CONFIG_FEATURE_BASH_IS_ASH=y
+# CONFIG_FEATURE_BASH_IS_HUSH is not set
+# CONFIG_FEATURE_BASH_IS_NONE is not set
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+CONFIG_SH_MATH_SUPPORT=y
+# CONFIG_SH_MATH_SUPPORT_64 is not set
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE is not set
+# CONFIG_FEATURE_SH_NOFORK is not set
+# CONFIG_CTTYHACK is not set
+
+#
+# System Logging Utilities
+#
+# CONFIG_SYSLOGD is not set
+# CONFIG_FEATURE_ROTATE_LOGFILE is not set
+# CONFIG_FEATURE_REMOTE_LOG is not set
+# CONFIG_FEATURE_SYSLOGD_DUP is not set
+CONFIG_FEATURE_SYSLOGD_READ_BUFFER_SIZE=256
+# CONFIG_FEATURE_IPC_SYSLOG is not set
+CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE=16
+# CONFIG_LOGREAD is not set
+# CONFIG_FEATURE_LOGREAD_REDUCED_LOCKING is not set
+# CONFIG_KLOGD is not set
+# CONFIG_LOGGER is not set
+
diff -Naur busybox/include/applets.src.h busybox-brcm/include/applets.src.h
--- busybox/include/applets.src.h	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/include/applets.src.h	2018-11-24 13:44:16.369966884 -0400
@@ -72,6 +72,9 @@
 IF_AR(APPLET(ar, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_ARP(APPLET(arp, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_ARPING(APPLET(arping, _BB_DIR_USR_BIN, _BB_SUID_DROP))
+// brcm begin
+IF_SENDARP(APPLET(sendarp, _BB_DIR_USR_BIN, _BB_SUID_DROP))
+// brcm end
 IF_ASH(APPLET(ash, _BB_DIR_BIN, _BB_SUID_DROP))
 IF_AWK(APPLET_NOEXEC(awk, awk, _BB_DIR_USR_BIN, _BB_SUID_DROP, awk))
 IF_BASENAME(APPLET_NOFORK(basename, basename, _BB_DIR_USR_BIN, _BB_SUID_DROP, basename))
@@ -374,6 +377,7 @@
 IF_SYNC(APPLET_NOFORK(sync, sync, _BB_DIR_BIN, _BB_SUID_DROP, sync))
 IF_BB_SYSCTL(APPLET(sysctl, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_SYSLOGD(APPLET(syslogd, _BB_DIR_SBIN, _BB_SUID_DROP))
+IF_CPULOGD(APPLET(cpulogd, _BB_DIR_SBIN, _BB_SUID_DROP))
 IF_TAC(APPLET_NOEXEC(tac, tac, _BB_DIR_USR_BIN, _BB_SUID_DROP, tac))
 IF_TAIL(APPLET(tail, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_TAR(APPLET(tar, _BB_DIR_BIN, _BB_SUID_DROP))
@@ -424,6 +428,9 @@
 IF_WALL(APPLET(wall, _BB_DIR_USR_BIN, _BB_SUID_REQUIRE))
 IF_WATCH(APPLET(watch, _BB_DIR_BIN, _BB_SUID_DROP))
 IF_WATCHDOG(APPLET(watchdog, _BB_DIR_SBIN, _BB_SUID_DROP))
+// brcm begin
+IF_SYSINFO(APPLET(sysinfo, _BB_DIR_SBIN, _BB_SUID_DROP))
+// brcm end
 IF_WC(APPLET(wc, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_WGET(APPLET(wget, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_WHICH(APPLET(which, _BB_DIR_USR_BIN, _BB_SUID_DROP))
diff -Naur busybox/include/libbb.h busybox-brcm/include/libbb.h
--- busybox/include/libbb.h	2010-08-22 21:47:02.000000000 -0300
+++ busybox-brcm/include/libbb.h	2018-11-24 13:44:16.369966884 -0400
@@ -1427,6 +1427,11 @@
 #if ENABLE_FEATURE_TOP_SMP_PROCESS
 	int last_seen_on_cpu;
 #endif
+#ifdef BRCM_CMS_BUILD
+	int cpu_affinity;
+	int priority;
+	int sched_policy;
+#endif
 } procps_status_t;
 /* flag bits for procps_scan(xx, flags) calls */
 enum {
diff -Naur busybox/include/usage.src.h busybox-brcm/include/usage.src.h
--- busybox/include/usage.src.h	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/include/usage.src.h	2018-11-24 13:44:16.373963043 -0400
@@ -115,6 +115,23 @@
      "\n	-s SRC_IP	Sender IP address" \
      "\n	DST_IP		Target IP address" \
 
+// brcm begin
+#define sendarp_trivial_usage \
+       "-s <src device name> -d <dst device name>"
+#define sendarp_full_usage "\n\n" \
+       "Send ARP packet with src device's IP and Hardware address to dst device.\n" \
+     "\nOptions:" \
+     "\n	-s DEVNAME	src device name." \
+     "\n	-d DEVNAME	dst device name." \
+
+#define sysinfo_trivial_usage \
+	"System status report"
+#define sysinfo_full_usage \
+	"System status report\n\n" 
+#define sysinfo_example_usage \
+	"$ sysinfo\n"
+// brcm end
+
 #define sh_trivial_usage NOUSAGE_STR
 #define sh_full_usage ""
 #define ash_trivial_usage NOUSAGE_STR
@@ -1404,6 +1421,28 @@
 
 #define ftpget_trivial_usage \
        "[OPTIONS] HOST [LOCAL_FILE] REMOTE_FILE"
+// brcm begin
+#if 1
+#define ftpget_full_usage "\n\n" \
+       "Retrieve a remote file via FTP\n" \
+     "\nOptions:" \
+	IF_FEATURE_FTPGETPUT_LONG_OPTIONS( \
+     "\n	-c,--continue	Continue previous transfer" \
+     "\n	-v,--verbose	Verbose" \
+     "\n	-u,--username	Username" \
+     "\n	-p,--password	Password" \
+     "\n	-P,--port	Port number" \
+	) \
+	IF_NOT_FEATURE_FTPGETPUT_LONG_OPTIONS( \
+     "\n	-c	Continue previous transfer" \
+     "\n	-v	Verbose" \
+     "\n	-u	Username" \
+     "\n	-p	Password" \
+     "\n	-P	Port number" \
+	) \
+     "\n	-f Get (flash) broadcom, whole image or config file to modem" \
+     "\n	   ex. -f -u username -p password server_ip filename" 
+#else
 #define ftpget_full_usage "\n\n" \
        "Retrieve a remote file via FTP\n" \
      "\nOptions:" \
@@ -1421,6 +1460,8 @@
      "\n	-p	Password" \
      "\n	-P	Port number" \
 	)
+#endif
+// brcm end
 
 #define ftpput_trivial_usage \
        "[OPTIONS] HOST [REMOTE_FILE] LOCAL_FILE"
@@ -4179,7 +4220,11 @@
 #define syslogd_example_usage \
        "$ syslogd -R masterlog:514\n" \
        "$ syslogd -R 192.168.1.1:601\n"
-
+#define cpulogd_trivial_usage \
+        "OPTIONS"
+#define cpulogd_full_usage "\n\n" \
+        "\nOPTIONS:" \
+        "\n        -t         Inteval time to record the cpu usage" 
 #define tac_trivial_usage \
 	"[FILE]..."
 #define tac_full_usage "\n\n" \
@@ -4334,7 +4379,27 @@
 
 #define tftp_trivial_usage \
        "[OPTIONS] HOST [PORT]"
-#define tftp_full_usage "\n\n" \
+// brcm begin
+#if 1
+# define tftp_full_usage "\n\n" \
+       "Transfer a file from/to tftp server\n" \
+     "\nOptions:" \
+     "\n	-l FILE	Local FILE" \
+     "\n	-r FILE	Remote FILE" \
+	IF_FEATURE_TFTP_GET( \
+     "\n	-g	Get file" \
+	) \
+	IF_FEATURE_TFTP_PUT( \
+     "\n	-p	Put file" \
+	) \
+	IF_FEATURE_TFTP_BLOCKSIZE( \
+     "\n	-b SIZE	Transfer blocks of SIZE octets" \
+	) \
+     "\n	-g -t i -f filename server_ip   Get (flash) broadcom or whole image to modem" \
+     "\n	-g -t c -f filename server_ip   Get (flash) config file to modem" \
+     "\n	-p -t f -f filename server_ip   Put (backup) config file to tftpd server" 
+#else
+# define tftp_full_usage "\n\n" \
        "Transfer a file from/to tftp server\n" \
      "\nOptions:" \
      "\n	-l FILE	Local FILE" \
@@ -4348,6 +4413,8 @@
 	IF_FEATURE_TFTP_BLOCKSIZE( \
      "\n	-b SIZE	Transfer blocks of SIZE octets" \
 	)
+#endif
+// brcm end
 
 #define tftpd_trivial_usage \
        "[-cr] [-u USER] [DIR]"
@@ -4382,7 +4449,15 @@
 #define top_full_usage "\n\n" \
        "Provide a view of process activity in real time.\n" \
        "Read the status of all processes from /proc each SECONDS\n" \
-       "and display a screenful of them." \
+       "and display a screenful of them.\n" \
+       "BCM options:\n" \
+       "  -a enable alt display mode\n" \
+       "  -c0|1 filter output by CPU\n" \
+       "  -lNUM set max lines for output (default is 24)\n" \
+       "While top is running:\n" \
+       "--press c to toggle between per-cpu and aggregate CPU modes.\n" \
+       "--press p to sort by cpu percentage.\n" \
+       "--press y to sort by priority (BCM). " \
 //TODO: add options and keyboard commands
 
 #define touch_trivial_usage \
diff -Naur busybox/init/init.c busybox-brcm/init/init.c
--- busybox/init/init.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/init/init.c	2018-11-24 13:44:16.373963043 -0400
@@ -19,6 +19,9 @@
 # include <utmp.h> /* DEAD_PROCESS */
 #endif
 
+#if defined(SUPPORT_GPL_UNDEFINED)
+extern int AEI_save_syslog();
+#endif
 
 /* Was a CONFIG_xxx option. A lot of people were building
  * not fully functional init by switching it on! */
@@ -666,6 +669,10 @@
 	const char *m;
 	unsigned rb;
 
+#if defined(SUPPORT_GPL_UNDEFINED)
+    AEI_save_syslog();
+#endif
+
 	/* We may call run() and it unmasks signals,
 	 * including the one masked inside this signal handler.
 	 * Testcase which would start multiple reboot scripts:
@@ -695,6 +702,9 @@
 static void restart_handler(int sig UNUSED_PARAM)
 {
 	struct init_action *a;
+#if defined(SUPPORT_GPL_UNDEFINED)
+    AEI_save_syslog();
+#endif
 
 	for (a = init_action_list; a; a = a->next) {
 		if (!(a->action_type & RESTART))
diff -Naur busybox/libbb/appletlib.c busybox-brcm/libbb/appletlib.c
--- busybox/libbb/appletlib.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/libbb/appletlib.c	2018-11-24 13:44:16.373963043 -0400
@@ -66,7 +66,7 @@
 #if ENABLE_FEATURE_COMPRESS_USAGE
 
 static const char packed_usage[] ALIGN1 = { PACKED_USAGE };
-# include "unarchive.h"
+#include "unarchive.h"
 static const char *unpack_usage_messages(void)
 {
 	char *outbuf = NULL;
@@ -708,6 +708,10 @@
 	if (ENABLE_FEATURE_INSTALLER && strcmp(argv[1], "--install") == 0) {
 		int use_symbolic_links;
 		const char *busybox;
+		
+		//fixing compiler warning
+		(void)use_symbolic_links;
+		
 		busybox = xmalloc_readlink(bb_busybox_exec_path);
 		if (!busybox)
 			busybox = bb_busybox_exec_path;
diff -Naur busybox/libbb/procps.c busybox-brcm/libbb/procps.c
--- busybox/libbb/procps.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/libbb/procps.c	2018-11-24 13:44:16.381955361 -0400
@@ -52,6 +52,31 @@
 }
 #endif
 
+// brcm begin
+static void bcmHidePassword(char *command) {
+   char *ptr = NULL;
+   char * begin, *end;
+   int len = 0;
+
+   /* pppd -i .....  -p password */
+   if ((ptr = strstr(command,"pppd")) != NULL) {
+     if (!strstr(ptr, "-p")) 
+        return;
+     begin = strstr(ptr,"-p") + 3;
+     end = strchr(begin,' ');
+     if (end == NULL) 
+       len = strlen(begin);
+     else 
+       len = end - begin;
+     while (len > 0) {
+       *begin = '*';
+       begin++; len--;
+     }
+   }
+
+}
+// brcm end
+
 static char* get_cached(cache_t *cp, long id,
 			char* FAST_FUNC x2x_utoa(long id))
 {
@@ -330,7 +355,12 @@
 			cp = skip_fields(cp, 6); /* tpgid, flags, min_flt, cmin_flt, maj_flt, cmaj_flt */
 			sp->utime = fast_strtoul_10(&cp);
 			sp->stime = fast_strtoul_10(&cp);
+#ifdef BRCM_CMS_BUILD
+			cp = skip_fields(cp, 2); /* cutime, cstime */
+			sp->priority = (int) fast_strtol_10(&cp);
+#else
 			cp = skip_fields(cp, 3); /* cutime, cstime, priority */
+#endif
 			tasknice = fast_strtol_10(&cp);
 			cp = skip_fields(cp, 2); /* timeout, it_real_value */
 			sp->start_time = fast_strtoul_10(&cp);
@@ -345,6 +375,10 @@
 			cp = skip_fields(cp, 14);
 //FIXME: is it safe to assume this field exists?
 			sp->last_seen_on_cpu = fast_strtoul_10(&cp);
+#ifdef BRCM_CMS_BUILD
+			cp = skip_fields(cp, 1);
+			sp->sched_policy = (int) fast_strtol_10(&cp);
+#endif
 # endif
 #endif /* end of !ENABLE_FEATURE_TOP_SMP_PROCESS */
 
@@ -352,6 +386,17 @@
 			sp->niceness = tasknice;
 #endif
 
+#ifdef BRCM_CMS_BUILD
+			{
+				// see taskset.c
+				cpu_set_t mask;
+				sp->cpu_affinity = 0;
+				if (sched_getaffinity(pid, sizeof(mask), &mask) >= 0) {
+					if (CPU_ISSET(0, &mask)) sp->cpu_affinity |= 1;
+					if (CPU_ISSET(1, &mask)) sp->cpu_affinity |= 2;
+				}
+			}
+#endif
 			if (sp->vsz == 0 && sp->state[0] != 'Z')
 				sp->state[1] = 'W';
 			else
@@ -511,6 +556,17 @@
 			if ((unsigned char)(buf[sz]) < ' ')
 				buf[sz] = ' ';
 		} while (--sz >= 0);
+
+		// brcm begin
+		if ( strncmp(comm,"pppd",4)==0) 
+			bcmHidePassword(buf);
+
+		if ( strncmp(buf, "vodsl", 5) == 0 || 
+			strncmp(buf, "dectd", 5) == 0 )
+		{
+			strncpy(buf, comm, col);
+		}
+		// brcm end
 	} else {
 		snprintf(buf, col, "[%s]", comm);
 	}
diff -Naur busybox/Makefile busybox-brcm/Makefile
--- busybox/Makefile	2010-08-22 21:51:08.000000000 -0300
+++ busybox-brcm/Makefile	2018-11-24 13:44:16.310024497 -0400
@@ -327,6 +327,9 @@
 KERNELRELEASE = $(shell cat .kernelrelease 2> /dev/null)
 KERNELVERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
+# brcm: avoid rebuild busybox when there is no config changed.
+BUSYBOX_CONFDIFF := $(shell if [ -e ./.config.old ]; then cmp -i 106 ./.config ./.config.old; else echo yes; fi)
+
 export	VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION \
 	ARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC \
 	CPP AR NM STRIP OBJCOPY OBJDUMP MAKE AWK GENKSYMS PERL UTS_MACHINE \
@@ -360,8 +363,13 @@
 
 # This target generates Kbuild's and Config.in's from *.c files
 PHONY += gen_build_files
+ifneq ($(strip $(BUSYBOX_CONFDIFF)),)
 gen_build_files: $(wildcard $(srctree)/*/*.c) $(wildcard $(srctree)/*/*/*.c)
 	$(Q)$(srctree)/scripts/gen_build_files.sh $(srctree) $(objtree)
+else
+gen_build_files: 
+	@echo "skipping busybox: gen_build_files.sh"
+endif
 
 # bbox: we have helpers in applets/
 # we depend on scripts_basic, since scripts/basic/fixdep
@@ -958,6 +966,7 @@
 CLEAN_DIRS  += $(MODVERDIR) _install 0_lib
 CLEAN_FILES +=	busybox busybox_unstripped* busybox.links \
                 System.map .kernelrelease \
+		include/config/prefix.h \
                 .tmp_kallsyms* .tmp_version .tmp_busybox* .tmp_System.map
 
 # Directories & files removed with 'make mrproper'
@@ -981,7 +990,8 @@
 $(clean-dirs):
 	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
 
-clean: archclean $(clean-dirs)
+# brcm-bca: call distclean to clean up some runtime files.
+clean: archclean $(clean-dirs) distclean
 	$(call cmd,rmdirs)
 	$(call cmd,rmfiles)
 	@find . $(RCS_FIND_IGNORE) \
@@ -1022,6 +1032,7 @@
 		-o -name '.*.rej' -o -name '*.tmp' -o -size 0 \
 		-o -name '*%' -o -name '.*.cmd' -o -name 'core' \) \
 		-type f -print | xargs rm -f
+	@rm -f $(srctree)/include/usage.h $(srctree)/include/applets.h $(srctree)/include/NUM_APPLETS.h
 
 
 # Packaging of the kernel to various formats
diff -Naur busybox/Makefile.flags busybox-brcm/Makefile.flags
--- busybox/Makefile.flags	2010-08-22 05:21:38.000000000 -0300
+++ busybox-brcm/Makefile.flags	2018-11-24 13:44:16.310024497 -0400
@@ -69,6 +69,37 @@
 endif
 endif
 
+# brcm begin
+CFLAGS += -I$(BCM_FSBUILD_DIR)/public/include
+CFLAGS += -I$(BUILD_DIR)/userspace/public/include -I$(BUILD_DIR)/userspace/public/include/$(OALDIR)
+CFLAGS += -DTFTPD $(CMS_COMPILE_FLAGS) $(CMS_INCLUDE_PATHS)
+CFLAGS += $(CMS_LOG_FLAGS)
+CFLAGS += -I$(TOOLCHAIN)/include
+CFLAGS += $(BRCM_WERROR_CFLAGS)
+CFLAGS += -I$(KERNEL_LINKS_DIR)
+LDFLAGS += -Wl,-L$(TOOLCHAIN)/lib
+LDFLAGS += -Wl,-L$(TOOLCHAIN)/mips-linux/lib -L$(INSTALL_DIR)/lib -L$(INSTALL_DIR)/lib/public
+
+LDLIBS +=  cms_msg cms_util cms_boardctl resolv 
+
+ifneq ($(strip $(DESKTOP_LINUX)),)
+CFLAGS += -DDESKTOP_LINUX 
+# On Fedora 7, these ICMP6 symbols are not defined, so define them in the Makefile
+# so we don't have to change the .c file.
+CFLAGS += -DICMP6_MEMBERSHIP_QUERY=130 -DICMP6_MEMBERSHIP_REPORT=131 -DICMP6_MEMBERSHIP_REDUCTION=132
+LDLIBS += rt
+endif
+
+ifeq ($(strip $(CONFIG_FEATURE_WGET_HTTPS)),y)
+CFLAGS += -I$(BUILD_DIR)/userspace/public/libs/openssl/include
+LDLIBS += ssl crypto gcc_s
+endif
+
+ifeq ($(strip $(BUILD_SNMP_CHINA_TELECOM_CPE_MIB)),y)
+	CFLAGS += -DCPE_DSL_MIB
+endif
+# brcm end
+
 # If arch/$(ARCH)/Makefile did not override it (with, say, -fPIC)...
 ARCH_FPIC ?= -fpic
 ARCH_FPIE ?= -fpie
diff -Naur busybox/miscutils/Config.src busybox-brcm/miscutils/Config.src
--- busybox/miscutils/Config.src	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/miscutils/Config.src	2018-11-24 13:44:16.389947679 -0400
@@ -649,4 +649,12 @@
 	  certain amount of time, the watchdog device assumes the system has
 	  hung, and will cause the hardware to reboot.
 
+# brcm begin
+config SYSINFO
+	bool "sysinfo"
+	default y
+	help
+	  The system status report utility.
+# brcm end
+
 endmenu
diff -Naur busybox/miscutils/flash_eraseall.c busybox-brcm/miscutils/flash_eraseall.c
--- busybox/miscutils/flash_eraseall.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/miscutils/flash_eraseall.c	2018-11-24 13:44:16.393943838 -0400
@@ -10,198 +10,251 @@
  * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
  */
 
+#include <getopt.h>
+#include <features.h>
+#include <sys/types.h>
+#include <sys/stat.h>           /* stat */
+#include <sys/ioctl.h>           /* stat */
+#include <ctype.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
 #include "libbb.h"
 #include <mtd/mtd-user.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 30)
+#include <mtd/jffs2-user.h>
+#else
 #include <linux/jffs2.h>
+#endif
 
-#define OPTION_J	(1 << 0)
-#define OPTION_Q	(1 << 1)
-#define IS_NAND		(1 << 2)
-#define BBTEST		(1 << 3)
 
-/* mtd/jffs2-user.h used to have this atrocity:
-extern int target_endian;
+/* Broadcom has changed the definition of this structure in the kernel version
+ * of mtdabi.h.  This file includes a version of mtdabi.h from the toolchain.
+ * Therefore, copy the kernel definition here.
+ */
+#undef ECCGETLAYOUT
+#define ECCGETLAYOUT        _IOR('M', 17, struct k_nand_ecclayout)
+
+#if defined(MTD_MAX_OOBFREE_ENTRIES)
+#undef MTD_MAX_OOBFREE_ENTRIES
+#endif
+#if defined(MTD_MAX_OOBFREE_ENTRIES)
+#undef MTD_MAX_OOBFREE_ENTRIES
+#endif
+
+#if 1 // defined(CONFIG_BRCMNAND_MTD_EXTENSION)
+#define MTD_MAX_OOBFREE_ENTRIES	17
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 30)
+#define MTD_MAX_ECCPOS_ENTRIES	320	
+#endif
+#else
+#define MTD_MAX_OOBFREE_ENTRIES	8
+#define MTD_MAX_ECCPOS_ENTRIES	64	
+#endif
+
+/*
+ * ECC layout control structure. Exported to userspace for
+ * diagnosis and to allow creation of raw images
+ */
+struct k_nand_ecclayout {
+    uint32_t eccbytes;
+    uint32_t eccpos[MTD_MAX_ECCPOS_ENTRIES];
+    uint32_t oobavail;
+    struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
+};
+
+
+#define OPTION_J    (1 << 0)
+#define OPTION_Q    (1 << 1)
+#define OPTION_R    (1 << 2)
+#define OPTION_E    (1 << 3)
+#define IS_NAND     (1 << 4)
+#define BBTEST      (1 << 5)
 
+int target_endian = __BYTE_ORDER;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 30)
 #define t16(x) ({ __u16 __b = (x); (target_endian==__BYTE_ORDER)?__b:bswap_16(__b); })
 #define t32(x) ({ __u32 __b = (x); (target_endian==__BYTE_ORDER)?__b:bswap_32(__b); })
 
 #define cpu_to_je16(x) ((jint16_t){t16(x)})
 #define cpu_to_je32(x) ((jint32_t){t32(x)})
-#define cpu_to_jemode(x) ((jmode_t){t32(x)})
-
-#define je16_to_cpu(x) (t16((x).v16))
-#define je32_to_cpu(x) (t32((x).v32))
-#define jemode_to_cpu(x) (t32((x).m))
-
-but mtd/jffs2-user.h is gone now (at least 2.6.31.6 does not have it anymore)
-*/
-
-/* We always use native endianness */
-#undef cpu_to_je16
-#undef cpu_to_je32
-#define cpu_to_je16(v) ((jint16_t){(v)})
-#define cpu_to_je32(v) ((jint32_t){(v)})
-
-static uint32_t crc32(uint32_t val, const void *ss, int len,
-		uint32_t *crc32_table)
-{
-	const unsigned char *s = ss;
-	while (--len >= 0)
-		val = crc32_table[(val ^ *s++) & 0xff] ^ (val >> 8);
-	return val;
-}
+#endif
 
 static void show_progress(mtd_info_t *meminfo, erase_info_t *erase)
 {
-	printf("\rErasing %u Kibyte @ %x - %2u%% complete.",
-		(unsigned)meminfo->erasesize / 1024,
-		erase->start,
-		(unsigned) ((unsigned long long) erase->start * 100 / meminfo->size)
-	);
-	fflush_all();
+    printf("\rErasing %d Kibyte @ %x -- %2llu %% complete.",
+        (unsigned)meminfo->erasesize / 1024, erase->start,
+        (unsigned long long) erase->start * 100 / meminfo->size);
+    fflush(stdout);
 }
 
 int flash_eraseall_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int flash_eraseall_main(int argc UNUSED_PARAM, char **argv)
 {
-	struct jffs2_unknown_node cleanmarker;
-	mtd_info_t meminfo;
-	int fd, clmpos, clmlen;
-	erase_info_t erase;
-	struct stat st;
-	unsigned int flags;
-	char *mtd_name;
+    struct jffs2_unknown_node oob_cleanmarker;
+    mtd_info_t meminfo;
+    int fd, clmpos, clmlen;
+    erase_info_t erase;
+    struct stat st;
+    unsigned int flags;
+    char *mtd_name;
+    unsigned char spare_buf[16 * 27];
 
 	opt_complementary = "=1";
-	flags = BBTEST | getopt32(argv, "jq");
+    flags = BBTEST | getopt32(argv, "jqre");
 
-	mtd_name = argv[optind];
-	fd = xopen(mtd_name, O_RDWR);
-	fstat(fd, &st);
-	if (!S_ISCHR(st.st_mode))
-		bb_error_msg_and_die("%s: not a char device", mtd_name);
-
-	xioctl(fd, MEMGETINFO, &meminfo);
-	erase.length = meminfo.erasesize;
-	if (meminfo.type == MTD_NANDFLASH)
-		flags |= IS_NAND;
-
-	clmpos = 0;
-	clmlen = 8;
-	if (flags & OPTION_J) {
-		uint32_t *crc32_table;
-
-		crc32_table = crc32_filltable(NULL, 0);
-
-		cleanmarker.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
-		cleanmarker.nodetype = cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER);
-		if (!(flags & IS_NAND))
-			cleanmarker.totlen = cpu_to_je32(sizeof(struct jffs2_unknown_node));
-		else {
-			struct nand_oobinfo oobinfo;
-
-			xioctl(fd, MEMGETOOBSEL, &oobinfo);
-
-			/* Check for autoplacement */
-			if (oobinfo.useecc == MTD_NANDECC_AUTOPLACE) {
-				/* Get the position of the free bytes */
-				clmpos = oobinfo.oobfree[0][0];
-				clmlen = oobinfo.oobfree[0][1];
-				if (clmlen > 8)
-					clmlen = 8;
-				if (clmlen == 0)
-					bb_error_msg_and_die("autoplacement selected and no empty space in oob");
-			} else {
-				/* Legacy mode */
-				switch (meminfo.oobsize) {
-				case 8:
-					clmpos = 6;
-					clmlen = 2;
-					break;
-				case 16:
-					clmpos = 8;
-					/*clmlen = 8;*/
-					break;
-				case 64:
-					clmpos = 16;
-					/*clmlen = 8;*/
-					break;
-				}
-			}
-			cleanmarker.totlen = cpu_to_je32(8);
-		}
-
-		cleanmarker.hdr_crc = cpu_to_je32(crc32(0, &cleanmarker, sizeof(struct jffs2_unknown_node) - 4,
-					crc32_table));
-	}
-
-	/* Don't want to destroy progress indicator by bb_error_msg's */
-	applet_name = xasprintf("\n%s: %s", applet_name, mtd_name);
-
-	for (erase.start = 0; erase.start < meminfo.size;
-	     erase.start += meminfo.erasesize) {
-		if (flags & BBTEST) {
-			int ret;
-			loff_t offset = erase.start;
-
-			ret = ioctl(fd, MEMGETBADBLOCK, &offset);
-			if (ret > 0) {
-				if (!(flags & OPTION_Q))
-					bb_info_msg("\nSkipping bad block at 0x%08x", erase.start);
-				continue;
-			}
-			if (ret < 0) {
-				/* Black block table is not available on certain flash
-				 * types e.g. NOR
-				 */
-				if (errno == EOPNOTSUPP) {
-					flags &= ~BBTEST;
-					if (flags & IS_NAND)
-						bb_error_msg_and_die("bad block check not available");
-				} else {
-					bb_perror_msg_and_die("MEMGETBADBLOCK error");
-				}
-			}
-		}
-
-		if (!(flags & OPTION_Q))
-			show_progress(&meminfo, &erase);
-
-		xioctl(fd, MEMERASE, &erase);
-
-		/* format for JFFS2 ? */
-		if (!(flags & OPTION_J))
-			continue;
-
-		/* write cleanmarker */
-		if (flags & IS_NAND) {
-			struct mtd_oob_buf oob;
-
-			oob.ptr = (unsigned char *) &cleanmarker;
-			oob.start = erase.start + clmpos;
-			oob.length = clmlen;
-			xioctl(fd, MEMWRITEOOB, &oob);
-		} else {
-			xlseek(fd, erase.start, SEEK_SET);
-			/* if (lseek(fd, erase.start, SEEK_SET) < 0) {
-				bb_perror_msg("MTD %s failure", "seek");
-				continue;
-			} */
-			xwrite(fd, &cleanmarker, sizeof(cleanmarker));
-			/* if (write(fd, &cleanmarker, sizeof(cleanmarker)) != sizeof(cleanmarker)) {
-				bb_perror_msg("MTD %s failure", "write");
-				continue;
-			} */
-		}
-		if (!(flags & OPTION_Q))
-			printf(" Cleanmarker written at %x.", erase.start);
-	}
-	if (!(flags & OPTION_Q)) {
-		show_progress(&meminfo, &erase);
-		bb_putchar('\n');
-	}
-
-	if (ENABLE_FEATURE_CLEAN_UP)
-		close(fd);
-	return EXIT_SUCCESS;
+    mtd_name = argv[optind];
+    stat(mtd_name, &st);
+    if (!S_ISCHR(st.st_mode))
+        bb_error_msg_and_die("%s: not a char device", mtd_name);
+
+    fd = xopen(mtd_name, O_RDWR);
+
+    ioctl(fd, MEMGETINFO, &meminfo);
+    erase.length = meminfo.erasesize;
+    if (meminfo.type == MTD_NANDFLASH)
+        flags |= IS_NAND;
+
+    clmpos = 0;
+    clmlen = 8;
+    if (flags & OPTION_J) {
+
+        oob_cleanmarker.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
+        oob_cleanmarker.nodetype = cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER);
+        oob_cleanmarker.totlen = cpu_to_je32(8);
+        oob_cleanmarker.hdr_crc = cpu_to_je32(0xffffffff);
+        memset(spare_buf, 0xff, sizeof(spare_buf));
+        memcpy(spare_buf, (unsigned char *) &oob_cleanmarker,
+            sizeof(oob_cleanmarker));
+
+        if (!(flags & IS_NAND))
+            oob_cleanmarker.totlen = cpu_to_je32(sizeof(struct jffs2_unknown_node));
+        else {
+            struct k_nand_ecclayout ecclayout;
+
+            ioctl(fd, ECCGETLAYOUT, &ecclayout);
+            clmlen = ecclayout.oobavail;
+            clmpos = 0;
+        }
+    }
+
+    /* Don't want to destroy progress indicator by bb_error_msg's */
+    printf("\nflash_eraseall: %s", mtd_name);
+
+    for (erase.start = 0; erase.start < meminfo.size;
+         erase.start += meminfo.erasesize) {
+        if (flags & BBTEST) {
+            int ret;
+            loff_t offset = erase.start;
+
+            ret = ioctl(fd, MEMGETBADBLOCK, &offset);
+            if (ret > 0) {
+                if (!(flags & OPTION_Q))
+                    printf("\nSkipping bad block at 0x%08x", erase.start);
+                continue;
+            }
+            if (ret < 0) {
+                /* Black block table is not available on certain flash
+                 * types e.g. NOR
+                 */
+                if (errno == EOPNOTSUPP) {
+                    flags = ~BBTEST;
+                    if (flags & IS_NAND)
+                        bb_error_msg_and_die("bad block check not available");
+                } else {
+                    bb_perror_msg_and_die("MEMGETBADBLOCK error");
+                }
+            }
+        }
+
+        if (!(flags & OPTION_Q))
+            show_progress(&meminfo, &erase);
+
+        if (!(flags & OPTION_E))
+            ioctl(fd, MEMERASE, &erase);
+
+        /* format for JFFS2 ? */
+        if (!(flags & OPTION_J))
+            continue;
+
+        /* write cleanmarker */
+        if (flags & IS_NAND) {
+            struct mtd_oob_buf oob;
+
+            oob.ptr = spare_buf;
+            oob.start = erase.start + clmpos;
+            oob.length = clmlen;
+            ioctl(fd, MEMWRITEOOB, &oob);
+        } else {
+            lseek(fd, erase.start, SEEK_SET);
+            /* if (lseek(fd, erase.start, SEEK_SET) < 0) {
+                bb_perror_msg("MTD %s failure", "seek");
+                continue;
+            } */
+            write(fd, &oob_cleanmarker, sizeof(oob_cleanmarker));
+            /* if (write(fd, &oob_cleanmarker, sizeof(oob_cleanmarker)) != sizeof(oob_cleanmarker)) {
+                bb_perror_msg("MTD %s failure", "write");
+                continue;
+            } */
+        }
+        if (!(flags & OPTION_Q))
+            printf(" Cleanmarker written at %x.", erase.start);
+    }
+    if (!(flags & OPTION_Q)) {
+        show_progress(&meminfo, &erase);
+        putchar('\n');
+    }
+
+    if (flags & OPTION_R) {
+        int i;
+        /* For testing, read back cleanmarker. */
+        for (i= 0; i< meminfo.size; i+= meminfo.erasesize) { 
+
+            if (flags & IS_NAND) {
+                unsigned char spare[64];
+                struct mtd_oob_buf oob;
+
+                memset(spare, 0x00, sizeof(spare));
+                oob.ptr = (unsigned char *) &spare;
+                oob.start = i;
+                oob.length = sizeof(spare);
+                ioctl(fd, MEMREADOOB, &oob);
+                printf("R %8.8lx: %8.8x %8.8x %8.8x %8.8x\n",
+                    (unsigned long) (i + 0),
+                    *((unsigned char *) &spare[0]),
+                    *((unsigned char *) &spare[4]),
+                    *((unsigned char *) &spare[8]),
+                    *((unsigned char *) &spare[12]));
+#if 0
+                printf("R %8.8lx: %8.8lx %8.8lx %8.8lx %8.8lx\n",
+                    (unsigned long) (i + 16),
+                    *((unsigned long *) &spare[16]),
+                    *((unsigned long *) &spare[20]),
+                    *((unsigned long *) &spare[24]),
+                    *((unsigned long *) &spare[28]));
+                printf("R %8.8lx: %8.8lx %8.8lx %8.8lx %8.8lx\n",
+                    (unsigned long) (i + 32),
+                    *((unsigned long *) &spare[32]),
+                    *((unsigned long *) &spare[36]),
+                    *((unsigned long *) &spare[40]),
+                    *((unsigned long *) &spare[44]));
+                printf("R %8.8lx: %8.8lx %8.8lx %8.8lx %8.8lx\n\n",
+                    (unsigned long) (i + 48),
+                    *((unsigned long *) &spare[48]),
+                    *((unsigned long *) &spare[52]),
+                    *((unsigned long *) &spare[56]),
+                    *((unsigned long *) &spare[60]));
+#endif
+            }
+        }
+    }
+
+    close(fd);
+    return EXIT_SUCCESS;
 }
+
diff -Naur busybox/miscutils/Kbuild.src busybox-brcm/miscutils/Kbuild.src
--- busybox/miscutils/Kbuild.src	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/miscutils/Kbuild.src	2018-11-24 13:44:16.389947679 -0400
@@ -48,3 +48,6 @@
 lib-$(CONFIG_VOLNAME)     += volname.o
 lib-$(CONFIG_WALL)        += wall.o
 lib-$(CONFIG_WATCHDOG)    += watchdog.o
+# brcm begin
+lib-$(CONFIG_SYSINFO)    += sysinfo.o
+# brcm end
diff -Naur busybox/miscutils/sysinfo.c busybox-brcm/miscutils/sysinfo.c
--- busybox/miscutils/sysinfo.c	1969-12-31 20:00:00.000000000 -0400
+++ busybox-brcm/miscutils/sysinfo.c	2018-11-24 13:44:16.393943838 -0400
@@ -0,0 +1,100 @@
+/*
+ *  Report system information including
+ *      number of processes, uptime, system average load
+ *      and memory information.
+ *
+ */
+
+
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include "busybox.h"
+
+static const int FSHIFT = 16;              /* nr of bits of precision */
+#define FIXED_1         (1<<FSHIFT)     /* 1.0 as fixed-point */
+#define LOAD_INT(x) ((x) >> FSHIFT)
+#define LOAD_FRAC(x) LOAD_INT(((x) & (FIXED_1-1)) * 100)
+
+static int sysinfo_mem(void)
+{
+	struct sysinfo info;
+	sysinfo(&info);
+
+	/* Kernels prior to 2.4.x will return info.mem_unit==0, so cope... */
+	if (info.mem_unit==0) {
+		info.mem_unit=1;
+	}
+	info.mem_unit*=1024;
+
+	/* TODO:  Make all this stuff not overflow when mem >= 4 Gib */
+	info.totalram/=info.mem_unit;
+	info.freeram/=info.mem_unit;
+	info.totalswap/=info.mem_unit;
+	info.freeswap/=info.mem_unit;
+	info.sharedram/=info.mem_unit;
+	info.bufferram/=info.mem_unit;
+
+	printf("%6s%13s%13s%13s%13s%13s\n", "", "total", "used", "free",
+			"shared", "buffers");
+
+	printf("%6s%13ld%13ld%13ld%13ld%13ld\n", "Mem:", info.totalram,
+			info.totalram-info.freeram, info.freeram,
+			info.sharedram, info.bufferram);
+
+	printf("%6s%13ld%13ld%13ld\n", "Swap:", info.totalswap,
+			info.totalswap-info.freeswap, info.freeswap);
+
+	printf("%6s%13ld%13ld%13ld\n", "Total:", info.totalram+info.totalswap,
+			(info.totalram-info.freeram)+(info.totalswap-info.freeswap),
+			info.freeram+info.freeswap);
+	return EXIT_SUCCESS;
+}
+
+
+
+static int sysinfo_uptime(void)
+{
+	int updays, uphours, upminutes;
+	struct sysinfo info;
+	struct tm *current_time;
+	time_t current_secs;
+
+	time(&current_secs);
+	current_time = localtime(&current_secs);
+
+	sysinfo(&info);
+
+    printf("Number of processes: %d\n", info.procs);
+	printf(" %2d:%02d%s  up ",
+			current_time->tm_hour%12 ? current_time->tm_hour%12 : 12,
+			current_time->tm_min, current_time->tm_hour > 11 ? "pm" : "am");
+	updays = (int) info.uptime / (60*60*24);
+	if (updays)
+		printf("%d day%s, ", updays, (updays != 1) ? "s" : "");
+	upminutes = (int) info.uptime / 60;
+	uphours = (upminutes / 60) % 24;
+	upminutes %= 60;
+	if(uphours)
+		printf("%2d:%02d, ", uphours, upminutes);
+	else
+		printf("%d min, ", upminutes);
+
+	printf("\nload average: 1 min:%ld.%02ld, 5 min:%ld.%02ld, 15 min:%ld.%02ld\n",
+			LOAD_INT(info.loads[0]), LOAD_FRAC(info.loads[0]),
+			LOAD_INT(info.loads[1]), LOAD_FRAC(info.loads[1]),
+			LOAD_INT(info.loads[2]), LOAD_FRAC(info.loads[2]));
+
+	return EXIT_SUCCESS;
+}
+
+extern int sysinfo_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM) MAIN_EXTERNALLY_VISIBLE;
+extern int sysinfo_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
+{
+    sysinfo_uptime();
+    sysinfo_mem();
+
+    return EXIT_SUCCESS;
+
+}
diff -Naur busybox/networking/aei_nslookup.c busybox-brcm/networking/aei_nslookup.c
--- busybox/networking/aei_nslookup.c	1969-12-31 20:00:00.000000000 -0400
+++ busybox-brcm/networking/aei_nslookup.c	2018-11-24 13:44:16.397939997 -0400
@@ -0,0 +1,463 @@
+/***********************************************************************
+ *
+ *  Copyright (c) 2011  Actiontec Electronics Inc.
+ *  All Rights Reserved
+ *
+ *  This file is to store all functions that developed by Actiontec Electronics
+ *  in addition to routines provided by Broadcom. All additional routines that 
+ *  are missing from nslookup.c file will locate in this file. 
+ *
+ ************************************************************************/
+
+#if defined(AEI_VDSL_SMARTLED)
+
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <resolv.h>
+
+#include "cms_msg.h"
+#include "cms_util.h"
+
+#define MAXPACKET 65468
+#define __NETDB_MAXADDRS 35
+#define __NETDB_MAXALIASES 35
+#define pthread_ipaddr_type int 
+#define HOST_BUFSIZE 4096
+#define ALIGN(p, t) ((char *)(((((long)(p) - 1) / sizeof(t)) + 1) * sizeof(t)))
+#define SP(p, t, n) (ALIGN(p, t) + (n) * sizeof(t))
+
+struct __res_state _res = {
+    RES_TIMEOUT,               	/* retransmition time interval */
+    4,                         	/* number of times to retransmit */
+    RES_DEFAULT,		/* options flags */
+    1,                         	/* number of name servers */
+};
+
+struct	res_data {
+    char *buf;
+    struct __res_state state;
+    int errval;
+    int sock;
+};
+
+typedef union {
+    HEADER hdr;
+    unsigned char buf[MAXPACKET];
+} querybuf;
+
+typedef union {
+    long al;
+    char ac;
+} align;
+
+
+/* Performs global initialization. */
+struct res_data *globledata = NULL;
+static struct __res_state start;
+char dns_txt[1024] = {0};
+
+struct res_data *_res_init()
+{
+    /* Initialize thread-specific data for this thread if it hasn't
+     * been done already. */
+    if (globledata)
+        return globledata;
+    else
+    {
+        globledata = (struct res_data *) malloc(sizeof(struct res_data));
+        if (globledata == NULL)
+            return NULL;
+		
+        globledata->buf = NULL;
+        globledata->state = start;
+        globledata->errval = NO_RECOVERY;
+        globledata->sock = -1;
+	
+        return globledata;
+    }
+}
+
+struct __res_state *_res_status()
+{
+    struct res_data *data;
+	
+    data = _res_init();
+    return (data) ? &data->state : NULL;
+}
+
+static int qcomp(const void *arg1, const void *arg2)
+{
+    const struct in_addr **a1 = (const struct in_addr **) arg1;
+    const struct in_addr **a2 = (const struct in_addr **) arg2;
+    struct __res_state *state = _res_status();
+
+    int pos1, pos2;
+	
+    for (pos1 = 0; pos1 < state->nsort; pos1++) {
+        if (state->sort_list[pos1].addr.s_addr ==
+            ((*a1)->s_addr & state->sort_list[pos1].mask))
+            break;
+    }
+    for (pos2 = 0; pos2 < state->nsort; pos2++) {
+        if (state->sort_list[pos2].addr.s_addr ==
+            ((*a2)->s_addr & state->sort_list[pos2].mask))
+            break;
+    }
+    return pos1 - pos2;
+}
+
+int __dn_skipname(comp_dn, eom)
+    const u_char *comp_dn, *eom;
+{
+    register u_char *cp;
+    register int n;
+
+    cp = (u_char *)comp_dn;
+    while (cp < eom && (n = *cp++)) {
+        /*
+         * check for indirection
+         */
+        switch (n & INDIR_MASK) {
+            case 0:			/* normal case, n == len */
+                cp += n;
+                continue;
+            case INDIR_MASK:		/* indirection */
+                cp++;
+                break;
+            default:			/* illegal type */
+                return (-1);
+        }
+        break;
+    }
+
+    if (cp > eom)
+        return -1;
+
+    return (cp - comp_dn);
+}
+
+u_short
+_getshort(msgp)
+    register const u_char *msgp;
+{
+    register u_short u;
+
+    GETSHORT(u, msgp);
+    return (u);
+}
+
+struct hostent *_res_parse_answer(querybuf *answer, int anslen, int iquery,
+                                  struct hostent *result, char *buf,
+                                  int bufsize, int *errval)
+{
+    struct res_data *data = _res_init();
+    register HEADER *hp;
+    register u_char *cp;
+    register int n;
+    u_char *eom;
+    char *aliases[__NETDB_MAXALIASES], *addrs[__NETDB_MAXADDRS];
+    char *bp = buf, **ap = aliases, **hap = addrs;
+    int type, class, ancount, qdcount, getclass = C_ANY, iquery_done = 0;
+	
+    eom = answer->buf + anslen;
+    /*
+     * find first satisfactory answer
+     */
+    hp = &answer->hdr;
+    ancount = ntohs(hp->ancount);
+    qdcount = ntohs(hp->qdcount);
+    bp = buf;
+    cp = answer->buf + sizeof(HEADER);
+
+    /* Read in the hostname if this is an address lookup. */
+    if (qdcount) {
+        if (iquery) {
+            if ((n = dn_expand((u_char *) answer->buf,
+                               (u_char *) eom, (u_char *) cp, (u_char *) bp,
+                                bufsize - (bp - buf))) < 0) {
+                *errval = NO_RECOVERY;
+                return ((struct hostent *) NULL);
+            }
+            cp += n + QFIXEDSZ;
+            result->h_name = bp;
+            bp += strlen(bp) + 1;
+        } else {
+            cp += __dn_skipname(cp, eom) + QFIXEDSZ;
+        }
+        while (--qdcount > 0)
+            cp += __dn_skipname(cp, eom) + QFIXEDSZ;
+    } else if (iquery) {
+        *errval = (hp->aa) ? HOST_NOT_FOUND : TRY_AGAIN;
+        return ((struct hostent *) NULL);
+    }
+
+    /* Read in the answers. */
+    *ap = NULL;
+    *hap = NULL;
+    while (--ancount >= 0 && cp < eom) {
+        if ((n = dn_expand((u_char *) answer->buf, (u_char *) eom,
+                           (u_char *) cp, (u_char *) bp,
+                           bufsize - (bp - buf))) < 0)
+            break;
+
+        cp += n;
+        type = _getshort(cp);
+        cp += sizeof(u_short);
+        class = _getshort(cp);
+        cp += sizeof(u_short) + sizeof(pthread_ipaddr_type);
+        n = _getshort(cp);
+        cp += sizeof(u_short);
+        if (type == T_CNAME) {
+            cp += n;
+            if (ap >= aliases + __NETDB_MAXALIASES - 1)
+                continue;
+            *ap++ = bp;
+            bp += strlen(bp) + 1;
+            continue;
+        }
+        if (iquery && type == T_PTR) {
+            if ((n = dn_expand((u_char *) answer->buf, (u_char *) eom,
+                               (u_char *) cp, (u_char *) bp,
+                                bufsize - (bp - buf))) < 0)
+                break;
+
+            cp += n;
+            result->h_name = bp;
+            bp += strlen(bp) + 1;
+            iquery_done = 1;
+            break;
+        }
+		
+        if (iquery || type == 0x0010)	{
+            //printf("expected answer type %d, size %d\n", type, n);
+            memset(dns_txt, 0, sizeof(dns_txt));
+            strncpy(dns_txt, cp, n);
+            dns_txt[n] = '\0';
+            //printf("dns txt %s\n", dns_txt);
+            cp += n;
+        }
+		
+        if (hap > addrs) {
+            if (n != result->h_length) {
+                cp += n;
+                continue;
+            }
+            if (class != getclass) {
+                cp += n;
+                continue;
+            }
+        } else {
+            result->h_length = n;
+            getclass = class;
+            result->h_addrtype = (class == C_IN) ? AF_INET : AF_UNSPEC;
+            if (!iquery) {
+                result->h_name = bp;
+                bp += strlen(bp) + 1;
+            }
+        }
+		
+        bp = ALIGN(bp, char *);
+        //bp = ALIGN(bp, pthread_ipaddr_type);
+        if (bp + n >= buf + bufsize) {
+            errno = ERANGE;
+            return NULL;
+        }
+        memcpy(bp, cp, n);
+        cp += n;
+        if (hap >= addrs + __NETDB_MAXADDRS - 1)
+            continue;
+        *hap++ = bp;
+        bp += n;
+        cp += n;
+    }
+
+    if (hap > addrs || iquery_done) {
+        *ap++ = NULL;
+        *hap++ = NULL;
+        if (data->state.nsort)
+            qsort(addrs, hap - addrs, sizeof(struct in_addr), qcomp);
+
+        if (SP(bp, char *, (hap - addrs) + (ap - aliases)) > buf + bufsize) {
+            errno = ERANGE;
+            return NULL;
+        }
+        result->h_addr_list = (char **) ALIGN(bp, char *);
+        memcpy(result->h_addr_list, addrs, (hap - addrs) * sizeof(char *));
+        result->h_aliases = result->h_addr_list + (hap - addrs);
+        memcpy(result->h_aliases, aliases, (ap - aliases) * sizeof(char *));
+        return result;
+    } else {
+        *errval = TRY_AGAIN;
+        return NULL;
+    }
+}
+
+static struct hostent *fake_hostent(const char *hostname, struct in_addr addr,
+                                    struct hostent *result, char *buf,
+                                    int bufsize, int *errval)
+{
+    int len = strlen(hostname);
+    char *name, *addr_ptr;
+
+    if (SP(SP(SP(buf, char, len + 1), addr, 1), char *, 3) > buf + bufsize) {
+        errno = ERANGE;
+        return NULL;
+    }
+
+    /* Copy faked name and address into buffer. */
+    strcpy(buf, hostname);
+    name = buf;
+    buf = ALIGN(buf + len + 1, addr);
+    *((struct in_addr *) buf) = addr;
+    addr_ptr = buf;
+    buf = ALIGN(buf + sizeof(addr), char *);
+    ((char **) buf)[0] = addr_ptr;
+    ((char **) buf)[1] = NULL;
+    ((char **) buf)[2] = NULL;
+
+    result->h_name = name;
+    result->h_aliases = ((char **) buf) + 2;
+    result->h_addrtype = AF_INET;
+    result->h_length = sizeof(addr);
+    result->h_addr_list = (char **) buf;
+
+    return result;
+}
+
+static struct hostent *gethostbyname_txt_r(const char *hostname, struct hostent *result,
+                                           char *buf, int bufsize, int *errval)
+{
+    struct in_addr addr;
+    querybuf qbuf;
+    const char *p;
+    int n;
+
+    /* Default failure condition is not a range error and not recoverable. */
+    errno = 0;
+    *errval = NO_RECOVERY;
+	
+    /* Check for all-numeric hostname with no trailing dot. */
+    if (isdigit(hostname[0])) {
+        p = hostname;
+        while (*p && (isdigit(*p) || *p == '.'))
+            p++;
+
+        if (!*p && p[-1] != '.') {
+            /* Looks like an IP address; convert it. */
+            if (inet_aton(hostname, &addr) == -1) {
+                *errval = HOST_NOT_FOUND;
+                return NULL;
+            }
+            return fake_hostent(hostname, addr, result, buf, bufsize, errval);
+        }
+    }
+	
+    /* Do the search. */
+    //n = res_search(hostname, C_IN, T_A, qbuf.buf, sizeof(qbuf));
+    n = res_search(hostname, C_IN, 0x0010, qbuf.buf, sizeof(qbuf));
+    if (n >= 0)
+        return _res_parse_answer(&qbuf, n, 0, result, buf, bufsize, errval);	
+    else
+        return NULL;
+}
+
+struct hostent *AEI_gethostbyname_txt(const char *hostname)
+{
+    struct res_data *data = _res_init();
+
+    if (!data)
+        return NULL;
+    if (!data->buf) {
+        data->buf = malloc(sizeof(struct hostent) + HOST_BUFSIZE);
+        if (!data->buf) {
+            errno = 0;
+            data->errval = NO_RECOVERY;
+            return NULL;
+        }
+    }
+    return gethostbyname_txt_r(hostname, (struct hostent *) data->buf,
+                               data->buf + sizeof(struct hostent), HOST_BUFSIZE,
+                               &data->errval);
+}
+
+void AEI_sendTxtRecordForNslookup(void *msgHandle)
+{
+   char buf[sizeof(CmsMsgHeader) + 512] = {0};
+   CmsMsgHeader *msg = (CmsMsgHeader *)buf;
+   char *txtRecord = (char *)(msg + 1);
+   int strLength = 0;
+   CmsRet ret;
+
+   if (dns_txt[0] != '\0')
+       strLength = sprintf(txtRecord, "%s", dns_txt);
+   else
+       strLength = sprintf(txtRecord, "%s", "NSLookUp_NoResponse");
+
+   msg->type = CMS_MSG_NSLOOKUP_TXT_RDATA;
+   msg->src = EID_NSLOOKUP;
+   msg->dst = EID_SSK;
+   msg->flags_event = 1;
+   msg->dataLength = strLength;
+
+   if ((ret = cmsMsg_send(msgHandle, msg)) != CMSRET_SUCCESS)
+   {
+      cmsLog_error("could not send out CMS_MSG_NSLOOKUP_STATE_CHANGED to SSK, txtRecord : %s", txtRecord);
+   }
+   else
+   {
+      cmsLog_debug("sent out CMS_MSG_NSLOOKUP_TXT_RDATA to SSK txtRecord : %s", txtRecord);
+   }
+   cmsMsg_cleanup(&msgHandle);
+   return;
+}
+
+void AEI_cleanup()
+{
+    if (globledata)
+    {
+        if (globledata->buf != NULL)
+            free(globledata->buf);
+        free(globledata);
+    }
+}
+#endif /* AEI_VDSL_SMARTLED */
+
+#if defined(SUPPORT_GPL_UNDEFINED) || defined(SUPPORT_GPL)
+#include "cms_msg.h"
+#include "cms_util.h"
+void AEI_sendNslookupResult(void *msgHandle)
+{
+   char buf[sizeof(CmsMsgHeader) + 512] = {0};
+   CmsMsgHeader *msg = (CmsMsgHeader *)buf;
+   char *txtRecord = (char *)(msg + 1);
+   int strLength = 0;
+   CmsRet ret;
+
+   strLength = sprintf(txtRecord, "%s", "NSLookUp_Result");
+
+   msg->type = CMS_MSG_NSLOOKUP_RESULT;
+   msg->src = EID_NSLOOKUP;
+   msg->dst = EID_SSK;
+   msg->flags_event = 1;
+   msg->dataLength = strLength;
+
+   if ((ret = cmsMsg_send(msgHandle, msg)) != CMSRET_SUCCESS)
+   {
+      cmsLog_error("could not send out CMS_MSG_NSLOOKUP_STATE_CHANGED to SSK, txtRecord : %s", txtRecord);
+   }
+   else
+   {
+      cmsLog_debug("sent out CMS_MSG_NSLOOKUP_TXT_RDATA to SSK txtRecord : %s", txtRecord);
+   }
+   cmsMsg_cleanup(&msgHandle);
+   return;
+}
+
+#endif /* #if defined(SUPPORT_GPL_UNDEFINED) */
+
diff -Naur busybox/networking/Config.src busybox-brcm/networking/Config.src
--- busybox/networking/Config.src	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/networking/Config.src	2018-11-24 13:44:16.397939997 -0400
@@ -60,6 +60,14 @@
 	help
 	  Ping hosts by ARP packets.
 
+# brcm begin
+config SENDARP
+	bool "sendarp"
+	default y
+	help
+	  Ping hosts by ARP packets.
+# brcm end
+
 config BRCTL
 	bool "brctl"
 	default y
@@ -838,6 +846,15 @@
 	  In other words: it should be run from inetd in nowait mode,
 	  or from udpsvd. Example: "udpsvd -E 0 69 tftpd DIR"
 
+# brcm begin
+config BRCMTFTPD
+	bool "brcmtftpd"
+	default y
+	depends on TFTPD
+	help
+	  This will give you the tftpd with f/w upgrading feature.
+# brcm end
+
 comment "Common options for tftp/tftpd"
 	depends on TFTP || TFTPD
 
@@ -987,6 +1004,13 @@
 	help
 	  Support long options for the wget applet.
 
+config FEATURE_WGET_HTTPS
+	bool "Enable HTTPS Support"
+	default y
+	depends on WGET
+	help
+	  Support HTTPS transfers.
+
 config ZCIP
 	bool "zcip"
 	default y
diff -Naur busybox/networking/ftpgetput.c busybox-brcm/networking/ftpgetput.c
--- busybox/networking/ftpgetput.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/networking/ftpgetput.c	2018-11-24 13:44:16.401936156 -0400
@@ -14,6 +14,8 @@
  */
 
 #include "libbb.h"
+#include "cms_util.h" // brcm
+#include "cms_msg.h"
 
 struct globals {
 	const char *user;
@@ -22,6 +24,7 @@
 	FILE *control_stream;
 	int verbose_flag;
 	int do_continue;
+	int ftp_upgrade;
 	char buf[1]; /* actually [BUFSZ] */
 } FIX_ALIASING;
 #define G (*(struct globals*)&bb_common_bufsiz1)
@@ -35,10 +38,33 @@
 #define control_stream (G.control_stream)
 #define verbose_flag   (G.verbose_flag  )
 #define do_continue    (G.do_continue   )
+#define ftp_upgrade    (G.ftp_upgrade   )
 #define buf            (G.buf           )
 #define INIT_G() do { } while (0)
 
 
+// brcm begin
+#define CPE_FTP_OPER_STATUS_NORMAL           1
+#define CPE_FTP_OPER_STATUS_CONNECT_SUCCESS  2
+#define CPE_FTP_OPER_STATUS_CONECT_FAILURE   3
+#define CPE_FTP_OPER_STATUS_DOWNLOADING      4
+#define CPE_FTP_OPER_STATUS_DOWNLOAD_SUCCESS 5
+#define CPE_FTP_OPER_STATUS_DOWNLOAD_FAILURE 6
+#define CPE_FTP_OPER_STATUS_SAVING           7
+#define CPE_FTP_OPER_STATUS_SAVE_FAILURE     8
+#define CPE_FTP_OPER_STATUS_UPGRADE_SUCCESS  9
+#define CPE_FTP_OPER_STATUS_UPGRADE_FAIL     10
+static char *glbImagePtr = NULL;
+static int glbUploadSize = 0;
+static char *glbCurPtr = NULL;
+static int glbStartTime;
+static int glbTotal_size = 0;
+static int glbRead_total = 0;
+
+static void *msgHandle=NULL;
+// brcm end
+
+
 static void ftp_die(const char *msg) NORETURN;
 static void ftp_die(const char *msg)
 {
@@ -176,6 +202,160 @@
 	return EXIT_SUCCESS;
 }
 
+// brcm begin
+static void ftp_log(int status, int totalSize, int doneSize, int elapseTime)
+{
+   static FILE *ftpFile = NULL;    // store ftp statistics
+   ftpFile = fopen ("/var/ftpStats", "w");
+   if (ftpFile == NULL)
+   {
+      bb_error_msg_and_die("ftp error: failed to open file\n");
+   }
+  
+   fprintf(ftpFile, "operStatus = %d totalSize = %d doneSize = %d elapseTime = %d\n", 
+                     status, totalSize/1024, doneSize/1024, elapseTime);
+   fclose(ftpFile);
+}
+static int myWrite(char *inBuf, int inBufLen)
+{
+	static SINT32 allocSize = 0;
+   
+	if (glbCurPtr == NULL) 
+	{
+		if (inBufLen < 512)   // not enough data for a valid first packet and exit
+		{
+			bb_error_msg("ftpgetput myWrite exit inBufLen=%d\n", inBufLen);
+			return -1;   
+		}
+		// Allocate maximum flash image size + possible broadcom header TAG.
+		// (Don't bother getting the length from the broadcom TAG, we don't
+		// get a TAG if it is a whole image anyways.)
+		// The Linux kernel will not assign physical pages to the buffer
+		// until we write to it, so it is OK if we allocate a little more
+		// than we really need.
+		allocSize = cmsImg_getImageFlashSize() + cmsImg_getBroadcomImageTagSize();
+		bb_error_msg("Allocating %d bytes for flash image.\n", allocSize);
+		if ((glbCurPtr = (char *) malloc(allocSize)) == NULL)
+		{
+			bb_error_msg("Not enough memory error.  Could not allocate %u bytes.", allocSize);   
+			return -1;
+		}
+		bb_error_msg("Memory allocated\n");
+		glbImagePtr = glbCurPtr;
+	}
+
+	// copy the data from the current packet into our buffer
+	if (glbUploadSize + inBufLen < allocSize)
+	{
+		memcpy(glbCurPtr, inBuf, inBufLen);
+		glbCurPtr += inBufLen;
+		glbUploadSize += inBufLen;
+	}
+	else
+	{
+		bb_error_msg("Image could not fit into %u byte buffer.\n", allocSize);
+		return -1;
+	}
+	
+	return inBufLen;
+}
+
+// from copyfd.c function bb_full_fd_action
+static size_t brcm_get_ftp_data(int src_fd, const size_t size)
+{
+	size_t read_total = 0;
+	struct timeval tim;
+	int ftp_status = CPE_FTP_OPER_STATUS_NORMAL;
+	FILE *ftpPid = NULL;
+	int elapseTime, currentTime;
+	
+   RESERVE_CONFIG_BUFFER(buffer,BUFSIZ);
+	
+	gettimeofday(&tim, NULL);
+	glbStartTime = (int) tim.tv_sec;
+
+	// init ftp log
+	ftp_log(ftp_status, (int)size, 0,  0);
+	
+	if ((ftpPid = fopen ("/var/ftpPid", "w")) != NULL) 
+	{
+		fprintf(ftpPid,"%d\n",getpid()); (void)fclose(ftpPid);
+	}
+	else 
+	{
+		bb_perror_msg(bb_msg_write_error);
+        /* Coverity Fix - 31770. Resource leak*/
+#if defined(AEI_COVERITY_FIX)
+		RELEASE_CONFIG_BUFFER(buffer);
+#endif
+		return read_total;
+	}
+	
+	glbTotal_size = (int) size;
+	currentTime = glbStartTime;
+	while ((size == 0) || (read_total < size)) 
+	{
+		size_t read_try;
+		ssize_t read_actual;
+	
+		if ((size == 0) || (size - read_total > BUFSIZ)) 
+		{
+			read_try = BUFSIZ;
+		} 
+		else 
+		{
+			read_try = size - read_total;
+		}
+		
+		read_actual = safe_read(src_fd, buffer, read_try);
+		if (read_actual > 0) 
+		{
+			if (myWrite(buffer, (int)read_actual) != (int) read_actual) 
+			{
+				bb_perror_msg(bb_msg_write_error);	/* match Read error below */
+				break;
+			}
+		}
+		else if (read_actual == 0) 
+		{
+			if (size) 
+			{
+			   bb_error_msg("Unable to read all data");
+			}
+			break;
+		} 
+		else 
+		{
+			/* read_actual < 0 */
+			bb_perror_msg("Read error");
+			break;
+		}
+	
+		read_total += read_actual;
+		glbRead_total = (int) read_total;
+		gettimeofday(&tim, NULL);
+		if (currentTime < (int) tim.tv_sec) 
+		{
+			currentTime = (int) tim.tv_sec;
+			ftp_log(CPE_FTP_OPER_STATUS_DOWNLOADING, glbTotal_size, glbRead_total, (currentTime - glbStartTime));
+		}
+	}
+	
+	RELEASE_CONFIG_BUFFER(buffer);
+	
+	gettimeofday(&tim, NULL);
+	elapseTime = (int) tim.tv_sec - glbStartTime;
+	printf(" *** received ftp size = %d, need size = %d and %d seconds elapsed\n", read_total, size, elapseTime);
+	if (read_total != size) 
+	{
+		ftp_log(CPE_FTP_OPER_STATUS_DOWNLOAD_FAILURE, (int)size, read_total, elapseTime);
+		return(read_total);
+	}
+	
+	return(read_total);
+}
+// brcm end
+
 #if !ENABLE_FTPGET
 int ftp_receive(const char *local_path, char *server_path);
 #else
@@ -185,6 +365,8 @@
 	int fd_data;
 	int fd_local = -1;
 	off_t beg_range = 0;
+	off_t filesize = 0;
+	CmsRet ret;
 
 	/* connect to the data socket */
 	fd_data = xconnect_ftpdata();
@@ -192,6 +374,11 @@
 	if (ftpcmd("SIZE", server_path) != 213) {
 		do_continue = 0;
 	}
+	else
+	{
+		// filesize = XATOOFF(buf + 4);
+		filesize = strtoul(buf+4, NULL, 0);
+	}
 
 	if (LONE_DASH(local_path)) {
 		fd_local = STDOUT_FILENO;
@@ -216,21 +403,105 @@
 		if (ftpcmd(buf, NULL) != 350) {
 			do_continue = 0;
 		}
+		else 
+		{
+			filesize -= beg_range;
+		}
 	}
 
 	if (ftpcmd("RETR", server_path) > 150) {
 		ftp_die("RETR");
 	}
 
-	/* create local file _after_ we know that remote file exists */
-	if (fd_local == -1) {
-		fd_local = xopen(local_path,
-			do_continue ? (O_APPEND | O_WRONLY)
-			            : (O_CREAT | O_TRUNC | O_WRONLY)
-		);
-	}
 
-	return pump_data_and_QUIT(fd_data, fd_local);
+
+// brcm begin
+	if (ftp_upgrade)
+	{
+		char connIfName[CMS_IFNAME_LENGTH]={0};
+
+		if (filesize == 0) 
+		{     // not getting it from SIZE command, try it on RETR buf
+			char *ptr = NULL, *ptr2 = NULL;
+			ptr = strchr(buf, '(');
+			if (ptr) 
+			{
+				ptr2 = strchr(ptr, ' ');
+				if (ptr2)
+				{
+					*ptr2 = '\0';
+				}
+				filesize = strtoul(ptr+1, NULL, 0);
+			}
+			else
+				bb_error_msg("No size info in RETR command\n");
+		}
+	
+	
+	
+		/*
+		* There is a big image coming.  tftp is about to malloc a big buffer
+		* and start filling it.  Notify smd so it can do killAllApps or
+		* something to make memory available on the modem.
+		*/
+		if ((ret = cmsImg_saveIfNameFromSocket(fd_data, connIfName)) != CMSRET_SUCCESS)
+		{
+			cmsLog_error("could not get ifName for socket %d, ret=%d", fd_data, ret);
+			/*
+			* We can still go on even if we cannot get connIfName.  smd is able to
+			* handle a blank connIfName.
+			*/
+		}
+	
+		cmsImg_sendLoadStartingMsg(msgHandle, connIfName);
+	      
+	
+		/* get the file */
+		if (brcm_get_ftp_data(fd_data, filesize) != filesize) 
+		{
+			exit(EXIT_FAILURE);
+		}
+	
+		/* close it all down */
+		close(fd_data);
+	
+		if (ftpcmd(NULL, NULL) != 226) 
+		{
+			ftp_die(NULL);
+		}
+	
+	 	ftpcmd("QUIT", NULL);
+	
+		bb_error_msg("ftp test suceeds\n");
+	
+		/*
+		* cmsImsg_writeImage will determine the image format and write
+		* to flash.  If successful, the system will do a sysMipsSoftReset
+		* immediately.  So we will not return from this function call.
+		* (But on the desktop, this call does return, so we still have to check the
+		* return value.)
+		*/
+		if ((ret = cmsImg_writeImage(glbImagePtr, glbUploadSize, msgHandle)) != CMSRET_SUCCESS)
+		{
+			bb_error_msg("Tftp Image failed: Illegal image.\n");
+		}
+	
+		cmsImg_sendLoadDoneMsg(msgHandle);
+	
+		cmsMsg_cleanup(&msgHandle);
+		return(EXIT_SUCCESS);
+	}else{
+// brcm end
+		/* create local file _after_ we know that remote file exists */
+		if (fd_local == -1) {
+			fd_local = xopen(local_path,
+				do_continue ? (O_APPEND | O_WRONLY)
+				            : (O_CREAT | O_TRUNC | O_WRONLY)
+			);
+		}
+		cmsMsg_cleanup(&msgHandle); // brcm
+		return pump_data_and_QUIT(fd_data, fd_local);
+	}
 }
 #endif
 
@@ -280,6 +551,8 @@
 {
 	unsigned opt;
 	const char *port = "ftp";
+	CmsLogLevel logLevel = DEFAULT_LOG_LEVEL; // brcm
+	CmsRet ret;
 	/* socket to ftp server */
 
 #if ENABLE_FTPPUT && !ENABLE_FTPGET
@@ -300,15 +573,26 @@
 	user = "anonymous";
 	password = "busybox@";
 
+// brcm begin
+	cmsLog_init(EID_FTP);
+	cmsLog_setLevel(logLevel);
+
+	if ((ret = cmsMsg_init(EID_FTP, &msgHandle)) != CMSRET_SUCCESS)
+	{
+		printf("failed to open comm link with smd, tftp failed.");
+		return 0;
+	}
+// brcm end
+
 	/*
 	 * Decipher the command line
 	 */
 #if ENABLE_FEATURE_FTPGETPUT_LONG_OPTIONS
 	applet_long_options = ftpgetput_longopts;
 #endif
-	opt_complementary = "-2:vv:cc"; /* must have 2 to 3 params; -v and -c count */
-	opt = getopt32(argv, "cvu:p:P:", &user, &password, &port,
-					&verbose_flag, &do_continue);
+	opt_complementary = "-2:vv:cc:ff"; /* must have 2 to 3 params; -v and -c count */
+	opt = getopt32(argv, "cvfu:p:P:", &user, &password, &port,
+					&verbose_flag, &do_continue, &ftp_upgrade);
 	argv += optind;
 
 	/* We want to do exactly _one_ DNS lookup, since some
diff -Naur busybox/networking/interface.c busybox-brcm/networking/interface.c
--- busybox/networking/interface.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/networking/interface.c	2018-11-24 13:44:16.405932315 -0400
@@ -32,6 +32,11 @@
  */
 #include <net/if.h>
 #include <net/if_arp.h>
+
+
+#define _LINUX_IF_H
+#include <bcm_local_kernel_include/linux/netdevice.h>
+
 #if (defined(__GLIBC__) && __GLIBC__ >= 2 && __GLIBC_MINOR__ >= 1) || defined(_NEWLIB_VERSION)
 # include <net/ethernet.h>
 #else
@@ -53,7 +58,9 @@
 #endif
 
 #define _PATH_PROCNET_DEV               "/proc/net/dev"
+#define _PATH_PROCNET_DEVEXTSTATS       "/proc/net/dev_extstats"
 #define _PATH_PROCNET_IFINET6           "/proc/net/if_inet6"
+#define _PATH_NETDEV_FEATURES            "/sys/class/net/%s/features"
 
 #ifdef HAVE_AFINET6
 # ifndef _LINUX_IN6_H
@@ -306,6 +313,18 @@
 	unsigned long rx_dropped;	/* no space in linux buffers    */
 	unsigned long tx_dropped;	/* no space available in linux  */
 	unsigned long rx_multicast;	/* multicast packets received   */
+
+#if defined(BRCM_CMS_BUILD)
+    unsigned long   tx_multicast_packets;  /* multicast packets transmitted */
+    unsigned long   rx_multicast_bytes;  /* multicast bytes recieved */ 
+    unsigned long   tx_multicast_bytes;  /* multicast bytes transmitted */
+    unsigned long   rx_unicast_packets;  /* unicast packets recieved */
+    unsigned long   tx_unicast_packets;  /* unicast packets transmitted */
+    unsigned long   rx_broadcast_packets;  /* broadcast packets recieved */
+    unsigned long   tx_broadcast_packets;  /* broadcast packets transmitted */
+    unsigned long   rx_unknown_packets;  /* unknown protocol packets recieved */
+#endif
+	
 	unsigned long rx_compressed;
 	unsigned long tx_compressed;
 	unsigned long collisions;
@@ -342,6 +361,11 @@
 	char hwaddr[32];                        /* HW address            */
 	int statistics_valid;
 	struct user_net_device_stats stats;     /* statistics            */
+
+#if defined(BRCM_CMS_BUILD)
+    int procnetdev_vsn;                     /* Format of statistics */
+    int procnetdev_num_fields_read;         /* Number of statistics fields parsed */
+#endif
 	int keepalive;                          /* keepalive value for SLIP */
 	int outfill;                            /* outfill value for SLIP */
 };
@@ -452,53 +476,112 @@
 static const char *const ss_fmt[] = {
 	"%n%llu%u%u%u%u%n%n%n%llu%u%u%u%u%u",
 	"%llu%llu%u%u%u%u%n%n%llu%llu%u%u%u%u%u",
-	"%llu%llu%u%u%u%u%u%u%llu%llu%u%u%u%u%u%u"
+	"%llu%llu%u%u%u%u%u%u%llu%llu%u%u%u%u%u%u",
+	
+#if defined(BRCM_CMS_BUILD)
+    /* Extended statstics format */
+    "%llu%llu%u%u%u%u%u%u%llu%llu%u%u%u%u%u%u%u%u%u%u%u%u%u%u"
+#endif
 };
 #else
 static const char *const ss_fmt[] = {
 	"%n%llu%lu%lu%lu%lu%n%n%n%llu%lu%lu%lu%lu%lu",
 	"%llu%llu%lu%lu%lu%lu%n%n%llu%llu%lu%lu%lu%lu%lu",
-	"%llu%llu%lu%lu%lu%lu%lu%lu%llu%llu%lu%lu%lu%lu%lu%lu"
+	"%llu%llu%lu%lu%lu%lu%lu%lu%llu%llu%lu%lu%lu%lu%lu%lu",
+
+#if defined(BRCM_CMS_BUILD)
+    /* Extended statstics format */
+	"%llu%llu%lu%lu%lu%lu%lu%lu%llu%llu%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu%lu"
+#endif
 };
 
 #endif
 
+#if defined(BRCM_CMS_BUILD)
+#define NUM_SS_FMT_FIELDS_BASE 16       /* Fields parsed in base format */
+#define NUM_SS_FMT_FIELDS_EXTSTATS 24   /* Fields parsed in extended format */
+#endif
+
 static void get_dev_fields(char *bp, struct interface *ife, int procnetdev_vsn)
 {
+    /* Clear the statistics structure */
 	memset(&ife->stats, 0, sizeof(struct user_net_device_stats));
 
-	sscanf(bp, ss_fmt[procnetdev_vsn],
-		   &ife->stats.rx_bytes, /* missing for 0 */
-		   &ife->stats.rx_packets,
-		   &ife->stats.rx_errors,
-		   &ife->stats.rx_dropped,
-		   &ife->stats.rx_fifo_errors,
-		   &ife->stats.rx_frame_errors,
-		   &ife->stats.rx_compressed, /* missing for <= 1 */
-		   &ife->stats.rx_multicast, /* missing for <= 1 */
-		   &ife->stats.tx_bytes, /* missing for 0 */
-		   &ife->stats.tx_packets,
-		   &ife->stats.tx_errors,
-		   &ife->stats.tx_dropped,
-		   &ife->stats.tx_fifo_errors,
-		   &ife->stats.collisions,
-		   &ife->stats.tx_carrier_errors,
-		   &ife->stats.tx_compressed /* missing for <= 1 */
-		   );
-
-	if (procnetdev_vsn <= 1) {
-		if (procnetdev_vsn == 0) {
-			ife->stats.rx_bytes = 0;
-			ife->stats.tx_bytes = 0;
-		}
-		ife->stats.rx_multicast = 0;
-		ife->stats.rx_compressed = 0;
-		ife->stats.tx_compressed = 0;
-	}
+#if defined(BRCM_CMS_BUILD)
+    /* Record what format is being used (so we can print it out appropriately) */
+    ife->procnetdev_vsn = procnetdev_vsn;
+#endif
+    
+    /* Parse depending on the format of the file */
+    if(procnetdev_vsn < 3) {
+	
+        sscanf(bp, ss_fmt[procnetdev_vsn],
+               &ife->stats.rx_bytes, /* missing for 0 */
+               &ife->stats.rx_packets,
+               &ife->stats.rx_errors,
+               &ife->stats.rx_dropped,
+               &ife->stats.rx_fifo_errors,
+               &ife->stats.rx_frame_errors,
+               &ife->stats.rx_compressed, /* missing for <= 1 */
+               &ife->stats.rx_multicast, /* missing for <= 1 */
+               &ife->stats.tx_bytes, /* missing for 0 */
+               &ife->stats.tx_packets,
+               &ife->stats.tx_errors,
+               &ife->stats.tx_dropped,
+               &ife->stats.tx_fifo_errors,
+               &ife->stats.collisions,
+               &ife->stats.tx_carrier_errors,
+               &ife->stats.tx_compressed /* missing for <= 1 */
+               );
+
+        if (procnetdev_vsn <= 1) {
+            if (procnetdev_vsn == 0) {
+                ife->stats.rx_bytes = 0;
+                ife->stats.tx_bytes = 0;
+            }
+            ife->stats.rx_multicast = 0;
+            ife->stats.rx_compressed = 0;
+            ife->stats.tx_compressed = 0;
+        }
+    }
+
+#if defined(BRCM_CMS_BUILD)
+    else {
+        /* Read format from extended output, including multi/uni/broadcast data */
+        ife->procnetdev_num_fields_read = sscanf(bp, ss_fmt[procnetdev_vsn],
+                /* Basic statistics, just like procnetdev_vsn == 2 */
+               &ife->stats.rx_bytes, 
+               &ife->stats.rx_packets,
+               &ife->stats.rx_errors,
+               &ife->stats.rx_dropped,
+               &ife->stats.rx_fifo_errors,
+               &ife->stats.rx_frame_errors,
+               &ife->stats.rx_compressed, 
+               &ife->stats.rx_multicast, 
+               &ife->stats.tx_bytes, 
+               &ife->stats.tx_packets,
+               &ife->stats.tx_errors,
+               &ife->stats.tx_dropped,
+               &ife->stats.tx_fifo_errors,
+               &ife->stats.collisions,
+               &ife->stats.tx_carrier_errors,
+               &ife->stats.tx_compressed,       
+               
+               /* extended statistics */
+               &ife->stats.tx_multicast_packets, &ife->stats.rx_multicast_bytes, &ife->stats.tx_multicast_bytes, 
+               &ife->stats.rx_unicast_packets, &ife->stats.tx_unicast_packets, &ife->stats.rx_broadcast_packets, &ife->stats.tx_broadcast_packets, 
+               &ife->stats.rx_unknown_packets
+               );
+    }
+#endif
+    
 }
 
 static int procnetdev_version(char *buf)
 {
+    /* Look for labels in the heading that indicate what format is being used */    
+	if (strstr(buf, "unicast"))
+		return 3;
 	if (strstr(buf, "compressed"))
 		return 2;
 	if (strstr(buf, "bytes"))
@@ -566,14 +649,26 @@
 	if (!target)
 		proc_read = 1;
 
+#if defined(BRCM_CMS_BUILD)
+    /* Try to read extended statistics first */
+    if((fh = fopen(_PATH_PROCNET_DEVEXTSTATS, "r")) == NULL)
+#endif        
 	fh = fopen_or_warn(_PATH_PROCNET_DEV, "r");
+    
 	if (!fh) {
 		return if_readconf();
 	}
-	fgets(buf, sizeof buf, fh);	/* eat line */
-	fgets(buf, sizeof buf, fh);
+	fgets(buf, sizeof buf, fh);	/* eat first line */
+	fgets(buf, sizeof buf, fh); /* read second line */
 
 	procnetdev_vsn = procnetdev_version(buf);
+    
+
+#if defined(BRCM_CMS_BUILD)
+    /* For some formats, there's a third line of header that needs to be ignored */
+    if(procnetdev_vsn == 3)
+        fgets(buf, sizeof buf, fh);	/* eat third line */
+#endif
 
 	err = 0;
 	while (fgets(buf, sizeof buf, fh)) {
@@ -587,7 +682,11 @@
 			break;
 	}
 	if (ferror(fh)) {
+#if defined(BRCM_CMS_BUILD)    
+		bb_perror_msg(_PATH_PROCNET_DEVEXTSTATS);
+#else
 		bb_perror_msg(_PATH_PROCNET_DEV);
+#endif        
 		err = -1;
 		proc_read = 0;
 	}
@@ -882,7 +981,7 @@
 
 static const char TRext[] ALIGN1 = "\0\0\0Ki\0Mi\0Gi\0Ti";
 
-static void print_bytes_scaled(unsigned long long ull, const char *end)
+static void print_bytes_scaled(unsigned long long ull)
 {
 	unsigned long long int_part;
 	const char *ext;
@@ -901,8 +1000,7 @@
 		}
 		--i;
 	} while (i);
-
-	printf("X bytes:%llu (%llu.%u %sB)%s", ull, int_part, frac_part, ext, end);
+	printf("%llu (%llu.%u %sB)", ull, int_part, frac_part, ext);
 }
 
 
@@ -982,6 +1080,7 @@
 #define ife_print6(a) ((void)0)
 #endif
 
+
 static void ife_print(struct interface *ptr)
 {
 	const struct aftype *ap;
@@ -1001,7 +1100,7 @@
 	hw = get_hwntype(hf);
 	if (hw == NULL)
 		hw = get_hwntype(-1);
-
+        
 	printf("%-9s Link encap:%s  ", ptr->name, hw->title);
 	/* For some hardware types (eg Ash, ATM) we don't print the
 	   hardware address if it's null.  */
@@ -1097,32 +1196,113 @@
 	/* If needed, display the interface statistics. */
 
 	if (ptr->statistics_valid) {
-		/* XXX: statistics are currently only printed for the primary address,
-		 *      not for the aliases, although strictly speaking they're shared
-		 *      by all addresses.
-		 */
-		printf("          ");
-
-		printf("RX packets:%llu errors:%lu dropped:%lu overruns:%lu frame:%lu\n",
-			   ptr->stats.rx_packets, ptr->stats.rx_errors,
-			   ptr->stats.rx_dropped, ptr->stats.rx_fifo_errors,
-			   ptr->stats.rx_frame_errors);
-		if (can_compress)
-			printf("             compressed:%lu\n",
-				   ptr->stats.rx_compressed);
-		printf("          ");
-		printf("TX packets:%llu errors:%lu dropped:%lu overruns:%lu carrier:%lu\n",
-			   ptr->stats.tx_packets, ptr->stats.tx_errors,
-			   ptr->stats.tx_dropped, ptr->stats.tx_fifo_errors,
-			   ptr->stats.tx_carrier_errors);
-		printf("          collisions:%lu ", ptr->stats.collisions);
-		if (can_compress)
-			printf("compressed:%lu ", ptr->stats.tx_compressed);
-		if (ptr->tx_queue_len != -1)
-			printf("txqueuelen:%d ", ptr->tx_queue_len);
-		printf("\n          R");
-		print_bytes_scaled(ptr->stats.rx_bytes, "  T");
-		print_bytes_scaled(ptr->stats.tx_bytes, "\n");
+
+#if defined(BRCM_CMS_BUILD)
+        /* Depending on the format read in and whether or not the interface supports
+           extended stats, output the statistics */
+        if(ptr->procnetdev_vsn <= 2 || ptr->procnetdev_num_fields_read < NUM_SS_FMT_FIELDS_EXTSTATS) {
+#endif
+            /* Legacy formats */
+            
+            /* XXX: statistics are currently only printed for the primary address,
+             *      not for the aliases, although strictly speaking they're shared
+             *      by all addresses.
+             */
+            printf("          ");
+
+            printf("RX packets:%llu errors:%lu dropped:%lu overruns:%lu frame:%lu\n",
+                   ptr->stats.rx_packets, ptr->stats.rx_errors,
+                   ptr->stats.rx_dropped, ptr->stats.rx_fifo_errors,
+                   ptr->stats.rx_frame_errors);               
+            
+            printf("          ");
+            printf("TX packets:%llu errors:%lu dropped:%lu overruns:%lu carrier:%lu\n",
+                   ptr->stats.tx_packets, ptr->stats.tx_errors,
+                   ptr->stats.tx_dropped, ptr->stats.tx_fifo_errors,
+                   ptr->stats.tx_carrier_errors);
+            printf("          collisions:%lu ", ptr->stats.collisions);
+            if (can_compress)
+                printf("compressed:%lu ", ptr->stats.tx_compressed);
+                
+            if (ptr->tx_queue_len != -1)
+                {
+                printf("          ");
+                printf("txqueuelen:%d ", ptr->tx_queue_len);
+                }
+                
+            // Byte counts
+            printf("\n");
+            printf("          ");
+            printf("RX bytes:");
+            print_bytes_scaled(ptr->stats.rx_bytes);
+            printf(" TX bytes:");        
+            print_bytes_scaled(ptr->stats.tx_bytes);
+            printf("\n");
+
+#if defined(BRCM_CMS_BUILD)
+        }
+    else {
+            /* Extended formats, including multi/uni/broadcast data */
+            
+            /* XXX: statistics are currently only printed for the primary address,
+             *      not for the aliases, although strictly speaking they're shared
+             *      by all addresses.
+             */              
+
+            // RX packet counts
+            printf("          ");
+            printf("RX packets:%llu multicast:%lu unicast:%lu broadcast:%lu",
+                   ptr->stats.rx_packets, ptr->stats.rx_multicast,
+                   ptr->stats.rx_unicast_packets, ptr->stats.rx_broadcast_packets);
+            if (can_compress)
+                printf(" compressed:%lu\n", ptr->stats.rx_compressed);
+            else
+                printf("\n");
+                
+            // RX error counts
+            printf("          ");
+            printf("RX errors:%lu dropped:%lu overruns:%lu frame:%lu\n",
+                   ptr->stats.rx_errors,
+                   ptr->stats.rx_dropped, ptr->stats.rx_fifo_errors,
+                   ptr->stats.rx_frame_errors);
+
+            // TX packet counts
+            printf("          ");
+            printf("TX packets:%llu multicast:%lu unicast:%lu broadcast:%lu",
+                   ptr->stats.tx_packets, ptr->stats.tx_multicast_packets,
+                   ptr->stats.tx_unicast_packets, ptr->stats.tx_broadcast_packets);
+            if (can_compress)
+                printf(" compressed:%lu\n", ptr->stats.tx_compressed);
+            else
+                printf("\n");
+                              
+            // TX error counts
+            printf("          ");
+            printf("TX errors:%lu dropped:%lu overruns:%lu carrier:%lu collisions:%lu\n",
+                   ptr->stats.tx_errors,
+                   ptr->stats.tx_dropped, ptr->stats.tx_fifo_errors,
+                   ptr->stats.tx_carrier_errors, ptr->stats.collisions);             
+                
+            if (ptr->tx_queue_len != -1)
+                {
+                printf("          ");
+                printf("txqueuelen:%d\n", ptr->tx_queue_len);
+                }
+                
+            // Byte counts
+            printf("          ");
+            printf("RX bytes:");
+            print_bytes_scaled(ptr->stats.rx_bytes);
+            printf(" TX bytes:");        
+            print_bytes_scaled(ptr->stats.tx_bytes);
+            printf("\n          ");
+            printf("RX multicast bytes:");
+            print_bytes_scaled(ptr->stats.rx_multicast_bytes);
+            printf(" TX multicast bytes:");        
+            print_bytes_scaled(ptr->stats.tx_multicast_bytes);
+            printf("\n");
+        }
+#endif
 	}
 
 	if (ptr->map.irq || ptr->map.mem_start
diff -Naur busybox/networking/Kbuild.src busybox-brcm/networking/Kbuild.src
--- busybox/networking/Kbuild.src	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/networking/Kbuild.src	2018-11-24 13:44:16.397939997 -0400
@@ -9,6 +9,9 @@
 INSERT
 lib-$(CONFIG_ARP)          += arp.o interface.o
 lib-$(CONFIG_ARPING)       += arping.o
+# brcm begin
+lib-$(CONFIG_SENDARP)      += sendarp.o
+# brcm end
 lib-$(CONFIG_BRCTL)        += brctl.o
 lib-$(CONFIG_DNSD)         += dnsd.o
 lib-$(CONFIG_ETHER_WAKE)   += ether-wake.o
@@ -28,7 +31,7 @@
 lib-$(CONFIG_NAMEIF)       += nameif.o
 lib-$(CONFIG_NC)           += nc.o
 lib-$(CONFIG_NETSTAT)      += netstat.o
-lib-$(CONFIG_NSLOOKUP)     += nslookup.o
+lib-$(CONFIG_NSLOOKUP)     += aei_nslookup.o nslookup.o
 lib-$(CONFIG_NTPD)         += ntpd.o
 lib-$(CONFIG_PING)         += ping.o
 lib-$(CONFIG_PING6)        += ping.o
@@ -40,6 +43,9 @@
 lib-$(CONFIG_TELNETD)      += telnetd.o
 lib-$(CONFIG_TFTP)         += tftp.o
 lib-$(CONFIG_TFTPD)        += tftp.o
+# brcm begin
+lib-$(CONFIG_BRCMTFTPD)   += tftpd.o
+# brcm end
 lib-$(CONFIG_TRACEROUTE)   += traceroute.o
 lib-$(CONFIG_TUNCTL)       += tunctl.o
 lib-$(CONFIG_VCONFIG)      += vconfig.o
diff -Naur busybox/networking/nslookup.c busybox-brcm/networking/nslookup.c
--- busybox/networking/nslookup.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/networking/nslookup.c	2018-11-24 13:44:16.409928474 -0400
@@ -8,168 +8,403 @@
  * Correct default name server display and explicit name server option
  * added by Ben Zeckel <bzeckel@hmc.edu> June 2001
  *
- * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
  */
 
+#include <ctype.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <stdint.h>
+#include <netdb.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <netinet/in.h>
 #include <resolv.h>
-#include "libbb.h"
+#include <arpa/inet.h>
+#include "busybox.h"
+
+#if defined(AEI_VDSL_SMARTLED) || defined (SUPPORT_GPL)
+#include "cms_msg.h"
+#include "cms_log.h"
+
+extern struct hostent *AEI_gethostbyname_txt(const char *hostname);
+extern void AEI_sendTxtRecordForNslookup(void *msgHandle);
+extern void AEI_cleanup();
+
+static void *msgHandle = NULL;
+#endif
 
 /*
- * I'm only implementing non-interactive mode;
- * I totally forgot nslookup even had an interactive mode.
- *
- * This applet is the only user of res_init(). Without it,
- * you may avoid pulling in _res global from libc.
+ |  I'm only implementing non-interactive mode;
+ |  I totally forgot nslookup even had an interactive mode.
  */
 
-/* Examples of 'standard' nslookup output
- * $ nslookup yahoo.com
- * Server:         128.193.0.10
- * Address:        128.193.0.10#53
- *
- * Non-authoritative answer:
- * Name:   yahoo.com
- * Address: 216.109.112.135
- * Name:   yahoo.com
- * Address: 66.94.234.13
- *
- * $ nslookup 204.152.191.37
- * Server:         128.193.4.20
- * Address:        128.193.4.20#53
- *
- * Non-authoritative answer:
- * 37.191.152.204.in-addr.arpa     canonical name = 37.32-27.191.152.204.in-addr.arpa.
- * 37.32-27.191.152.204.in-addr.arpa       name = zeus-pub2.kernel.org.
- *
- * Authoritative answers can be found from:
- * 32-27.191.152.204.in-addr.arpa  nameserver = ns1.kernel.org.
- * 32-27.191.152.204.in-addr.arpa  nameserver = ns2.kernel.org.
- * 32-27.191.152.204.in-addr.arpa  nameserver = ns3.kernel.org.
- * ns1.kernel.org  internet address = 140.211.167.34
- * ns2.kernel.org  internet address = 204.152.191.4
- * ns3.kernel.org  internet address = 204.152.191.36
- */
+/* only works for IPv4 */
+static int addr_fprint(char *addr)
+{
+	uint8_t split[4];
+	uint32_t ip;
+	uint32_t *x = (uint32_t *) addr;
+
+	ip = ntohl(*x);
+	split[0] = (ip & 0xff000000) >> 24;
+	split[1] = (ip & 0x00ff0000) >> 16;
+	split[2] = (ip & 0x0000ff00) >> 8;
+	split[3] = (ip & 0x000000ff);
+	printf("%d.%d.%d.%d", split[0], split[1], split[2], split[3]);
+	return 0;
+}
 
-static int print_host(const char *hostname, const char *header)
+/* takes the NULL-terminated array h_addr_list, and
+ * prints its contents appropriately
+ */
+static int addr_list_fprint(char **h_addr_list)
 {
-	/* We can't use xhost2sockaddr() - we want to get ALL addresses,
-	 * not just one */
-	struct addrinfo *result = NULL;
-	int rc;
-	struct addrinfo hint;
-
-	memset(&hint, 0 , sizeof(hint));
-	/* hint.ai_family = AF_UNSPEC; - zero anyway */
-	/* Needed. Or else we will get each address thrice (or more)
-	 * for each possible socket type (tcp,udp,raw...): */
-	hint.ai_socktype = SOCK_STREAM;
-	// hint.ai_flags = AI_CANONNAME;
-	rc = getaddrinfo(hostname, NULL /*service*/, &hint, &result);
-
-	if (!rc) {
-		struct addrinfo *cur = result;
-		unsigned cnt = 0;
-
-		printf("%-10s %s\n", header, hostname);
-		// puts(cur->ai_canonname); ?
-		while (cur) {
-			char *dotted, *revhost;
-			dotted = xmalloc_sockaddr2dotted_noport(cur->ai_addr);
-			revhost = xmalloc_sockaddr2hostonly_noport(cur->ai_addr);
-
-			printf("Address %u: %s%c", ++cnt, dotted, revhost ? ' ' : '\n');
-			if (revhost) {
-				puts(revhost);
-				if (ENABLE_FEATURE_CLEAN_UP)
-					free(revhost);
+	int i, j;
+	char *addr_string = (h_addr_list[1])
+		? "Addresses:" : "Address:";
+
+	printf("%s", addr_string);
+	for (i = 0, j = 0; h_addr_list[i]; i++, j++) {
+		addr_fprint(h_addr_list[i]);
+
+		/* real nslookup does this */
+		if (j == 4) {
+			if (h_addr_list[i + 1]) {
+				printf("\n          ");
+			}
+			j = 0;
+		} else {
+			if (h_addr_list[i + 1]) {
+				printf(", ");
 			}
-			if (ENABLE_FEATURE_CLEAN_UP)
-				free(dotted);
-			cur = cur->ai_next;
 		}
+
+	}
+	printf("\n");
+	return 0;
+}
+
+/* print the results as nslookup would */
+static struct hostent *hostent_fprint(struct hostent *host, const char *server_host)
+{
+	if (host) {
+		printf("%s     %s\n", server_host, host->h_name);
+		addr_list_fprint(host->h_addr_list);
 	} else {
-#if ENABLE_VERBOSE_RESOLUTION_ERRORS
-		bb_error_msg("can't resolve '%s': %s", hostname, gai_strerror(rc));
-#else
-		bb_error_msg("can't resolve '%s'", hostname);
-#endif
+		printf("*** Unknown host\n");
 	}
-	if (ENABLE_FEATURE_CLEAN_UP)
-		freeaddrinfo(result);
-	return (rc != 0);
+	return host;
+}
+
+/* changes a c-string matching the perl regex \d+\.\d+\.\d+\.\d+
+ * into a uint32_t
+ */
+static uint32_t str_to_addr(const char *addr)
+{
+	uint32_t split[4];
+	uint32_t ip;
+
+	sscanf(addr, "%d.%d.%d.%d",
+		   &split[0], &split[1], &split[2], &split[3]);
+
+	/* assuming sscanf worked */
+	ip = (split[0] << 24) |
+		(split[1] << 16) | (split[2] << 8) | (split[3]);
+
+	return htonl(ip);
+}
+
+/* gethostbyaddr wrapper */
+static struct hostent *gethostbyaddr_wrapper(const char *address)
+{
+	struct in_addr addr;
+
+	addr.s_addr = str_to_addr(address);
+	return gethostbyaddr((char *) &addr, 4, AF_INET);	/* IPv4 only for now */
 }
 
 /* lookup the default nameserver and display it */
-static void server_print(void)
+static inline void server_print(void)
 {
-	char *server;
-	struct sockaddr *sa;
+	struct sockaddr_in def = _res.nsaddr_list[0];
+	char *ip = inet_ntoa(def.sin_addr);
+
 
-#if ENABLE_FEATURE_IPV6
-	sa = (struct sockaddr*)_res._u._ext.nsaddrs[0];
-	if (!sa)
-#endif
-		sa = (struct sockaddr*)&_res.nsaddr_list[0];
-	server = xmalloc_sockaddr2dotted_noport(sa);
-
-	print_host(server, "Server:");
-	if (ENABLE_FEATURE_CLEAN_UP)
-		free(server);
-	bb_putchar('\n');
+	hostent_fprint(gethostbyaddr_wrapper(ip), "Server:");
+	printf("\n");
 }
 
 /* alter the global _res nameserver structure to use
-   an explicit dns server instead of what is in /etc/resolv.conf */
-static void set_default_dns(const char *server)
+   an explicit dns server instead of what is in /etc/resolv.h */
+static inline void set_default_dns(char *server)
 {
-	len_and_sockaddr *lsa;
-
-	/* NB: this works even with, say, "[::1]:5353"! :) */
-	lsa = xhost2sockaddr(server, 53);
+	struct in_addr server_in_addr;
 
-	if (lsa->u.sa.sa_family == AF_INET) {
+	if(inet_aton(server,&server_in_addr))
+	{
 		_res.nscount = 1;
-		/* struct copy */
-		_res.nsaddr_list[0] = lsa->u.sin;
+		_res.nsaddr_list[0].sin_addr = server_in_addr;
 	}
-#if ENABLE_FEATURE_IPV6
-	/* Hoped libc can cope with IPv4 address there too.
-	 * No such luck, glibc 2.4 segfaults even with IPv6,
-	 * maybe I misunderstand how to make glibc use IPv6 addr?
-	 * (uclibc 0.9.31+ should work) */
-	if (lsa->u.sa.sa_family == AF_INET6) {
-		// glibc neither SEGVs nor sends any dgrams with this
-		// (strace shows no socket ops):
-		//_res.nscount = 0;
-		_res._u._ext.nscount = 1;
-		/* store a pointer to part of malloc'ed lsa */
-		_res._u._ext.nsaddrs[0] = &lsa->u.sin6;
-		/* must not free(lsa)! */
+}
+
+/* naive function to check whether char *s is an ip address */
+static int is_ip_address(const char *s)
+{
+	while (*s) {
+		if ((isdigit(*s)) || (*s == '.')) {
+			s++;
+			continue;
+		}
+		return 0;
 	}
+	return 1;
+}
+
+/* ________________________________________________________________________ */
+
+
+#if defined(SUPPORT_GPL_UNDEFINED) || defined(SUPPORT_GPL)
+unsigned int get_curr_timestamp_ms()
+{
+        unsigned int timestamp = 0;
+
+        struct timespec ts;
+        int rc;
+
+        rc = clock_gettime(CLOCK_MONOTONIC, &ts);
+        if (rc == 0)
+        {
+                timestamp =ts.tv_sec*1000 + ts.tv_nsec/(1000*1000);
+        }
+        else
+        {
+                timestamp = time(0)*1000;
+        }
+
+	printf(" ts.tv_sec:%d  ts.tv_nsec:%d timestamp:%d\n",ts.tv_sec,  ts.tv_nsec,timestamp);
+	return timestamp;
+
+
+}
+
+static struct hostent *hostent_fprint_with_responsetime(struct hostent *host, const char *server_host, unsigned int responsetime)
+{
+	if (host) {
+		printf("%s:%d\n", "responsetime", responsetime);
+		printf("%s:%s\n", server_host, host->h_name);
+		addr_list_fprint(host->h_addr_list);
+	} else {
+//		printf("%s:%d\n", "responsetime", responsetime);
+//		printf("%s:%s\n", server_host, host->h_name);
+		printf("resolve failed\n");
+	}
+	return host;
+}
+
 #endif
+
+#if defined (SUPPORT_GPL)
+void AEI_sendEventMessageForNsloopup(int flag)
+{
+   char buf[sizeof(CmsMsgHeader) + sizeof(int)]={0};
+   CmsMsgHeader *msg=(CmsMsgHeader *) buf;
+   int *nslookupBody = (int*) (msg+1);
+   CmsRet ret;
+
+   *nslookupBody=flag;
+
+   msg->type = CMS_MSG_NSLOOKUP_BACKOFF_RETURN;
+   msg->src = EID_NSLOOKUP;
+   msg->dst = EID_SSK;
+   msg->flags_event = 1;
+   msg->dataLength = sizeof(int);
+
+   
+   if ((ret = cmsMsg_send(msgHandle, msg)) != CMSRET_SUCCESS)
+   {
+      cmsLog_error("could not send out CMS_MSG_NSLOOKUP_BACKOFF_RETURN to SSK, ret=%d", ret);
+   }
+   else
+   {
+      cmsLog_debug("sent out CMS_MSG_NSLOOKUP_BACKOFF_RETURN (state=%d) to SSK", flag);
+   }
+   cmsMsg_cleanup(&msgHandle);
+   return;
 }
 
-int nslookup_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+//BRCM end
+#endif
+
+#ifdef SUPPORT_GPL_UNDEFINED
 int nslookup_main(int argc, char **argv)
 {
-	/* We allow 1 or 2 arguments.
-	 * The first is the name to be looked up and the second is an
-	 * optional DNS server with which to do the lookup.
-	 * More than 3 arguments is an error to follow the pattern of the
-	 * standard nslookup */
-	if (!argv[1] || argv[1][0] == '-' || argc > 3)
+
+	struct hostent *host;
+
+	/*
+	* initialize DNS structure _res used in printing the default
+	* name server and in the explicit name server option feature.
+	*/
+
+	
+	res_init();
+
+	/*
+	* We allow 1 or 2 arguments.
+	* The first is the name to be looked up and the second is an
+	* optional DNS server with which to do the lookup.
+	* More than 3 arguments is an error to follow the pattern of the
+	* standard nslookup
+	*/
+
+	if (argc < 2 || *argv[1]=='-' || argc > 3)
 		bb_show_usage();
+	else if(argc == 3)
+		set_default_dns(argv[2]);
+
+	if (is_ip_address(argv[1])) {
+		host = gethostbyaddr_wrapper(argv[0]);
+		printf("Name:       %s\n", argv[1]);
+		printf("Address:    %s\n", argv[1]);
+		return EXIT_SUCCESS;
+	} else {
+		host = xgethostbyname(argv[1]);
+	}
+	hostent_fprint(host, "Name:  ");
+	if (host) {
+		return EXIT_SUCCESS;
+	}
+	return EXIT_FAILURE;
+}
+
+#else
+int nslookup_main(int argc, char **argv)
+{
+	struct hostent *host;
+
+	/*
+	* initialize DNS structure _res used in printing the default
+	* name server and in the explicit name server option feature.
+	*/
+
+#if defined(SUPPORT_GPL_UNDEFINED) || defined(SUPPORT_GPL)
+	unsigned int timestamp = 0;
+	unsigned int responsetime = 0;
+#endif
 
-	/* initialize DNS structure _res used in printing the default
-	 * name server and in the explicit name server option feature. */
 	res_init();
-	/* rfc2133 says this enables IPv6 lookups */
-	/* (but it also says "may be enabled in /etc/resolv.conf") */
-	/*_res.options |= RES_USE_INET6;*/
 
-	if (argv[2])
+#if defined(AEI_VDSL_SMARTLED) || defined (SUPPORT_GPL)
+    cmsLog_init(EID_NSLOOKUP);
+    cmsLog_setLevel(DEFAULT_LOG_LEVEL);
+    cmsMsg_init(EID_NSLOOKUP, &msgHandle);
+#endif
+
+	/*
+	* We allow 1 or 2 arguments.
+	* The first is the name to be looked up and the second is an
+	* optional DNS server with which to do the lookup.
+	* More than 3 arguments is an error to follow the pattern of the
+	* standard nslookup
+	*/
+
+#if defined(SUPPORT_GPL_UNDEFINED) || defined(SUPPORT_GPL)
+	if (argc < 2 || *argv[1]=='-' || argc > 4)
+		bb_show_usage();
+	else if(argc==3 || argc==4)
 		set_default_dns(argv[2]);
+#else
+	if (argc < 2 || *argv[1]=='-' || argc > 3)
+		bb_show_usage();
+	else if(argc == 3)
+		set_default_dns(argv[2]);
+#endif
 
-	server_print();
-	return print_host(argv[1], "Name:");
+#if defined(AEI_VDSL_SMARTLED)
+	if (is_ip_address(argv[1])) {
+		host = gethostbyaddr_wrapper(argv[1]);
+	} else {
+#if defined(SUPPORT_GPL_UNDEFINED) || defined(SUPPORT_GPL)
+		if(argc==4 && !strcmp(argv[3], "nslookup_tmp")){
+			timestamp = get_curr_timestamp_ms();
+			host = gethostbyname(argv[1]);
+			responsetime =  get_curr_timestamp_ms() - timestamp;
+			hostent_fprint_with_responsetime(host, "hostname", responsetime);
+		}else
+#endif
+		host = AEI_gethostbyname_txt(argv[1]);
+	}
+#if defined(SUPPORT_GPL_UNDEFINED) || defined(SUPPORT_GPL)
+	if(argc==4 && !strcmp(argv[3], "nslookup_tmp")){
+		AEI_sendNslookupResult(msgHandle);
+	}else
+#endif
+	AEI_sendTxtRecordForNslookup(msgHandle);
+	AEI_cleanup();
+
+	if (host) {
+#if defined (SUPPORT_GPL)	    
+	    if(!strcmp(argv[1], "www.microsoft.com")||!strcmp(argv[1], "www.google.ca")||!strcmp(argv[1], "www.bellaliant.net"))
+	        AEI_sendEventMessageForNsloopup(1);
+#endif	    
+		return EXIT_SUCCESS;
+	}
+#if defined (SUPPORT_GPL)	    
+	if(!strcmp(argv[1], "www.microsoft.com")||!strcmp(argv[1], "www.google.ca")||!strcmp(argv[1], "www.bellaliant.net"))
+	    AEI_sendEventMessageForNsloopup(0);
+#endif		
+	return EXIT_FAILURE;
+#else
+	if (is_ip_address(argv[1])) {
+		host = gethostbyaddr_wrapper(argv[1]);
+	} else {
+#if defined(SUPPORT_GPL_UNDEFINED) || defined(SUPPORT_GPL)
+		if(argc==4 && !strcmp(argv[3], "nslookup_tmp")){
+			timestamp = get_curr_timestamp_ms();
+			host = gethostbyname(argv[1]);
+			responsetime =  get_curr_timestamp_ms() - timestamp;
+			hostent_fprint_with_responsetime(host, "hostname", responsetime);
+		}else
+#endif
+		host = xgethostbyname(argv[1]);
+	}
+#if defined(SUPPORT_GPL_UNDEFINED) || defined(SUPPORT_GPL)
+	if(argc==4 && !strcmp(argv[3], "nslookup_tmp")){
+		AEI_sendNslookupResult(msgHandle);
+	}else
+#endif
+	hostent_fprint(host, "Name:  ");
+	if (host) {
+#if defined (SUPPORT_GPL)	    
+	    if(!strcmp(argv[1], "www.microsoft.com")||!strcmp(argv[1], "www.google.ca")||!strcmp(argv[1], "www.bellaliant.net"))
+	        AEI_sendEventMessageForNsloopup(1);
+#endif	
+		return EXIT_SUCCESS;
+	}
+#if defined (SUPPORT_GPL)	    
+	if(!strcmp(argv[1], "www.microsoft.com")||!strcmp(argv[1], "www.google.ca")||!strcmp(argv[1], "www.bellaliant.net"))
+	    AEI_sendEventMessageForNsloopup(0);
+#endif
+	return EXIT_FAILURE;
+#endif
 }
+#endif
+
+/* $Id: nslookup.c,v 1.31 2004/01/30 22:40:05 andersen Exp $ */
diff -Naur busybox/networking/ping.c busybox-brcm/networking/ping.c
--- busybox/networking/ping.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/networking/ping.c	2018-11-24 13:44:16.409928474 -0400
@@ -39,6 +39,12 @@
 # endif
 #endif
 
+#ifdef BRCM_CMS_BUILD
+#include "cms_msg.h"
+#include "cms_util.h"
+#include "cms_log.h"
+#endif
+
 enum {
 	DEFDATALEN = 56,
 	MAXIPLEN = 60,
@@ -50,6 +56,24 @@
 
 /* Common routines */
 
+// brcm begin
+#ifdef BRCM_CMS_BUILD
+
+#define PING_IN_PROGRESS  0
+#define PING_FINISHED      1
+#define PING_ERROR        2  /* ping process exits on error */
+#define PING_UNKNOWN_HOST 3  /* ping unable to resolve host name */
+
+#ifdef BRCM_OMCI
+static UINT16 tcID = 0;
+static OmciPingDataMsgBody omciMsg;
+#endif
+static void *msgHandle=NULL;
+static CmsEntityId requesterId=0;
+#endif  /* BRCM_CMS_BUILD */
+// brcm end
+
+
 static int in_cksum(unsigned short *buf, int sz)
 {
 	int nleft = sz;
@@ -223,17 +247,21 @@
 
 /* Full(er) version */
 
-#define OPT_STRING ("qvc:s:w:W:I:4" IF_PING6("6"))
+#define OPT_STRING ("qvmc:s:w:W:I:t:i:Q:4" IF_PING6("6"))
 enum {
 	OPT_QUIET = 1 << 0,
 	OPT_VERBOSE = 1 << 1,
-	OPT_c = 1 << 2,
-	OPT_s = 1 << 3,
-	OPT_w = 1 << 4,
-	OPT_W = 1 << 5,
-	OPT_I = 1 << 6,
-	OPT_IPV4 = 1 << 7,
-	OPT_IPV6 = (1 << 8) * ENABLE_PING6,
+	OPT_m = 1 << 2,
+	OPT_c = 1 << 3,
+	OPT_s = 1 << 4,
+	OPT_w = 1 << 5,
+	OPT_W = 1 << 6,
+	OPT_I = 1 << 7,
+	OPT_t = 1 << 8,
+	OPT_i = 1 << 9,
+	OPT_Q = 1 << 10,
+	OPT_IPV4 = 1 << 11,
+	OPT_IPV6 = (1 << 12) * ENABLE_PING6,
 };
 
 
@@ -241,6 +269,8 @@
 	int pingsock;
 	int if_index;
 	char *str_I;
+	char *str_t;  // brcm
+	char *str_i;  // brcm
 	len_and_sockaddr *source_lsa;
 	unsigned datalen;
 	unsigned pingcount; /* must be int-sized */
@@ -252,6 +282,9 @@
 	unsigned timeout;
 	unsigned total_secs;
 	unsigned sizeof_rcv_packet;
+#ifdef AEI_VDSL_CUSTOMER_NCS
+    unsigned dscp;
+#endif
 	char *rcv_packet; /* [datalen + MAXIPLEN + MAXICMPLEN] */
 	void *snd_packet; /* [datalen + ipv4/ipv6_const] */
 	const char *hostname;
@@ -270,6 +303,8 @@
 #define if_index     (G.if_index    )
 #define source_lsa   (G.source_lsa  )
 #define str_I        (G.str_I       )
+#define str_t        (G.str_t       )  // brcm
+#define str_i        (G.str_i       )  // brcm
 #define datalen      (G.datalen     )
 #define ntransmitted (G.ntransmitted)
 #define nreceived    (G.nreceived   )
@@ -282,11 +317,15 @@
 #define deadline     (G.deadline    )
 #define timeout      (G.timeout     )
 #define total_secs   (G.total_secs  )
+#ifdef AEI_VDSL_CUSTOMER_NCS
+#define dscp         (G.dscp        )
+#endif
 #define hostname     (G.hostname    )
 #define dotted       (G.dotted      )
 #define pingaddr     (G.pingaddr    )
 #define rcvd_tbl     (G.rcvd_tbl    )
 void BUG_ping_globals_too_big(void);
+// brcm: changed default value of pingcount from 0 to 4.
 #define INIT_G() do { \
 	if (sizeof(G) > COMMON_BUFSIZE) \
 		BUG_ping_globals_too_big(); \
@@ -294,6 +333,7 @@
 	datalen = DEFDATALEN; \
 	timeout = MAXWAIT; \
 	tmin = UINT_MAX; \
+	pingcount = 4; \
 } while (0)
 
 
@@ -305,11 +345,172 @@
 
 /**************************************************************************/
 
+// brcm begin
+#ifdef BRCM_CMS_BUILD
+/* this is call to send message back to SMD to relay to interested party about the
+ * statistic of the most recent completed or stopped PING test */
+static void sendEventMessage(int finish, const char *host)
+{
+   char buf[sizeof(CmsMsgHeader) + sizeof(PingDataMsgBody)]={0};
+   CmsMsgHeader *msg=(CmsMsgHeader *) buf;
+   PingDataMsgBody *pingBody = (PingDataMsgBody*) (msg+1);
+   CmsRet ret;
+
+   cmsLog_debug("finish %d, ip %s, nTransmited/receive/tmin/tmax/tsum %d/%d/%d/%d/%d",
+                finish,host,ntransmitted,nreceived,tmin,tmax,tsum);
+
+   msg->type = CMS_MSG_PING_STATE_CHANGED;
+   msg->src = MAKE_SPECIFIC_EID(getpid(), EID_PING);
+   msg->dst = EID_SSK;
+   msg->flags_event = 1;
+   msg->dataLength = sizeof(PingDataMsgBody);
+
+   if (finish == PING_FINISHED)
+   {
+      sprintf(pingBody->diagnosticsState,MDMVS_COMPLETE); 
+   }
+   else if (finish == PING_IN_PROGRESS)
+   {
+      sprintf(pingBody->diagnosticsState,MDMVS_PING_INPROGRESS); 
+   }
+   else if (finish == PING_ERROR)
+   {
+      /* none, no status to report because ping process has error and die */
+      sprintf(pingBody->diagnosticsState,MDMVS_ERROR_CANNOTRESOLVEHOSTNAME); 
+   }
+
+   //   sprintf(pingBody->host,ip); 
+   sprintf(pingBody->host,host); 
+   pingBody->requesterId = requesterId;
+   pingBody->successCount = nreceived;
+   pingBody->failureCount = (ntransmitted-nreceived);
+   if (nreceived)
+   {
+      /*
+       * tsum,tmin,tmax are in us, but data model expects value in ms, so
+       * divide by 1000, with a round up to nearest ms.
+       */
+#ifndef CONFIG_FEATURE_FANCY_PING
+      pingBody->averageResponseTime = tsum / (nreceived + nrepeats);
+#else
+      pingBody->averageResponseTime = tsum / nreceived;
+#endif
+      pingBody->averageResponseTime = (pingBody->averageResponseTime+500)/1000;
+      pingBody->minimumResponseTime = (tmin+500) / 1000;
+      pingBody->maximumResponseTime = (tmax+500) / 1000;
+   }
+   else 
+   {
+      pingBody->averageResponseTime = 0;
+      pingBody->minimumResponseTime = 0;
+      pingBody->maximumResponseTime = 0;
+   }
+
+   if ((ret = cmsMsg_send(msgHandle, msg)) != CMSRET_SUCCESS)
+   {
+      cmsLog_error("could not send out CMS_MSG_PING_STATE_CHANGED to SSK, ret=%d", ret);
+   }
+   else
+   {
+      cmsLog_notice("sent out CMS_MSG_PING_STATE_CHANGED (finish=%d) to SSK", finish);
+   }
+   if (requesterId != 0)
+   {
+      msg->dst = requesterId;
+      if ((ret = cmsMsg_send(msgHandle, msg)) != CMSRET_SUCCESS)
+      {
+         cmsLog_error("could not send out CMS_MSG_PING_STATE_CHANGED to requestId %d, ret=%d", ret,(int)requesterId);
+      }
+      else
+      {
+         cmsLog_notice("sent out CMS_MSG_PING_STATE_CHANGED (finish=%d) to requesterId %d", finish,(int)requesterId);
+      }   
+   }
+   return;
+}
+
+#ifdef BRCM_OMCI
+static void sendOmciEventMessage(int finish)
+{
+   char buf[sizeof(CmsMsgHeader) + sizeof(OmciPingDataMsgBody)]={0};
+   CmsMsgHeader *msg=(CmsMsgHeader *) buf;
+   OmciPingDataMsgBody *pingBody = (OmciPingDataMsgBody*) (msg+1);
+   CmsRet ret;
+
+   if (finish == PING_IN_PROGRESS)
+      return;
+
+   cmsLog_debug("finish %d", finish);
+
+   msg->type = CMS_MSG_PING_STATE_CHANGED;
+   msg->src = MAKE_SPECIFIC_EID(getpid(), EID_PING);
+   msg->dst = EID_OMCID;
+   msg->flags_event = 1;
+   msg->dataLength = sizeof(OmciPingDataMsgBody);
+
+   omciMsg.tcid = tcID;
+   if (finish == PING_FINISHED)
+   {
+      omciMsg.result = CMSRET_SUCCESS;
+   }
+   else 
+   {
+      /* none, no status to report because ping process has error and die */
+      omciMsg.result = CMSRET_INTERNAL_ERROR;
+   }
+   memcpy(pingBody, &omciMsg, sizeof(omciMsg));
+
+   if ((ret = cmsMsg_send(msgHandle, msg)) != CMSRET_SUCCESS)
+   {
+      cmsLog_error("could not send out CMS_MSG_PING_STATE_CHANGED to OMCID, ret=%d", ret);
+   }
+   else
+   {
+      cmsLog_notice("sent out CMS_MSG_PING_STATE_CHANGED (finish=%d) to OMCID", finish);
+   }
+}
+#endif
+
+static void cmsCleanup(void)
+{
+   if (option_mask32 & OPT_m)
+   {
+      cmsMsg_cleanup(&msgHandle);
+   }
+   cmsLog_cleanup();
+}
+
+static void logStat(int finish)
+{
+   /* 
+    * Only call sendEventMessage if msgHandle to smd was successfully initialized.
+    */
+   if (msgHandle != NULL)
+   {
+#ifdef BRCM_OMCI
+      if (option_mask32 & OPT_i)
+         sendOmciEventMessage(finish);
+      else
+#endif
+         sendEventMessage(finish,hostname);
+   }
+}
+#endif  /* BRCM_CMS_BUILD */
+// brcm end
+
 static void print_stats_and_exit(int junk) NORETURN;
 static void print_stats_and_exit(int junk UNUSED_PARAM)
 {
 	signal(SIGINT, SIG_IGN);
 
+#ifdef BRCM_CMS_BUILD
+	// call logStat before ntransmitted is wiped out below
+	logStat(PING_FINISHED);
+#endif
+#ifdef AEI_VDSL_CUSTOMER_NCS
+	usleep(10000);//wait for send msg finished.
+#endif
+
 	printf("\n--- %s ping statistics ---\n", hostname);
 	printf("%lu packets transmitted, ", ntransmitted);
 	printf("%lu packets received, ", nreceived);
@@ -325,6 +526,11 @@
 			tavg / 1000, tavg % 1000,
 			tmax / 1000, tmax % 1000);
 	}
+
+#ifdef BRCM_CMS_BUILD
+	cmsCleanup();
+#endif
+
 	/* if condition is true, exit with 1 -- 'failure' */
 	exit(nreceived == 0 || (deadline && nreceived < pingcount));
 }
@@ -338,9 +544,44 @@
 
 	/* sizeof(pingaddr) can be larger than real sa size, but I think
 	 * it doesn't matter */
+//BRCM: fix network unreachable, ping exit in xsendto
+#if 0
 	sz = xsendto(pingsock, pkt, size_pkt, &pingaddr.sa, sizeof(pingaddr));
-	if (sz != size_pkt)
+#else
+    //copy from xsendto
+	sz = sendto(pingsock, pkt, size_pkt, 0, &pingaddr.sa, sizeof(pingaddr));
+	if (sz < 0) {
+#if defined(BRCM_CMS_BUILD)
+#ifdef BRCM_OMCI
+        if (option_mask32 & OPT_i)
+        {
+            //clear icmpReply, omcipmd sends out test timeout
+            memset(omciMsg.msg.icmpReply, 0, sizeof(omciMsg.msg.icmpReply));
+        }
+#endif
+        logStat(PING_ERROR);
+        cmsCleanup();
+#endif
+		if (ENABLE_FEATURE_CLEAN_UP)
+			close(pingsock);
+		bb_perror_msg_and_die("sendto");
+	}
+
+#endif
+	if (sz != size_pkt) {
+#if defined(BRCM_CMS_BUILD)
+#ifdef BRCM_OMCI
+        if (option_mask32 & OPT_i)
+        {
+            //clear icmpReply, omcipmd sends out test timeout
+            memset(omciMsg.msg.icmpReply, 0, sizeof(omciMsg.msg.icmpReply));
+        }
+#endif
+        logStat(PING_ERROR);
+        cmsCleanup();
+#endif
 		bb_error_msg_and_die(bb_msg_write_error);
+    }
 
 	if (pingcount == 0 || deadline || ntransmitted < pingcount) {
 		/* Didn't send all pings yet - schedule next in 1s */
@@ -394,7 +635,7 @@
 #if ENABLE_PING6
 static void sendping6(int junk UNUSED_PARAM)
 {
-	struct icmp6_hdr *pkt = alloca(datalen + sizeof(struct icmp6_hdr) + 4);
+	struct icmp6_hdr *pkt = G.snd_packet;
 
 	//memset(pkt, 0, datalen + sizeof(struct icmp6_hdr) + 4);
 	pkt->icmp6_type = ICMP6_ECHO_REQUEST;
@@ -460,7 +701,7 @@
 }
 #endif
 
-static void unpack_tail(int sz, uint32_t *tp,
+static void unpack_tail(int sz, uint32_t *tp, uint32_t *seq UNUSED_PARAM,
 		const char *from_str,
 		uint16_t recv_seq, int ttl)
 {
@@ -488,6 +729,20 @@
 		dupmsg += 7;
 	}
 
+// brcm begin
+#ifdef BRCM_CMS_BUILD
+#ifdef BRCM_OMCI
+   if (msgHandle != NULL)
+   {
+       if (recv_seq < pingcount) {
+           omciMsg.msg.responseTime[recv_seq] = (triptime < 1000) ? 1 : (triptime/1000);
+       }
+   }
+#endif
+       logStat(PING_IN_PROGRESS);
+#endif /* endif */
+// brcm end
+
 	if (option_mask32 & OPT_QUIET)
 		return;
 
@@ -514,7 +769,43 @@
 	sz -= hlen;
 	icmppkt = (struct icmp *) (buf + hlen);
 	if (icmppkt->icmp_id != myid)
-		return;				/* not our ping */
+    {
+#if defined(BRCM_CMS_BUILD) && defined(BRCM_OMCI)
+	    if (icmppkt->icmp_type == ICMP_DEST_UNREACH || 
+            icmppkt->icmp_type == ICMP_SOURCE_QUENCH ||
+            icmppkt->icmp_type == ICMP_TIME_EXCEEDED)
+        {
+            struct iphdr *iphdr_in;
+    	    struct icmp *icmppkt_in;
+            int hlen_in;
+
+            //icmp header len is 4, and 4 bytes unsed
+            //then ori ip header and icmp header
+            iphdr_in = (struct iphdr *) (buf + hlen + 8);
+	        hlen_in = iphdr_in->ihl << 2;
+            //now sz = sz - hlen, sz must >= 4(outter icmp header) + 4(unused of icmp) 
+            // + hlen_in + 6(inner icmp header)
+            if (sz < (4 + 4 + hlen_in + 6))
+                return;
+
+            icmppkt_in = (struct icmp *) (buf + hlen + 4 + 4 + hlen_in);
+    	    if (icmppkt_in->icmp_id != myid)
+                return;
+
+            if (option_mask32 & OPT_i)
+            {
+                memcpy(omciMsg.msg.icmpReply, &buf[hlen], sizeof(omciMsg.msg.icmpReply));
+                logStat(PING_ERROR);
+                cmsCleanup();
+                bb_error_msg_and_die("Warning: Got ICMP %d (%s)",
+                icmppkt->icmp_type, icmp_type_name (icmppkt->icmp_type));
+            }
+
+        }
+        else
+#endif
+		    return;				/* not our ping */
+    }
 
 	if (icmppkt->icmp_type == ICMP_ECHOREPLY) {
 		uint16_t recv_seq = ntohs(icmppkt->icmp_seq);
@@ -522,11 +813,23 @@
 
 		if (sz >= ICMP_MINLEN + sizeof(uint32_t))
 			tp = (uint32_t *) icmppkt->icmp_data;
-		unpack_tail(sz, tp,
+
+		unpack_tail(sz, tp, (uint32_t *)&icmppkt->icmp_seq,
 			inet_ntoa(*(struct in_addr *) &from->sin_addr.s_addr),
 			recv_seq, iphdr->ttl);
 	} else if (icmppkt->icmp_type != ICMP_ECHO) {
-		bb_error_msg("warning: got ICMP %d (%s)",
+#if defined(BRCM_CMS_BUILD) && defined(BRCM_OMCI)
+                if (option_mask32 & OPT_i)
+                {
+                   memcpy(omciMsg.msg.icmpReply, &buf[hlen], sizeof(omciMsg.msg.icmpReply));
+                   logStat(PING_ERROR);
+                   cmsCleanup();
+                   bb_error_msg_and_die("Warning: Got ICMP %d (%s)",
+                   icmppkt->icmp_type, icmp_type_name (icmppkt->icmp_type));
+                }
+                else
+#endif
+		   bb_error_msg("warning: got ICMP %d (%s)",
 				icmppkt->icmp_type,
 				icmp_type_name(icmppkt->icmp_type));
 	}
@@ -551,7 +854,7 @@
 
 		if (sz >= sizeof(struct icmp6_hdr) + sizeof(uint32_t))
 			tp = (uint32_t *) &icmppkt->icmp6_data8[4];
-		unpack_tail(sz, tp,
+		unpack_tail(sz, tp, NULL, 
 			inet_ntop(AF_INET6, &pingaddr.sin6.sin6_addr,
 					buf, sizeof(buf)),
 			recv_seq, hoplimit);
@@ -586,6 +889,18 @@
 	sockopt = (datalen * 2) + 7 * 1024; /* giving it a bit of extra room */
 	setsockopt(pingsock, SOL_SOCKET, SO_RCVBUF, &sockopt, sizeof(sockopt));
 
+ #ifdef AEI_VDSL_CUSTOMER_NCS
+	if (dscp > 0)
+	{
+		unsigned int val = dscp << 2;
+		if (setsockopt(pingsock, IPPROTO_IP, IP_TOS,
+				(char *)&val, sizeof(val)) < 0)
+		{
+			bb_perror_msg("set Qos parameter DSCP %u failed", dscp);
+		}
+	}
+#endif
+
 	signal(SIGINT, print_stats_and_exit);
 
 	/* start the ping's going ... */
@@ -658,6 +973,18 @@
 	/* request ttl info to be returned in ancillary data */
 	setsockopt(pingsock, SOL_IPV6, IPV6_HOPLIMIT, &const_int_1, sizeof(const_int_1));
 
+#ifdef AEI_VDSL_CUSTOMER_NCS
+	if (dscp > 0)
+	{
+		unsigned int val = dscp;
+		int on = 1;
+	    if (setsockopt(pingsock, SOL_IPV6, IPV6_RECVTCLASS,&on, sizeof(on)) < 0)
+			bb_perror_msg("set RECVTCLASS failed");
+	    if (setsockopt(pingsock, SOL_IPV6, IPV6_TCLASS,&val, sizeof(val)) < 0)
+			bb_perror_msg("set TCLASS %u failed", dscp);
+	}
+#endif
+
 	if (if_index)
 		pingaddr.sin6.sin6_scope_id = if_index;
 
@@ -682,7 +1009,7 @@
 
 		c = recvmsg(pingsock, &msg, 0);
 		if (c < 0) {
-			if (errno != EINTR)
+			     if (errno != EINTR)
 				bb_perror_msg("recvfrom");
 			continue;
 		}
@@ -735,9 +1062,14 @@
 
 	INIT_G();
 
-	/* exactly one argument needed; -v and -q don't mix; -c NUM, -w NUM, -W NUM */
-	opt_complementary = "=1:q--v:v--q:c+:w+:W+";
-	opt |= getopt32(argv, OPT_STRING, &pingcount, &str_s, &deadline, &timeout, &str_I);
+	/* exactly one argument needed; -v and -q don't mix; -c NUM, -w NUM, -W NUM -Q dscp*/
+#ifdef AEI_VDSL_CUSTOMER_NCS
+	opt_complementary = "=1:q--v:v--q:c+:w+:W+:Q+";
+	opt |= getopt32(argv, OPT_STRING, &pingcount, &str_s, &deadline, &timeout, &str_I, &str_t, &str_i,&dscp);
+#else
+    opt_complementary = "=1:q--v:v--q:c+:w+:W+";
+	opt |= getopt32(argv, OPT_STRING, &pingcount, &str_s, &deadline, &timeout, &str_I, &str_t, &str_i);
+#endif
 	if (opt & OPT_s)
 		datalen = xatou16(str_s); // -s
 	if (opt & OPT_I) { // -I
@@ -748,6 +1080,26 @@
 			str_I = NULL; /* don't try to bind to device later */
 		}
 	}
+
+#ifdef BRCM_CMS_BUILD
+	if (option_mask32 & OPT_t)
+		requesterId = xatou16(str_t); // -t
+
+#ifdef BRCM_OMCI
+	if (option_mask32 & OPT_i)
+    {
+		tcID = xatou16(str_i); // -i
+        memset(&omciMsg, 0, sizeof(OmciPingDataMsgBody));
+    }
+#endif
+    cmsLog_initWithName(EID_PING, argv[0]);
+    cmsLog_setLevel(DEFAULT_LOG_LEVEL);
+    if (option_mask32 & OPT_m)
+        cmsMsg_initWithFlags(EID_PING, EIF_MULTIPLE_INSTANCES, &msgHandle);
+
+    cmsLog_debug("starting ping argv %s",*argv);
+#endif
+
 	myid = (uint16_t) getpid();
 	hostname = argv[optind];
 #if ENABLE_PING6
@@ -757,7 +1109,26 @@
 			af = AF_INET;
 		if (opt & OPT_IPV6)
 			af = AF_INET6;
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+#define DNS_RESOLVE_TEST_WEBSITE "www.google.com"
+		if ((requesterId == EID_HTTPD) && (strncmp(hostname, DNS_RESOLVE_TEST_WEBSITE, strlen(DNS_RESOLVE_TEST_WEBSITE)) == 0))
+		{
+			lsa = host_and_af2sockaddr(hostname, 0, af);
+			if (lsa == NULL)
+			{
+				/* Need send the msg to SSK and HTTPD */
+				sendEventMessage(PING_ERROR, hostname);
+				usleep(10000);//wait for send msg finished.
+				xfunc_die();
+			}
+		}
+		else
+		{
+			lsa = xhost_and_af2sockaddr(hostname, 0, af);
+		}
+#else
 		lsa = xhost_and_af2sockaddr(hostname, 0, af);
+#endif
 	}
 #else
 	lsa = xhost_and_af2sockaddr(hostname, 0, AF_INET);
diff -Naur busybox/networking/sendarp.c busybox-brcm/networking/sendarp.c
--- busybox/networking/sendarp.c	1969-12-31 20:00:00.000000000 -0400
+++ busybox-brcm/networking/sendarp.c	2018-11-24 13:44:16.409928474 -0400
@@ -0,0 +1,169 @@
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/if_packet.h>
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <netinet/if_ether.h>
+#include "busybox.h"
+
+#define MAC_BCAST_ADDR	"\xff\xff\xff\xff\xff\xff"
+
+#define IFIPADDR        1
+#define IFHWADDR        2
+
+struct arpMsg {
+	struct ethhdr ethhdr;	 		/* Ethernet header */
+	u_short htype;				/* hardware type (must be ARPHRD_ETHER) */
+	u_short ptype;				/* protocol type (must be ETH_P_IP) */
+	u_char  hlen;				/* hardware address length (must be 6) */
+	u_char  plen;				/* protocol address length (must be 4) */
+	u_short operation;			/* ARP opcode */
+	u_char  sHaddr[6];			/* sender's hardware address */
+	u_char  sInaddr[4];			/* sender's IP address */
+	u_char  tHaddr[6];			/* target's hardware address */
+	u_char  tInaddr[4];			/* target's IP address */
+	u_char  pad[18];			/* pad for min. Ethernet payload (60 bytes) */
+};
+
+/* local prototypes */
+static void sendArp(char *srcDev, char *destDev);
+static void mkArpMsg(int opcode, u_long tInaddr, u_char *tHaddr, u_long sInaddr, u_char *sHaddr, struct arpMsg *msg);
+static int getDevInfo (char *devname, int infotype, char *data);
+
+int sendarp_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int sendarp_main(int argc, char **argv)
+{
+	char *srcdev = NULL;
+	char *dstdev = NULL;
+	int opt;
+
+	while ((opt = getopt(argc, argv, "s:d:")) != -1) {
+		switch (opt) {
+		case 's': 
+			srcdev = xstrdup(optarg);
+			break;
+		case 'd':
+			dstdev = xstrdup(optarg);
+			break;
+		}
+	}
+
+    if ((srcdev == NULL) || (dstdev == NULL)) {
+        bb_show_usage();
+        return 0;
+    }
+
+    /* send gratutious ARP packet with srcdev's IP and hardware address to dstdev */
+    sendArp(srcdev, dstdev);
+
+	return EXIT_SUCCESS;
+}
+
+static void mkArpMsg(int opcode, u_long tInaddr, u_char *tHaddr,
+		 u_long sInaddr, u_char *sHaddr, struct arpMsg *msg) {
+	bzero(msg, sizeof(*msg));
+	bcopy(MAC_BCAST_ADDR, msg->ethhdr.h_dest, 6); /* MAC DA */
+	bcopy(sHaddr, msg->ethhdr.h_source, 6);	/* MAC SA */
+	msg->ethhdr.h_proto = htons(ETH_P_ARP);	/* protocol type (Ethernet) */
+	msg->htype = htons(ARPHRD_ETHER);		/* hardware type */
+	msg->ptype = htons(ETH_P_IP);			/* protocol type (ARP message) */
+	msg->hlen = 6;							/* hardware address length */
+	msg->plen = 4;							/* protocol address length */
+	msg->operation = htons(opcode);			/* ARP op code */
+//brcm start
+   bcopy((u_char *)&sInaddr, &msg->sInaddr[0], 4);  /* source IP address */
+	bcopy(sHaddr, msg->sHaddr, 6);			/* source hardware address */
+   bcopy((u_char *)&tInaddr, &msg->tInaddr[0], 4);  /* target IP address */
+//brcm end
+	if ( opcode == ARPOP_REPLY )
+		bcopy(tHaddr, msg->tHaddr, 6);		/* target hardware address */
+}
+
+static int getDevInfo (char *devname, int infotype, char *data) {
+    int    sock;
+    struct ifreq ifr;
+    int rc = 0;
+
+    /* create device level socket */
+    if ((sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) < 0)
+    {
+		perror("cannot open socket ");
+        return -1;
+    }
+
+    memset(&ifr, 0, sizeof(struct ifreq));
+    strcpy(ifr.ifr_name, devname);
+    switch(infotype) {
+        case IFIPADDR:
+            /* get IP address */
+            if (ioctl(sock, SIOCGIFADDR, &ifr) == -1) {
+                rc = -1;
+            } else {
+                memcpy(data, &((struct sockaddr_in *)&(ifr.ifr_addr))->sin_addr, sizeof(struct in_addr));
+            }
+            break;
+        case IFHWADDR:
+            /* get hardware address */
+            if (ioctl(sock, SIOCGIFHWADDR, &ifr) == -1) {
+                rc = -1;
+            } else {
+                memcpy(data, ifr.ifr_hwaddr.sa_data, ETH_ALEN);
+            }
+            break;
+        default:
+            rc = -1;
+            break;
+    }
+	close (sock);
+	return rc;
+}
+
+static void sendArp(char *srcDev, char *destDev) {
+    int sock;
+    struct arpMsg arp;
+    unsigned char br_macaddr[ETH_ALEN];
+    unsigned char eth_macaddr[ETH_ALEN];
+    unsigned int br_ipAddr;
+    struct sockaddr_ll sll; 
+    struct ifreq ifr;
+    int flag;
+
+    if ((getDevInfo(srcDev, IFIPADDR, (char *)&br_ipAddr) == 0) &&
+       (getDevInfo(srcDev, IFHWADDR, (char *)br_macaddr) == 0) &&
+       (getDevInfo(destDev, IFHWADDR, (char *)eth_macaddr) == 0)) {
+            /* create device level socket */
+            if ((sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))) < 0) {
+		        perror("cannot open socket ");
+                return;
+            }
+
+            memset(&sll, 0, sizeof(sll));
+            sll.sll_family = AF_PACKET;
+            sll.sll_protocol = htons(ETH_P_ALL);
+
+            /* get interface index number */
+            memset(&ifr, 0, sizeof(struct ifreq));
+            strcpy(ifr.ifr_name, destDev);
+            if (ioctl(sock, SIOCGIFINDEX, &ifr) < 0) {
+ 		        perror("SIOCGIFINDEX(): ");
+                close(sock);
+                return;
+            }
+            sll.sll_ifindex = ifr.ifr_ifindex;
+            /* bind the socket to the interface */
+            if (bind(sock, (struct sockaddr *)&sll,	sizeof(sll)) == -1) {
+ 		        perror("bind(): ");
+                close(sock);
+                return;
+            }
+            /* set socket to non-blocking operation */
+            if ((flag = fcntl(sock, F_GETFL, 0)) >= 0) {
+                fcntl(sock, F_SETFL, flag | O_NONBLOCK);
+            }
+            mkArpMsg(ARPOP_REQUEST, br_ipAddr, NULL, br_ipAddr, br_macaddr, &arp);
+            sendto(sock, &arp, sizeof(arp), 0, (struct sockaddr *)&sll, sizeof(sll));
+            close(sock);
+    }
+}
diff -Naur busybox/networking/tftp.c busybox-brcm/networking/tftp.c
--- busybox/networking/tftp.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/networking/tftp.c	2018-11-24 13:44:16.413924633 -0400
@@ -19,6 +19,14 @@
  * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
  */
 #include "libbb.h"
+#include "inet_common.h"
+#include <net/if.h>
+
+// brcm begin
+#include "cms_util.h"
+#include "cms_msg.h"
+// brcm end
+
 
 #if ENABLE_FEATURE_TFTP_GET || ENABLE_FEATURE_TFTP_PUT
 
@@ -50,26 +58,65 @@
 #define ERR_BAD_USER 7
 #define ERR_BAD_OPT  8
 
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+#if defined(SUPPORT_GPL_UNDEFINED)
+#define TFTPC_OPT_MAX_BASE 8    
+#else
+#define TFTPC_OPT_MAX_BASE 7
+#endif
+#if defined(AEI_DEFAULT_CFG_CUSTOMER)
+#define TFTPC_OPT_MAX   (TFTPC_OPT_MAX_BASE+1)
+#else
+#define TFTPC_OPT_MAX   TFTPC_OPT_MAX_BASE
+#endif
+#endif
 /* masks coming from getopt32 */
 enum {
 	TFTP_OPT_GET = (1 << 0),
 	TFTP_OPT_PUT = (1 << 1),
+#if defined AEI_DEFAULT_CFG_CUSTOMER
+	TFTP_OPT_CUST_CFG = (1 << 2),   //follow CMD_GET(opt)
+#endif
 	/* pseudo option: if set, it's tftpd */
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+	TFTPD_OPT = (1 << TFTPC_OPT_MAX) * ENABLE_TFTPD,
+	TFTPD_OPT_r = (1 << TFTPC_OPT_MAX+1) * ENABLE_TFTPD,
+	TFTPD_OPT_c = (1 << TFTPC_OPT_MAX+2) * ENABLE_TFTPD,
+	TFTPD_OPT_u = (1 << TFTPC_OPT_MAX+3) * ENABLE_TFTPD,
+#else
 	TFTPD_OPT = (1 << 7) * ENABLE_TFTPD,
 	TFTPD_OPT_r = (1 << 8) * ENABLE_TFTPD,
 	TFTPD_OPT_c = (1 << 9) * ENABLE_TFTPD,
 	TFTPD_OPT_u = (1 << 10) * ENABLE_TFTPD,
+#endif
 };
 
 #if ENABLE_FEATURE_TFTP_GET && !ENABLE_FEATURE_TFTP_PUT
-#define IF_GETPUT(...)
+    #if defined AEI_DEFAULT_CFG_CUSTOMER
+    #define CMD_CUST_CFG(cmd) ((cmd) & TFTP_OPT_CUST_CFG)
+    #define IF_GETPUT(...) __VA_ARGS__
+    #else
+    #define CMD_CUST_CFG(cmd) 0
+    #define IF_GETPUT(...)
+    #endif
 #define CMD_GET(cmd) 1
 #define CMD_PUT(cmd) 0
 #elif !ENABLE_FEATURE_TFTP_GET && ENABLE_FEATURE_TFTP_PUT
-#define IF_GETPUT(...)
+    #if defined AEI_DEFAULT_CFG_CUSTOMER
+    #define CMD_CUST_CFG(cmd) ((cmd) & TFTP_OPT_CUST_CFG)
+    #define IF_GETPUT(...) __VA_ARGS__
+    #else
+    #define CMD_CUST_CFG(cmd) 0
+    #define IF_GETPUT(...)
+    #endif
 #define CMD_GET(cmd) 0
 #define CMD_PUT(cmd) 1
 #else
+    #if defined AEI_DEFAULT_CFG_CUSTOMER
+    #define CMD_CUST_CFG(cmd) ((cmd) & TFTP_OPT_CUST_CFG)
+    #else
+    #define CMD_CUST_CFG(cmd) 0
+    #endif
 #define IF_GETPUT(...) __VA_ARGS__
 #define CMD_GET(cmd) ((cmd) & TFTP_OPT_GET)
 #define CMD_PUT(cmd) ((cmd) & TFTP_OPT_PUT)
@@ -104,6 +151,339 @@
 #define error_pkt_reason (error_pkt[3])
 #define error_pkt_str    (error_pkt + 4)
 
+// brcm begin
+// use some globals to reduce the messiness of change the original tftp function.
+char *glbImagePtr = NULL;
+int glbUploadSize = 0;
+int brcm_tftp = 0;
+char *glbCurPtr = NULL;
+char glbUploadType = 'i';
+static void *msgHandle=NULL;
+/* 
+ * connIfName is the linux interface name that our socket is going out of.
+ * We need this information when doing image downloads because we might
+ * want to kill all unneeded WAN services to free up memory.
+ */
+char connIfName[CMS_IFNAME_LENGTH]={0};
+
+
+static int myRead(char *outBuf, int inLen)
+{
+   int readLen = 0;
+   static int xmlCfgLen = 0;
+   static int offset = 0;
+   static CmsMsgHeader *responseMsg=NULL;
+   CmsMsgHeader requestMsg = EMPTY_MSG_HEADER;
+   char *cfgStart;
+   CmsRet ret;
+   
+   
+   if (responseMsg == NULL) 
+   {
+      cmsLog_debug("first time, get config file from smd");
+      /*
+       * This is the first time that we were called.
+       * Send a message to smd to request a copy of the config file.
+       */
+      requestMsg.src = EID_TFTP;
+      requestMsg.dst = EID_SMD;
+      requestMsg.type = CMS_MSG_GET_CONFIG_FILE;
+      requestMsg.flags_request = 1;
+      
+      if ((ret = cmsMsg_send(msgHandle, &requestMsg)) != CMSRET_SUCCESS)
+      {
+         cmsLog_error("could not send GET_CONFIG_FILE msg to smd.");
+         return -1;
+      }
+
+      if ((ret = cmsMsg_receive(msgHandle, &responseMsg)) != CMSRET_SUCCESS)
+      {
+         cmsLog_error("could not receive GET_CONFIG_FILE msg from smd.");
+         CMSMEM_FREE_BUF_AND_NULL_PTR(responseMsg);
+         return -1;
+      }      
+
+      xmlCfgLen = (int) responseMsg->dataLength;
+      cmsLog_debug("got config buffer len=%u", xmlCfgLen);
+   }
+
+   /* config data starts immediately after the header */
+   cfgStart = (char *) (responseMsg + 1);
+   
+   if (xmlCfgLen <= inLen)
+      readLen = xmlCfgLen;
+   else
+      readLen = inLen;
+
+   memcpy(outBuf, (cfgStart + offset), readLen);
+
+   xmlCfgLen -= readLen;
+   offset += readLen;
+   glbUploadSize += readLen;
+
+   if (xmlCfgLen == 0)
+   {
+      /* done copying all the config data out, free the message */
+      CMSMEM_FREE_BUF_AND_NULL_PTR(responseMsg);
+      offset = 0;
+      cmsLog_debug("send out entire config buf, free msg");
+   }
+
+   return readLen;
+}
+
+
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+static void tftp_killAppWhileUpgrade()
+{
+      system("killall -9 dhcpd");
+      system("killall -9 sntp");
+      system("killall -9 tr64c");
+      system("killall -9 mynetwork");
+      system("killall -9 rtd");
+      system("killall -9 wlevt");
+      system("killall -9 wlmngr");
+#ifndef SUPPORT_GPL_UNDEFINED
+      system("killall -9 consoled");
+      system("killall -9 syslogd");
+      system("killall -9 klogd");
+#endif
+      system("killall -9 mcpd");
+      system("killall -9 urlfilterd");
+      system("killall -9 detectWANService");
+      system("killall -9 dsldiagd");
+      system("killall -9 eapd");
+      system("killall -9 nas");
+      system("killall -9 lld2d");
+      system("killall -9 wps_monitor");
+      system("killall -9 acsd");
+      system("killall -9 upnp");
+      system("killall -9 ntpclient");
+      system("killall -9 swmdk");
+      system("killall -9 data_center");
+      system("killall -9 pmd");
+}
+#endif
+
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+#define BLOCK_ALLOC 1000000
+/* let's do a 1MB alloc and add realloc increment upto max flash size */
+static int myWrite(char *inBuf, int inBufLen)
+{
+   static SINT32 allocSize = 0;
+   char *myglbCurPtr = NULL;
+
+   if (glbImagePtr == NULL)
+   {
+      if (inBufLen < TFTP_BLKSIZE_DEFAULT)   // not enough data for a valid first packet and exit
+         return -1;
+
+      // Allocate maximum flash image size + possible broadcom header TAG.
+      // (Don't bother getting the length from the broadcom TAG, we don't
+      // get a TAG if it is a whole image anyways.)
+      // The Linux kernel will not assign physical pages to the buffer
+      // until we write to it, so it is OK if we allocate a little more
+      // than we really need.
+
+#if !defined(CHIP_63138)
+      /*63138 has enough sdram*/
+      tftp_killAppWhileUpgrade();
+#endif
+
+      allocSize = BLOCK_ALLOC ; //cmsImg_getImageFlashSize() + cmsImg_getBroadcomImageTagSize();
+      printf("Allocating %d bytes for flash image.\n", allocSize);
+      if ((glbImagePtr = (char *) malloc(allocSize)) == NULL)
+      {
+         printf("Not enough memory error.  Could not allocate %u bytes.", allocSize);
+         return -1;
+      }
+      else
+      {
+         printf("Memory allocated %u bytes\n",allocSize);
+         glbCurPtr = glbImagePtr;
+         if (glbUploadSize + inBufLen < allocSize)
+         {
+            memcpy(glbImagePtr, inBuf, inBufLen);
+            glbCurPtr += inBufLen;
+            glbUploadSize += inBufLen;
+            return inBufLen;
+         }
+      }
+   }
+   else
+   {
+      if (glbUploadSize + inBufLen < allocSize)
+      {
+          memcpy(glbCurPtr, inBuf, inBufLen);
+          glbCurPtr += inBufLen;
+          glbUploadSize += inBufLen;
+      }
+      else
+      {
+          /* need to reset pointers */
+          char *myglbCurPtr = NULL;
+          SINT32 maxSize = cmsImg_getImageFlashSize() + cmsImg_getBroadcomImageTagSize();
+          allocSize = glbUploadSize + BLOCK_ALLOC;
+          if ( allocSize > maxSize )
+          {
+              allocSize = maxSize;
+          }
+
+          myglbCurPtr  = realloc(glbImagePtr, allocSize);
+
+          if (myglbCurPtr)
+          {
+              printf("Memory reallocated %u bytes\n",allocSize);
+              glbImagePtr = myglbCurPtr;
+              glbCurPtr = myglbCurPtr +  glbUploadSize;
+              if (glbUploadSize + inBufLen < allocSize)
+              {
+                  memcpy(glbCurPtr, inBuf, inBufLen);
+                  glbCurPtr += inBufLen;
+                  glbUploadSize += inBufLen;
+              }
+              else
+              {
+                  printf("Image could not fit into %u byte buffer.\n", allocSize);
+                  return -1;
+              }
+          }
+          else
+          {
+              printf("Image could not fit into %u byte buffer.\n", allocSize);
+              return -1;
+
+          }
+      }
+   }
+
+   return inBufLen;
+}
+#else
+static int myWrite(char *inBuf, int inBufLen)
+{
+   /* To use the old logic - allocate memory with flash size    
+   * replace  CMS_IMAGE_MAX_ALLOC_LEN with 0, ie. 
+   * int bcmImageGussstimated = 0;
+   */
+   SINT32 bcmImageGussstimated = CMS_IMAGE_MAX_ALLOC_LEN;
+   static SINT32 allocSize = 0;
+
+   if (glbCurPtr == NULL) 
+   {
+      UINT32 bcmImageSize = 0;
+      
+      if (inBufLen < TFTP_BLKSIZE_DEFAULT)   // not enough data for a valid first packet and exit
+         return -1;   
+
+
+
+      if (cmsImg_isBcmTaggedImage(inBuf, &bcmImageSize))
+      {
+         /* If it is a bcmTagged image, use the image length info from the bcmTag 
+         * and also make bcmImageGussstimated 0 since bcmTagged image will not use that
+         */
+         allocSize =  bcmImageSize;
+         bcmImageGussstimated = 0;
+      }
+      else
+      {
+         /* Not bcmTagged image.  Need to check if bcmImageGussstimated is initialized (> 0) or not */
+         if (bcmImageGussstimated > 0)
+         {
+            /* If bcmImageGstmated size > 0, Use guestimated image size */
+            allocSize = bcmImageGussstimated;
+         }
+         else
+         {
+            /* original logic if bcmImageGussstimated == 0, allocate memory with flash size plus bcm image tag */
+            allocSize = cmsImg_getImageFlashSize() + cmsImg_getBroadcomImageTagSize();
+         }     
+      }
+
+      bb_error_msg("Allocating %d bytes for flash image.\n", allocSize);
+      
+      if ((glbCurPtr = (char *) malloc(allocSize)) == NULL)
+      {
+         if (bcmImageGussstimated > 0)
+         {
+            /* If bcmImageGussstimated is initialized, try that (with allocSize = bcmImageGussstimated)
+            * and if still failing,  try reducing 64K from allocSize and try again as long as
+            * allocSize > CMS_IMAGE_REQUIRED_LEN.
+            */
+            while  (((glbCurPtr = (char *) malloc(allocSize)) == NULL) && 
+               (allocSize > CMS_IMAGE_REQUIRED_LEN))
+            {
+               allocSize -= 64 * 1024 ;
+               cmsLog_debug("Try allocating %d kb", allocSize/1024);
+            }
+         }
+
+         /* Failed to allocate memory and will quite tftp operation */
+         if (glbCurPtr == NULL)
+         {
+            bb_error_msg("Not enough memory error.  Could not allocate %u bytes.", allocSize);   
+            return -1;
+         }
+      }         
+      bb_error_msg("Memory allocated\n");
+      glbImagePtr = glbCurPtr;
+   }
+
+   // copy the data from the current packet into our buffer
+   if (glbUploadSize + inBufLen <= allocSize)
+   {
+      memcpy(glbCurPtr, inBuf, inBufLen);
+      glbCurPtr += inBufLen;
+      glbUploadSize += inBufLen;
+   }
+   else
+   {
+       bb_error_msg("Image could not fit into %u byte buffer.\n", allocSize);
+       return -1;
+   }
+
+   return inBufLen;
+}
+#endif
+
+
+//-- from igmp
+#include <bits/socket.h>
+#include <sys/uio.h>
+#include <sys/ioctl.h>
+#define MAXCTRLSIZE						\
+	(sizeof(struct cmsghdr) + sizeof(struct sockaddr_in) +	\
+	sizeof(struct cmsghdr) + sizeof(int) + 32)
+
+#ifdef not_used
+/*
+ * Interesting, tftp uses a different method for getting the 
+ * linux interface name. See also cmsImg_saveIfNameFromSocket().
+ * Sean says tftp is a client, so it needs to use this method.
+ * In all other upload methods, the modem is the server, so the method
+ * in cmsImg_saveIfNameFromSocket() is used.
+ */
+static char *myif_indextoname(int sockfd,unsigned int ifindex,char *ifname)
+{
+	struct ifreq ifr;
+	int status;
+
+	memset(&ifr,0,sizeof(struct ifreq));
+ 	ifr.ifr_ifindex = ifindex;
+	
+	status = ioctl(sockfd,SIOCGIFNAME,&ifr);
+	
+	if (status < 0) {
+		//bb_error_msg("ifindex %d has no device \n",ifindex);
+		return NULL;
+	}
+	else
+		return strncpy(ifname,ifr.ifr_name,IFNAMSIZ);
+}
+#endif
+// brcm end
+
 #if ENABLE_FEATURE_TFTP_PROGRESS_BAR
 /* SIGALRM logic nicked from the wget applet */
 static void progress_meter(int flag)
@@ -228,7 +608,7 @@
 	uint16_t opcode;
 	uint16_t block_nr;
 	uint16_t recv_blk;
-	int open_mode, local_fd;
+	int open_mode, local_fd = -1; // brcm
 	int retries, waittime_ms;
 	int io_bufsize = blksize + 4;
 	char *cp;
@@ -269,7 +649,7 @@
 		open_mode = O_RDONLY;
 	} else {
 		open_mode = O_WRONLY | O_TRUNC | O_CREAT;
-#if ENABLE_TFTPD
+#if !ENABLE_BRCMTFTPD
 		if ((option_mask32 & (TFTPD_OPT+TFTPD_OPT_c)) == TFTPD_OPT) {
 			/* tftpd without -c */
 			open_mode = O_WRONLY | O_TRUNC;
@@ -336,9 +716,22 @@
 
 	} else { /* tftp */
 		/* Open file (must be after changing user) */
-		local_fd = CMD_GET(option_mask32) ? STDOUT_FILENO : STDIN_FILENO;
-		if (NOT_LONE_DASH(local_file))
-			local_fd = xopen(local_file, open_mode);
+		if ( !brcm_tftp ) {
+			local_fd = CMD_GET(option_mask32) ? STDOUT_FILENO : STDIN_FILENO;
+			if (NOT_LONE_DASH(local_file))
+				local_fd = xopen(local_file, open_mode);
+		} else {
+			/* need to send in the connection interface name to smd */
+			if (glbUploadType == 'i')
+			{
+			   /*
+			    * There is a big image coming.  tftp is about to malloc a big buffer
+			    * and start filling it.  Notify smd so it can do killAllApps or
+			    * something to make memory available on the modem.
+			    */
+			   cmsImg_sendLoadStartingMsg(msgHandle, connIfName);
+			}
+		}
 /* Removing #if, or using if() statement instead of #if may lead to
  * "warning: null argument where non-null required": */
 #if ENABLE_TFTP
@@ -431,7 +824,11 @@
 		opcode = TFTP_ACK;
 		if (CMD_PUT(option_mask32)) {
 			opcode = TFTP_DATA;
-			len = full_read(local_fd, cp, blksize);
+			if( brcm_tftp ) {
+ 				len = myRead(cp, blksize);
+			} else {
+	  			len = full_read(local_fd, cp, blksize);
+			}
 			if (len < 0) {
 				goto send_read_err_pkt;
 			}
@@ -594,7 +991,14 @@
 
 		if (CMD_GET(option_mask32) && (opcode == TFTP_DATA)) {
 			if (recv_blk == block_nr) {
-				int sz = full_write(local_fd, &rbuf[4], len - 4);
+// brcm				int sz = full_write(local_fd, &rbuf[4], len - 4);
+				int sz; 
+				if ( local_fd != -1 ) {
+					sz=write(local_fd, &rbuf[4], len - 4);
+					glbUploadSize += sz;
+				}else{
+					sz=myWrite(&rbuf[4], len - 4);
+				}
 				if (sz != len - 4) {
 					strcpy((char*)error_pkt_str, bb_msg_write_error);
 					error_pkt_reason = ERR_WRITE;
@@ -668,20 +1072,54 @@
 	const char *blksize_str = TFTP_BLKSIZE_DEFAULT_STR;
 	int blksize;
 # endif
+// brcm begin
+	const char *brcm_remote_file = NULL;
+	const char *upload_type = NULL; 
+	const char *brcm_loglevel = NULL;
+	CmsLogLevel logLevel=DEFAULT_LOG_LEVEL;
+	SINT32 logLevelNum;
+	CmsRet ret;
+// brcm end
 	int result;
 	int port;
 	IF_GETPUT(int opt;)
 
 	INIT_G();
 
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+#ifdef AEI_DEFAULT_CFG_CUSTOMER
+#define CUST_CFG "c"
+#else
+#define CUST_CFG
+#endif
+
+#define CUST_2PARTITION_FALSH   "d:"
+	const char *dualPartition = NULL;
+#endif
+
+// brcm begin
+    cmsLog_init(EID_TFTP);
+    cmsLog_setLevel(logLevel);
+// brcm end
+#if defined AEI_DEFAULT_CFG_CUSTOMER
+    glbCustomerSpecifyDefConfigFile = FALSE;
+#endif
+
 	/* -p or -g is mandatory, and they are mutually exclusive */
 	opt_complementary = "" IF_FEATURE_TFTP_GET("g:") IF_FEATURE_TFTP_PUT("p:")
 			IF_GETPUT("g--p:p--g:");
 
 	IF_GETPUT(opt =) getopt32(argv,
 			IF_FEATURE_TFTP_GET("g") IF_FEATURE_TFTP_PUT("p")
-				"l:r:" IF_FEATURE_TFTP_BLOCKSIZE("b:"),
-			&local_file, &remote_file
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+            CUST_CFG CUST_2PARTITION_FALSH "l:r:f:t:v:" IF_FEATURE_TFTP_BLOCKSIZE("b:"),
+#else
+				"l:r:f:t:v" IF_FEATURE_TFTP_BLOCKSIZE("b:"),
+#endif
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+            &dualPartition,
+#endif
+			&local_file, &remote_file, &brcm_remote_file, &upload_type, &brcm_loglevel
 			IF_FEATURE_TFTP_BLOCKSIZE(, &blksize_str));
 	argv += optind;
 
@@ -695,6 +1133,31 @@
 	}
 # endif
 
+#if defined AEI_DEFAULT_CFG_CUSTOMER
+    if(CMD_CUST_CFG(opt))
+    {
+        glbCustomerSpecifyDefConfigFile = TRUE;
+    }
+#endif
+// brcm begin
+	if ( upload_type && brcm_remote_file ) {
+		brcm_tftp = 1;
+		glbUploadType = upload_type[0];
+		remote_file = brcm_remote_file;
+	}
+	if (brcm_loglevel) {
+		logLevelNum = xatoul_range(brcm_loglevel, 0, 7);
+		if (logLevelNum == 0) {
+			logLevel = LOG_LEVEL_ERR;
+		} else if (logLevelNum == 1) {
+			logLevel = LOG_LEVEL_NOTICE;
+		} else {
+			logLevel = LOG_LEVEL_DEBUG;
+		}
+		cmsLog_setLevel(logLevel);
+	}
+// brcm end
+ 
 	if (remote_file) {
 		if (!local_file) {
 			const char *slash = strrchr(remote_file, '/');
@@ -704,6 +1167,7 @@
 		remote_file = local_file;
 	}
 
+
 	/* Error if filename or host is not known */
 	if (!remote_file || !argv[0])
 		bb_show_usage();
@@ -720,23 +1184,87 @@
 # if ENABLE_FEATURE_TFTP_PROGRESS_BAR
 	G.file = remote_file;
 # endif
-	result = tftp_protocol(
+// brcm begin
+	/* We need to establish a comm link with smd. */
+	if ((ret = cmsMsg_init(EID_TFTP, &msgHandle)) != CMSRET_SUCCESS)
+	{
+		bb_error_msg("failed to open comm link with smd, tftp failed.");
+		return 0;
+	}
+
+	if( brcm_tftp ) {
+   	   result = tftp_protocol(
 		NULL /*our_lsa*/, peer_lsa,
 		local_file, remote_file
 		IF_FEATURE_TFTP_BLOCKSIZE(, 1 /* want_transfer_size */)
 		IF_FEATURE_TFTP_BLOCKSIZE(, blksize)
-	);
-	tftp_progress_done();
-
-	if (result != EXIT_SUCCESS && NOT_LONE_DASH(local_file) && CMD_GET(opt)) {
-		unlink(local_file);
-	}
+	   	);
+	   if ( glbUploadType == 'f' ) {
+		cmsLog_debug("sending config to remote file %s", remote_file);
+		if (result == 0) {		
+			bb_error_msg("backed up config file to %s (%d bytes)\n", remote_file, glbUploadSize);
+		} else {
+			bb_error_msg("Could not back up config file.\n");
+		}
+	   } else {
+	      if ( result == EXIT_SUCCESS ) {
+		bb_error_msg("Got image via tftp, total image size: %d\n", glbUploadSize);
+		
+		/*
+		 * cmsImsg_writeImage will determine the image format and write
+		 * to flash.  If successful, the system will do a sysMipsSoftReset
+		 * immediately.  So we will not return from this function call.
+		 * (But on the desktop, this call does return, so we still have to check the
+		 * return value.)
+		 */
+#if defined(AEI_CONFIG_JFFS)
+        if(dualPartition &&  glbUploadType == 'i' )
+        {
+            if ((ret = AEI_writeDualPartition(glbImagePtr, glbUploadSize, msgHandle, atoi(dualPartition))) != CMSRET_SUCCESS)
+            {
+                printf("Tftp Image failed: Illegal image.\n");
+            }
+        }
+		else
+#endif
+		if ((ret = cmsImg_writeImage(glbImagePtr, glbUploadSize, msgHandle)) != CMSRET_SUCCESS)
+		{
+		   bb_error_msg("Tftp Image failed: Illegal image.\n");
+		}
+		/*
+		 * If we get here, the image download has failed.  Tell smd to go back
+		 * to normal operation.
+		 */
+		if (glbImagePtr)
+		{
+		   free(glbImagePtr);
+		}
+		
+		if (glbUploadType == 'i')
+		{
+		   cmsImg_sendLoadDoneMsg(msgHandle);
+		}
+	      }
+	   }
+	} else {
+// brcm end
+		result = tftp_protocol(
+			NULL /*our_lsa*/, peer_lsa,
+			local_file, remote_file
+			IF_FEATURE_TFTP_BLOCKSIZE(, 1 /* want_transfer_size */)
+			IF_FEATURE_TFTP_BLOCKSIZE(, blksize)
+		);
+		tftp_progress_done();
+		if (result != EXIT_SUCCESS && NOT_LONE_DASH(local_file) && CMD_GET(opt)) {
+			unlink(local_file);
+		}
+        }
 	return result;
 }
 
 #endif /* ENABLE_TFTP */
 
-#if ENABLE_TFTPD
+#if !ENABLE_BRCMTFTPD
 int tftpd_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int tftpd_main(int argc UNUSED_PARAM, char **argv)
 {
@@ -764,7 +1292,11 @@
 	peer_lsa->len = our_lsa->len;
 
 	/* Shifting to not collide with TFTP_OPTs */
+#if defined(AEI_VDSL_CUSTOMER_NCS)
+	opt = option_mask32 = TFTPD_OPT | (getopt32(argv, "rcu:", &user_opt) << (TFTPC_OPT_MAX+1));
+#else
 	opt = option_mask32 = TFTPD_OPT | (getopt32(argv, "rcu:", &user_opt) << 8);
+#endif
 	argv += optind;
 	if (argv[0])
 		xchdir(argv[0]);
diff -Naur busybox/networking/tftpd.c busybox-brcm/networking/tftpd.c
--- busybox/networking/tftpd.c	1969-12-31 20:00:00.000000000 -0400
+++ busybox-brcm/networking/tftpd.c	2018-11-24 13:44:16.413924633 -0400
@@ -0,0 +1,1036 @@
+/* 
+ * $Id$
+ * A simple tftpd server for busybox
+ *
+ * Copyright (C) 2001 Steven Carr <Steven_Carr@yahoo.com>
+ *
+ * Tries to follow RFC1350 and RFC2347.
+ * Only "octet" mode supported.
+ * tsize option is supported on sending files only (pxelinux support).
+ * chroot jail for security.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-137 USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/stat.h>
+#include <netdb.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <arpa/tftp.h>
+#include <linux/if.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <asm/ioctls.h>
+#include <sys/ioctl.h>
+#include <signal.h>
+#include <errno.h>
+#include "busybox.h"
+
+#include "cms.h"
+#include "cms_util.h"
+#include "cms_msg.h"
+
+#if defined (AEI_VDSL_CUSTOMER_NCS)
+#define SUPPORT_IPV6
+#define TFTPD_ROOT "/var/tmp" /* Quantenna firmware dir */
+#define TFTPD_PATH_LEN 128 /* 128 bytes should be long enough */
+#endif
+
+#ifndef OACK
+#define OACK 6
+#endif
+#ifndef EOPTNEG
+#define EOPTNEG 8
+#endif
+
+#define ENOPUT -2
+#define ENOGET -3
+
+#if !defined(__UCLIBC__) || defined(__UCLIBC_HAS_MMU__)
+#define FORK() fork()
+#else
+#define FORK() vfork()
+#endif
+
+#define TFTP_BLOCKSIZE_DEFAULT 512   /* according to RFC 1350, don't change */
+#define TFTP_TIMEOUT           5     /* seconds */
+#define TFTPD_TIMEOUT          300   /* seconds */
+
+// brcm begine.  Enable put only
+
+#define DUP_PKT_CHECK_COUNT      3
+#if defined (AEI_VDSL_CUSTOMER_NCS)
+//Enable both put and get
+#define CONFIG_FEATURE_TFTPD_GET
+#define CONFIG_FEATURE_TFTPD_PUT
+#else
+//Enable put only
+//#define CONFIG_FEATURE_TFTPD_GET
+#define CONFIG_FEATURE_TFTPD_PUT
+#endif
+static char connIfName[CMS_IFNAME_LENGTH]={0};
+static void *msgHandle=NULL;
+static int glbPeerFd=-1;
+
+
+static void common_exit(int code)
+{
+   if (glbPeerFd != -1)
+   {
+      close(glbPeerFd);
+   }
+   
+   exit(code);  
+}
+
+static void handler_sigterm(int signum)
+{
+   cmsLog_notice("received signal %d", signum);
+   common_exit(0);
+}
+
+
+static void perror_msg_and_die(const char * msg)
+{
+    printf("fatal: %s\n", msg);
+    common_exit(0);
+}
+
+
+
+/*
+ * Handle initial connection protocol.
+ *     +-------+---~~---+---+---~~---+---+---~~---+---+---~~---+---+-->  >-------+---+---~~---+---+
+ *     |  opc  |filename| 0 |  mode  | 0 |  opt1  | 0 | value1 | 0 | <  <  optN  | 0 | valueN | 0 |
+ *     +-------+---~~---+---+---~~---+---+---~~---+---+---~~---+---+-->  >-------+---+---~~---+---+
+ *             ^--->
+ */
+
+/* The options are zero terminated, retrieve a list of pointers to the first character of each option */
+static int tftpd_options (char *options, int opt_len, char **argv, int max_arg)
+{
+  int x;
+  int y;
+  argv[0] = options;
+  for (y = 1, x = 0; (y < max_arg) && (x < (opt_len - 1)); x++)
+    {
+      if (options[x] == 0)
+   {
+     if (options[x + 1] == 0)
+       return y;
+     argv[y] = &options[x + 1];
+     y++;
+   }
+    }
+  return y;
+}
+
+
+/*
+ * Send a nak packet (error message).
+ * Error code passed in is one of the
+ * standard TFTP codes, or a UNIX errno
+ * offset by 100.
+ */
+static void tftpd_nak (int peer, int error)
+{
+  char buf[TFTP_BLOCKSIZE_DEFAULT + 4];
+  struct tftphdr *pkt;
+
+  pkt = (struct tftphdr *) buf;
+  pkt->th_opcode = htons ((u_short) ERROR);
+  pkt->th_code = htons ((u_short) error);
+
+  switch (error)
+    {
+    case ENOPUT:
+      strcpy (pkt->th_msg, "Put not supported");
+      pkt->th_code = htons (EUNDEF);
+      break;
+    case ENOGET:
+      strcpy (pkt->th_msg, "Get not supported");
+      pkt->th_code = htons (EUNDEF);
+      break;
+    case EUNDEF:
+      strcpy (pkt->th_msg, "Undefined error code");
+      break;
+    case ENOTFOUND:
+      strcpy (pkt->th_msg, "File not found");
+      break;
+    case EACCESS:
+      strcpy (pkt->th_msg, "Access violation");
+      break;
+    case ENOSPACE:
+      strcpy (pkt->th_msg, "Disk full or allocation exceeded");
+      break;
+    case EBADOP:
+      strcpy (pkt->th_msg, "Illegal TFTP operation");
+      break;
+    case EBADID:
+      strcpy (pkt->th_msg, "Unknown transfer ID");
+      break;
+    case EEXISTS:
+      strcpy (pkt->th_msg, "File already exists");
+      break;
+    case ENOUSER:
+      strcpy (pkt->th_msg, "No such user");
+      break;
+    case EOPTNEG:
+      strcpy (pkt->th_msg, "Failure to negotiate RFC2347 options");
+      break;
+    default:
+      strcpy (pkt->th_msg, strerror (error - 100));
+      pkt->th_code = htons (EUNDEF);
+      break;
+    }
+
+  send (peer, buf, strlen (pkt->th_msg) + 5, 0);
+}
+
+/*
+ * Send a ack packet 
+ */
+static void tftpd_ack (int peer, int block)
+{
+  struct tftphdr pkt;
+
+  pkt.th_opcode = htons (ACK);
+  pkt.th_block = htons (block);
+
+  if (send (peer, &pkt, sizeof(pkt), 0)!=sizeof(pkt))
+     perror_msg_and_die("tftpd_ack send");
+}
+
+
+#ifdef CONFIG_FEATURE_TFTPD_GET
+/*
+ * send an oack
+ */
+static void tftpd_oack (int peer, int count, char **list)
+{
+  char buf[TFTP_BLOCKSIZE_DEFAULT + 4];
+  struct tftphdr *pkt;
+  int x;
+  char *ptr;
+
+  pkt=(struct tftphdr *)buf;
+  pkt->th_opcode = htons (OACK);
+  ptr=pkt->th_stuff;
+  
+  for (x=0;x<count;x++)
+    ptr=strrchr (strcpy (ptr, list[x]), '\0') + 1;
+
+ if ( send (peer, buf, (ptr-buf), 0)!=(ptr-buf))
+     perror_msg_and_die("tftpd_oack send");
+}
+
+
+/*
+ * send data
+ */
+static void tftpd_data (int peer, int block, char *data, int size)
+{
+  struct tftphdr *pkt;
+  char buf[TFTP_BLOCKSIZE_DEFAULT + 4];
+
+  pkt=(struct tftphdr *)buf;
+  pkt->th_opcode = htons (DATA);
+  pkt->th_block  = htons(block);
+  
+  memcpy(pkt->th_data,data,size);
+
+  if (send (peer, &buf, size+4, 0)!=(size+4))
+     perror_msg_and_die("tftpd_data send");
+}
+#endif /* CONFIG_FEATURE_TFTPD_GET */
+
+static int tftpd_getdata(int peer, int block, char *data, int size)
+{
+  struct tftphdr *pkt;
+  struct timeval tv;
+  fd_set rfds;
+  int len=-1;
+  int timeout_counter = 4;
+  
+  pkt=(struct tftphdr *)data;
+  
+  do {   
+      tv.tv_sec = TFTP_TIMEOUT;
+      tv.tv_usec = 0;
+      FD_ZERO (&rfds);
+      FD_SET (peer, &rfds);
+      switch (select (FD_SETSIZE, &rfds, NULL, NULL, &tv))
+   {
+   case 1:      /* data ready */
+     len = recv (peer, data, size, 0);
+     if (len < 0)
+       perror_msg_and_die ("failed to read (data)");
+
+     pkt->th_opcode = ntohs (pkt->th_opcode);
+     pkt->th_block = ntohs (pkt->th_block);
+     if (pkt->th_opcode == ERROR)
+       {
+         bb_error_msg (pkt->th_data);
+         common_exit(0);
+       }
+     if ((pkt->th_opcode == DATA) && (pkt->th_block != block))
+       {
+         //synchronize (peer);
+       }
+     break;
+   case 0:      /* timeout */
+     timeout_counter--;
+     if (timeout_counter == 0)
+       {
+         bb_error_msg ("last timeout");
+         common_exit(0);
+       }
+     break;
+   default:      /* error */
+     perror_msg_and_die ("select failed");
+     break;
+   }
+   }while (!(pkt->th_opcode == DATA) && (pkt->th_block == block));
+   return len;
+}
+
+
+
+#ifdef CONFIG_FEATURE_TFTPD_GET
+static int tftpd_getack(int peer, int block)
+{
+  char data[TFTP_BLOCKSIZE_DEFAULT + 4];
+  struct tftphdr *pkt;
+  struct timeval tv;
+  fd_set rfds;
+  int timeout_counter = 4;
+  int len;
+  
+  pkt=(struct tftphdr *)data;
+
+  do {   
+      tv.tv_sec = TFTP_TIMEOUT;
+      tv.tv_usec = 0;
+      FD_ZERO (&rfds);
+      FD_SET (peer, &rfds);
+      switch (select (FD_SETSIZE, &rfds, NULL, NULL, &tv))
+   {
+   case 1:      /* data ready */
+
+     len = recv (peer, data, TFTP_BLOCKSIZE_DEFAULT + 4, 0);
+     if (len < 0)
+       perror_msg_and_die ("failed to read (data)");
+
+     pkt->th_opcode = ntohs (pkt->th_opcode);
+     pkt->th_block = ntohs (pkt->th_block);
+
+     if (pkt->th_opcode == ERROR)
+       {
+         bb_error_msg (pkt->th_data);
+         common_exit(0);
+       }
+
+     if ((pkt->th_opcode == ACK) && (pkt->th_block != block))
+       {
+         //synchronize (peer);
+       }
+     break;
+   case 0:      /* timeout */
+     timeout_counter--;
+     if (timeout_counter == 0)
+       {
+         bb_error_msg ("last timeout");
+         common_exit(0);
+       }
+     break;
+   default:      /* error */
+     perror_msg_and_die ("select failed");
+     break;
+   }
+   }while (! ((pkt->th_opcode == ACK) && (pkt->th_block == block)) );
+
+  return (1==1);
+}
+#endif /* CONFIG_FEATURE_TFTPD_GET */
+
+
+
+
+
+#ifndef CONFIG_FEATURE_TFTPD_GET
+static void
+tftpd_send (int peer,
+            struct tftphdr *tp UNUSED_PARAM,
+            int n UNUSED_PARAM,
+            int buffersize UNUSED_PARAM)
+{
+   /* we aren't configured for sending files */
+   tftpd_nak (peer, ENOGET);
+   common_exit(0);
+}
+
+#else
+static void
+tftpd_send (int peer, struct tftphdr *first_pkt, int pkt_len, int buffersize)
+{
+   FILE *file=NULL;
+   char buffer[TFTP_BLOCKSIZE_DEFAULT+4];
+   char *list[64]; /* list of pointers to options and values */
+   int listcount;
+   char *reply_list[64];
+   int reply_listcount=0;
+   char tsize_ret[32];
+   int block, inbytes, x;
+#if defined (AEI_VDSL_CUSTOMER_NCS)
+   char path[TFTPD_PATH_LEN];
+#endif
+   
+   listcount = tftpd_options (first_pkt->th_stuff, pkt_len, list ,64);
+
+   /* get the size of the file (remember, chroot() supposed to point us in the right directory) */
+
+   if (strcasecmp(list[1],"octet")!=0)
+   {
+      tftpd_nak(peer,EBADOP);
+      common_exit(0);
+   }
+
+#if defined (AEI_VDSL_CUSTOMER_NCS)
+   /* simply avoid chdir outside of tftpd ROOT */
+   if (strstr(list[0], ".."))
+   {
+      tftpd_nak(peer,EACCESS);
+      common_exit(0);
+   }
+
+   snprintf(path, TFTPD_PATH_LEN, "%s/%s", TFTPD_ROOT, list[0]);
+   file = fopen (path, "r");
+#else
+   file = fopen (list[0], "r");
+#endif
+   if (file == NULL)
+   {
+     tftpd_nak (peer, ENOTFOUND);
+     common_exit(0);
+   }
+   fseek (file, 0, SEEK_END);
+   sprintf(tsize_ret,"%lu", ftell (file));
+   fseek (file, 0, SEEK_SET);
+
+
+   /* 0=filename, 1=mode, 2=option, 3=option_value ... */
+   block = 1;
+   reply_listcount=0;
+
+   /* look through the options for the ones we support */
+   for (x=2;x<listcount;x++)
+   {
+      if (strcasecmp(list[x],"tsize")==0) /* only one option supported so far */
+      {
+         reply_list[reply_listcount]=list[x];      
+         reply_listcount++;
+         reply_list[reply_listcount]=tsize_ret; /* point to the real value */
+         reply_listcount++;
+      }
+   }
+
+   /* if there are any options, send an OACK instead of an ACK */
+   if (reply_listcount>0)
+   {
+      do
+      {
+         tftpd_oack(peer,reply_listcount,reply_list);
+      }
+      while (!tftpd_getack(peer,0));
+   }   
+
+
+   /* Send the file! */
+   while ((inbytes = fread(buffer,1,TFTP_BLOCKSIZE_DEFAULT,file))>0)
+   {
+      do
+      {
+         tftpd_data(peer,block,buffer,inbytes);
+      }
+      while (!tftpd_getack(peer,block));
+      block++;
+   }
+   fclose(file);
+   common_exit(0);
+}
+
+#endif
+
+
+#ifndef CONFIG_FEATURE_TFTPD_PUT
+static void
+tftpd_receive (int peer, struct tftphdr *tp, int n, int buffersize)
+{
+   /* we aren't configured for receiving files */
+   tftpd_nak (peer, ENOPUT);
+   common_exit(0);
+}
+
+#else
+static void
+//brcm begin
+tftpd_receive (int peer, struct tftphdr *first_pkt, int pkt_len, int buffersize UNUSED_PARAM)
+{
+// brcm   FILE *file=NULL;
+   char buffer[TFTP_BLOCKSIZE_DEFAULT+4];
+   struct tftphdr *pkt;
+   int block, inbytes;
+   char *list[64];
+   int listcount;
+
+    //brcm begin
+    int byteRd = 0;
+    int i = 0;   
+    CmsRet ret;
+    static UBOOL8 isConfigFile=FALSE;
+    int totalAllocatedSize = 0;
+    int uploadSize = 0;
+    char *imagePtr = NULL;
+    char *curPtr = NULL;
+    
+
+
+//printf("tftpd_receive, peer = %d, pkt_len = %d, buffersize=%d\n", peer, pkt_len, buffersize);
+
+   pkt=(struct tftphdr *)buffer;
+   listcount = tftpd_options (first_pkt->th_stuff, pkt_len, list ,64);
+
+   /* get the size of the file (remember, chroot() supposed to point us in the right directory) */
+
+//printf ("mode= %s, file= %s\n", list[1], list[0]);   
+    if (strcasecmp(list[1],"octet")!=0)
+   {
+        printf("Only support 'bin' mode. Type 'bin' at tftp client\n");
+      tftpd_nak(peer,EBADOP);
+      common_exit(0);
+   }
+
+#if 0//brcm
+    file = fopen (list[0], "w");
+   if (file == NULL)
+   {
+     tftpd_nak (peer, EACCESS);
+     common_exit(0);
+   }
+#endif //brcm
+
+
+
+   block=0;
+
+   do
+   {
+      tftpd_ack(peer,block);
+      block++;
+
+      // if duplicate pkt, (for slow ack on 38R board) discard it.
+      for (i = 0; i < DUP_PKT_CHECK_COUNT; i++)
+      {
+         inbytes=tftpd_getdata(peer,block,buffer,TFTP_BLOCKSIZE_DEFAULT+4);
+         if (block == (int) (*(short*)(buffer+2)))
+            break;
+      }
+      
+      
+      // brcm fwrite(pkt->th_msg,1,inbytes-4,file);
+      byteRd=inbytes-4;
+      
+      // brcm begin
+      if (curPtr == NULL) 
+      {
+         // First time through, need to allocate buffer for image
+         
+         if (byteRd < TFTP_BLOCKSIZE_DEFAULT)   // not enough data for a valid first packet and exit
+         {
+            cmsLog_error("first packet too short, byteRd=%d default block size=%d", byteRd, TFTP_BLOCKSIZE_DEFAULT);
+            uploadSize = byteRd;
+            break;
+         }
+         
+         // The first TFTP_BLOCKSIZE_DEFAULT (512 bytes) of the image
+         // is in pkt->th_msg.  First determine if it is a config file.
+         isConfigFile = cmsImg_isConfigFileLikely(pkt->th_msg);
+         cmsLog_debug("isConfigFile = %d", isConfigFile);
+
+         if (isConfigFile)
+         {
+            totalAllocatedSize = cmsImg_getConfigFlashSize();
+         }
+         else
+         {
+            totalAllocatedSize = cmsImg_getImageFlashSize() + cmsImg_getBroadcomImageTagSize();
+            // let smd know that we are about to start a big download
+            cmsImg_sendLoadStartingMsg(msgHandle, connIfName);
+         }       
+
+         if ((curPtr = (char *) malloc(totalAllocatedSize)) == NULL)
+         {
+            printf("Not enough memory error (%d bytes needed).\n", totalAllocatedSize);       
+            common_exit(0);
+         }
+
+         printf("%d bytes allocated for image\n", totalAllocatedSize);
+         imagePtr = curPtr;
+      } // if curPtr == NULL
+
+      if (uploadSize + byteRd < totalAllocatedSize)
+      {
+         memcpy(curPtr, pkt->th_msg, byteRd);
+         curPtr += byteRd;
+         uploadSize += byteRd;
+      }
+      else
+      {
+         printf("Image could not fit into %d byte buffer.\n", totalAllocatedSize);
+         common_exit(0);
+      }
+   }
+   while (inbytes==(TFTP_BLOCKSIZE_DEFAULT+4));
+
+    tftpd_ack(peer,block); /* final acknowledge */
+
+// brcm   fclose(file);
+
+   printf("Total upload size: %d bytes\n", uploadSize);
+   
+    /*
+     * cmsImsg_writeImage will determine the image format and write
+     * to flash.  If successful, the system will do a sysMipsSoftReset
+     * immediately.  So we will not return from this function call.
+     * But on desktop linux, we still return from this call, so still
+     * check for return value.
+     */
+    if ((ret = cmsImg_writeImage(imagePtr, uploadSize, msgHandle)) != CMSRET_SUCCESS)
+    {
+       printf("Tftp Image failed: Illegal image.\n");
+    }  
+    
+    if (!isConfigFile)
+    {
+       cmsImg_sendLoadDoneMsg(msgHandle);
+    } 
+    
+    if (imagePtr)
+    {
+       free(imagePtr);
+    }
+    
+    common_exit(0);
+}
+// brcm end
+#endif
+
+#ifdef not_used
+static struct in_addr getLanIp(void) //struct in_addr *lan_ip)
+{
+#ifdef DESKTOP_LINUX
+   struct in_addr inaddr;
+   
+   inet_aton("127.0.0.1", &inaddr);
+   return inaddr;
+#else
+
+   int socketfd;
+   struct ifreq lan;
+
+   cmsLog_debug("getting LAN ip (what for?)");
+   
+   memset(&lan, 0, sizeof(lan));
+   if ((socketfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
+        printf("Error openning socket when getting LAN info\n");
+   }
+   else  {
+        strcpy(lan.ifr_name, "br0");
+        if (ioctl(socketfd,SIOCGIFADDR,&lan) < 0) {
+            printf("Error getting LAN IP address\n");
+        }
+   }
+   close(socketfd);
+   return ((struct sockaddr_in *)&(lan.ifr_addr))->sin_addr;
+#endif
+}
+#endif /* not_used */
+
+// brcm -- from igmp
+#include <bits/socket.h>
+#include <sys/uio.h>
+#define MAXCTRLSIZE                  \
+   (sizeof(struct cmsghdr) + sizeof(struct sockaddr_in) +   \
+   sizeof(struct cmsghdr) + sizeof(int) + 32)
+// brmc end
+
+static int
+tftpd_daemon (char *directory UNUSED_PARAM,
+              char *address UNUSED_PARAM,
+              int port UNUSED_PARAM)
+{
+   struct tftphdr *tp;
+#ifdef SUPPORT_IPV6
+   struct sockaddr_in6 from;
+   struct sockaddr_in6 myaddr;
+#else
+   struct sockaddr_in from;
+   struct sockaddr_in myaddr;
+#endif
+   int fd = -1;
+   int rv;
+   int n;
+#if 0
+   struct sockaddr_in bindaddr;
+   pid_t pid;
+   int i = 1;
+#endif
+   int peer;
+
+   char buf[TFTP_BLOCKSIZE_DEFAULT + 4];
+   struct iovec iov = { buf, sizeof buf };
+   struct cmsghdr *cmsg;
+   char *ctrl = (char *)xmalloc(MAXCTRLSIZE);
+   struct msghdr msg = { (void*)&from, sizeof from, &iov, 1, (void*)ctrl, MAXCTRLSIZE, 0};
+   struct in_pktinfo *info = NULL;
+
+#if 1
+
+   //
+   // We should have defined a CONFIG_FEATURE_TFTPD_INETD
+   // to distinguish between inetd based tftpd or consoled based tftpd spawning
+   // In the latter case, we do need to daemonize using daemon(0,1) so that
+   // the tftpd could detach from the console/cli.
+   //
+   // CRDDB00016882
+   // daemon(0,1);	inetd already daemonizes tftpd.
+   //
+
+
+   signal(SIGTERM, handler_sigterm);
+   
+   /* mwang: for smd dynamic launch, the server fd is at a fixed number */
+   fd = CMS_DYNAMIC_LAUNCH_SERVER_FD;
+   
+#endif
+
+#if 0
+   /* mwang: do not daemonize in CMS */
+   daemon(0,1);
+
+   if ((fd = socket (PF_INET, SOCK_DGRAM, 0)) < 0)
+      perror_msg_and_die ("socket");
+   memset (&bindaddr, 0, sizeof (bindaddr));
+   bindaddr.sin_family = AF_INET;
+   bindaddr.sin_addr.s_addr = INADDR_ANY;
+   bindaddr.sin_port = htons (port);
+   if (address != NULL)
+   {
+      struct hostent *hostent;
+      hostent = xgethostbyname (address);
+      if (!hostent || hostent->h_addrtype != AF_INET)
+         perror_msg_and_die ("cannot resolve local bind address");
+      memcpy (&bindaddr.sin_addr, hostent->h_addr, hostent->h_length);
+   }
+   // set option for getting the to ip address.
+   setsockopt(fd, IPPROTO_IP, IP_PKTINFO, &i, sizeof(i));
+
+   if (bind (fd, (struct sockaddr *) &bindaddr, sizeof (bindaddr)) < 0)
+      perror_msg_and_die ("daemon bind failed");
+   /* This means we don't want to wait() for children */
+   signal (SIGCHLD, SIG_IGN);
+
+  // get pid for web access function to start/stop tftpd.
+  {
+    FILE *pid_fp;
+    if (!(pid_fp = fopen("/var/run/tftpd_pid", "w"))) 
+    {
+        printf("Error open /var/run/tftpd_pid");
+        common_exit(0);
+    }
+    fprintf(pid_fp, "%d\n", getpid());
+    fclose(pid_fp);
+  }
+#endif
+
+   while (1)
+   {
+      struct timeval timer;
+      fd_set         readset;
+      
+      memset(buf,0,TFTP_BLOCKSIZE_DEFAULT + 4);
+      memset (&myaddr, 0, sizeof (myaddr));
+
+      /* You have to do this in Linux, reinitialize timer each iteration */
+      timer.tv_sec  = TFTPD_TIMEOUT;
+      timer.tv_usec = 0;
+
+      FD_ZERO (&readset);
+      FD_SET (fd, &readset);
+
+      /* Never time out, we're in standalone mode */
+      rv = select (fd + 1, &readset, NULL, NULL, &timer);
+      if (rv <= 0)
+      {
+         perror_msg_and_die("error during select, exit");
+      }
+
+#if 0 //inetd
+      if (rv == -1 && errno == EINTR)
+         continue;      /* Signal caught, reloop */
+      if (rv == -1)
+         perror_msg_and_die ("select loop");
+      if (rv == 0)
+      {
+	  bb_error_msg ("We shouldn't be timeing out!");
+	  exit (0);		/* Timeout, return to inetd */
+      }
+#endif
+      n = recvmsg (fd, &msg, MSG_WAITALL);
+      if (n <= 0)
+      {
+         if (n == 0)  /* Keven -- Received message with zero length, reloop */
+            continue;
+         else
+         {         
+            perror_msg_and_die("*** error recvmsg < 0\n");
+         }
+      }
+//printf("incoming_ip=%s, n=%d\n", inet_ntoa(from.sin_addr), n);
+      for(cmsg=CMSG_FIRSTHDR(&msg); cmsg != NULL;cmsg =CMSG_NXTHDR(&msg,cmsg))
+      {
+         if (cmsg->cmsg_type == IP_PKTINFO)
+         {
+            info = (struct in_pktinfo *)CMSG_DATA(cmsg);
+//            printf("sepc_dst=%s, ipi_addr=%s\n", inet_ntoa(info->ipi_spec_dst),inet_ntoa(info->ipi_addr));
+            break;
+         }
+      }
+
+      /* Process the request */
+#ifdef SUPPORT_IPV6
+      bzero((char *)&myaddr, sizeof(struct sockaddr_in6));
+      myaddr.sin6_family = AF_INET6;
+      myaddr.sin6_port = htons (0);   /* we want a new local port */
+      myaddr.sin6_addr = in6addr_any;
+#else
+      bzero((char *)&myaddr, sizeof(struct sockaddr_in));
+      myaddr.sin_family = AF_INET;
+      myaddr.sin_port = htons (0);   /* we want a new local port */
+      myaddr.sin_addr.s_addr = INADDR_ANY;   //getLanIp();
+#endif
+
+#if 0
+      // mwang: not sure exactly what this is trying to do, but it doesn't
+      // make any sense and does no good.  Just skip it.
+      if (myaddr.sin_addr.s_addr != info->ipi_spec_dst.s_addr)
+         memcpy (&myaddr.sin_addr, &bindaddr.sin_addr,sizeof bindaddr.sin_addr);
+#endif
+
+      /* we got the request, break out of loop */
+      break;
+
+#if 0 //inetd
+      /* Now that we have read the request packet from the UDP
+         socket, we fork and go back to listening to the socket. */
+      pid = FORK ();
+
+      if (pid < 0)
+         perror_msg_and_die ("cannot fork");
+      if (pid == 0)
+         break;         /* Child exits the while(1), parent continues to loop */
+#endif
+   }  //while (1)
+
+   /* Close file descriptors we don't need */
+   // brcm close (fd);
+
+   /* Get a socket.  This has to be done before the chroot() (/dev goes away) */
+#ifdef SUPPORT_IPV6
+   peer = socket (AF_INET6, SOCK_DGRAM, 0);
+#else
+   peer = socket (AF_INET, SOCK_DGRAM, 0);
+#endif
+   glbPeerFd = peer;
+   if (peer < 0)
+      perror_msg_and_die ("socket");
+#ifndef DESKTOP_LINUX
+   if (chroot ("."))
+      perror_msg_and_die ("chroot");
+#endif
+//   from.sin_family = AF_INET;
+
+   /* Process the request */
+//   cmsLog_debug("binding to %s", inet_ntoa(myaddr.sin_addr));
+   if (bind (peer, (struct sockaddr *) &myaddr, sizeof myaddr) < 0)
+      perror_msg_and_die ("daemon-child bind");
+
+//printf("after bind. my_ip=%s*****\n", inet_ntoa(myaddr.sin_addr));
+
+   if (connect (peer, (struct sockaddr *) &from, sizeof from) < 0)
+   {
+      perror_msg_and_die ("daemon-child connect");
+   }
+   
+   /* save the connection interface name for later deciding if
+   * it is a WAN or LAN interface in the uploading process
+   */
+   if (cmsImg_saveIfNameFromSocket(peer, connIfName) != CMSRET_SUCCESS)
+   {
+      printf("Failed to get remote ifc name!\n");
+   }         
+
+
+   tp = (struct tftphdr *) buf;
+
+//printf("after connect \n");
+
+   /*
+    * iptables will block any traffic that is not allowed.
+    * Unlike before, userspace code do not need to check with access
+    * control lists.  If tftpd gets a packet, it should service it.
+    */
+
+   tp->th_opcode = ntohs (tp->th_opcode);
+
+   switch(tp->th_opcode)
+   {
+      case RRQ:
+         tftpd_send (peer, tp, n, TFTP_BLOCKSIZE_DEFAULT);
+         break;
+      case WRQ:
+         tftpd_receive (peer, tp, n, TFTP_BLOCKSIZE_DEFAULT);
+         break;
+   }
+
+   common_exit(0);
+   return 0; // not reached, but suppresses a compiler warning
+}
+
+
+
+int tftpd_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int tftpd_main (int argc, char **argv)
+{
+  int result;
+  char *address = NULL;      /* address to listen to */
+  
+  // brcm in CMS, smd opens the tftpd server port and launches tftpd when
+  // activity is detected on that port.  So port number is not used here.
+  int port = -1;  /* actually 69 */
+  
+  CmsLogLevel logLevel=DEFAULT_LOG_LEVEL;
+  SINT32 logLevelNum;
+  int opt;
+  
+  cmsLog_init(EID_TFTPD);
+  while ((opt = getopt(argc, argv, "v:")) != -1)
+  {
+     switch(opt)
+     {
+     case 'v':
+     logLevelNum = atoi(optarg);
+     if (logLevelNum == 0)
+     {
+        logLevel = LOG_LEVEL_ERR;
+     }
+     else if (logLevelNum == 1)
+     {
+        logLevel = LOG_LEVEL_NOTICE;
+     }
+     else
+     {
+        logLevel = LOG_LEVEL_DEBUG;
+     }
+     cmsLog_setLevel(logLevel);
+     break;
+     }
+  }
+
+#if 0 //brcm
+  int daemonize = 0;  
+  int on = 1;
+  int fd = 0;
+  int opt;  
+  char directory[256];      /* default directory "/tftpboot/" */
+  memset (directory, 0, sizeof (directory));
+  strcpy (directory, "/tftpboot/");
+
+  while ((opt = getopt (argc, argv, "sp:a:d:h")) != -1)
+    {
+      switch (opt)
+   {
+   case 'p':
+     port = atoi (optarg);
+     break;
+   case 'a':
+     address = optarg;
+     break;
+   case 's':
+     daemonize = (1 == 1);
+     break;
+   case 'd':
+     safe_strncpy (directory, optarg, sizeof (directory));
+     break;
+   case 'h':
+     show_usage ();
+     break;
+   }
+    }
+  if (chdir (directory))
+    perror_msg_and_die ("Invalid Directory");
+
+  if (ioctl (fd, FIONBIO, &on) < 0)
+    perror_msg_and_die ("ioctl(FIONBIO)");
+
+  /* daemonize this process */
+  if (daemonize)
+    {
+      pid_t f = FORK ();
+      if (f > 0) {
+        FILE *pid_fp;
+        if (!(pid_fp = fopen("/var/run/tftpd_pid", "w"))) 
+        {
+            printf("Error open /var/run/tftpd_pid");
+            exit(0);
+        }
+        fprintf(pid_fp, "%d\n", f);
+        fclose(pid_fp);
+       exit (0);
+      }
+      if (f < 0)
+       perror_msg_and_die ("cannot fork");
+      close (0);
+      close (1);
+      close (2);
+    }
+#endif /* 0 */ /* brcm */
+
+  cmsMsg_init(EID_TFTPD, &msgHandle);
+
+  result = tftpd_daemon (NULL, address, port);
+  
+  cmsMsg_cleanup(&msgHandle);
+  
+  return (result);
+}
+
diff -Naur busybox/networking/traceroute.c busybox-brcm/networking/traceroute.c
--- busybox/networking/traceroute.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/networking/traceroute.c	2018-11-24 13:44:16.413924633 -0400
@@ -239,6 +239,12 @@
 #include "libbb.h"
 #include "inet_common.h"
 
+#ifdef BRCM_CMS_BUILD
+#include "cms_msg.h"
+#include "cms_util.h"
+#include "cms_log.h"
+#endif
+
 #ifndef IPPROTO_ICMP
 # define IPPROTO_ICMP 1
 #endif
@@ -247,7 +253,7 @@
 #endif
 
 
-#define OPT_STRING "FIlnrdvxt:i:m:p:q:s:w:z:f:" \
+#define OPT_STRING "FIlnrdvxt:i:m:p:q:s:w:z:f:T:R:M" \
 		    IF_FEATURE_TRACEROUTE_SOURCE_ROUTE("g:") \
 		    "4" IF_TRACEROUTE6("6")
 enum {
@@ -268,9 +274,12 @@
 	OPT_WAITTIME     = (1 << 14),   /* w */
 	OPT_PAUSE_MS     = (1 << 15),   /* z */
 	OPT_FIRST_TTL    = (1 << 16),   /* f */
-	OPT_SOURCE_ROUTE = (1 << 17) * ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE, /* g */
-	OPT_IPV4         = (1 << (17+ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE)),   /* 4 */
-	OPT_IPV6         = (1 << (18+ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE)) * ENABLE_TRACEROUTE6, /* 6 */
+    OPT_T            = (1 << 17),   /* BRCM, T omci test TCID */
+    OPT_R            = (1 << 18),   /* BRCM, R requester id  */
+    OPT_M            = (1 << 19),   /* BRCM, M create msg handler */
+	OPT_SOURCE_ROUTE = (1 << 20) * ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE, /* g */
+	OPT_IPV4         = (1 << (20+ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE)),   /* 4 */
+	OPT_IPV6         = (1 << (21+ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE)) * ENABLE_TRACEROUTE6, /* 6 */
 };
 #define verbose (option_mask32 & OPT_VERBOSE)
 
@@ -317,6 +326,8 @@
 	/* loose source route gateway list (including room for final destination) */
 	uint32_t gwlist[NGATEWAYS + 1];
 #endif
+	char *str_T;  // brcm
+	char *str_R;  // brcm
 };
 
 #define G (*ptr_to_globals)
@@ -333,6 +344,8 @@
 #endif
 #define recv_pkt  (G.recv_pkt )
 #define gwlist    (G.gwlist   )
+#define str_T     (G.str_T       )  // brcm
+#define str_R     (G.str_R       )  // brcm
 #define INIT_G() do { \
 	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
 	port = 32768 + 666; \
@@ -343,6 +356,106 @@
 #define outudp  ((struct udphdr *)(outip + 1))
 
 
+// brcm begin
+#ifdef BRCM_CMS_BUILD
+
+#define TRACERT_IN_PROGRESS  0
+#define TRACERT_FINISHED      1
+#define TRACERT_ERROR        2  /* traceroute process exits on error */
+#define TRACERT_UNKNOWN_HOST 3  /* traceroute unable to resolve host name */
+
+#ifdef BRCM_OMCI
+static UINT16 tcID = 0;
+static OmciTracertDataMsgBody omciMsg;
+unsigned char icmpReply[30];
+#endif
+static void *msgHandle=NULL;
+static CmsEntityId requesterId=0;
+static int hops = 0;
+#endif  /* BRCM_CMS_BUILD */
+// brcm end
+
+
+// brcm begin
+#ifdef BRCM_CMS_BUILD
+/* this is call to send message back to SMD to relay to interested party about the
+ * statistic of the most recent completed or stopped PING test */
+
+#ifdef BRCM_OMCI
+static void sendOmciEventMessage(int finish)
+{
+   char buf[sizeof(CmsMsgHeader) + sizeof(OmciTracertDataMsgBody)]={0};
+   CmsMsgHeader *msg=(CmsMsgHeader *) buf;
+   OmciTracertDataMsgBody *tracertBody = (OmciTracertDataMsgBody*) (msg+1);
+   CmsRet ret;
+
+   if (finish == TRACERT_IN_PROGRESS)
+      return;
+
+   cmsLog_debug("finish %d", finish);
+
+   msg->type = CMS_MSG_TRACERT_STATE_CHANGED;
+   msg->src = MAKE_SPECIFIC_EID(getpid(), EID_TRACERT);
+   msg->dst = EID_OMCID;
+   msg->flags_event = 1;
+   msg->dataLength = sizeof(OmciTracertDataMsgBody);
+
+   omciMsg.tcid = tcID;
+   if ((finish == TRACERT_FINISHED && hops > 0) || hops > 0)
+   {
+       omciMsg.result = 2; /* time exceeded */
+       if (hops < sizeof(omciMsg.msg.neighbour)/sizeof(UINT32))
+           omciMsg.hops = hops;
+       else
+           omciMsg.hops = sizeof(omciMsg.msg.neighbour)/sizeof(UINT32);
+   }
+   else if (finish == TRACERT_ERROR)
+   {
+      omciMsg.result = 3; /* unexpected icmp reponse */
+   }
+   else //hops == 0
+   {
+      omciMsg.result = 0; /* no response */
+   }
+   memcpy(tracertBody, &omciMsg, sizeof(omciMsg));
+
+   if ((ret = cmsMsg_send(msgHandle, msg)) != CMSRET_SUCCESS)
+   {
+      cmsLog_error("could not send out CMS_MSG_TRACERT_STATE_CHANGED to OMCID, ret=%d", ret);
+   }
+   else
+   {
+      cmsLog_notice("sent out CMS_MSG_TRACERT_STATE_CHANGED (finish=%d) to OMCID", finish);
+   }
+}
+#endif
+
+static void cmsCleanup(void)
+{
+   if (option_mask32 & OPT_M)
+   {
+      cmsMsg_cleanup(&msgHandle);
+   }
+   cmsLog_cleanup();
+}
+
+static void logStat(int finish)
+{
+   /* 
+    * Only call sendEventMessage if msgHandle to smd was successfully initialized.
+    */
+   if (msgHandle != NULL)
+   {
+#ifdef BRCM_OMCI
+      if (option_mask32 & OPT_T)
+         sendOmciEventMessage(finish);
+#endif
+   }
+}
+#endif  /* BRCM_CMS_BUILD */
+// brcm end
+
+
 /* libbb candidate? tftp uses this idiom too */
 static len_and_sockaddr* dup_sockaddr(const len_and_sockaddr *lsa)
 {
@@ -553,6 +666,12 @@
 	}
 	read_len -= hlen;
 	icp = (struct icmp *)(recv_pkt + hlen);
+#ifdef BRCM_OMCI
+    memset(icmpReply, 0, sizeof(icmpReply));
+    memcpy(icmpReply, (unsigned char *)icp, 
+        read_len > sizeof(icmpReply) ? sizeof(icmpReply) : read_len);
+#endif
+
 	type = icp->icmp_type;
 	code = icp->icmp_code;
 	/* Path MTU Discovery (RFC1191) */
@@ -757,6 +876,13 @@
 		printf(" %d bytes to %s", read_len, ina);
 		free(ina);
 	}
+#ifdef BRCM_OMCI
+    if (hops < sizeof(omciMsg.msg.neighbour)/sizeof(UINT32))
+    {
+        omciMsg.msg.neighbour[hops] = (unsigned int)(((struct sockaddr_in*)from)->sin_addr.s_addr);
+    }
+    hops++;
+#endif
 }
 
 static void
@@ -790,6 +916,10 @@
 	char *waittime_str;
 	char *pausemsecs_str;
 	char *first_ttl_str;
+#ifdef SUPPORT_GPL
+		int ttl_set_flag = 0;
+        int failcount = 0;
+#endif
 #if ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE
 	llist_t *source_route_list = NULL;
 	int lsrr = 0;
@@ -812,12 +942,28 @@
 	op |= getopt32(argv, OPT_STRING
 		, &tos_str, &device, &max_ttl_str, &port_str, &nprobes_str
 		, &source, &waittime_str, &pausemsecs_str, &first_ttl_str
+        , &str_T, &str_R /* BRCM */
 #if ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE
 		, &source_route_list
 #endif
 	);
 	argv += optind;
 
+#ifdef BRCM_CMS_BUILD
+	if (option_mask32 & OPT_R)
+		requesterId = xatou16(str_R); // -R
+
+#ifdef BRCM_OMCI
+	if (option_mask32 & OPT_T)
+    {
+		tcID = xatou16(str_T); // -T
+        memset(&omciMsg, 0, sizeof(OmciTracertDataMsgBody));
+    }
+#endif
+    cmsLog_debug("starting traceroute argv %s",*argv);
+#endif
+
+
 #if 0 /* IGNORED */
 	if (op & OPT_IP_CHKSUM)
 		bb_error_msg("warning: ip checksums disabled");
@@ -825,7 +971,12 @@
 	if (op & OPT_TOS)
 		tos = xatou_range(tos_str, 0, 255);
 	if (op & OPT_MAX_TTL)
+    {
 		max_ttl = xatou_range(max_ttl_str, 1, 255);
+#ifdef SUPPORT_GPL
+		ttl_set_flag = 1;
+#endif
+    }
 	if (op & OPT_PORT)
 		port = xatou16(port_str);
 	if (op & OPT_NPROBES)
@@ -1039,6 +1190,15 @@
 	}
 #endif
 
+/* trace used fixed fd 3 and 4 for send and receive socket */
+/* msgHandle must be init after tracert socket open */ 
+#ifdef BRCM_CMS_BUILD
+    cmsLog_initWithName(EID_TRACERT, "traceroute");
+    cmsLog_setLevel(DEFAULT_LOG_LEVEL);
+    if (option_mask32 & OPT_M)
+        cmsMsg_initWithFlags(EID_TRACERT, EIF_MULTIPLE_INSTANCES, &msgHandle);
+#endif
+
 	/* Revert to non-privileged user after opening sockets */
 	xsetgid(getgid());
 	xsetuid(getuid());
@@ -1182,15 +1342,61 @@
 			}
 			/* there was no packet at all? */
 			if (read_len == 0)
+            {
 				printf("  *");
+#ifdef SUPPORT_GPL
+		        failcount++;
+#endif
+            }
+#ifdef SUPPORT_GPL
+            else
+            {
+                failcount = 0;
+            }
+#endif
 		}
 		bb_putchar('\n');
+#ifdef SUPPORT_GPL
+        if(failcount >= nprobes *2 && ttl_set_flag == 0)
+        {
+            logStat(TRACERT_ERROR);
+            cmsCleanup();
+            return 0;
+        }
+#endif
 		if (got_there
 		 || (unreachable > 0 && unreachable >= nprobes - 1)
 		) {
+#ifdef BRCM_OMCI
+            if (unreachable > 0 && unreachable >= nprobes - 1 && hops <= 1)
+            {
+                //if hops <= 1, and unreachable, send content of icmp packet
+                hops = 0;
+                memcpy(omciMsg.msg.icmpReply, icmpReply, sizeof(icmpReply));
+                logStat(TRACERT_ERROR);
+                cmsCleanup();
+                return 0;
+            }
+            else
+                break;
+#else
 			break;
+#endif
 		}
+
+// brcm begin
+#ifdef BRCM_CMS_BUILD
+        logStat(TRACERT_IN_PROGRESS);
+#endif /* endif */
+// brcm end
+
 	}
+// brcm begin
+#ifdef BRCM_CMS_BUILD
+    logStat(TRACERT_FINISHED);
+    cmsCleanup();
+#endif
+// brcm end
 
 	return 0;
 }
diff -Naur busybox/networking/vconfig.c busybox-brcm/networking/vconfig.c
--- busybox/networking/vconfig.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/networking/vconfig.c	2018-11-24 13:44:16.417920792 -0400
@@ -21,7 +21,10 @@
 	GET_VLAN_INGRESS_PRIORITY_CMD,
 	GET_VLAN_EGRESS_PRIORITY_CMD,
 	SET_VLAN_NAME_TYPE_CMD,
-	SET_VLAN_FLAG_CMD
+	SET_VLAN_FLAG_CMD,
+// brcm begin
+	SET_VLAN_NFMARK_TO_PRIORITY_CMD	
+// brcm end
 };
 enum vlan_name_types {
 	VLAN_NAME_TYPE_PLUS_VID, /* Name will look like:  vlan0005 */
@@ -42,6 +45,7 @@
 		unsigned int name_type;
 		unsigned int bind_type;
 		unsigned int flag; /* Matches vlan_dev_info flags */
+		int nfmark_to_priority;  // brcm
 	} u;
 
 	short vlan_qos;
@@ -84,6 +88,11 @@
 	's', 'e', 't', '_',
 	'i', 'n', 'g', 'r', 'e', 's', 's', '_',
 	'm', 'a', 'p', 0,
+// brcm begin	
+	4, SET_VLAN_NFMARK_TO_PRIORITY_CMD, 19,
+	'n', 'f', 'm', 'a', 'r', 'k',
+	'_', 't', 'o', '_', 'p', 'r', 'i', 'o', 'r', 'i', 't', 'y', 0,
+// brcm end
 };
 
 static const char name_types[] ALIGN1 = {
@@ -148,6 +157,10 @@
 			ifr.vlan_qos = xatoul_range(argv[3], 0, 7);
 		} else if (ifr.cmd == ADD_VLAN_CMD) { /* add */
 			ifr.u.VID = xatoul_range(p, 0, VLAN_GROUP_ARRAY_LEN-1);
+// brcm begin	
+		} else if (ifr.cmd == SET_VLAN_NFMARK_TO_PRIORITY_CMD) {
+			ifr.u.nfmark_to_priority = xatoul_range(p, 0, 29);
+// brcm end	
 		} else if (ifr.cmd != DEL_VLAN_CMD) { /* set_{egress|ingress}_map */
 			ifr.u.skb_priority = xatou(p);
 			ifr.vlan_qos = xatoul_range(argv[3], 0, 7);
diff -Naur busybox/networking/wget.c busybox-brcm/networking/wget.c
--- busybox/networking/wget.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/networking/wget.c	2018-11-24 13:44:16.417920792 -0400
@@ -8,6 +8,11 @@
  */
 #include "libbb.h"
 
+#ifdef CONFIG_FEATURE_WGET_HTTPS 
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#endif
+
 struct host_info {
 	// May be used if we ever will want to free() all xstrdup()s...
 	/* char *allocated; */
@@ -16,6 +21,9 @@
 	char       *host;
 	int         port;
 	smallint    is_ftp;
+#ifdef CONFIG_FEATURE_WGET_HTTPS
+	smallint    is_https;
+#endif   
 };
 
 
@@ -37,6 +45,66 @@
 };
 #define INIT_G() do { } while (0)
 
+#ifdef CONFIG_FEATURE_WGET_HTTPS
+/*--------------------*/
+typedef struct HttpHdrs{
+  /* common */
+  char *content_type;
+  char *protocol;
+  char *wwwAuthenticate;
+  char *Authorization;
+  char *TransferEncoding;
+  char *Connection;
+  /* request */
+  char *method;
+  char *path;
+  char *host;
+  int  port;
+  int  content_length;
+
+  /* result */
+  int  status_code;
+  char *message;
+  char *locationHdr;		/* from 3xx status response */
+
+  /* request derived */
+  unsigned int addr;  /* IP-address of communicating entity */
+  char *filename;
+  char *arg;
+} HttpHdrs;
+
+static HttpHdrs httphdrs;
+
+static void ssl_Init(void);
+static int ssl_send_get_request(SSL *ssl, const char *host, const char *uri, char *authhdr);
+static int ssl_rev_header_resp(SSL *ssl, int fd, HttpHdrs *hdrs, char *errmsg);
+static int ssl_rev_file_date(SSL *ssl, HttpHdrs *hdrs, int stream, char *errmsg);
+
+static SSL_CTX *ssl_ctx = NULL;
+static char HostStr[]="Host:";
+static char ConnectionStr[]="Connection:";
+static char ContentLthStr[]="Content-Length:";
+static char ContentTypeStr[]="Content-Type:";
+static char WWWAuthenticateStr[]="WWW-Authenticate:";
+static char AuthorizationStr[]="Authorization:";
+static char TransferEncoding[]="Transfer-Encoding:";
+static char LocationStr[]="Location:";
+
+#define BUF_SIZE_MAX 4096
+
+//#define WGET_HTTPS_DEBUG
+#ifdef WGET_HTTPS_DEBUG
+#define DEBUGP(args...) fprintf(stdout, args)
+#else
+#define DEBUGP(args...)  
+#endif
+
+#ifdef USE_CERTIFICATES
+#define WGET_CIPHERS     "RSA:DES:SHA+RSA:RC4:SAH+MEDIUM"
+#else
+#define WGET_CIPHERS     "SSLv3"
+#endif
+#endif /*CONFIG_FEATURE_WGET_HTTPS*/
 
 #if ENABLE_FEATURE_WGET_STATUSBAR
 
@@ -214,10 +282,21 @@
 		h->port = bb_lookup_port("http", "tcp", 80);
 		h->host = url + 7;
 		h->is_ftp = 0;
+      #ifdef CONFIG_FEATURE_WGET_HTTPS
+          h->is_https = 0;
+      #endif
 	} else if (strncmp(url, "ftp://", 6) == 0) {
 		h->port = bb_lookup_port("ftp", "tcp", 21);
 		h->host = url + 6;
 		h->is_ftp = 1;
+   #ifdef CONFIG_FEATURE_WGET_HTTPS
+          h->is_https = 0;
+	}else if (strncmp(url, "https://", 8) == 0){
+          h->port = bb_lookup_port("https", "tcp", 443);
+		h->host = url + 8;
+		h->is_ftp = 0;
+          h->is_https = 1;
+   #endif
 	} else
 		bb_error_msg_and_die("not an http or ftp url: %s", sanitize_string(url));
 
@@ -591,6 +670,13 @@
 
 	/* Use the proxy if necessary */
 	use_proxy = (strcmp(proxy_flag, "off") != 0);
+#ifdef CONFIG_FEATURE_WGET_HTTPS
+     //don't support proxy for https now
+     if(target.is_https)
+     {
+          use_proxy = 0;
+     }
+#endif
 	if (use_proxy) {
 		proxy = getenv(target.is_ftp ? "ftp_proxy" : "http_proxy");
 		if (proxy && proxy[0]) {
@@ -656,6 +742,9 @@
 		free(s);
 	}
  establish_session:
+#ifdef CONFIG_FEATURE_WGET_HTTPS
+   if(!target.is_https){
+#endif   
 	if (use_proxy || !target.is_ftp) {
 		/*
 		 *  HTTP session
@@ -858,6 +947,595 @@
 			bb_error_msg_and_die("ftp error: %s", sanitize_string(buf+4));
 		/* ftpcmd("QUIT", NULL, sfp, buf); - why bother? */
 	}
+#ifdef CONFIG_FEATURE_WGET_HTTPS
+   }/*!target.is_https*/
+   else //support WGET_HTTPS
+   {
+      int ssl_fd, i=0;
+      SSL *ssl;
+      int sslConn;
+      char errmsg[256];
+      HttpHdrs *hdrs = &httphdrs;
+#ifdef CONFIG_FEATURE_WGET_AUTHENTICATION
+      char authhdr[256];
+#endif
+      
+      ssl_Init();
+      if((ssl_fd = xconnect_stream(lsa)) <0)
+         bb_error_msg_and_die("Create socket to remote host (%s) fail.",
+				inet_ntoa(((struct sockaddr_in *)(&lsa->u.sa))->sin_addr));
+
+      ssl = SSL_new(ssl_ctx);
+      if(ssl == NULL)
+         bb_error_msg_and_die("SSL failed: SSL_new.");
+
+      if(!SSL_set_fd (ssl, ssl_fd))
+         bb_error_msg_and_die("SSL failed: SSL_set_fd.");
+
+      SSL_set_connect_state (ssl);
+      if (SSL_connect (ssl) <= 0 || ssl->state != SSL_ST_OK)
+         bb_error_msg_and_die("SSL failed: SSL_connect.");
+      
+      memset(hdrs, 0, sizeof(struct HttpHdrs));
+      //send request header
+#ifdef CONFIG_FEATURE_WGET_AUTHENTICATION
+      if (target.user) {
+      	i = sprintf(authhdr, "Authorization: Basic %s\r\n", base64enc_512(buf, target.user));
+          authhdr[i] = '\0';
+
+          if(ssl_send_get_request(ssl, target.host, target.path, authhdr) <0)
+            bb_error_msg_and_die("SSL failed: Send Get Request Error.");
+      }
+      else if(ssl_send_get_request(ssl, target.host, target.path, NULL) <0)
+               bb_error_msg_and_die("SSL failed: Send Get Request Error.");
+#else
+      if(ssl_send_get_request(ssl, target.host, target.path, NULL) <0)
+         bb_error_msg_and_die("SSL failed: Send Get Request Error.");
+#endif
+      
+      //get header response and parse it
+      if(ssl_rev_header_resp(ssl, ssl_fd, hdrs, errmsg) < 0)
+         bb_error_msg_and_die(errmsg);
+
+      if(hdrs->status_code < 100 || hdrs->status_code >= 600)
+         bb_error_msg_and_die("SSL failed: status code %d from serve is error.", hdrs->status_code);
+
+      if (hdrs->status_code == 200 && 
+         ((hdrs->content_length > 0) ||
+          (hdrs->TransferEncoding && !strcasecmp(hdrs->TransferEncoding,"chunked"))))
+      {
+         int mlth = 0;
+         char *rambuf = NULL;
+         
+         DEBUGP("Starting download file");
+         
+         if (output_fd < 0) {
+		   int o_flags = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL;
+		   /* compat with wget: -O FILE can overwrite */
+		   if (opt & WGET_OPT_OUTNAME)
+			   o_flags = O_WRONLY | O_CREAT | O_TRUNC;
+		   output_fd = xopen(fname_out, o_flags);
+	    }  
+         
+         //retrieve file data
+         if(ssl_rev_file_date(ssl, hdrs, output_fd, errmsg) < 0){
+            xclose(output_fd);
+		  unlink(fname_out);
+            bb_error_msg_and_die(errmsg);           
+         }
+      }
+      else if (hdrs->status_code == 401)
+      {
+         bb_error_msg_and_die("SSL failed: 401 Unauthorized.");
+      }
+      else if (hdrs->status_code == 404)
+      {
+         bb_error_msg_and_die("SSL failed: 404 NOT FOUND.");
+      }
+      else
+      {
+         bb_error_msg_and_die("SSL failed: No support status code %d.", hdrs->status_code);
+      }      
+   }
+#endif
+   fprintf(stdout, "200 OK, File Get Success\n");
 
 	return EXIT_SUCCESS;
 }
+
+#ifdef CONFIG_FEATURE_WGET_HTTPS
+/*======================================================================*
+ * ssl_Init
+ *======================================================================*/
+void ssl_Init()
+{
+   DEBUGP("Enter ssl_init()\n");
+   
+   SSL_load_error_strings();
+   SSL_library_init();
+   ssl_ctx = SSL_CTX_new(SSLv3_client_method());
+   if (ssl_ctx == NULL) 
+   {
+      bb_error_msg_and_die("Could not create SSL context");
+   }
+
+   if (! SSL_CTX_set_cipher_list(ssl_ctx, WGET_CIPHERS) )
+   {
+      DEBUGP("Err: Could not set cipher list for SSL\n");
+   }
+
+#ifdef USE_CERTIFICATES
+   {
+      struct stat fstat;
+      // PT: add to support client certificate
+      if (lstat(CLIENT_CERT_FILE, &fstat) == 0) 
+      {
+         if (lstat(CLIENT_PRIVATE_KEY_FILE, &fstat) == 0)
+         {         
+            if (SSL_CTX_use_certificate_file(ssl_ctx, CLIENT_CERT_FILE, SSL_FILETYPE_PEM) <= 0) 
+            {
+               DEBUGP("Err: Error loading the client certificate\n");
+            }
+            if (SSL_CTX_use_PrivateKey_file(ssl_ctx, CLIENT_PRIVATE_KEY_FILE, SSL_FILETYPE_PEM) <= 0) 
+            {
+               DEBUGP("Err: Error loading the client private key\n");
+            }
+            if (! SSL_CTX_check_private_key(ssl_ctx)) 
+            {
+               DEBUGP("Err: Private key does not match the client certificate public key\n");
+            }
+         } 
+         else 
+         {
+            DEBUGP("Err: No private key found\n");
+         }
+      } 
+      else 
+      {
+         DEBUGP("Notice: No client certificate found\n");
+      }
+      
+      if (lstat(ROOT_CERT_FILE, &fstat) == 0) 
+      {
+         int retval = SSL_CTX_load_verify_locations(ssl_ctx, ROOT_CERT_FILE, CERT_PATH);
+         /* for both ssl, retval == 1 is load verified */
+         if (retval != 1)
+         {
+            DEBUGP("Err: Could not load verify locations\n");
+         }
+         /* if fail to load certificate, set the certificate verify anyway */		      
+         SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, verify_callback);
+      } 
+      else 
+      {
+         /* for bcm ssl, if no certificate in the system, just skip the certificate check */
+         DEBUGP("Notice: No server certificate found. Skip checking on certificate.\n");
+         SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_NONE, 0);
+      }
+   }   
+#endif // USE_CERTIFICATES
+
+   SSL_CTX_set_mode(ssl_ctx, SSL_MODE_AUTO_RETRY);
+   ERR_print_errors_fp(stderr);
+   SSL_CTX_set_session_cache_mode(ssl_ctx, SSL_SESS_CACHE_OFF);
+}  /* End of proto_Init() */
+
+/*----------------------------------------------------------------------
+ * removes any trailing whitespaces, \r and \n
+ * it destroys its argument...
+ */
+void www_StripTail(char *s)
+{
+  if (*s != '\0') {
+    while(*s) s++;
+    s--;
+    while(*s == '\r' || *s == '\n' || *s == ' ' || *s == '\t') {
+      *s = '\0';
+      s--;
+    }
+  }
+}
+
+int read_timeout(int socket_, int timeOutSec_)
+{
+   fd_set readSet;
+
+   FD_ZERO(&readSet);
+   FD_SET(socket_, &readSet);
+   if (timeOutSec_ == 0)
+   {
+      // zero means BLOCKING operation (will wait indefinitely)
+      return (select(socket_ + 1, &readSet, NULL, NULL, NULL));
+   }
+    // otherwise, wait up to the specified time period
+    struct timeval tv;
+
+    tv.tv_sec = timeOutSec_;
+    tv.tv_usec = 0;
+
+    return (select(socket_ + 1, &readSet, NULL, NULL, &tv));
+
+    // returns 0 if the time limit expired.
+    // returns -1 on error, otherwise there is data on the port ready to read
+}
+
+int ssl_Readn(SSL *ssl, char *ptr, int nbytes)
+{
+    int fd, nleft, nread=0;
+    int   errnoval;
+
+    nleft = nbytes;
+    while (nleft > 0) {
+      errno =0;
+      if((fd = SSL_get_fd(ssl)) <0)
+         return -1;
+      
+      if (read_timeout(fd, 30) <= 0) 
+      {
+        return -99; //timeout!!!
+      }  
+      
+      nread = SSL_read(ssl, (void *) ptr, nleft);        
+
+      if (nread < 0) {                            /* This function will read until the byte cnt*/
+         errnoval=errno;                         /* is reached or the return is <0. In the case*/
+         if (errnoval==EAGAIN )                  /* of non-blocking reads this may happen after*/
+             return nbytes-nleft;                /* some bytes have been retrieved. The EAGAIN*/
+         else                                    /* status indicates that more are coming */
+            return nread; /* error, return < 0 */
+      } else if (nread == 0) {
+         break; /* EOF */
+      }
+
+      nleft -= nread;
+      ptr += nread;
+   }
+
+   return nbytes - nleft; /* return >= 0 */
+}
+
+int ssl_Readline(SSL *ssl, char *buf, int maxlen)
+{
+    int fd, n, rc;
+    char   *ptr = buf;
+    char c;
+    int flags, bflags;
+
+    if((fd = SSL_get_fd(ssl)) <0)
+         return -1;
+    
+    for (n = 1; n < maxlen; n++) {
+        rc = ssl_Readn(ssl, &c, 1);
+        if (rc == 1) {
+            *ptr++ = c;
+            if (c == '\n')
+                break;
+        } else if (rc == 0) {
+            if (n == 1) {
+                return 0; /* EOF, no data read */
+            } else
+                break;    /* EOF, some data was read */
+        } else {
+            return -1; /* ERROR */
+        }
+    }
+
+    *ptr = '\0';
+
+    DEBUGP("ssl_Readline : %s", buf);
+    return n;
+}
+
+static char *ssl_readLengthMsg(SSL *ssl, int readLth, int *mlth, int doFlushStream, char *errmsg) {
+   int bufCnt = 0, readCnt = 0, nread=0;
+   int bufLth = readLth;
+   char *soapBuf = NULL;
+   char c;
+
+   *mlth = 0;
+   /*
+    * This is the path taken when we do image download.  Don't zeroize
+    * the buffer that is allocated here because that will force linux
+    * to immediately assign physical pages to the buffer.  Intead, just
+    * let the buffer fill in as the transfer progresses.  This will give
+    * smd and the kernel more time to make physical pages available.
+    */
+   if ((soapBuf = (char *) malloc(readLth + 1)) != NULL)
+   {
+      while (bufCnt < readLth)
+      {
+         // if ((readCnt = proto_ReadWait(wg->pc, soapBuf+bufCnt, bufLth)) > 0)
+         if ((readCnt = ssl_Readn(ssl, soapBuf+bufCnt, bufLth)) > 0)
+         {
+            bufCnt += readCnt;
+            bufLth -= readCnt;
+         }
+         else
+         {
+            if (readCnt == -99) {
+                  /* read error */
+                  if(soapBuf != NULL)
+                     free(soapBuf);
+                  soapBuf = NULL;
+                  strcpy(errmsg, "SSL failed: read socket timeout.\n");
+                  break;
+               }
+            }
+      }
+      DEBUGP("soapBuf bufCnt=%d readLth=%d\n", bufCnt, readLth);
+      if(readCnt != -99)
+      {
+         *mlth = bufCnt;
+         soapBuf[bufCnt] = '\0';
+      }
+      if (doFlushStream)
+      {
+         do {
+               nread = SSL_read(ssl, &c, 1);
+         } while (nread>0);   
+      }
+   }
+   else
+      strcpy(errmsg, "SSL failed: malloc failed in ssl_readLengthMsg.\n");
+      
+   return soapBuf;
+}
+
+static char *ssl_readChunkedMsg(SSL *ssl, int *mlth, int maxSize, char *errmsg) {
+   char *soapBuf = NULL;
+   char chunkedBuf[128];   
+   char c;
+   int nread=0;
+   
+   *mlth = 0;
+   // read chunked size of first chunk*/
+   if (ssl_Readline(ssl, chunkedBuf, sizeof(chunkedBuf)) > 0)
+   {
+      int  chunkedSz = 0, readSz = 0;
+      char *newBuf = NULL, *readBuf = NULL;
+      
+      sscanf(chunkedBuf, "%x", &chunkedSz);
+      while (chunkedSz > 0)
+      {
+         // read chunked data
+         int doFlushStream=FALSE;
+         readBuf = ssl_readLengthMsg(ssl, chunkedSz, &readSz, doFlushStream, errmsg);
+         if (chunkedSz != readSz)
+            DEBUGP("===> ssl_readChunkedMsg, chunked size = %d, read size = %d\n", chunkedSz, readSz);
+         if (readBuf == NULL)
+         {
+            if(soapBuf)
+               free(soapBuf);
+            *mlth = 0;
+            break;
+         }
+         if ((*mlth + readSz) > maxSize)
+         {
+            sprintf(errmsg, "SSL failed: reading more data than maxSize (%d)\n", maxSize);
+            if(soapBuf)
+               free(soapBuf);
+            *mlth = 0;
+            if(readBuf)
+               free(readBuf);
+            readSz = 0;
+            break;
+         }
+         if (soapBuf == NULL)
+         {
+            // allocate the first chunk since cmsMem_realloc
+            // does not accept soapBuf as NULL pointer.
+            newBuf = soapBuf = malloc(*mlth + readSz);
+         }
+         else 
+         {
+            // reallocate soap message size
+            newBuf = realloc(soapBuf, *mlth + readSz);
+         }
+         
+         if (newBuf == NULL)
+         {
+            strcpy(errmsg, "SSL failed: malloc failed in ssl_readChunkedMsg\n");
+
+            if(soapBuf)
+               free(soapBuf);
+            *mlth = 0;
+            if(readBuf)
+               free(readBuf);
+            readSz = 0;
+            break;
+         }
+         // point soap message to new allocated memory
+         soapBuf = newBuf;
+         // append chunked data to soap message 
+         strncpy(soapBuf + *mlth, readBuf, readSz);
+         // increase soap message size
+         *mlth += readSz;
+         // free chunked data
+         if(readBuf)
+            free(readBuf);
+         readSz = 0;
+         chunkedSz = 0;
+         // flush off trailing crlf
+         do
+         {
+            chunkedBuf[0] = '\0';
+            readSz = ssl_Readline(ssl, chunkedBuf, sizeof(chunkedBuf));
+         } while (readSz > 0 && isxdigit(chunkedBuf[0]) == 0);
+         // read chunked size of next chunk*/
+         if (isxdigit(chunkedBuf[0]) != 0)
+         {
+            sscanf(chunkedBuf, "%x", &chunkedSz);
+         }
+         else
+         {
+            if(soapBuf)
+               free(soapBuf);
+            *mlth = 0;
+         }
+      }      
+      // skip(flush) anything else
+      do {
+            nread = SSL_read(ssl, &c, 1);
+      } while (nread>0);   
+   }
+   else
+      strcpy(errmsg, "SSL failed: read chunked size of first chunk.\n");
+
+   return soapBuf;
+}
+
+int ssl_send_get_request(SSL *ssl, const char *host, const char *uri, char *authhdr)
+{
+   char buf[BUF_SIZE_MAX];
+   int len=0, nwritten=0;
+
+   if(uri==NULL || host==NULL)
+      return -1;
+   
+   len = sprintf(buf,"GET /%s HTTP/1.1\r\n", uri);
+   len += sprintf(buf+len,"Host: %s\r\nUser-Agent: Wget\r\n", host);
+
+   if(authhdr != NULL)
+      len += sprintf(buf+len,authhdr);
+   
+   len += sprintf(buf+len,"Connection: close\r\n\r\n");
+   
+   nwritten = SSL_write(ssl, buf, len);
+
+   buf[len] = '\0';
+   DEBUGP("Send Request header to server: [%s] len = %d, nwritten = %d\n", buf, len, nwritten);
+
+   if(nwritten != len)
+      return -1;
+   else
+      return nwritten;
+}  /* End of ssl_send_get_request() */
+
+int ssl_rev_header_resp(SSL *ssl, int fd, HttpHdrs *hdrs, char *errmsg)
+{
+    char buf[BUF_SIZE_MAX];
+    char protocol[BUF_SIZE_MAX];
+    char status[BUF_SIZE_MAX];
+    char message[BUF_SIZE_MAX];
+    char *cp;
+    int status_code, n;
+
+    DEBUGP("Enter proto_ParseResponse()");    
+
+    /*step 1: Parse the first line of the request. */
+    if (ssl_Readline(ssl, buf, BUF_SIZE_MAX) <= 0) {
+        strcpy(errmsg, "SSL failed: read the first line of header error");
+        return -1;
+    }
+
+    if (sscanf(buf, "%[^ ] %[^ ] %[^\r]", protocol, status, message ) != 3) {
+        strcpy(errmsg, "SSL failed: can't get protocol/status/message in resp header.");
+        return -1;
+    }
+
+    www_StripTail(protocol);
+    www_StripTail(status);
+    www_StripTail(message);
+    if(hdrs->protocol != NULL)
+      free(hdrs->protocol);
+    hdrs->protocol = strdup(protocol);
+    hdrs->status_code = atoi(status); /* TBD: add sanity check */
+    if(hdrs->message != NULL)
+      free(hdrs->message);
+    hdrs->message = strdup(message);
+    DEBUGP("proto_ParseResponse, step 1: (protocol=\"%s\", status=%d message=\"%s\")",
+            hdrs->protocol, hdrs->status_code, hdrs->message);
+
+    /*step 2: Parse the rest of the request headers. */
+    while ((n = ssl_Readline(ssl, buf, BUF_SIZE_MAX)) > 0) 
+    {
+        www_StripTail(buf);
+        DEBUGP("proto_ParseResponse, step 2:  read \"%s\"", buf);
+        
+        if (strcmp(buf, "") == 0) {
+            break;
+        } else if (strncasecmp(buf, HostStr,sizeof(HostStr)-1) == 0) {
+            cp = &buf[sizeof(HostStr)-1];
+            cp += strspn(cp, " \t");
+            if(hdrs->host != NULL)
+               free(hdrs->host);
+            hdrs->host = strdup(cp);
+        } else if (strncasecmp(buf, ContentLthStr,sizeof(ContentLthStr)-1) == 0) {
+            cp = &buf[sizeof(ContentLthStr)-1];
+            cp += strspn(cp, " \t");
+            hdrs->content_length = atoi(cp);
+        } else if (strncasecmp(buf, ContentTypeStr,sizeof(ContentTypeStr)-1) == 0) {
+            cp = &buf[sizeof(ContentTypeStr)-1];
+            cp += strspn(cp, " \t");
+            if(hdrs->content_type != NULL)
+               free(hdrs->content_type);
+            hdrs->content_type = strdup(cp);
+        } else if (strncasecmp(buf, ConnectionStr,sizeof(ConnectionStr)-1) == 0) {
+            cp = &buf[sizeof(ConnectionStr)-1];
+            cp += strspn(cp, " \t");
+            if(hdrs->Connection != NULL)
+               free(hdrs->Connection);
+            hdrs->Connection = strdup(cp);
+        } else if (strncasecmp(buf, WWWAuthenticateStr, sizeof(WWWAuthenticateStr)-1)==0) {
+            cp =&buf[sizeof(WWWAuthenticateStr)-1];
+            cp += strspn(cp, " \t");
+            if(hdrs->wwwAuthenticate != NULL)
+               free(hdrs->wwwAuthenticate);
+            hdrs->wwwAuthenticate = strdup(cp);
+        } else if (strncasecmp(buf, AuthorizationStr, sizeof(AuthorizationStr)-1)==0) {
+            cp =&buf[sizeof(AuthorizationStr)-1];
+            cp += strspn(cp, " \t");
+            if(hdrs->Authorization != NULL)
+               free(hdrs->Authorization);
+            hdrs->Authorization = strdup(cp);
+        } else if (strncasecmp(buf, TransferEncoding, sizeof(TransferEncoding)-1)==0) {
+            cp =&buf[sizeof(TransferEncoding)-1];
+            cp += strspn(cp, " \t");
+            if(hdrs->TransferEncoding != NULL)
+               free(hdrs->TransferEncoding);
+            hdrs->TransferEncoding = strdup(cp);
+        } else if (strncasecmp(buf, LocationStr, sizeof(LocationStr)-1)==0) {
+            cp =&buf[sizeof(LocationStr)-1];
+            cp += strspn(cp, " \t");
+            if(hdrs->locationHdr != NULL)
+               free(hdrs->locationHdr);
+            hdrs->locationHdr = strdup(cp);
+        }
+    }
+
+    if(n < 0)
+      strcpy(errmsg, "SSL failed: read rest of request header error.");
+    
+    return n;
+}
+
+int ssl_rev_file_date(SSL *ssl, HttpHdrs *hdrs, int stream, char *errmsg)
+{
+   char *soapBuf = NULL;
+   int mlth = 0;
+
+   if (hdrs->content_length > 0)
+   {
+      int doFlushStream = TRUE;
+
+      /* this is the path taken by image downloads */
+      DEBUGP("Get file data with content_length=%d", hdrs->content_length);
+      soapBuf = ssl_readLengthMsg(ssl, hdrs->content_length, &mlth, doFlushStream, errmsg);
+   }
+   else if (hdrs->TransferEncoding && !strcasecmp(hdrs->TransferEncoding,"chunked"))
+   {
+      int maxSize = 1024*1024;
+      DEBUGP("Get file data Chunked with maxSize=%d", maxSize);
+      soapBuf = ssl_readChunkedMsg(ssl, &mlth, maxSize, errmsg);
+   }
+
+   //MUST free soapBuf if it's not NULL.
+   if(soapBuf){
+      xwrite(stream, soapBuf, mlth);
+      free(soapBuf);
+      return 0; 
+   } 
+   else
+      return -1;
+}
+#endif
diff -Naur busybox/procps/top.c busybox-brcm/procps/top.c
--- busybox/procps/top.c	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/procps/top.c	2018-11-24 13:44:16.417920792 -0400
@@ -47,6 +47,11 @@
 #if ENABLE_FEATURE_TOP_SMP_PROCESS
 	int last_seen_on_cpu;
 #endif
+#ifdef BRCM_CMS_BUILD
+	int cpu_affinity;
+	int priority;
+	int sched_policy;
+#endif
 } top_status_t;
 
 typedef struct jiffy_counts_t {
@@ -100,7 +105,7 @@
 	int num_cpus;
 #endif
 	char line_buf[80];
-}; //FIX_ALIASING; - large code growth
+} FIX_ALIASING;
 enum { LINE_BUF_SIZE = COMMON_BUFSIZE - offsetof(struct globals, line_buf) };
 #define G (*(struct globals*)&bb_common_bufsiz1)
 struct BUG_bad_size {
@@ -125,6 +130,21 @@
 #define total_pcpu       (G.total_pcpu        )
 #define line_buf         (G.line_buf          )
 
+
+#ifdef BRCM_CMS_BUILD
+int cpufilter=-1;
+int altdisplay=0;
+enum {
+	OPT_d = (1 << 0),
+	OPT_n = (1 << 1),
+	OPT_c = (1 << 2),
+	OPT_l = (1 << 3),
+	OPT_a = (1 << 4),
+	OPT_b = (1 << 5),
+	OPT_m = (1 << 6),
+	OPT_EOF = (1 << 7), /* pseudo: "we saw EOF in stdin" */
+};
+#else
 enum {
 	OPT_d = (1 << 0),
 	OPT_n = (1 << 1),
@@ -132,8 +152,20 @@
 	OPT_m = (1 << 3),
 	OPT_EOF = (1 << 4), /* pseudo: "we saw EOF in stdin" */
 };
+#endif /* BRCM_CMS_BUILD */
 #define OPT_BATCH_MODE (option_mask32 & OPT_b)
 
+#ifdef BRCM_CMS_BUILD
+static int prio_sort(top_status_t *P, top_status_t *Q)
+{
+	return (P->priority - Q->priority);
+}
+
+static int affinity_sort(top_status_t *P, top_status_t *Q)
+{
+	return (Q->cpu_affinity - P->cpu_affinity);
+}
+#endif  /* BRCM_CMS_BUILD */
 
 #if ENABLE_FEATURE_USE_TERMIOS
 static int pid_sort(top_status_t *P, top_status_t *Q)
@@ -518,6 +550,16 @@
 #endif
 
 	/* what info of the processes is shown */
+#ifdef BRCM_CMS_BUILD
+	int local_ntops;
+	if (altdisplay)
+		printf(OPT_BATCH_MODE ? "%.*s" : "\033[7m%.*s\033[0m", scr_width,
+			"  PID  PPID USER     STAT  INFO PRIO"
+			IF_FEATURE_TOP_SMP_PROCESS(" CPU")
+			IF_FEATURE_TOP_CPU_USAGE_PERCENTAGE(" %CPU")
+			" COMMAND");
+	else
+#endif
 	printf(OPT_BATCH_MODE ? "%.*s" : "\033[7m%.*s\033[0m", scr_width,
 		"  PID  PPID USER     STAT   VSZ %MEM"
 		IF_FEATURE_TOP_SMP_PROCESS(" CPU")
@@ -586,18 +628,56 @@
 	if (lines_rem > ntop)
 		lines_rem = ntop;
 	s = top;
+#ifdef BRCM_CMS_BUILD
+	if (altdisplay && cpufilter >= 0)
+		pcpu_shift--;
+
+	local_ntops = ntop;
+	while (lines_rem > 0 && local_ntops > 0) {
+#else
 	while (--lines_rem >= 0) {
+#endif
 		unsigned col;
 		CALC_STAT(pmem, (s->vsz*pmem_scale + pmem_half) >> pmem_shift);
 #if ENABLE_FEATURE_TOP_CPU_USAGE_PERCENTAGE
 		CALC_STAT(pcpu, (s->pcpu*pcpu_scale + pcpu_half) >> pcpu_shift);
 #endif
-
+#ifdef BRCM_CMS_BUILD
+		local_ntops--;
+		if (cpufilter >= 0 && cpufilter != s->last_seen_on_cpu) {
+			s++;
+			continue;
+		}
+		lines_rem--;
+#endif
 		if (s->vsz >= 100000)
 			sprintf(vsz_str_buf, "%6ldm", s->vsz/1024);
 		else
 			sprintf(vsz_str_buf, "%7ld", s->vsz);
 		/* PID PPID USER STAT VSZ %MEM [%CPU] COMMAND */
+#ifdef BRCM_CMS_BUILD
+		if (altdisplay) {
+			sprintf(vsz_str_buf, "       ");
+			if (SCHED_OTHER == s->sched_policy)
+				vsz_str_buf[6] = 'O';
+			else if (SCHED_FIFO == s->sched_policy)
+				vsz_str_buf[6] = 'F';
+			else if (SCHED_RR == s->sched_policy)
+				vsz_str_buf[6] = 'R';
+			else
+				vsz_str_buf[6] = '?';
+			col = snprintf(line_buf, scr_width,
+					"\n" "%5u%6u %-8.8s %s%s" "%5d %d:%d"
+					IF_FEATURE_TOP_CPU_USAGE_PERCENTAGE(FMT)
+					" ",
+					s->pid, s->ppid, get_cached_username(s->uid),
+					s->state, vsz_str_buf,
+					s->priority, s->cpu_affinity, s->last_seen_on_cpu
+					IF_FEATURE_TOP_CPU_USAGE_PERCENTAGE(, SHOW_STAT(pcpu))
+				);
+		}
+		else
+#endif
 		col = snprintf(line_buf, scr_width,
 				"\n" "%5u%6u %-8.8s %s%s" FMT
 				IF_FEATURE_TOP_SMP_PROCESS(" %3d")
@@ -840,6 +920,10 @@
 	int lines_rem;
 	unsigned interval;
 	char *str_interval, *str_iterations;
+#ifdef BRCM_CMS_BUILD
+	char *str_cpufilter, *str_xlines;
+	int xlines=0;
+#endif
 	unsigned scan_mask = TOP_MASK;
 #if ENABLE_FEATURE_USE_TERMIOS
 	struct termios new_settings;
@@ -863,7 +947,11 @@
 
 	/* all args are options; -n NUM */
 	opt_complementary = "-"; /* options can be specified w/o dash */
+#ifdef BRCM_CMS_BUILD
+	col = getopt32(argv, "d:n:c:l:ab"IF_FEATURE_TOPMEM("m"), &str_interval, &str_iterations, &str_cpufilter, &str_xlines);
+#else
 	col = getopt32(argv, "d:n:b"IF_FEATURE_TOPMEM("m"), &str_interval, &str_iterations);
+#endif
 #if ENABLE_FEATURE_TOPMEM
 	if (col & OPT_m) /* -m (busybox specific) */
 		scan_mask = TOPMEM_MASK;
@@ -882,6 +970,20 @@
 		iterations = xatou(str_iterations);
 	}
 
+#ifdef BRCM_CMS_BUILD
+	if (col & OPT_c) {
+		cpufilter = xatou(str_cpufilter);
+		if (cpufilter != 0 && cpufilter != 1) {
+			printf("cpufilter must be 0 or 1\n");
+			exit(0);
+		}
+	}
+	if (col & OPT_l)
+		xlines = xatou(str_xlines);
+	if (col & OPT_a)
+		altdisplay = 1;;
+#endif
+
 	/* change to /proc */
 	xchdir("/proc");
 #if ENABLE_FEATURE_USE_TERMIOS
@@ -915,6 +1017,10 @@
 			continue;
 		}
 #endif
+#ifdef BRCM_CMS_BUILD
+		if (xlines > 0)
+			lines = xlines;
+#endif
 		if (col > LINE_BUF_SIZE-2) /* +2 bytes for '\n', NUL, */
 			col = LINE_BUF_SIZE-2;
 
@@ -939,6 +1045,11 @@
 #if ENABLE_FEATURE_TOP_SMP_PROCESS
 				top[n].last_seen_on_cpu = p->last_seen_on_cpu;
 #endif
+#ifdef BRCM_CMS_BUILD
+				top[n].priority = p->priority;
+				top[n].cpu_affinity = p->cpu_affinity;
+				top[n].sched_policy = p->sched_policy;
+#endif
 			}
 #if ENABLE_FEATURE_TOPMEM
 			else { /* TOPMEM */
@@ -1013,6 +1124,13 @@
 			c |= 0x20; /* lowercase */
 			if (c == 'q')
 				break;
+#ifdef BRCM_CMS_BUILD
+			if (c == 'y') {
+				sort_function[0] = prio_sort;
+				sort_function[1] = affinity_sort;
+				sort_function[2] = pid_sort;
+			}
+#endif /* BRCM_CMS_BUILD */
 			if (c == 'n') {
 				IF_FEATURE_TOPMEM(scan_mask = TOP_MASK;)
 				sort_function[0] = pid_sort;
diff -Naur busybox/scripts/gen_build_files.sh busybox-brcm/scripts/gen_build_files.sh
--- busybox/scripts/gen_build_files.sh	2010-08-22 21:44:35.000000000 -0300
+++ busybox-brcm/scripts/gen_build_files.sh	2018-11-24 13:44:16.421916952 -0400
@@ -7,7 +7,9 @@
 # In separate objtree build, include/ might not exist yet
 mkdir include 2>/dev/null
 
-srctree="$1"
+# brcm: avoid sed argument too long error with some linux hosts.
+#srctree="$1"
+srctree="."
 
 # (Re)generate include/applets.h
 src="$srctree/include/applets.src.h"
diff -Naur busybox/shell/math.c busybox-brcm/shell/math.c
--- busybox/shell/math.c	2010-08-22 21:44:36.000000000 -0300
+++ busybox-brcm/shell/math.c	2018-11-24 13:44:16.457882383 -0400
@@ -13,7 +13,7 @@
  * was re-ported from NetBSD and debianized.
  *
  * rewrite arith.y to micro stack based cryptic algorithm by
- * Copyright (c) 2001 Aaron Lehmann <aaronl@vitelus.com>
+ * Copyright (c) 2001 Aaron Lehmann <aaronl@viXXX.com>
  *
  * Modified by Paul Mundt <lethal@linux-sh.org> (c) 2004 to support
  * dynamic variables.
@@ -25,7 +25,7 @@
  *
  * Licensed under the GPL v2 or later, see the file LICENSE in this tarball.
  */
-/* Copyright (c) 2001 Aaron Lehmann <aaronl@vitelus.com>
+/* Copyright (c) 2001 Aaron Lehmann <aaronl@viXXX.com>
 
    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
diff -Naur busybox/sysklogd/Config.src busybox-brcm/sysklogd/Config.src
--- busybox/sysklogd/Config.src	2010-08-22 21:44:36.000000000 -0300
+++ busybox-brcm/sysklogd/Config.src	2018-11-24 13:44:16.457882383 -0400
@@ -125,6 +125,12 @@
 	    messages to the system log (i.e. the 'syslogd' utility) so
 	    they can be logged. This is generally used to help locate
 	    problems that occur within programs and scripts.
+config CPULOGD
+       bool "cpulogd"
+       default y
+       depends on SYSLOGD
+       help
+         the cpulogd is used to rcord the log of cpu usage.
 
 endmenu
 
diff -Naur busybox/sysklogd/cpulogd.c busybox-brcm/sysklogd/cpulogd.c
--- busybox/sysklogd/cpulogd.c	1969-12-31 20:00:00.000000000 -0400
+++ busybox-brcm/sysklogd/cpulogd.c	2018-11-24 13:44:16.457882383 -0400
@@ -0,0 +1,159 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sched.h>
+#include <sys/syslog.h>
+
+#define DEFAULT_SAMPLE_INTERVAL  5  /* seconds */
+#define DEFAULT_CPU_LOG_INTERVAL 60 /* seconds */
+
+struct cpu_stats
+{
+    int idle_jiffies;
+    int total_jiffies;
+};
+
+static struct cpu_stats start_sample;
+static struct cpu_stats end_sample;
+
+static int cpu_log_start = 0;
+static int cpu_log_interval = DEFAULT_CPU_LOG_INTERVAL;
+
+static void do_cpu_sample(struct cpu_stats *sample)
+{
+    char col[9][32];
+    char line[256];
+    FILE *fs = NULL;
+
+    if (sample == NULL)
+        return;
+
+    memset(sample, 0, sizeof(struct cpu_stats));
+
+    if ((fs = fopen("/proc/stat", "r")) == NULL)
+    {
+        return;
+    }
+
+    if (fgets(line, sizeof(line), fs))
+    {
+        /* title, user, nice, system, idle, iowait, irq, softirq */
+        sscanf(line, "%s %s %s %s %s %s %s %s %s",
+                     col[0], col[1], col[2], col[3], col[4], col[5],
+                     col[6], col[7], col[8]);
+
+        sample->total_jiffies = atoi(col[1]) + atoi(col[2]) +
+                                atoi(col[3]) + atoi(col[4]) +
+                                atoi(col[5]) + atoi(col[6]) + atoi(col[7]);
+        sample->idle_jiffies = atoi(col[4]);
+    }
+
+    fclose(fs);
+}
+
+static void do_cpu_log(void)
+{
+    float cpu_percent = 0;
+    int idle_period;
+    int work_period;
+    int total_period;
+
+    idle_period = end_sample.idle_jiffies - start_sample.idle_jiffies;
+    total_period = end_sample.total_jiffies - start_sample.total_jiffies;
+    work_period = total_period - idle_period;
+    if (work_period && total_period)
+    {
+        cpu_percent = (float)work_period / total_period * 100;
+        syslog(LOG_WARNING, "CPU utilization:    %.1f%%\n", cpu_percent);
+    }
+}
+
+static void doCpulogd(void)
+{
+    int ret;
+    fd_set fds;
+    struct timeval tv;
+    struct timeval *ptv;
+    for (;;) {
+        FD_ZERO(&fds);
+
+        if (cpu_log_start)
+            tv.tv_sec = DEFAULT_SAMPLE_INTERVAL;
+        else
+            tv.tv_sec = cpu_log_interval - DEFAULT_SAMPLE_INTERVAL;
+
+        tv.tv_usec = 0;
+        ptv = &tv;
+
+        ret = select(0, &fds, NULL, NULL, ptv);
+        if (ret < 0)
+        {
+            if (errno == EINTR)
+            {
+                /* alarm may have happened. */
+                continue;
+            }
+            return;
+        }
+        else if (ret == 0)
+        {
+            cpu_log_start = !cpu_log_start;
+            if (cpu_log_start)
+                do_cpu_sample(&start_sample);
+            else
+            {
+                do_cpu_sample(&end_sample);
+                do_cpu_log();
+            }
+
+            continue;
+        }
+    }
+}
+
+static void set_realtime_priority(void)
+{
+    int sched;
+    int max_prior;
+    struct sched_param param;
+
+    max_prior = sched_get_priority_max(SCHED_FIFO);
+    if (max_prior != -1)
+    {
+        param.sched_priority = max_prior;
+        if (sched_setscheduler(0, SCHED_FIFO, &param) == -1)
+           printf("failed to set real-time priority to cpulogd\n");
+    }
+}
+
+extern int cpulogd_main(int argc, char **argv)
+{
+    int opt;
+
+    while ((opt = getopt(argc, argv, "t:")) > 0)
+    {
+        switch (opt)
+        {
+        case 't':
+            cpu_log_interval = atoi(optarg);
+            if (cpu_log_interval <= DEFAULT_SAMPLE_INTERVAL)
+                cpu_log_interval = DEFAULT_SAMPLE_INTERVAL + 5;
+            break;
+        default:
+            break;
+        }
+    }
+    /*
+    * detach from the terminal so we don't catch the user typing control-c
+    */
+    if (setsid() == -1)
+        printf("Could not detach from terminal\n");
+
+    set_realtime_priority();
+
+    doCpulogd();
+
+    return EXIT_SUCCESS;
+}
diff -Naur busybox/sysklogd/Kbuild.src busybox-brcm/sysklogd/Kbuild.src
--- busybox/sysklogd/Kbuild.src	2010-08-22 21:44:36.000000000 -0300
+++ busybox-brcm/sysklogd/Kbuild.src	2018-11-24 13:44:16.457882383 -0400
@@ -11,3 +11,4 @@
 lib-$(CONFIG_LOGGER)		+= syslogd_and_logger.o
 lib-$(CONFIG_LOGREAD)		+= logread.o
 lib-$(CONFIG_SYSLOGD)		+= syslogd_and_logger.o
+lib-$(CONFIG_CPULOGD)           += cpulogd.o
diff -Naur busybox/sysklogd/klogd.c busybox-brcm/sysklogd/klogd.c
--- busybox/sysklogd/klogd.c	2010-08-22 21:44:36.000000000 -0300
+++ busybox-brcm/sysklogd/klogd.c	2018-11-24 13:44:16.457882383 -0400
@@ -21,6 +21,11 @@
 #include <syslog.h>
 #include <sys/klog.h>
 
+// brcm begin
+#include "cms_util.h"
+#include "cms_msg.h"
+// brcm end
+
 static void klogd_signal(int sig)
 {
 	/* FYI: cmd 7 is equivalent to setting console_loglevel to 7
@@ -46,6 +51,10 @@
 	int opt;
 	int used = 0;
 
+#ifdef BRCM_CMS_BUILD
+    cmsLog_init(EID_KLOGD);
+    cmsLog_setLevel(DEFAULT_LOG_LEVEL);
+#endif
 	opt = getopt32(argv, "c:n", &opt_c);
 	if (opt & OPT_LEVEL) {
 		/* Valid levels are between 1 and 8 */
@@ -59,6 +68,23 @@
 
 	bb_signals(BB_FATAL_SIGS, klogd_signal);
 	signal(SIGHUP, SIG_IGN);
+// brcm begin
+#ifdef BRCM_CMS_BUILD
+    if (setsid() == -1)
+    {
+       cmsLog_error("Could not detach from terminal");
+    }
+    else
+    {
+       cmsLog_debug("detached from terminal");
+    }
+    /* In CMS, daemons should ignore SIGINT */
+    signal(SIGINT, SIG_IGN);
+    /* set signal masks */
+    signal(SIGPIPE, SIG_IGN); /* Ignore SIGPIPE signals */
+#endif
+// brcm end
+
 
 	/* "Open the log. Currently a NOP" */
 	klogctl(1, NULL, 0);
diff -Naur busybox/sysklogd/syslogd.c busybox-brcm/sysklogd/syslogd.c
--- busybox/sysklogd/syslogd.c	2010-08-22 21:44:36.000000000 -0300
+++ busybox-brcm/sysklogd/syslogd.c	2018-11-24 13:44:16.457882383 -0400
@@ -34,6 +34,10 @@
 #include <sys/shm.h>
 #endif
 
+// brcm begin
+#include "cms_util.h"
+#include "cms_msg.h"
+// brcm end
 
 #define DEBUG 0
 
@@ -45,6 +49,12 @@
 /* Write locking does not seem to be useful either */
 #undef SYSLOGD_WRLOCK
 
+// brcm begin
+/* All the access to /dev/log will be redirected to /var/log/log
+ *  * which is TMPFS, memory file system.
+ **/
+#define BRCM_PATH_LOG "/var/log/log"
+// brcm end
 enum {
 	MAX_READ = CONFIG_FEATURE_SYSLOGD_READ_BUFFER_SIZE,
 	DNS_WAIT_SEC = 2 * 60,
@@ -74,6 +84,7 @@
 	/*int markInterval;*/                   \
 	/* level of messages to be logged */    \
 	int logLevel;                           \
+	int remotelogLevel;                     \
 IF_FEATURE_ROTATE_LOGFILE( \
 	/* max size of file before rotation */  \
 	unsigned logFileSize;                   \
@@ -122,9 +133,10 @@
 	.logFilePath = "/var/log/messages",
 	.logFD = -1,
 #ifdef SYSLOGD_MARK
-	.markInterval = 20 * 60,
+	.markInterval = 60 * 60, // brcm
 #endif
-	.logLevel = 8,
+	.logLevel = -1,
+	.remotelogLevel = -1, // brcm
 #if ENABLE_FEATURE_ROTATE_LOGFILE
 	.logFileSize = 200 * 1024,
 	.logFileRotate = 1,
@@ -150,6 +162,7 @@
 	OPTBIT_nofork, // -n
 	OPTBIT_outfile, // -O
 	OPTBIT_loglevel, // -l
+	OPTBIT_remoteloglevel, // -r  // brcm
 	OPTBIT_small, // -S
 	IF_FEATURE_ROTATE_LOGFILE(OPTBIT_filesize   ,)	// -s
 	IF_FEATURE_ROTATE_LOGFILE(OPTBIT_rotatecnt  ,)	// -b
@@ -162,6 +175,7 @@
 	OPT_nofork      = 1 << OPTBIT_nofork  ,
 	OPT_outfile     = 1 << OPTBIT_outfile ,
 	OPT_loglevel    = 1 << OPTBIT_loglevel,
+	OPT_remoteloglevel    = 1 << OPTBIT_remoteloglevel, // brcm
 	OPT_small       = 1 << OPTBIT_small   ,
 	OPT_filesize    = IF_FEATURE_ROTATE_LOGFILE((1 << OPTBIT_filesize   )) + 0,
 	OPT_rotatecnt   = IF_FEATURE_ROTATE_LOGFILE((1 << OPTBIT_rotatecnt  )) + 0,
@@ -170,18 +184,18 @@
 	OPT_circularlog = IF_FEATURE_IPC_SYSLOG(    (1 << OPTBIT_circularlog)) + 0,
 	OPT_dup         = IF_FEATURE_SYSLOGD_DUP(   (1 << OPTBIT_dup        )) + 0,
 };
-#define OPTION_STR "m:nO:l:S" \
+#define OPTION_STR "m:nO:l:r:S" \
 	IF_FEATURE_ROTATE_LOGFILE("s:" ) \
 	IF_FEATURE_ROTATE_LOGFILE("b:" ) \
 	IF_FEATURE_REMOTE_LOG(    "R:" ) \
 	IF_FEATURE_REMOTE_LOG(    "L"  ) \
 	IF_FEATURE_IPC_SYSLOG(    "C::") \
 	IF_FEATURE_SYSLOGD_DUP(   "D"  )
-#define OPTION_DECL *opt_m, *opt_l \
+#define OPTION_DECL *opt_m, *opt_l, *opt_r \
 	IF_FEATURE_ROTATE_LOGFILE(,*opt_s) \
 	IF_FEATURE_ROTATE_LOGFILE(,*opt_b) \
 	IF_FEATURE_IPC_SYSLOG(    ,*opt_C = NULL)
-#define OPTION_PARAM &opt_m, &G.logFilePath, &opt_l \
+#define OPTION_PARAM &opt_m, &G.logFilePath, &opt_l , &opt_r\
 	IF_FEATURE_ROTATE_LOGFILE(,&opt_s) \
 	IF_FEATURE_ROTATE_LOGFILE(,&opt_b) \
 	IF_FEATURE_REMOTE_LOG(	  ,&remoteAddrList) \
@@ -384,9 +398,13 @@
 #endif
 }
 
-static void parse_fac_prio_20(int pri, char *res20)
+static int parse_fac_prio_20(int pri, char *res20)
 {
 	const CODE *c_pri, *c_fac;
+// brcm begin
+	int localLog=1;
+	int remoteLog=1;
+// brcm end
 
 	if (pri != 0) {
 		c_fac = facilitynames;
@@ -397,6 +415,12 @@
 			}
 			/* facility is found, look for prio */
 			c_pri = prioritynames;
+// brcm begin
+			if (c_pri->c_val > G.logLevel)
+			    localLog = 0;
+			if (c_pri->c_val > G.remotelogLevel)
+			    remoteLog = 0;
+// brcm end
 			while (c_pri->c_name) {
 				if (c_pri->c_val != LOG_PRI(pri)) {
 					c_pri++;
@@ -404,23 +428,63 @@
 				}
 				snprintf(res20, 20, "%s.%s",
 						c_fac->c_name, c_pri->c_name);
-				return;
+// brcm begin
+				if (!localLog && !remoteLog)
+				    return 1;
+				else
+				    return 0;
+// brcm end
 			}
 			/* prio not found, bail out */
 			break;
 		}
 		snprintf(res20, 20, "<%d>", pri);
 	}
-}
+// brcm begin
+	if (!localLog && !remoteLog)
+	    return 1;
+	else
+	    return 0;
+// brcm end
+}
+#ifdef AEI_VDSL_CUSTOMER_NCS
+#define TZ2SYSLOG
+#ifdef TZ2SYSLOG
+char *weekday_abbr[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
+#endif
+#endif
 
 /* len parameter is used only for "is there a timestamp?" check.
  * NB: some callers cheat and supply len==0 when they know
  * that there is no timestamp, short-circuiting the test. */
-static void timestamp_and_log(int pri, char *msg, int len)
+static void timestamp_and_log(int pri, const char *msg, int len)
 {
 	char *timestamp;
 	time_t now;
 
+#ifdef AEI_VDSL_CUSTOMER_NCS
+#ifdef TZ2SYSLOG
+	FILE *fp = NULL;
+	char timezone[128]="(GMT)";
+	char *ptemp;
+    char year[5],wday[2];
+    struct timespec tv;
+    if (clock_gettime(CLOCK_REALTIME, &tv) == 0)
+    {
+        struct tm tt;
+        localtime_r(&tv.tv_sec, &tt);
+        strftime(year, 4, "%Y", &tt);
+        year[4] = '\0';
+        strftime(wday, 1, "%w", &tt); /*range 0~6, Sunday:0 */
+        wday[1] = '\0';
+    }
+    else {
+        year[0] = '\0';
+        wday[0] = '\0';
+    }
+#endif
+#endif
+
 	/* Jan 18 00:11:22 msg... */
 	/* 01234567890123456 */
 	if (len < 16 || msg[3] != ' ' || msg[6] != ' '
@@ -434,19 +498,50 @@
 		msg += 16;
 	}
 	timestamp[15] = '\0';
+#ifdef AEI_VDSL_CUSTOMER_NCS
+#ifdef TZ2SYSLOG
+    {
+       char *tmz = NULL;
+
+	   fp = fopen("/var/timezone", "r");
+	   if(fp != NULL) {
+		   fgets(timezone, sizeof(timezone), fp);
+		   fclose(fp);
+	   }
+	   if ((ptemp = strchr(timezone, ')')) != NULL)
+	   *(ptemp+1) = '\0';
+       tmz = strndup(timezone, ptemp-timezone+1);
+       if (wday[0] >= '0' && wday[0] < '7'){
+           sprintf(timezone, "%s %s", weekday_abbr[wday[0]-'0'], tmz);
+       } /*the format is: June 16 00:00:00 Mon (GMT-xx:xx)2008*/
+       sprintf(timezone+strlen(timezone), "%s", year);
+       free(tmz);
+       tmz = NULL;
+    }
+#endif
+#endif
 
 	if (option_mask32 & OPT_small)
 		sprintf(G.printbuf, "%s %s\n", timestamp, msg);
 	else {
 		char res[20];
-		parse_fac_prio_20(pri, res);
-		sprintf(G.printbuf, "%s %.64s %s %s\n", timestamp, G.hostname, res, msg);
+		int length; // brcm
+		if( parse_fac_prio_20(pri, res) )
+		    return;
+#if defined(AEI_VDSL_CUSTOMER_NCS) && defined(TZ2SYSLOG)
+        length = (strlen(timezone)+strlen(timestamp)+strlen(G.hostname)+strlen(res)+strlen(msg)+9+1);
+        sprintf(G.printbuf, "%s %s %.64s %s %s %3i\n", timestamp, timezone, G.hostname, res, msg, length); // brcm
+#else
+		length = (strlen(timestamp)+strlen(G.hostname)+strlen(res)+strlen(msg)+9);
+		sprintf(G.printbuf, "%s %.64s %s %s %3i\n", timestamp, G.hostname, res, msg, length); // brcm
+#endif
 	}
 
 	/* Log message locally (to file or shared mem) */
 	log_locally(now, G.printbuf);
 }
 
+#ifdef SYSLOGD_MARK
 static void timestamp_and_log_internal(const char *msg)
 {
 	/* -L, or no -R */
@@ -454,6 +549,7 @@
 		return;
 	timestamp_and_log(LOG_SYSLOG | LOG_INFO, (char*)msg, 0);
 }
+#endif
 
 /* tmpbuf[len] is a NUL byte (set by caller), but there can be other,
  * embedded NULs. Split messages on each of these NULs, parse prio,
@@ -462,6 +558,7 @@
 {
 	char *p = tmpbuf;
 
+
 	tmpbuf += len;
 	while (p < tmpbuf) {
 		char c;
@@ -517,8 +614,8 @@
 
 	/* Unlink old /dev/log or object it points to. */
 	/* (if it exists, bind will fail) */
-	strcpy(sunx.sun_path, "/dev/log");
-	dev_log_name = xmalloc_follow_symlinks("/dev/log");
+	strcpy(sunx.sun_path, BRCM_PATH_LOG); // brcm
+	dev_log_name = xmalloc_follow_symlinks(BRCM_PATH_LOG); // brcm
 	if (dev_log_name) {
 		safe_strncpy(sunx.sun_path, dev_log_name, sizeof(sunx.sun_path));
 		free(dev_log_name);
@@ -527,7 +624,7 @@
 
 	sock_fd = xsocket(AF_UNIX, SOCK_DGRAM, 0);
 	xbind(sock_fd, (struct sockaddr *) &sunx, sizeof(sunx));
-	chmod("/dev/log", 0666);
+	chmod(BRCM_PATH_LOG, 0666); // brcm
 
 	return sock_fd;
 }
@@ -570,6 +667,12 @@
 	signal_no_SA_RESTART_empty_mask(SIGINT, record_signo);
 	//signal_no_SA_RESTART_empty_mask(SIGQUIT, record_signo);
 	signal(SIGHUP, SIG_IGN);
+// brcm begin
+#ifdef BRCM_CMS_BUILD
+	/* In CMS, daemons should ignore SIGINT */
+	signal(SIGINT, SIG_IGN);
+#endif
+// brcm end
 #ifdef SYSLOGD_MARK
 	signal(SIGALRM, do_mark);
 	alarm(G.markInterval);
@@ -580,7 +683,8 @@
 		ipcsyslog_init();
 	}
 
-	timestamp_and_log_internal("syslogd started: BusyBox v" BB_VER);
+	// timestamp_and_log_internal("syslogd started: BusyBox v" BB_VER);
+	timestamp_and_log(LOG_SYSLOG | LOG_EMERG, "BCM CPE started: BusyBox v" BB_VER, 0);
 
 	while (!bb_got_signal) {
 		ssize_t sz;
@@ -596,7 +700,7 @@
 		sz = read(sock_fd, recvbuf, MAX_READ - 1);
 		if (sz < 0) {
 			if (!bb_got_signal)
-				bb_perror_msg("read from /dev/log");
+				bb_perror_msg("read from %s", BRCM_PATH_LOG); // brcm
 			break;
 		}
 
@@ -643,13 +747,14 @@
 				&(rh->remoteAddr->u.sa), rh->remoteAddr->len);
 		}
 #endif
-		if (!ENABLE_FEATURE_REMOTE_LOG || (option_mask32 & OPT_locallog)) {
+		if (/*!ENABLE_FEATURE_REMOTE_LOG ||*/ (option_mask32 & OPT_locallog)) {
 			recvbuf[sz] = '\0'; /* ensure it *is* NUL terminated */
 			split_escape_and_log(recvbuf, sz);
 		}
 	} /* while (!bb_got_signal) */
 
-	timestamp_and_log_internal("syslogd exiting");
+	// timestamp_and_log_internal("syslogd exiting"); // brcm
+	timestamp_and_log(LOG_SYSLOG | LOG_EMERG, "syslogd exiting", 0);
 	puts("syslogd exiting");
 	if (ENABLE_FEATURE_IPC_SYSLOG)
 		ipcsyslog_cleanup();
@@ -666,12 +771,22 @@
 	llist_t *remoteAddrList = NULL;
 #endif
 
+#ifdef BRCM_CMS_BUILD
+    cmsLog_init(EID_SYSLOGD);
+    cmsLog_setLevel(DEFAULT_LOG_LEVEL);
+#endif
+
 	INIT_G();
 
 	/* No non-option params, -R can occur multiple times */
 	opt_complementary = "=0" IF_FEATURE_REMOTE_LOG(":R::");
 	opts = getopt32(argv, OPTION_STR, OPTION_PARAM);
 #if ENABLE_FEATURE_REMOTE_LOG
+	if (opts & OPT_remoteloglevel){ // -r  // brcm
+		G.remotelogLevel = xatou_range(opt_r, 0, 7);
+		if (G.remotelogLevel < LOG_EMERG)
+		     G.remotelogLevel = LOG_ERR;
+	}
 	while (remoteAddrList) {
 		remoteHost_t *rh = xzalloc(sizeof(*rh));
 		rh->remoteHostname = llist_pop(&remoteAddrList);
@@ -687,8 +802,11 @@
 #endif
 	//if (opts & OPT_nofork) // -n
 	//if (opts & OPT_outfile) // -O
-	if (opts & OPT_loglevel) // -l
-		G.logLevel = xatou_range(opt_l, 1, 8);
+	if (opts & OPT_loglevel) { // -l
+		G.logLevel = xatou_range(opt_l, 0, 7); // brcm
+		if (G.logLevel < LOG_EMERG)
+		    G.logLevel = LOG_DEBUG;
+	}
 	//if (opts & OPT_small) // -S
 #if ENABLE_FEATURE_ROTATE_LOGFILE
 	if (opts & OPT_filesize) // -s
@@ -712,6 +830,20 @@
 	if (!(opts & OPT_nofork)) {
 		bb_daemonize_or_rexec(DAEMON_CHDIR_ROOT, argv);
 	}
+
+#ifdef BRCM_CMS_BUILD
+    if (setsid() == -1)
+    {
+       cmsLog_error("Could not detach from terminal");
+    }
+    else
+    {
+       cmsLog_debug("detached from terminal");
+    }
+    /* set signal masks */
+    signal(SIGPIPE, SIG_IGN); /* Ignore SIGPIPE signals */
+#endif
+
 	//umask(0); - why??
 	write_pidfile("/var/run/syslogd.pid");
 	do_syslogd();
diff -Naur busybox/util-linux/mount.c busybox-brcm/util-linux/mount.c
--- busybox/util-linux/mount.c	2010-08-22 21:44:36.000000000 -0300
+++ busybox-brcm/util-linux/mount.c	2018-11-24 13:44:16.477863179 -0400
@@ -387,6 +387,7 @@
 	char *fs, *buf;
 	llist_t *list = NULL;
 	int i;
+	int read_proc =0;
 	FILE *f;
 
 	for (i = 0; i < 2; i++) {
@@ -397,13 +398,23 @@
 			if (strncmp(buf, "nodev", 5) == 0 && isspace(buf[5]))
 				continue;
 			fs = skip_whitespace(buf);
-			if (*fs == '#' || *fs == '*' || !*fs)
+
+			if (*fs == '#' || !*fs)
+				continue;
+
+			if (*fs == '*')
+			{
+				read_proc =1;
 				continue;
+			}
 
 			llist_add_to_end(&list, xstrdup(fs));
 			free(buf);
 		}
 		if (ENABLE_FEATURE_CLEAN_UP) fclose(f);
+
+		if(!read_proc)
+	 		break;
 	}
 
 	return list;
