diff -Naur ftpd/commands.c ftpd-brcm/commands.c
--- ftpd/commands.c	2003-05-09 18:47:48.000000000 -0300
+++ ftpd-brcm/commands.c	2018-11-23 22:28:25.136777740 -0400
@@ -50,6 +50,7 @@
 #include "main.h"
 #include "targzip.h"
 #include "cwd.h"
+#include <syslog.h>
 
 #ifdef HAVE_ZLIB_H
 # include <zlib.h>
@@ -71,7 +72,27 @@
 int epsvall = 0;
 int xfer_bufsize;
 
-void control_printf(char success, char *format, ...)
+//brcm begin
+#include "cms_util.h"
+static char *imagePtr = NULL;
+static UINT32 uploadSize = 0;
+static CmsImageFormat imageFormat = CMS_IMAGE_FORMAT_INVALID;
+extern void *msgHandle;
+
+/* defined in main.c */
+extern char connIfName[CMS_IFNAME_LENGTH];
+
+typedef enum
+{
+    UPLOAD_OK,
+    UPLOAD_FAIL_NO_MEM,
+    UPLOAD_FAIL_ILLEGAL_IMAGE,
+    UPLOAD_FAIL_FLASH,
+    UPLOAD_FAIL_FTP,
+} UPLOAD_RESULT;
+//brcm end
+
+void control_printf(char success __attribute__((unused)), char *format, ...)
 {
     char buffer[256];
     va_list val;
@@ -80,9 +101,10 @@
     va_end(val);
     fprintf(stderr, "%s\r\n", buffer);
     replace(buffer, "\r", "");
-    bftpd_statuslog(3, success, "%s", buffer);
+    // brcm bftpd_statuslog(3, success, "%s", buffer);
 }
 
+#ifdef SUPPORT_FTPD_STORAGE
 void new_umask()
 {
     int um;
@@ -93,6 +115,7 @@
         um = strtoul(foo, NULL, 8);
     umask(um);
 }
+#endif
 
 void prepare_sock(int sock)
 {
@@ -119,14 +142,14 @@
 {
 	struct sockaddr foo;
 	struct sockaddr_in local;
-	int namelen = sizeof(foo);
-    int curuid = geteuid();
+	size_t namelen = sizeof(foo);
+    // brcm int curuid = geteuid();
 
 	memset(&foo, 0, sizeof(foo));
 	memset(&local, 0, sizeof(local));
 
 	if (pasv) {
-		sock = accept(pasvsock, (struct sockaddr *) &foo, (int *) &namelen);
+		sock = accept(pasvsock, (struct sockaddr *) &foo, &namelen);
 		if (sock == -1) {
             control_printf(SL_FAILURE, "425-Unable to accept data connection.\r\n425 %s.",
                      strerror(errno));
@@ -139,17 +162,21 @@
         prepare_sock(sock);
 		local.sin_addr.s_addr = name.sin_addr.s_addr;
 		local.sin_family = AF_INET;
+#if 0 //brcm
         if (!strcasecmp(config_getoption("DATAPORT20"), "yes")) {
             seteuid(0);
             local.sin_port = htons(20);
         }
+#endif //brcm
 		if (bind(sock, (struct sockaddr *) &local, sizeof(local)) < 0) {
 			control_printf(SL_FAILURE, "425-Unable to bind data socket.\r\n425 %s.",
 					strerror(errno));
 			return 1;
 		}
+#if 0 //brcm
         if (!strcasecmp(config_getoption("DATAPORT20"), "yes"))
             seteuid(curuid);
+#endif //brcm
 		sa.sin_family = AF_INET;
 		if (connect(sock, (struct sockaddr *) &sa, sizeof(sa)) == -1) {
 			control_printf(SL_FAILURE, "425-Unable to establish data connection.\r\n"
@@ -179,21 +206,27 @@
 
 void command_user(char *username)
 {
-	char *alias;
+
+//printf("In command_user username=%s\n", username); // brcm
+
+	// brcm char *alias;
 	if (state) {
 		control_printf(SL_FAILURE, "503 Username already given.");
 		return;
 	}
 	mystrncpy(user, username, sizeof(user) - 1);
     userinfo_set = 1; /* Dirty! */
-	alias = (char *) config_getoption("ALIAS");
+#if 0 // brcm 	
+    alias = (char *) config_getoption("ALIAS");
     userinfo_set = 0;
 	if (alias[0] != '\0')
 		mystrncpy(user, alias, sizeof(user) - 1);
+#endif //brcm
     init_userinfo();
 #ifdef DEBUG
-	bftpd_log("Trying to log in as %s.\n", user);
+//	bftpd_log("Trying to log in as %s.\n", user);
 #endif
+#if 0 //brcm
     expand_groups();
 	if (!strcasecmp(config_getoption("ANONYMOUS_USER"), "yes"))
 		bftpd_login("");
@@ -201,39 +234,51 @@
 		state = STATE_USER;
 		control_printf(SL_SUCCESS, "331 Password please.");
 	}
+#endif //brcm
+    state = STATE_USER; //brcm
+	control_printf(SL_SUCCESS, "331 Password please."); //brcm
+
+//printf("Done command_user username=%s\n", username); // brcm
 }
 
 void command_pass(char *password)
 {
+//printf("In command_pass password=%s\n", password); // brcm
 	if (state > STATE_USER) {
 		control_printf(SL_FAILURE, "503 Already logged in.");
 		return;
 	}
 	if (bftpd_login(password)) {
-		bftpd_log("Login as user '%s' failed.\n", user);
+//brcm		bftpd_log("Login as user '%s' failed.\n", user);
 		control_printf(SL_FAILURE, "421 Login incorrect.");
+      syslog(LOG_WARNING,"104051 FTP Server Login UserName or Password Error\n");
 		exit(0);
 	}
 }
 
+void command_type(char *params)
+{
+    if ((*params == 'I') || (*params == 'i')) {
+      	control_printf(SL_SUCCESS, "200 Transfer type changed to BINARY");
+        xfertype = TYPE_BINARY;
+    } else {
+#ifdef SUPPORT_FTPD_STORAGE
+        control_printf(SL_SUCCESS, "200 Transfer type changed to ASCII");
+        xfertype = TYPE_ASCII;
+#else
+        control_printf(SL_FAILURE, "500 Type '%c' not supported. Only support BINARY mode", *params);
+#endif
+    }
+}
+
+#ifdef SUPPORT_FTPD_STORAGE
 void command_pwd(char *params)
 {
 	control_printf(SL_SUCCESS, "257 \"%s\" is the current working directory.",
 	               bftpd_cwd_getcwd());
 
 }
-
-void command_type(char *params)
-{
-    if ((*params == 'A') || (*params == 'a')) {
-        control_printf(SL_SUCCESS, "200 Transfer type changed to ASCII");
-        xfertype = TYPE_ASCII;
-    } else if ((*params == 'I') || (*params == 'i')) {
-      	control_printf(SL_SUCCESS, "200 Transfer type changed to BINARY");
-        xfertype = TYPE_BINARY;
-    } else
-        control_printf(SL_FAILURE, "500 Type '%c' not supported.", *params);
-}
+#endif
 
 void command_port(char *params) {
   unsigned long a0, a1, a2, a3, p0, p1, addr;
@@ -243,10 +288,12 @@
   }
   sscanf(params, "%lu,%lu,%lu,%lu,%lu,%lu", &a0, &a1, &a2, &a3, &p0, &p1);
   addr = htonl((a0 << 24) + (a1 << 16) + (a2 << 8) + a3);
+#if 0 //brcm
   if((addr != remotename.sin_addr.s_addr) &&( strncasecmp(config_getoption("ALLOW_FXP"), "yes", 3))) {
       control_printf(SL_FAILURE, "500 The given address is not yours.");
       return;
   }
+#endif //brcm
   sa.sin_addr.s_addr = addr;
   sa.sin_port = htons((p0 << 8) + p1);
   if (pasv) {
@@ -257,46 +304,14 @@
            a0, a1, a2, a3, (p0 << 8) + p1);
 }
 
-void command_eprt(char *params) {
-    char delim;
-    int af;
-    char addr[51];
-    char foo[20];
-    int port;
-    if (epsvall) {
-        control_printf(SL_FAILURE, "500 EPSV ALL has been called.");
-        return;
-    }
-    if (strlen(params) < 5) {
-        control_printf(SL_FAILURE, "500 Syntax error.");
-        return;
-    }
-    delim = params[0];
-    sprintf(foo, "%c%%i%c%%50[^%c]%c%%i%c", delim, delim, delim, delim, delim);
-    if (sscanf(params, foo, &af, addr, &port) < 3) {
-        control_printf(SL_FAILURE, "500 Syntax error.");
-        return;
-    }
-    if (af != 1) {
-        control_printf(SL_FAILURE, "522 Protocol unsupported, use (1)");
-        return;
-    }
-    sa.sin_addr.s_addr = inet_addr(addr);
-    if ((sa.sin_addr.s_addr != remotename.sin_addr.s_addr) && (strncasecmp(config_getoption("ALLOW_FXP"), "yes", 3))) {
-        control_printf(SL_FAILURE, "500 The given address is not yours.");
-        return;
-    }
-    sa.sin_port = htons(port);
-    if (pasv) {
-        close(sock);
-        pasv = 0;
-    }
-    control_printf(SL_FAILURE, "200 EPRT %s:%i OK", addr, port);
-}
+
+
+#ifdef SUPPORT_FTPD_STORAGE
 
 void command_pasv(char *foo)
 {
-	int namelen, a1, a2, a3, a4;
+	int a1, a2, a3, a4;
+   socklen_t namelen;
 	struct sockaddr_in localsock;
     if (epsvall) {
         control_printf(SL_FAILURE, "500 EPSV ALL has been called.");
@@ -323,7 +338,7 @@
             if (bind(pasvsock, (struct sockaddr *) &sa, sizeof(sa)) == 0) {
                 success = 1;
 #ifdef DEBUG
-                bftpd_log("Passive mode: Successfully bound port %d\n", port);
+//                bftpd_log("Passive mode: Successfully bound port %d\n", port);
 #endif
                 break;
             }
@@ -334,6 +349,7 @@
         }
         prepare_sock(pasvsock);
     }       
+
 	if (listen(pasvsock, 1)) {
 		control_printf(SL_FAILURE, "425-Error: Unable to make socket listen.\r\n425 %s",
 				 strerror(errno));
@@ -348,6 +364,48 @@
 	pasv = 1;
 }
 
+#endif /* SUPPORT_FTPD_STORAGE */
+
+
+#if 0
+void command_eprt(char *params) {
+    char delim;
+    int af;
+    char addr[51];
+    char foo[20];
+    int port;
+    if (epsvall) {
+        control_printf(SL_FAILURE, "500 EPSV ALL has been called.");
+        return;
+    }
+    if (strlen(params) < 5) {
+        control_printf(SL_FAILURE, "500 Syntax error.");
+        return;
+    }
+    delim = params[0];
+    sprintf(foo, "%c%%i%c%%50[^%c]%c%%i%c", delim, delim, delim, delim, delim);
+    if (sscanf(params, foo, &af, addr, &port) < 3) {
+        control_printf(SL_FAILURE, "500 Syntax error.");
+        return;
+    }
+    if (af != 1) {
+        control_printf(SL_FAILURE, "522 Protocol unsupported, use (1)");
+        return;
+    }
+    sa.sin_addr.s_addr = inet_addr(addr);
+    if ((sa.sin_addr.s_addr != remotename.sin_addr.s_addr) && (strncasecmp(config_getoption("ALLOW_FXP"), "yes", 3))) {
+        control_printf(SL_FAILURE, "500 The given address is not yours.");
+        return;
+    }
+    sa.sin_port = htons(port);
+    if (pasv) {
+        close(sock);
+        pasv = 0;
+    }
+    control_printf(SL_FAILURE, "200 EPRT %s:%i OK", addr, port);
+}
+
+
 void command_epsv(char *params)
 {
     struct sockaddr_in localsock;
@@ -389,6 +447,14 @@
     pasv = 1;
 }
 
+void command_allo(char *foo)
+{
+    command_noop(foo);
+}
+#endif // brcm commands not used
+
+
+#ifdef SUPPORT_FTPD_STORAGE
 char test_abort(char selectbefore, int file, int sock)
 {
     char str[256];
@@ -408,46 +474,80 @@
     	close(file);
 		close(sock);
    		control_printf(SL_SUCCESS, "226 Aborted.");
-		bftpd_log("Client aborted file transmission.\n");
+         //		bftpd_log("Client aborted file transmission.\n");
+      printf("Client aborted file transmission. \n");
         alarm(control_timeout);
         return 1;
 	}
     return 0;
 }
+#endif
 
-void command_allo(char *foo)
+
+void displayMessage(UPLOAD_RESULT result)
 {
-    command_noop(foo);
+
+    switch (result)
+    {
+        case UPLOAD_OK:
+ 	        control_printf(SL_SUCCESS, "226 Ftp image done. PLEASE TYPE 'bye' or 'quit' NOW to quit ftp and the Router will start writing the image to flash.");
+            break;
+        case UPLOAD_FAIL_NO_MEM:
+            control_printf(SL_FAILURE, "226 Not enough memory error.");        
+            break;
+        case UPLOAD_FAIL_ILLEGAL_IMAGE:
+            control_printf(SL_FAILURE, "226 Image updating failed. The selected file contains an illegal image.  PLEASE TYPE 'bye' or 'quit' NOW to quit ftp");
+            break;
+        case UPLOAD_FAIL_FLASH:
+        case UPLOAD_FAIL_FTP:
+            control_printf(SL_FAILURE, "226 ftp connection failed.");
+            break;
+    }
 }
 
-void do_stor(char *filename, int flags)
-{
-	char *buffer;
-	int fd, i, max;
+
+#ifndef SUPPORT_FTPD_STORAGE
+
+/*
+ * We only do image updates when FTPD storage feature is not defined.
+ */
+
+void do_fwUpdate(void)
+{
+    int byteRd = 0;
+    char *curPtr = NULL;
+    unsigned int totalAllocatedSize = 0;
+    char *buffer;
+    int max;
     fd_set rfds;
     struct timeval tv;
-    char *p, *pp;
-	char *mapped = bftpd_cwd_mappath(filename);
-	fd = open(mapped, flags, 00666);
-	if (mapped)
-		free(mapped);
-	if (fd == -1) {
-		bftpd_log("Error: '%s' while trying to store file '%s'.\n",
-				  strerror(errno), filename);
-		control_printf(SL_FAILURE, "553 Error: %s.", strerror(errno));
-		return;
-	}
-	bftpd_log("Client is storing file '%s'.\n", filename);
+    UBOOL8 isConfigFile;
+    
+    /* To use the old logic - allocate memory with flash size    
+    * replace  CMS_IMAGE_MAX_ALLOC_LEN with 0, ie. 
+    * int bcmImageGussstimated = 0;
+    */
+    int bcmImageGussstimated = CMS_IMAGE_MAX_ALLOC_LEN;
+
+   /* reset all of our globals before starting another download */    
+    imageFormat = CMS_IMAGE_FORMAT_INVALID;
+    if (imagePtr)
+       free(imagePtr);
+    imagePtr = NULL;
+    uploadSize = 0;
+
 	if (dataconn())
-		return;
+	    return;
     alarm(0);
-    buffer = malloc(xfer_bufsize);
-	lseek(fd, offset, SEEK_SET);
-	offset = 0;
-    /* Do not use the whole buffer, because a null byte has to be
-     * written after the string in ASCII mode. */
+
+    if ((buffer = malloc(xfer_bufsize)) == NULL)
+    {
+        displayMessage(UPLOAD_FAIL_NO_MEM);
+        return;
+    }
+
     max = (sock > fileno(stdin) ? sock : fileno(stdin)) + 1;
-	for (;;) {
+    for (;;) {
         FD_ZERO(&rfds);
         FD_SET(sock, &rfds);
         FD_SET(fileno(stdin), &rfds);
@@ -456,53 +556,339 @@
         tv.tv_usec = 0;
         if (!select(max, &rfds, NULL, NULL, &tv)) {
             close(sock);
-            close(fd);
             control_printf(SL_FAILURE, "426 Kicked due to data transmission timeout.");
-            bftpd_log("Kicked due to data transmission timeout.\n");
-            exit(0);
-        }
-        if (FD_ISSET(fileno(stdin), &rfds)) {
-            test_abort(0, fd, sock);
-			if (buffer)
-				free(buffer);
-            return;
+            if (imagePtr)
+                free(imagePtr);
+            free(buffer);
+            displayMessage(UPLOAD_FAIL_FTP);
+            return;     // exit ?
         }
-		if (!((i = recv(sock, buffer, xfer_bufsize - 1, 0))))
+
+		  if (!((byteRd = recv(sock, buffer, xfer_bufsize, 0))))
             break;
-        bytes_recvd += i;
-        if (xfertype == TYPE_ASCII) {
-            buffer[i] = '\0';
-            p = pp = buffer;
-    		while (*p) {
-        		if ((unsigned char) *p == 13)
-        			p++;
-        		else
-        			*pp++ = *p++;
+
+        if (curPtr == NULL)
+        {
+            // Also look in tftpd.c, which does about the same thing
+
+            isConfigFile = cmsImg_isConfigFileLikely(buffer);
+            cmsLog_debug("isConfigFile = %d", isConfigFile);
+            
+            if (isConfigFile)
+            {
+               totalAllocatedSize = cmsImg_getConfigFlashSize();
+            }
+            else
+            {
+               UINT32 bcmImageSize = 0;
+               if (cmsImg_isBcmTaggedImage(buffer, &bcmImageSize))
+               {
+                  /* If it is a bcmTagged image, use the image length info from the bcmTag 
+                  * and also make bcmImageGussstimated 0 since bcmTagged image will not use that
+                  */
+                  totalAllocatedSize =  bcmImageSize;
+                  bcmImageGussstimated = 0;
+               }
+               else
+               {
+                  /* Not bcmTagged image.  Need to check if bcmImageGussstimated is initialized (> 0) or not */
+                  if (bcmImageGussstimated > 0)
+                  {
+                     /* If bcmImageGstmated size > 0, Use guestimated image size */
+                     totalAllocatedSize = bcmImageGussstimated;
+                  }
+                  else
+                  {
+                     /* original logic if bcmImageGussstimated == 0, allocate memory with flash size plus bcm image tag */
+                     totalAllocatedSize = cmsImg_getImageFlashSize() + cmsImg_getBroadcomImageTagSize();
+                  }     
+               }
+               
+               // let smd know that we are about to start a big download
+               cmsImg_sendLoadStartingMsg(msgHandle, connIfName);
+            }
+
+            cmsLog_debug("Try to allocate %d bytes", totalAllocatedSize);
+            if ((curPtr = (char *) malloc(totalAllocatedSize)) == NULL)
+            {
+               if (bcmImageGussstimated > 0)
+               {
+                  /* If bcmImageGussstimated is initialized, try that (with totalAllocatedSize = bcmImageGussstimated)
+                  * and if still failing,  try reducing 64K from totalAlocatedSize and try again as long as
+                  * totalAllocatedSize > CMS_IMAGE_REQUIRED_LEN.
+                  */
+                  while  (((curPtr = (char *) malloc(totalAllocatedSize)) == NULL) && 
+                     (totalAllocatedSize > CMS_IMAGE_REQUIRED_LEN))
+                  {
+                     totalAllocatedSize -= 64 * 1024 ;
+                     cmsLog_debug("Try allocating %d kb", totalAllocatedSize/1024);
+                  }
+               }
+
+               /* Failed to allocate memory and will quite ftp operation */
+               if (curPtr == NULL)
+               {
+                  cmsLog_error("Not enough memory (%d bytes needed)", totalAllocatedSize);
+                  free(buffer);
+                  cmsImg_sendLoadDoneMsg(msgHandle);
+                  displayMessage(UPLOAD_FAIL_NO_MEM);   
+                  close(sock);   // this tells the ftp client that the transfer is complete
+                  return;
+               }                  
             }
-        	*pp++ = 0;
-            i = strlen(buffer);
+            printf("%d bytes allocated for image\n", totalAllocatedSize);
+            imagePtr = curPtr;   
         }
-        write(fd, buffer, i);
-	}
-	free(buffer);
+
+        if (uploadSize + byteRd <= totalAllocatedSize)
+        {
+            memcpy(curPtr, buffer, byteRd);     
+            curPtr += byteRd;
+            uploadSize += byteRd;
+        }
+        else
+        {
+            printf("Image could not fit into %d byte buffer.\n", totalAllocatedSize);
+            free(buffer);
+            free(imagePtr);
+            imagePtr = NULL;
+            cmsImg_sendLoadDoneMsg(msgHandle);
+            displayMessage(UPLOAD_FAIL_NO_MEM);
+            close(sock);   // this tells the ftp client that the transfer is complete
+            return;
+        }
+        
+	}  // end for loop to read in complete image
+
+
+   free(buffer);
+
+   
+   /*
+    * Now we have the entire image.  Validate it.
+    */
+   if ((imageFormat = cmsImg_validateImage(imagePtr, uploadSize, msgHandle)) == CMS_IMAGE_FORMAT_INVALID)
+   {
+      displayMessage(UPLOAD_FAIL_ILLEGAL_IMAGE);
+      free(imagePtr);
+      imagePtr = NULL;
+      cmsImg_sendLoadDoneMsg(msgHandle);
+   }
+   else
+   {
+      printf("Image validated, size=%u format=%d, waiting for quit before flashing.\n", uploadSize, imageFormat);
+      displayMessage(UPLOAD_OK);  // flash image will be done when user types bye or OK
+      /* Do not close socket right away so that ftp client can exist gracefully */
+      sleep(2);
+   }
+
+   close(sock);   // this tells the ftp client that the transfer is complete
+   alarm(control_timeout);
+
+}
+
+
+
+void command_fwupdate(char *param  __attribute__((unused)))
+{
+    do_fwUpdate();
+}
+
+#endif /* not SUPPORT_FTPD_STORAGE */
+
+
+void command_syst(char *params __attribute__((unused)))
+{
+	control_printf(SL_SUCCESS, "215 UNIX Type: L8");
+}
+
+void command_quit(char *params __attribute__((unused)))
+{
+   CmsRet ret;
+   
+   if (imagePtr == NULL)
+   {
+      /*
+       * Either no image download was attempted, or download failed, or
+       * got a bad image.
+       */
+       
+      control_printf(SL_SUCCESS, "221 %s", "See you later...");
+      exit(0);
+   }
+
+        
+   /*
+    * This is when the user has successfully download an image,
+    * and now the user quits the control connection, so we go and
+    * write the image.
+    */
+   control_printf(SL_SUCCESS, "221 %s", "The Router is rebooting...");
+   printf("Flashing image now....\n");
+   ret = cmsImg_writeValidatedImage(imagePtr, uploadSize, imageFormat, msgHandle);
+   if (ret != CMSRET_SUCCESS)
+   {
+      /* uh, oh, something still went wrong.  Tell the user */
+      control_printf(SL_FAILURE, "Image updating failed.");
+      cmsImg_sendLoadDoneMsg(msgHandle);
+      exit(1);
+   }
+   else
+   {
+      /* on the modem, a successful flash of the image or the 
+       * config file will result in reboot.  On desktop linux, we
+       * simulate this effect by exiting.
+       */
+       /*note: in order to fix some  bugs of gui, the function  that trigger a reboot in  "cmsImg_writeValidatedImage"  was disabled now,
+          so we send messages to smd to reboot the modem . */
+          #if  defined(SUPPORT_GPL_UNDEFINED)
+          cmsUtil_sendRequestRebootMsg(msgHandle);
+           #endif
+      exit(0);
+    }
+}
+
+
+
+#ifdef SUPPORT_FTPD_STORAGE
+
+void do_stor(char* filename, int flags)
+{
+    int fd, i, max;
+    char *buffer;
+    fd_set rfds;
+    char *mapped = bftpd_cwd_mappath(filename);
+    int xfer_delay;
+    struct timeval tv;
+    char *p, *pp;
+
+    // See if we should delay between data transfers
+    xfer_delay = strtoul( config_getoption("XFER_DELAY"), NULL, 0);
+
+    // Check the file exists and over-writable
+    fd = open(mapped, O_RDONLY);
+    if (fd >= 0) 	// file exists
+    {
+	// close file
 	close(fd);
+	// check over-writable
+	if ( !strcasecmp( config_getoption("ALLOWCOMMAND_DELE"), "no") )
+	{
+	    control_printf(SL_FAILURE, "553 Error: Remote file is write protected.");
+	    if (mapped)
+		free(mapped);
+	    close(sock);
+	    return;
+	}
+    }
+    fd = open(mapped, flags, 00666);
+    if (mapped)
+	free(mapped);
+    if(fd == -1) 
+    {
+	control_printf(SL_FAILURE, "553 Error: %s.", strerror(errno));
+	return;
+    }
+    printf("Client is storing file '%s'.\n", filename);
+    if (dataconn())
+	return;
+
+    alarm(0);
+    buffer = malloc(xfer_bufsize);
+    // check out of memory
+    if ( ! buffer)
+    {
+	printf("Unable to create buffer to receive file.\n");
+	control_printf(SL_FAILURE, "553 Error: An unknown error occured on the server.");
+	if (fd >= 0)
+	    close(fd);
 	close(sock);
+	return;
+    }
+
+    lseek(fd, offset, SEEK_SET);
+    offset = 0;
+    // Do not use the whole buffer, because a null byte is needed in ASCII mode
+    max = (sock > fileno(stdin) ? sock : fileno(stdin)) + 1;
+    for (;;)
+    {
+	FD_ZERO(&rfds);
+	FD_SET(sock, &rfds);
+	FD_SET(fileno(stdin), &rfds);
+	
+	tv.tv_sec = data_timeout;
+	tv.tv_usec = 0;
+	if ( !select(max, &rfds, NULL, NULL, &tv))
+	{
+	    close(sock);
+	    close(fd);
+	    control_printf(SL_FAILURE, "426 Kicked dut to data transmission timeout.");
+	    printf("Kicked due to data transmission timeout.\n");
+	    exit(0);
+	}
+	if (FD_ISSET(fileno(stdin), &rfds))
+	{
+	    test_abort(0, fd, sock);
+	    if (buffer)
+		free(buffer);
+	    return;
+	}
+	if (!(i = recv(sock, buffer, xfer_bufsize-1, 0)))
+	    break;
+	bytes_recvd += i;
+	if (xfertype == TYPE_ASCII)
+	{
+	    buffer[i] = '\0';
+	    // on ASCII transfer, strip character 13
+	    p = pp = buffer;
+	    while(*p) {
+		if ( (unsigned char) *p == 13)
+		    p++;
+		else
+		    *pp++ = *p++;
+	    }
+	    *pp++ = 0;
+	    i = strlen(buffer);
+	}	// end of ASCII type transfer
+	
+	// write data into fd
+	write(fd, buffer, i);
+
+	if ( xfer_delay )
+	{
+	    struct timeval wait_time;
+	    wait_time.tv_sec = 0;
+	    wait_time.tv_usec = xfer_delay; 
+	    select( 0, NULL, NULL, NULL, &wait_time);
+	}
+    }	// end of for
+    free(buffer);
+    close(fd);
+    close(sock);
     alarm(control_timeout);
     offset = 0;
-	control_printf(SL_SUCCESS, "226 File transmission successful.");
-	bftpd_log("File transmission successful.\n");
+    control_printf(SL_SUCCESS, "226 File transmission successful.");
+    printf("File transmission successful.\n");
 }
 
+
 void command_stor(char *filename)
 {
     do_stor(filename, O_CREAT | O_WRONLY | O_TRUNC);
 }
 
+#endif  /* SUPPORT_FTPD_STORAGE */
+
+// brcm command not used
+#if 0
 void command_appe(char *filename)
 {
-    do_stor(filename, O_CREAT | O_WRONLY | O_APPEND);
+    // brcm do_stor(filename, O_CREAT | O_WRONLY | O_APPEND);
 }
+#endif
 
+
+#ifdef SUPPORT_FTPD_STORAGE
 void command_retr(char *filename)
 {
 	char *mapped;
@@ -550,8 +936,9 @@
 			}
 #endif
 		if (whattodo == DO_NORMAL) {
-			bftpd_log("Error: '%s' while trying to receive file '%s'.\n",
-					  strerror(errno), filename);
+			//bftpd_log("Error: '%s' while trying to receive file '%s'.\n",
+			//		  strerror(errno), filename);
+			printf("Error: '%s' while trying to receive file '%s'.\n", strerror(errno), filename);
 			control_printf(SL_FAILURE, "553 Error: %s.", strerror(errno));
 			if (mapped)
 				free(mapped);
@@ -565,18 +952,22 @@
 			free(mapped);
 		return;
 	}
+   /*
 	if ((((statbuf.st_size - offset) * ratio_send) / ratio_recv > bytes_recvd
 		 - bytes_sent) && (strcmp((char *) config_getoption("RATIO"), "none"))) {
-		bftpd_log("Error: 'File too big (ratio)' while trying to receive file "
-				  "'%s'.\n", filename);
+		// bftpd_log("Error: 'File too big (ratio)' while trying to receive file "
+		//		  "'%s'.\n", filename);
+		//cbj
+		printf("Error: 'File too big (ratio)' while trying to receive file %s.\n", filename);
 		control_printf(SL_FAILURE, "553 File too big. Send at least %i bytes first.",
 				(int) (((statbuf.st_size - offset) * ratio_send) / ratio_recv)
 				- bytes_recvd);
 		if (mapped)
 			free(mapped);
 		return;
-	}
-	bftpd_log("Client is receiving file '%s'.\n", filename);
+      } */
+	// bftpd_log("Client is receiving file '%s'.\n", filename);
+	printf("Client is receiving file '%s'.\n", filename);
 	switch (whattodo) {
 #if (defined(WANT_TAR) && defined(WANT_GZIP))
         case DO_TARGZ:
@@ -669,6 +1060,7 @@
 #ifdef HAVE_SYS_SENDFILE_H
             sendfile_offset = offset;
             if (xfertype != TYPE_ASCII) {
+#if 0
                 alarm_type = phile;
                 while (sendfile(sock, phile, &sendfile_offset, xfer_bufsize)) {
                     alarm(data_timeout);
@@ -677,6 +1069,30 @@
                 }
                 alarm(control_timeout);
                 alarm_type = 0;
+#endif
+
+			lseek(phile, offset, SEEK_SET);
+			offset = 0;
+			buffer = malloc(xfer_bufsize * 2 + 1);
+			while ((i = read(phile, buffer, xfer_bufsize))) {
+				if (test_abort(1, phile, sock)) {
+					free(buffer);
+					return;
+				}
+
+#ifndef HAVE_SYS_SENDFILE_H
+                if (xfertype == TYPE_ASCII) {
+#endif
+                    buffer[i] = '\0';
+                    i += replace(buffer, "\n", "\r\n");
+#ifndef HAVE_SYS_SENDFILE_H
+                }
+#endif
+				send(sock, buffer, i, 0);
+				bytes_sent += i;
+			}
+            free(buffer);
+
             } else {
 #endif
 			lseek(phile, offset, SEEK_SET);
@@ -709,7 +1125,8 @@
     offset = 0;
     alarm(control_timeout);
 	control_printf(SL_SUCCESS, "226 File transmission successful.");
-	bftpd_log("File transmission successful.\n");
+   //	bftpd_log("File transmission successful.\n");
+	printf("File transmission successful.\n");
 }
 
 void do_dirlist(char *dirname, char verbose)
@@ -750,6 +1167,10 @@
 	do_dirlist(dirname, 0);
 }
 
+#endif /* SUPPORT_FTPD_STORAGE */
+
+// brcm not used commands
+#if 0
 void command_syst(char *params)
 {
 	control_printf(SL_SUCCESS, "215 UNIX Type: L8");
@@ -772,22 +1193,26 @@
 	}
 	free(fullfilename);
 }
+#endif
+
+
+#ifdef SUPPORT_FTPD_STORAGE
 
 void command_cwd(char *dir)
 {
     if (bftpd_cwd_chdir(dir)) {
-		bftpd_log("Error: '%s' while changing directory to '%s'.\n",
-				  strerror(errno), dir);
+       // bftpd_log("Error: '%s' while changing directory to '%s'.\n",
+       //				  strerror(errno), dir);
 		control_printf(SL_FAILURE, "451 Error: %s.", strerror(errno));
 	} else {
-		bftpd_log("Changed directory to '%s'.\n", dir);
+       //bftpd_log("Changed directory to '%s'.\n", dir);
 		control_printf(SL_SUCCESS, "250 OK");
 	}
 }
 
 void command_cdup(char *params)
 {
-	bftpd_log("Changed directory to '..'.\n");
+   //	bftpd_log("Changed directory to '..'.\n");
 	bftpd_cwd_chdir("..");
 	control_printf(SL_SUCCESS, "250 OK");
 }
@@ -796,25 +1221,31 @@
 {
 	char *mapped = bftpd_cwd_mappath(filename);
 	if (unlink(mapped)) {
-		bftpd_log("Error: '%s' while trying to delete file '%s'.\n",
-				  strerror(errno), filename);
+		//bftpd_log("Error: '%s' while trying to delete file '%s'.\n",
+		//		  strerror(errno), filename);
 		control_printf(SL_FAILURE, "451 Error: %s.", strerror(errno));
 	} else {
-		bftpd_log("Deleted file '%s'.\n", filename);
+		//bftpd_log("Deleted file '%s'.\n", filename);
 		control_printf(SL_SUCCESS, "200 OK");
 	}
 	free(mapped);
 }
 
+void command_noop(char *params)
+{
+        control_printf(SL_SUCCESS, "200 OK");
+}
+
+
 void command_mkd(char *dirname)
 {
 	char *mapped = bftpd_cwd_mappath(dirname);
 	if (mkdir(mapped, 0755)) {
-		bftpd_log("Error: '%s' while trying to create directory '%s'.\n",
-				  strerror(errno), dirname);
+      //bftpd_log("Error: '%s' while trying to create directory '%s'.\n",
+		//		  strerror(errno), dirname);
 		control_printf(SL_FAILURE, "451 Error: %s.", strerror(errno));
 	} else {
-		bftpd_log("Created directory '%s'.\n", dirname);
+		//bftpd_log("Created directory '%s'.\n", dirname);
 		control_printf(SL_SUCCESS, "257 \"%s\" has been created.", dirname);
 	}
 	free(mapped);
@@ -824,20 +1255,21 @@
 {
 	char *mapped = bftpd_cwd_mappath(dirname);
 	if (rmdir(mapped)) {
-		bftpd_log("Error: '%s' while trying to remove directory '%s'.\n",
-				  strerror(errno), dirname);
+		//bftpd_log("Error: '%s' while trying to remove directory '%s'.\n",
+		//		  strerror(errno), dirname);
 		control_printf(SL_FAILURE, "451 Error: %s.", strerror(errno));
 	} else {
-		bftpd_log("Removed directory '%s'.\n", dirname);
+		//bftpd_log("Removed directory '%s'.\n", dirname);
 		control_printf(SL_SUCCESS, "250 OK");
 	}
 	free(mapped);
 }
 
-void command_noop(char *params)
-{
-	control_printf(SL_SUCCESS, "200 OK");
-}
+#endif /* SUPPORT_FTPD_STORAGE */
+
+
+// brcm not needed
+#if 0
 
 void command_rnfr(char *oldname)
 {
@@ -993,8 +1425,10 @@
     control_printf(SL_FAILURE, "550 Not implemented yet\r\n");
 }
 
-/* Command parsing */
+#endif //brcm command not used
 
+/* Command parsing */
+#if 0 //brcm orig commands - can be put back if needed
 const struct command commands[] = {
 	{"USER", "<sp> username", command_user, STATE_CONNECTED, 0},
 	{"PASS", "<sp> password", command_pass, STATE_USER, 0},
@@ -1036,7 +1470,51 @@
 */    {"ADMIN_LOGIN", "(admin)", command_adminlogin, STATE_CONNECTED, 0},
 	{NULL, NULL, NULL, 0, 0}
 };
+#endif //brcm
 
+
+#ifdef SUPPORT_FTPD_STORAGE
+/*
+ * Commands used when we are in ftpd storage mode.
+ * I don't know why our Taiwan intern "cbj" removed the
+ * syntax part of the command.  Just porting his code over.  --mwang
+ */
+const struct command commands[] = {
+	{"USER",/* "<sp> username",*/ command_user, STATE_CONNECTED, 0},
+	{"PASS",/* "<sp> password",*/ command_pass, STATE_USER, 0},
+	{"PORT",/* "<sp> h1,h2,h3,h4,p1,p2",*/ command_port, STATE_AUTHENTICATED, 0},
+	{"RETR",/* "<sp> pathname",*/ command_retr, STATE_AUTHENTICATED, 0},
+	{"MKD",/* "<sp> pathname",*/ command_mkd, STATE_AUTHENTICATED, 0},
+	{"RMD",/* "<sp> pathname",*/ command_rmd, STATE_AUTHENTICATED, 0},
+	{"PWD",/* "(return cwd)",*/ command_pwd, STATE_AUTHENTICATED, 0},
+	{"CWD",/* "<sp> pathname",*/ command_cwd, STATE_AUTHENTICATED, 0},
+	{"CDUP",/* "(up one directory)",*/ command_cdup, STATE_AUTHENTICATED, 0},
+	{"DELE",/* "<sp> pathname",*/ command_dele, STATE_AUTHENTICATED, 0},
+	{"LIST",/* "[<sp> pathname]",*/ command_list, STATE_AUTHENTICATED, 0},
+	{"NLST",/* "[<sp> pathname]",*/ command_nlst, STATE_AUTHENTICATED, 0},
+	{"NOOP",/* "(no operation)",*/ command_noop, STATE_AUTHENTICATED, 0},
+	{"PASV",/* "(returns address/port)",*/ command_pasv, STATE_AUTHENTICATED, 0},
+	{"TYPE",/* "<sp> type-code (A or I)",*/ command_type, STATE_AUTHENTICATED, 0},
+	{"SYST",/* "(returns system type)",*/ command_syst, STATE_CONNECTED, 0},
+	{"STOR",/* "<sp> pathname",*/ command_stor, STATE_AUTHENTICATED, 0},
+	{"QUIT",/* "(close control connection)",*/ command_quit, STATE_CONNECTED, 0},
+	{NULL, NULL, 0, 0}
+};
+#else
+// brcm - commands in use for firmware update only
+const struct command commands[] = {
+	{"USER", "<sp> username", command_user, STATE_CONNECTED, 0},
+	{"PASS", "<sp> password", command_pass, STATE_USER, 0},
+	{"PORT", "<sp> h1,h2,h3,h4,p1,p2", command_port, STATE_AUTHENTICATED, 0},
+	{"TYPE", "<sp> type-code (A or I)", command_type, STATE_AUTHENTICATED, 0},
+	{"SYST", "(returns system type)", command_syst, STATE_CONNECTED, 0},
+	{"STOR", "<sp> pathname", command_fwupdate, STATE_AUTHENTICATED, 0},
+	{"QUIT", "(close control connection)", command_quit, STATE_CONNECTED, 0},
+	{NULL, NULL, NULL, 0, 0}
+};
+#endif /* SUPPORT_FTPD_STORAGE */
+
+#if 0 //brcm
 void command_feat(char *params)
 {
     int i;
@@ -1061,6 +1539,7 @@
 				control_printf(SL_SUCCESS, "214 Syntax: %s", commands[i].syntax);
 	}
 }
+#endif //brcm, not in use
 
 int parsecmd(char *str)
 {
@@ -1074,13 +1553,18 @@
 			*pp++ = *p++;
 	*pp++ = 0;
 	for (i = 0; commands[i].name; i++) {	/* Parse command */
+
+// printf("commands[i].name=%s\n", commands[i].name); // brcm
+
 		if (!strncasecmp(str, commands[i].name, strlen(commands[i].name))) {
             sprintf(confstr, "ALLOWCOMMAND_%s", commands[i].name);
+#if 0 //brcm
             if (!strcasecmp(config_getoption(confstr), "no")) {
                 control_printf(SL_FAILURE, "550 The command '%s' is disabled.",
                         commands[i].name);
                 return 1;
             }
+#endif //brcm
 			cutto(str, strlen(commands[i].name));
 			p = str;
 			while ((*p) && ((*p == ' ') || (*p == '\t')))
diff -Naur ftpd/commands.h ftpd-brcm/commands.h
--- ftpd/commands.h	2003-05-09 18:47:48.000000000 -0300
+++ ftpd-brcm/commands.h	2018-11-23 22:28:25.140777710 -0400
@@ -66,10 +66,13 @@
 void command_help(char *);
 void command_stat(char *);
 void command_feat(char *);
+void command_fwupdate(char *);   //brcm 
 
 struct command {
   char *name;
+#ifndef SUPPORT_FTPD_STORAGE
   char *syntax;
+#endif
   void (*function)(char *);
   char state_needed;
   char showinfeat;
diff -Naur ftpd/config.h ftpd-brcm/config.h
--- ftpd/config.h	1969-12-31 20:00:00.000000000 -0400
+++ ftpd-brcm/config.h	2018-11-23 22:28:25.140777710 -0400
@@ -0,0 +1,87 @@
+/* config.h.  Generated automatically by configure.  */
+/* config.h.in.  Generated automatically from configure.in by autoheader 2.13.  */
+/* Define if we want to use PAM. */
+#undef WANT_PAM // brcm
+
+/* Define if we want to use GZIP. **/
+#undef WANT_GZIP // brcm
+
+/* Define if we want to use TAR. */
+#undef WANT_TAR // brcm
+
+/* Define if we can use getusershell(). */
+#define HAVE_GETUSERSHELL 1
+
+
+/* Define if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* #undef _ALL_SOURCE */
+#endif
+
+/* Define if you have the <arpa/inet.h> header file.  */
+#define HAVE_ARPA_INET_H 1
+
+/* Define if you have the <asm/socket.h> header file.  */
+#define HAVE_ASM_SOCKET_H 1
+
+/* Define if you have the <crypt.h> header file.  */
+#define HAVE_CRYPT_H 1
+
+/* Define if you have the <dirent.h> header file.  */
+#define HAVE_DIRENT_H 1
+
+/* Define if you have the <ndir.h> header file.  */
+/* #undef HAVE_NDIR_H */
+
+/* Define if you have the <netinet/in.h> header file.  */
+#define HAVE_NETINET_IN_H 1
+
+/* Define if you have the <paths.h> header file.  */
+#define HAVE_PATHS_H 1
+
+/* Define if you have the <security/pam_appl.h> header file.  */
+/* #undef HAVE_SECURITY_PAM_APPL_H */
+
+/* Define if you have the <shadow.h> header file.  */
+// BRCM #define HAVE_SHADOW_H 1
+
+/* Define if you have the <sys/dir.h> header file.  */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define if you have the <sys/ndir.h> header file.  */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define if you have the <sys/sendfile.h> header file.  */
+#define HAVE_SYS_SENDFILE_H 1
+
+/* Define if you have the <sys/socket.h> header file.  */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define if you have the <sys/stat.h> header file.  */
+#define HAVE_SYS_STAT_H 1
+
+/* Define if you have the <sys/time.h> header file.  */
+#define HAVE_SYS_TIME_H 1
+
+/* Define if you have the <sys/types.h> header file.  */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define if you have the <sys/wait.h> header file.  */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define if you have the <syslog.h> header file.  */
+#define HAVE_SYSLOG_H 1
+
+/* Define if you have the <time.h> header file.  */
+#define HAVE_TIME_H 1
+
+/* Define if you have the <utmp.h> header file.  */
+//#define HAVE_UTMP_H 1
+
+/* Define if you have the <wait.h> header file.  */
+#define HAVE_WAIT_H 1
+
+/* Define if you have the <zlib.h> header file.  */
+/* #undef HAVE_ZLIB_H */
diff -Naur ftpd/dirlist.c ftpd-brcm/dirlist.c
--- ftpd/dirlist.c	2003-05-09 18:47:48.000000000 -0300
+++ ftpd-brcm/dirlist.c	2018-11-23 22:28:25.140777710 -0400
@@ -40,7 +40,7 @@
 #include <pwd.h>
 #include <grp.h>
 #include <errno.h>
-#include <glob.h>
+//#include <glob.h>
 
 #include "cwd.h"
 #include "options.h"
@@ -48,6 +48,7 @@
 #include "login.h"
 #include "dirlist.h"
 
+#if 0	//cbj
 struct hidegroup *hidegroups = NULL;
 
 void add_to_hidegroups(int gid)
@@ -90,12 +91,13 @@
             hidegroups = tmp;
         }
 }
+#endif	//cbj
 
 void bftpd_stat(char *name, FILE * client)
 {
     struct stat statbuf;
-	char temp[MAXCMD + 3], linktarget[MAXCMD + 5], perm[11], timestr[17],
-		uid[USERLEN + 1], gid[USERLEN + 1];
+	char temp[MAXCMD + 3], linktarget[MAXCMD + 5], perm[11], timestr[17];
+	//char uid[USERLEN + 1], gid[USERLEN + 1];
     struct tm filetime;
     time_t t;
     if (lstat(name, (struct stat *) &statbuf) == -1) { // used for command_stat
@@ -140,10 +142,11 @@
     	mystrncpy(timestr, ctime(&(statbuf.st_mtime)) + 4, 12);
     else
         strftime(timestr, sizeof(timestr), "%b %d  %G", &filetime);
-    mygetpwuid(statbuf.st_uid, passwdfile, uid)[8] = 0;
-    mygetpwuid(statbuf.st_gid, groupfile, gid)[8] = 0;
-	fprintf(client, "%s %3i %-8s %-8s %8lu %s %s%s\r\n", perm,
-			(int) statbuf.st_nlink, uid, gid,
+    //cbj -- without authentication 	
+    //mygetpwuid(statbuf.st_uid, passwdfile, uid)[8] = 0;	
+    //mygetpwuid(statbuf.st_gid, groupfile, gid)[8] = 0;	
+	fprintf(client, "%s %3i %8lu %s %s%s\r\n", perm,
+			(int) statbuf.st_nlink,
 			(unsigned long) statbuf.st_size,
 			timestr, name, linktarget);
 }
@@ -151,6 +154,7 @@
 void dirlist_one_file(char *name, FILE *client, char verbose)
 {
     struct stat statbuf;
+/*  cbj
     struct hidegroup *tmp = hidegroups;
     if (!stat(name, (struct stat *) &statbuf)) {
         if (tmp)
@@ -159,6 +163,7 @@
                     return;
             } while ((tmp = tmp->next));
     }
+*/
     if (verbose)
         bftpd_stat(name, client);
     else
@@ -167,24 +172,35 @@
 
 void dirlist(char *name, FILE * client, char verbose)
 {
-	DIR *directory;
-    char *cwd = NULL;
-    int i;
-	glob_t globbuf;
-    if ((strstr(name, "/.")) && strchr(name, '*'))
-        return; /* DoS protection */
-	if ((directory = opendir(name))) {
-		closedir(directory);
-        cwd = bftpd_cwd_getcwd();
-        chdir(name);
-        glob("*", 0, NULL, &globbuf);
-	} else
-    	glob(name, 0, NULL, &globbuf);
-	for (i = 0; i < globbuf.gl_pathc; i++)
-        dirlist_one_file(globbuf.gl_pathv[i], client, verbose);
-	globfree(&globbuf);
-	if (cwd) {
-		chdir(cwd);
-		free(cwd);
-	}
+   DIR *directory;
+   struct dirent *entry;
+   char dirbuffer[20];
+   
+   getcwd(dirbuffer,20);   
+   directory = opendir(dirbuffer);
+   
+   if (directory == NULL)
+   {
+      return;
+   } 
+   else 
+   {
+      while ((entry = readdir(directory)) != NULL)
+      {
+         if (entry->d_name[0] == '.')
+         {
+            if ((entry->d_name[1] == 0) || ( entry->d_name[1] == '.')
+               && (entry->d_name[2] == 0))
+            {
+               continue;
+            }
+         }
+         
+         dirlist_one_file(entry->d_name, client, verbose);
+      }
+   }
+   closedir(directory);
 }
+
+
+
diff -Naur ftpd/dirlist.h ftpd-brcm/dirlist.h
--- ftpd/dirlist.h	2003-05-09 18:47:48.000000000 -0300
+++ ftpd-brcm/dirlist.h	2018-11-23 22:28:25.140777710 -0400
@@ -6,9 +6,9 @@
     struct hidegroup *next;
 };
 
-void hidegroups_init();
-void hidegroups_end();
-void bftpd_stat(char *name, FILE *client);
+//void hidegroups_init();
+//void hidegroups_end();
+//void bftpd_stat(char *name, FILE *client);
 void dirlist(char *name, FILE *client, char verbose);
 
 #endif
diff -Naur ftpd/INSTALL ftpd-brcm/INSTALL
--- ftpd/INSTALL	2003-05-09 18:47:50.000000000 -0300
+++ ftpd-brcm/INSTALL	1969-12-31 20:00:00.000000000 -0400
@@ -1,405 +0,0 @@
-  bftpd documentation
-  written by Max-Wilhelm Bruker <brukie@gmx.net>
-
-
-  This document is the documentation for the bftpd FTP server.
-  ______________________________________________________________________
-
-  Table of Contents
-
-
-  1. Introduction
-  2. Installation
-     2.1 Compiling
-     2.2 Running the server
-
-  3. Configuration
-     3.1 User management
-     3.2 The configuration file
-        3.2.1 The global structure
-        3.2.2 User structures
-        3.2.3 Group structures
-        3.2.4 Directory structures
-
-  4. FAQ
-     4.1 Problems while compiling
-        4.1.1 I can't compile bftpd
-        4.1.2 There are strange warnings
-        4.1.3 Make tells me I can't use wtmp
-     4.2 Problems when trying to run it
-        4.2.1 I get a warning like "Could not get peer IP address."
-        4.2.2 I get an error like "Bind failed: Address already in use."
-     4.3 Problems during the FTP sessions
-        4.3.1 I get an error like "500 Unknown command: 'foo'"
-        4.3.2 The session terminates with a 421 error
-     4.4 Miscellaneous
-        4.4.1 How does the on-the-fly compression work?
-        4.4.2 My options for an anonymous user don't work
-        4.4.3 Why is there so little documentation?
-
-  5. Credits
-     5.1 Portability testing
-     5.2 Suggestions, bug reports & code contributions
-     5.3 Documentation contributions
-     5.4 Others
-
-
-  ______________________________________________________________________
-
-  [1m1.  Introduction[0m
-
-  bftpd is an FTP server for Linux, BSD/OS, FreeBSD, Solaris, DG-UX and
-  Tru64. (I don't know if it runs on other systems, please mail me if
-  you have tried it). It runs either with inetd or standalone.
-
-  It tries to be very configurable while being fast and small. You can
-  make defaults for each configuration option, and then override these
-  defaults in user-specific and directory-specific structures.
-
-  Features of bftpd include:
-
-  +o  Easy configuration
-
-  +o  Speed
-
-  +o  Support for most RFC FTP commands
-
-  +o  tar.gz on-the-fly compression/archiving
-
-  +o  Security with chroot without special setup
-
-  +o  No need for files (sh, ls...) in a chroot environment
-
-  +o  Logging to wtmp and to a logfile or syslog
-
-  +o  PAM and passwd/shadow support
-
-  +o  Support for SITE CHOWN/CHMOD
-
-  [1m2.  Installation[0m
-
-  [1m2.1.  Compiling[0m
-
-  First execute the following commands (replacing x.x.x by the version
-  number you are installing):
-
-
-       tar xzf bftpd-x.x.x.tar.gz
-       cd bftpd-x.x.x
-       ./configure
-       make
-       make install
-
-
-
-  Note that you have to copy bftpd.conf from the source directory to
-  /etc manually if you are upgrading from a previous version, as 'make
-  install' does not overwrite your existing configuration.
-
-  Note: If you want to use the 'tar.gz on-the-fly' feature of bftpd, you
-  must grab the source code of the program "pax" and extract it into a
-  subdirectory of the bftpd source directory. Then, instead of doing
-  "./configure", do "./configure --enable-pax=pax-sourcedir --enable-
-  libz".  You must also have the library libz and its header file,
-  /usr/include/zlib.h.
-
-  [1m2.2.  Running the server[0m
-
-  bftpd runs in either standalone or inetd mode.
-
-     [1mIf you want inetd mode[0m
-        Add the following to your /etc/inetd.conf:
-
-
-          ftp stream tcp nowait root /usr/sbin/bftpd bftpd
-
-
-
-     Give inetd a HUP or reboot your system. Your FTP server should work
-     now.
-
-     [1mIf you want inetd mode with xinetd[0m
-        Add the following to your /etc/xinetd.conf:
-
-
-
-     service ftp
-     {
-         disable = no
-         socket_type             = stream
-         wait                    = no
-         user                    = root
-         server                  = /usr/sbin/bftpd
-         log_on_success          += DURATION USERID
-         log_on_failure          += USERID
-         nice                    = 10
-     }
-
-
-
-     (contributed by JackRipper)
-
-     [1mIf you want standalone mode:[0m
-        Make the OS execute
-
-
-          /usr/sbin/bftpd -d
-
-
-
-     at bootup.
-
-  [1m3.  Configuration[0m
-
-  [1m3.1.  User management[0m
-
-  You can manage the users simply by editing /etc/passwd and, if your
-  system supports it, /etc/shadow. Any user existent in /etc/passwd can
-  connect to the FTP server if he has a usable password and meets
-  certain configurable criteria. Having anonymous users is possible by
-  setting a configuration variable called ANONYMOUS_USER to yes. PAM is
-  also supported.
-
-  [1m3.2.  The configuration file[0m
-
-  [1m3.2.1.  The global structure[0m
-
-  In the "global" structure, you can assign values to configuration
-  options. The syntax is like the following:
-
-
-       global {
-         name1="value1"
-         name2="value2"
-       }
-
-
-
-  [1m3.2.2.  User structures[0m
-
-  There are also user structures, in which you can override the global
-  settings for particular users. Example:
-
-
-
-  global {
-    name1="value1"
-    name2="value2"
-  }
-  user foo {
-    name1="value3"
-  }
-
-
-
-  If the user foo is logged in, name1 will be value3. If another user is
-  logged in, name1 will be value1. name2 is always value2.
-
-  [1m3.2.3.  Group structures[0m
-
-  You can also define options for groups of users. It is just as it
-  would be for one user, but you can put more than one user in a group.
-  You can also put system groups into them by using the @ character.
-  Example:
-
-
-       group foo,bar,@baz {
-         name1="value1"
-       }
-
-
-
-  This options affect the users foo and bar and every user who is in the
-  system group baz. A supplementary membership is sufficient.
-
-  [1m3.2.4.  Directory structures[0m
-
-  You can set options which affects only the users who are in a certain
-  directory, or in any subdirectory of it, recursively. Note that you
-  must put these structures [4minside[24m the global, user and group
-  structures. This way, you can also override directory-specific
-  settings for particular users. Example:
-
-
-       global {
-         name1="value1"
-         directory "/foo" {
-           name1="value2"
-         }
-       }
-       user bar {
-         directory "/foo" {
-           name1="value3"
-         }
-       }
-
-
-
-  In this example, name1 will be value3 if the user bar is in the direc-
-  tory /foo. It will be value2 if another user is in the directory /foo.
-  In any other case, it will be value1.
-
-  An explanation of the name/value pairs is in the example configuration
-  file supplied with bftpd (if you are not upgrading, this file has
-  already been copied to /etc on your system). Modify it so that it fits
-  your needs. The defaults should be OK though.
-
-
-  [1m4.  FAQ[0m
-
-  [1m4.1.  Problems while compiling[0m
-
-  [1m4.1.1.  I can't compile bftpd[0m
-
-  Let me know. Please tell me what architecture and operating system you
-  are using, and give me the output of the complete compilation process
-  (configure and make). I don't get a lot of mail, so I'll try to answer
-  your questions. If I don't reply, I have almost certainly forgotten
-  your mail, so please send it again :)
-
-  [1m4.1.2.  There are strange warnings[0m
-
-  It is likely that compiling bftpd on a platform I haven't tested may
-  give you some warnings. Even if it compiles successfully and runs
-  without crashing, please tell me, as compiler warnings [4mcan[24m cause
-  problems which are not obvious.
-
-  [1m4.1.3.  Make tells me I can't use wtmp[0m
-
-  You are probably running Solaris. As I don't have access to a Solaris
-  computer, I have never been able to test the wtmp functions in it. If
-  you get a warning like this and you don't know what wtmp is, just
-  don't care, else help me to fix the error.
-
-  [1m4.2.  Problems when trying to run it[0m
-
-  [1m4.2.1.  I get a warning like "Could not get peer IP address."[0m
-
-  You have started bftpd on the console. If you want to run it as a
-  standalone server, you have to invoke it with the "-d" option. If you
-  have set it up as an inetd server, you can test it with:
-
-
-       hostname:~$ ftp localhost
-
-
-
-  [1m4.2.2.  I get an error like "Bind failed: Address already in use."[0m
-
-  This error means that another process has bound itself to the port you
-  want to run bftpd on. You can set this port in bftpd.conf with the
-  option PORT in the global structure. It defaults to 21. If you have
-  not changed that, you probably forgot to turn off your old FTP server.
-  Look in /etc/inetd.conf and in "ps auxwww | grep ftp".
-
-  [1m4.3.  Problems during the FTP sessions[0m
-
-  [1m4.3.1.  I get an error like "500 Unknown command: 'foo'"[0m
-
-  Your client has sent a command to the server which it didn't
-  understand. This is my fault, unless you have written a really
-  inexistent command. Please check your command for typographic errors
-  and report the error to me if you are sure that the command was right.
-
-  [1m4.3.2.  The session terminates with a 421 error[0m
-
-  If you try to log in with a wrong password, bftpd will terminate the
-  connection. If you already had logged in before the error appeared, or
-  the error appeared before you could log in, it definitely is a bug.
-  Please tell me everything about it.
-
-
-
-  [1m4.4.  Miscellaneous[0m
-
-  [1m4.4.1.  How does the on-the-fly compression work?[0m
-
-  Let's say you have a directory called foo. Even if there is no file
-  called foo.tar.gz, you can RETR this file over FTP and it will contain
-  the contents of the directory foo, tar-gzipped. You can also RETR the
-  following files:
-
-  +o  dirname.tar
-
-  +o  filename.gz
-
-     If you want to use this, you must compile it in (see the
-     installation section).
-
-  [1m4.4.2.  My options for an anonymous user don't work[0m
-
-  If you have a structure with an ALIAS=... in it, you mustn't put any
-  more options in it. Instead, put them into the structure the alias
-  points to.
-
-  [1m4.4.3.  Why is there so little documentation?[0m
-
-  The answer is simple, nobody has written anything :)
-  I never know what to write, so if you have any idea of how to improve
-  the documentation, please tell me. The same applies to translations of
-  documentation. If you want to contribute something, just do it, but
-  [4mplease[24m care about typographic errors and grammar.
-
-  [1m5.  Credits[0m
-
-  [1m5.1.  Portability testing[0m
-
-
-  +o  David L. Nicol (david@kasey.umkc.edu) tested bftpd on Tru64.
-
-  +o  JackRipper (vic@altoona.net) tested bftpd on BSD/OS and DG-UX.
-
-  +o  Christian Beyerlein (christian@beyerlein.de) tested bftpd on
-     FreeBSD and Solaris.
-
-  +o  The people from #linux (IRCNet) tested bftpd on various operating
-     systems.
-
-  [1m5.2.  Suggestions, bug reports & code contributions[0m
-
-
-  +o  Josh Woodcock (josh@hamparts.com) gave some hints about Solaris 8.
-
-  +o  Floh (floh@maflohsoft.de) suggested the ASCII mode support.
-
-  +o  Erik Hensema (erik@hensema.xs4all.nl) found a Linux 2.4.0 netfilter
-     bug which affected bftpd.
-
-  +o  Heiko Rother (rother@cmsnet.de) suggested a lot of things (see
-     changelog).
-
-  +o  Christophe Bailleux (cb@grolier.fr) loves to find problems in the
-     directory listing routines. He also suggested a lot of things and
-     contributed some code.
-
-  +o  Jonathan Heusser (jonathanheusser@gyml.unibas.ch) found a buffer
-     overflow bug.
-
-
-  +o  Christian Beyerlein (christian@beyerlein.de) suggested to make user
-     aliases.
-
-  +o  Elmusafir (jslmarti@campus.cem.itesm.mx) reported the StarOffice
-     problem fixed in 1.0.8.
-
-  +o  Alex Madden (alexm@immstudios.com) and Daniel Mack
-     (daniel.mack@nextra.de) reported the Solaris imcompatibility fixed
-     in 1.0.8.
-
-  +o  Daniel Mack (daniel.mack@nextra.de) contributed a big patch (see
-     changelog).
-
-  [1m5.3.  Documentation contributions[0m
-
-
-  +o  Radek Michalski (radek@end.p-s.com.pl) translates the bftpd docs
-     into Polish and also contributes new text.
-
-  [1m5.4.  Others[0m
-
-
-  +o  Some ideas about code structure and portability where taken from
-     betaftpd bei Steinar H. Gunderson. But these were only a few lines!
-
-
-
diff -Naur ftpd/list.c ftpd-brcm/list.c
--- ftpd/list.c	2003-05-09 18:47:48.000000000 -0300
+++ ftpd-brcm/list.c	2018-11-23 22:28:25.144777681 -0400
@@ -1,3 +1,5 @@
+#if 0 //inetd
+
 #include <stdio.h>
 #include <stdlib.h>
 
@@ -53,6 +55,8 @@
 {
 	struct bftpd_list_element *tmp = list;
 	int i;
+   if (!tmp)
+      return NULL;
 	for (i = 0; i < index; i++) {
 		if (!(tmp->next))
 			return NULL;
@@ -60,3 +64,4 @@
 	}
 	return tmp->data;
 }
+#endif
diff -Naur ftpd/login.c ftpd-brcm/login.c
--- ftpd/login.c	2003-05-09 18:47:48.000000000 -0300
+++ ftpd-brcm/login.c	2018-11-23 22:28:25.144777681 -0400
@@ -47,6 +47,12 @@
 #include "logging.h"
 #include "bftpdutmp.h"
 #include "main.h"
+#include "syslog.h"
+
+// brcm
+#include "cms_util.h"
+#include "cms_msg.h"
+extern NetworkAccessMode accessMode;
 
 #ifdef WANT_PAM
 char usepam = 0;
@@ -59,7 +65,7 @@
 
 struct passwd userinfo;
 char userinfo_set = 0;
-
+#if 0 //brcm
 char *mygetpwuid(int uid, FILE * file, char *name)
 {
 	int _uid;
@@ -107,6 +113,7 @@
 	}
 	return -1;
 }
+#endif //brcm
 
 #ifdef HAVE_UTMP_H
 void wtmp_init()
@@ -155,7 +162,7 @@
 	}
 }
 #endif
-
+#if 0 //brcm
 void login_init()
 {
     char *foo = config_getoption("INITIAL_CHROOT");
@@ -170,26 +177,44 @@
         }
     }
 }
-
+#endif //brcm
 int bftpd_setuid(uid_t uid)
 {
+#if 0 //brcm
     /* If we must open the data connections from port 20,
      * we have to keep the possibility to regain root privileges */
     if (!strcasecmp(config_getoption("DATAPORT20"), "yes"))
         return seteuid(uid);
     else
+#endif //brcm
         return setuid(uid);
 }
 
+
 int bftpd_login(char *password)
 {
-	char str[256];
+#if 0	// brcm 
+    char str[256];
 	char *foo;
 	int maxusers;
+#endif //brcm
+//printf("In bftpd_login password=%s, user=%s\n", password, user); // brcm
 	if (!getpwnam(user)) {
+        syslog(LOG_WARNING,"104051 FTP Server Login UserName or Password Error\n");
         control_printf(SL_FAILURE, "421 Login incorrect.");
-		exit(0);
+		return 1;
     }
+    // brcm add local/remote login check
+    if ((accessMode == NETWORK_ACCESS_DISABLED) ||
+        (accessMode == NETWORK_ACCESS_LAN_SIDE && (strcmp(user, "user") && strcmp(user, "admin"))) ||
+        (accessMode == NETWORK_ACCESS_WAN_SIDE && strcmp(user, "support")))
+    {
+       syslog(LOG_WARNING,"104051 FTP Server Login UserName or Password Error\n");
+       cmsLog_debug("wrong username, accessMode=%d user=%s", accessMode, user);
+       control_printf(SL_FAILURE, "421 Login incorrect.");
+	    return 1;
+    }
+#if 0 //brcm
 	if (strncasecmp(foo = config_getoption("DENY_LOGIN"), "no", 2)) {
 		if (foo[0] != '\0') {
 			if (strncasecmp(foo, "yes", 3))
@@ -210,12 +235,20 @@
 		control_printf(SL_FAILURE, "421 User %s is already logged in %i times.", user, maxusers);
 		exit(0);
 	}
-	if(checkuser() || checkshell()) {
+#endif //brcm
+
+    if(checkuser() || checkshell()) {
+      syslog(LOG_WARNING,"104051 FTP Server Login UserName or Password Error\n");
+      cmsLog_debug("checkuser or checkshell failed");
 		control_printf(SL_FAILURE, "421 Login incorrect.");
 		exit(0);
 	}
 	if (checkpass(password))
+   {
+      cmsLog_debug("checkpass returned non-zero");
 		return 1;
+   }
+#if 0 //brcm
 	if (strcasecmp((char *) config_getoption("RATIO"), "none")) {
 		sscanf((char *) config_getoption("RATIO"), "%i/%i",
 			   &ratio_send, &ratio_recv);
@@ -229,8 +262,11 @@
 		passwdfile = fopen("/etc/passwd", "r");
 		groupfile = fopen("/etc/group", "r");
 	}
+#endif //brcm
 	setgid(userinfo.pw_gid);
+
 	initgroups(userinfo.pw_name, userinfo.pw_gid);
+#if 0 //brcm
 	if (strcasecmp(config_getoption("DO_CHROOT"), "no")) {
 		if (chroot(str)) {
 			control_printf(SL_FAILURE, "421 Unable to change root directory.\r\n%s.",
@@ -259,16 +295,26 @@
 	}
     new_umask();
 	print_file(230, config_getoption("MOTD_USER"));
-	control_printf(SL_SUCCESS, "230 User logged in.");
+#endif //brcm
+	
+    control_printf(SL_SUCCESS, "230 User logged in.");
+
 #ifdef HAVE_UTMP_H
 	bftpd_logwtmp(1);
 #endif
+#if 0 //brcm
     bftpdutmp_log(1);
 	bftpd_log("Successfully logged in as user '%s'.\n", user);
+
     if (config_getoption("AUTO_CHDIR")[0])
         chdir(config_getoption("AUTO_CHDIR"));
+#endif //brcm        
 	state = STATE_AUTHENTICATED;
+
+#ifdef SUPPORT_FTPD_STORAGE
 	bftpd_cwd_init();
+#endif
+
 	return 0;
 }
 
@@ -276,14 +322,16 @@
 {
     if (!getpwnam(user))
 		return 1;
-	if (!strcasecmp(config_getoption("ANONYMOUS_USER"), "yes"))
+#if 0 //brcm
+    if (!strcasecmp(config_getoption("ANONYMOUS_USER"), "yes"))
 		return 0;
+#endif //brcm
 #ifdef WANT_PAM
 	if (!strcasecmp(config_getoption("AUTH"), "pam"))
 		return checkpass_pam(password);
 	else
 #endif
-		return checkpass_pwd(password);
+	return checkpass_pwd(password);
 }
 
 void login_end()
@@ -302,12 +350,14 @@
 #ifdef HAVE_SHADOW_H
 	struct spwd *shd;
 #endif
-	if (strcmp(userinfo.pw_passwd, (char *) crypt(password, userinfo.pw_passwd))) {
+    if (strncmp(userinfo.pw_passwd, (char *) crypt(password, userinfo.pw_passwd), strlen(userinfo.pw_passwd))) {
 #ifdef HAVE_SHADOW_H
 		if (!(shd = getspnam(user)))
 			return 1;
 		if (strcmp(shd->sp_pwdp, (char *) crypt(password, shd->sp_pwdp)))
 #endif
+         cmsLog_debug("passwd check failed, userinfo.pw_passwd=%s password=%s", userinfo.pw_passwd, password);
+         cmsLog_debug("crypt version %s", crypt(password, userinfo.pw_passwd));
 			return 1;
 	}
 	return 0;
@@ -362,7 +412,7 @@
 
 int checkuser()
 {
-
+#if 0 //brcm 
 	FILE *fd;
 	char *p;
 	char line[256];
@@ -380,6 +430,7 @@
 			}
 		fclose(fd);
 	}
+#endif //brcm 
 	return 0;
 }
 
@@ -388,11 +439,12 @@
 #ifdef HAVE_GETUSERSHELL
 	char *cp;
 	struct passwd *pwd;
-
+#if 0 //brcm
     if (!strcasecmp(config_getoption("AUTH_ETCSHELLS"), "no"))
         return 0;
-    
+#endif //brcm    
 	pwd = getpwnam(user);
+
 	while ((cp = getusershell()))
 		if (!strcmp(cp, pwd->pw_shell))
 			break;
diff -Naur ftpd/main.c ftpd-brcm/main.c
--- ftpd/main.c	2003-05-09 18:47:48.000000000 -0300
+++ ftpd-brcm/main.c	2018-11-23 22:28:25.144777681 -0400
@@ -15,6 +15,8 @@
 
 #include <config.h>
 #include <stdio.h>
+#include <sys/select.h>
+#include <sys/time.h>
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
@@ -58,23 +60,36 @@
 #include "login.h"
 #include "list.h"
 
-int global_argc;
-char **global_argv;
+//brcm
+#include "cms_util.h"
+#include "cms_msg.h"
+void *msgHandle = NULL;
+
+#define FTPD_TIMEOUT    300
+
+// brcm int global_argc;
+//brcm char **global_argv;
 struct sockaddr_in name;
 int isparent = 1;
-int listensocket, sock;
-FILE *passwdfile = NULL, *groupfile = NULL, *devnull;
+//int sock     = -1;
+int listensocket;
+// brcm FILE *passwdfile = NULL, *groupfile = NULL, *devnull;
 struct sockaddr_in remotename;
 char *remotehostname;
 int control_timeout, data_timeout;
 int alarm_type = 0;
 
-struct bftpd_list_element *child_list;
+//inetd struct bftpd_list_element *child_list;
 
 /* Command line parameters */
-char *configpath = PATH_BFTPD_CONF;
-int daemonmode = 0;
+char *configpath = NULL;    
+int daemonmode = 1;         // brcm was 0;
+NetworkAccessMode accessMode; // needed by login.c for authentication
 
+/* interface name from socket */
+char connIfName[CMS_IFNAME_LENGTH]={0};
+
+#if 0 // brcm bengin
 void print_file(int number, char *filename)
 {
 	FILE *phile;
@@ -88,80 +103,98 @@
 		fclose(phile);
 	}
 }
+#endif // brcm end
 
 void end_child()
 {
-	if (passwdfile)
+#if 0 //brcm	
+   if (passwdfile)
 		fclose(passwdfile);
 	if (groupfile)
 		fclose(groupfile);
+
 	config_end();
 	bftpd_log("Quitting.\n");
-    bftpd_statuslog(1, 0, "quit");
-    bftpdutmp_end();
+   bftpd_statuslog(1, 0, "quit");
+   // brcm bftpdutmp_end();
 	log_end();
 	login_end();
-	bftpd_cwd_end();
-	if (daemonmode) {
-		close(sock);
-		close(0);
+   bftpd_cwd_end();
+
+   if (daemonmode) {
+      close(sock);
+      close(0);
 		close(1);
 		close(2);
 	}
+#endif //brcm
 }
 
+#if 0 //inetd
 void handler_sigchld(int sig)
 {
 	pid_t pid;
 	int i;
 	struct bftpd_childpid *childpid;
+
 	pid = wait(NULL);					/* Get the child's return code so that the zombie dies */
+
 	for (i = 0; i < bftpd_list_count(child_list); i++) {
 		childpid = bftpd_list_get(child_list, i);
 		if (childpid->pid == pid) {
 			close(childpid->sock);
 			bftpd_list_del(&child_list, i);
 			free(childpid);
+         break;
 		}
 	}
 }
+#endif
 
-void handler_sigterm(int signum)
+void handler_sigterm(int signum __attribute__((unused)))
 {
 	exit(0);					/* Force normal termination so that end_child() is called */
 }
 
-void handler_sigalrm(int signum)
+void handler_sigalrm(int signum __attribute__((unused)))
 {
     if (alarm_type) {
         close(alarm_type);
-        bftpd_log("Kicked from the server due to data connection timeout.\n");
+//brcm        bftpd_log("Kicked from the server due to data connection timeout.\n");
         control_printf(SL_FAILURE, "421 Kicked from the server due to data connection timeout.");
         exit(0);
     } else {
-        bftpd_log("Kicked from the server due to control connection timeout.\n");
+//brcm        bftpd_log("Kicked from the server due to control connection timeout.\n");
         control_printf(SL_FAILURE, "421 Kicked from the server due to control connection timeout.");
         exit(0);
     }
 }
-
+#if 0 //brcm
 void init_everything()
 {
+
 	if (!daemonmode) {
 		config_init();
         hidegroups_init();
     }
+
 	log_init();
     bftpdutmp_init();
 	login_init();
 }
+#endif //brcm
 
 int main(int argc, char **argv)
 {
 	char str[MAXCMD + 1];
 	static struct hostent *he;
-	int i = 1, port;
-	int retval;
+	UINT32 i = 1;
+   int retval;
+   int logLevelNum;
+   CmsLogLevel logLevel;
+   CmsRet ret;
+   
+#if 0 // brcm begin
 	while (((retval = getopt(argc, argv, "c:hdDin"))) > -1) {
 		switch (retval) {
 			case 'h':
@@ -181,137 +214,263 @@
 			case 'n': configpath = NULL; break;
 		}
 	}
+#endif //brcm end
+
+   cmsLog_init(EID_FTPD);
+
+   while (((retval = getopt(argc, argv, "v:h"))) > -1) {
+      switch (retval) {
+         case 'h':
+            printf(
+               "Usage: %s [-v verbosity_level]\n"
+               "-h print this help\n"
+               "-v verbosity level (2-max, 1-terse, 0-errors only)\n", argv[0]);
+            return 0;
+         case 'v':
+         logLevelNum = atoi(optarg);
+         if (logLevelNum == 0)
+         {
+            logLevel = LOG_LEVEL_ERR;
+         }
+         else if (logLevelNum == 1)
+         {
+            logLevel = LOG_LEVEL_NOTICE;
+         }
+         else
+         {
+            logLevel = LOG_LEVEL_DEBUG;
+         }
+         /*
+          * By default, CMS logging goes to standard error.  But about 100
+          * lines from here, ftpd will do a dup2 of the socket to the client
+          * to standard error, so all logging will start going to the client.
+          * But the client expects messages in a special ftp format, so
+          * our messages will confuse the client.  Bottom line: if you
+          * use cmsLog_debug/notice/error, it will only work up to the point
+          * ftp does the dup2.  After that, you will need to configure CMS
+          * logging to log to syslog to see it.
+          */
+         cmsLog_setLevel(logLevel);
+         break;
+      }
+   }   
+
+   if ((ret = cmsMsg_init(EID_FTPD, &msgHandle)) != CMSRET_SUCCESS)
+   {
+      cmsLog_error("Could not initialize msgHandle, ret=%d", ret);
+      exit(1);
+   }
+   
+#if 0 //inetd
 	if (daemonmode) {
-		struct sockaddr_in myaddr, new;
+		struct sockaddr_in new;
+		struct sockaddr_in myaddr;
+
 		if (daemonmode == 1) {
-			if (fork())
+         if (fork()) {
 				exit(0);  /* Exit from parent process */
+         }
 			setsid();
-			if (fork())
-				return 0;
-		}
+         int pid = 0;
+         if ((pid = fork()) != 0) {
+            if (!(pid_fp = fopen("/var/run/ftpd_pid", "w"))) {
+               perror("/var/run/ftpd_pid");
+               return 0;
+            }
+            fprintf(pid_fp, "%d\n", pid);
+            fclose(pid_fp);
+			   return 0;
+         }
+      }
+
 		signal(SIGCHLD, handler_sigchld);
-		config_init();
-		chdir("/");
-        hidegroups_init();
+#if 0 //brcm		
+      config_init();
+    	chdir("/");
+      hidegroups_init();
+#endif //brcm
+
 		listensocket = socket(AF_INET, SOCK_STREAM, 0);
 #ifdef SO_REUSEADDR
-		setsockopt(listensocket, SOL_SOCKET, SO_REUSEADDR, (void *) &i,
-				   sizeof(i));
+		setsockopt(listensocket, SOL_SOCKET, SO_REUSEADDR, (void *) &i, sizeof(i));
 #endif
 #ifdef SO_REUSEPORT
-		setsockopt(listensocket, SOL_SOCKET, SO_REUSEPORT, (void *) &i,
-				   sizeof(i));
+		setsockopt(listensocket, SOL_SOCKET, SO_REUSEPORT, (void *) &i, sizeof(i));
 #endif
 		memset((void *) &myaddr, 0, sizeof(myaddr));
-        if (!((port = strtoul(config_getoption("PORT"), NULL, 10))))
-            port = 21;
-		myaddr.sin_port = htons(port);
-		if (!strcasecmp(config_getoption("BIND_TO_ADDR"), "any")
-			|| !config_getoption("BIND_TO_ADDR")[0])
+#if 0 //brcm
+      if (!((port = strtoul(config_getoption("PORT"), NULL, 10)))) 
+         port = 21;
+      if (!strcasecmp(config_getoption("BIND_TO_ADDR"), "any")
+            || !config_getoption("BIND_TO_ADDR")[0])
 			myaddr.sin_addr.s_addr = INADDR_ANY;
 		else
 			myaddr.sin_addr.s_addr = inet_addr(config_getoption("BIND_TO_ADDR"));
-		if (bind(listensocket, (struct sockaddr *) &myaddr, sizeof(myaddr)) < 0) {
-			fprintf(stderr, "Bind failed: %s\n", strerror(errno));
-			exit(1);
-		}
-		if (listen(listensocket, 5)) {
-			fprintf(stderr, "Listen failed: %s\n", strerror(errno));
-			exit(1);
-		}
-		for (i = 0; i < 3; i++) {
-			close(i);		/* Remove fd pointing to the console */
-			open("/dev/null", O_RDWR);	/* Create fd pointing nowhere */
-		}
-		i = sizeof(new);
-		while ((sock = accept(listensocket, (struct sockaddr *) &new, &i))) {
-			pid_t pid;
-			/* If accept() becomes interrupted by SIGCHLD, it will return -1.
-			 * So in order not to create a child process when that happens,
-			 * we have to check if accept() returned an error.
-			 */
-			if (sock > 0) {
-				pid = fork();
-				if (!pid) {
-					close(0);
-					close(1);
-					close(2);
-					isparent = 0;
-					dup2(sock, fileno(stdin));
-					dup2(sock, fileno(stderr));
-					break;
-				} else {
-					struct bftpd_childpid *tmp_pid = malloc(sizeof(struct bftpd_childpid));
-					tmp_pid->pid = pid;
-					tmp_pid->sock = sock;
-					bftpd_list_add(&child_list, tmp_pid);
-				}
-			}
-		}
-	}
-	devnull = fopen("/dev/null", "w");
-	global_argc = argc;
-	global_argv = argv;
-	init_everything();
-	atexit(end_child);
-	signal(SIGTERM, handler_sigterm);
-    signal(SIGALRM, handler_sigalrm);
-    control_timeout = strtoul(config_getoption("CONTROL_TIMEOUT"), NULL, 0);
-    if (!control_timeout)
-        control_timeout = 300;
-    data_timeout = strtoul(config_getoption("DATA_TIMEOUT"), NULL, 0);
-    if (!data_timeout)
-        data_timeout = 300;
-    xfer_bufsize = strtoul(config_getoption("XFER_BUFSIZE"), NULL, 0);
-    if (!xfer_bufsize)
-        xfer_bufsize = 4096;
-
-	i = sizeof(remotename);
-    if (getpeername(fileno(stderr), (struct sockaddr *) &remotename, &i)) {
-		control_printf(SL_FAILURE, "421-Could not get peer IP address.\r\n421 %s.",
+#endif //brcm use default beloww (3 lines)
+      port = 21;
+		myaddr.sin_port = htons(port);
+      myaddr.sin_addr.s_addr = INADDR_ANY;
+
+      if (bind(listensocket, (struct sockaddr *) &myaddr, sizeof(myaddr)) < 0) {
+         fprintf(stderr, "Bind failed: %s\n", strerror(errno));
+         exit(1);
+      }
+      if (listen(listensocket, 5)) {
+         fprintf(stderr, "Listen failed: %s\n", strerror(errno));
+         exit(1);
+      }
+#if 0
+      for (i = 0; i < 3; i++) {
+         close(i);		/* Remove fd pointing to the console */
+         open("/dev/null", O_RDWR);	/* Create fd pointing nowhere */
+      }
+#endif
+   }
+#endif   //inetd
+
+   {
+#if defined(SUPPORT_IPV6) || defined(AEI_CONTROL_LAYER) /* aka SUPPORT_IPV6 */
+      struct sockaddr_in6 new;
+#else
+      struct sockaddr_in new;
+#endif
+      fd_set          readFds;
+      int             selret;
+
+      atexit(end_child);
+      signal(SIGTERM, handler_sigterm);
+      signal(SIGALRM, handler_sigalrm);
+      signal(SIGPIPE, SIG_IGN);
+
+      listensocket = CMS_DYNAMIC_LAUNCH_SERVER_FD;
+      
+    	FD_ZERO(&readFds);
+		FD_SET(listensocket, &readFds);
+
+		/* pend, waiting for one or more fds to become ready */
+		selret = select(listensocket+1, &readFds, NULL, NULL, NULL);
+      if (selret <= 0)
+      {
+         exit(0);
+      }
+      
+      i = sizeof(new);
+      sock = accept(listensocket, (struct sockaddr *) &new, &i);
+      if (sock > 0) {
+         char ipAddr[BUFLEN_128] = {0};
+
+#if defined(SUPPORT_IPV6) || defined(AEI_CONTROL_LAYER) /* aka SUPPORT_IPV6 */
+         char ipAddrBuf[BUFLEN_40];
+
+         inet_ntop(AF_INET6, &new.sin6_addr, ipAddrBuf, sizeof(ipAddrBuf));
+         cmsLog_debug("client ip=%s", ipAddrBuf);
+
+         /* see if this is a IPv4-Mapped IPv6 address (::ffff:xxx.xxx.xxx.xxx) */
+         if (strchr(ipAddrBuf, '.') && strstr(ipAddrBuf, ":ffff:"))
+         {
+            /* IPv4 client */
+            char *v4addr;
+
+            /* convert address to clean ipv4 address */
+            v4addr = strrchr(ipAddrBuf, ':') + 1;
+               
+            strcpy(ipAddr, v4addr);
+         }
+         else
+         {
+            /* IPv6 client */
+            strcpy(ipAddr, ipAddrBuf);
+         }
+#else
+
+         strcpy(ipAddr, inet_ntoa(new.sin_addr));
+
+#endif
+
+         cmsLog_debug("checking accessMode for %s", ipAddr);
+
+         accessMode = cmsNet_isAddressOnLanSide(ipAddr) ? 
+                          NETWORK_ACCESS_LAN_SIDE : NETWORK_ACCESS_WAN_SIDE;
+
+         cmsLog_debug("accessMode=%d", accessMode);
+
+         /* save the connection interface name for later deciding if
+         * it is a WAN or LAN interface in the uploading process
+         */
+         if (cmsImg_saveIfNameFromSocket(sock, connIfName) != CMSRET_SUCCESS)
+         {
+            cmsLog_error("Failed to get remote ifc name!");
+         }         
+
+         isparent = 0;
+         dup2(sock, fileno(stdin));
+         dup2(sock, fileno(stderr));
+      }
+      else
+      {
+         cmsLog_error("accept of connection failed, exit server.");
+         exit(0);
+      }
+   }
+
+
+
+   control_timeout = FTPD_TIMEOUT;
+   data_timeout = FTPD_TIMEOUT;
+
+#ifdef SUPPORT_FTPD_STORAGE
+   xfer_bufsize = 128*1024;
+#else
+   xfer_bufsize = 4*1024;
+#endif
+
+   i = sizeof(remotename);
+   if (getpeername(fileno(stderr), (struct sockaddr *) &remotename, &i)) {
+      control_printf(SL_FAILURE, "421-Could not get peer IP address.\r\n421 %s.",
 		               strerror(errno));
-		return 0;
-	}
+      return 0;
+   }
+
 	i = 1;
-	setsockopt(fileno(stdin), SOL_SOCKET, SO_OOBINLINE, (void *) &i,
-			   sizeof(i));
-	setsockopt(fileno(stdin), SOL_SOCKET, SO_KEEPALIVE, (void *) &i,
-			   sizeof(i));
-	/* If option is set, determine the client FQDN */
-	if (!strcasecmp((char *) config_getoption("RESOLVE_CLIENT_IP"), "yes")) {
-		if ((he = gethostbyaddr((char *) &remotename.sin_addr,
-								sizeof(struct in_addr), AF_INET)))
-			remotehostname = strdup(he->h_name);
-		else
-			remotehostname = strdup(inet_ntoa(remotename.sin_addr));
-	} else
-		remotehostname = strdup(inet_ntoa(remotename.sin_addr));
-	bftpd_log("Incoming connection from %s.\n", remotehostname);
-    bftpd_statuslog(1, 0, "connect %s", remotehostname);
-	i = sizeof(name);
-	getsockname(fileno(stdin), (struct sockaddr *) &name, &i);
-	print_file(220, config_getoption("MOTD_GLOBAL"));
-	/* Parse hello message */
-	strcpy(str, (char *) config_getoption("HELLO_STRING"));
-	replace(str, "%v", VERSION);
-	if (strstr(str, "%h")) {
-		if ((he = gethostbyaddr((char *) &name.sin_addr, sizeof(struct in_addr), AF_INET)))
+   setsockopt(fileno(stdin), SOL_SOCKET, SO_OOBINLINE, (void *) &i, sizeof(i));
+   setsockopt(fileno(stdin), SOL_SOCKET, SO_KEEPALIVE, (void *) &i, sizeof(i));
+
+   remotehostname = strdup(inet_ntoa(remotename.sin_addr));
+
+#if 0 //brcm
+   bftpd_log("Incoming connection from %s.\n", remotehostname);
+   bftpd_statuslog(1, 0, "connect %s", remotehostname);
+#endif //brcm
+   i = sizeof(name);
+   getsockname(fileno(stdin), (struct sockaddr *) &name, &i);
+
+
+//brcm	print_file(220, config_getoption("MOTD_GLOBAL"));
+
+   /* Parse hello message */
+   // brcm strcpy(str, (char *) config_getoption("HELLO_STRING"));
+   strcpy(str, "Ftp firmware update utility");     //brcm
+   //brcm replace(str, "%v", VERSION);
+   if (strstr(str, "%h")) {
+      if ((he = gethostbyaddr((char *) &name.sin_addr, sizeof(struct in_addr), AF_INET)))
 			replace(str, "%h", he->h_name);
 		else
 			replace(str, "%h", (char *) inet_ntoa(name.sin_addr));
-	}
-	replace(str, "%i", (char *) inet_ntoa(name.sin_addr));
-	control_printf(SL_SUCCESS, "220 %s", str);
-	/* Read lines from client and execute appropriate commands */
-	while (fgets(str, sizeof(str), stdin)) {
-        alarm(control_timeout);
-        str[strlen(str) - 2] = 0;
-        bftpd_statuslog(2, 0, "%s", str);
+   }
+
+   replace(str, "%i", (char *) inet_ntoa(name.sin_addr));
+   control_printf(SL_SUCCESS, "220 %s", str);
+
+   /* Read lines from client and execute appropriate commands */
+   while (fgets(str, sizeof(str), stdin)) {
+// printf("after while (fgets(str = %s, stdin\n", str);  // brcm
+      alarm(control_timeout);
+      str[strlen(str) - 2] = 0;
+//brcm        bftpd_statuslog(2, 0, "%s", str);
 #ifdef DEBUG
-		bftpd_log("Processing command: %s\n", str);
+//		bftpd_log("Processing command: %s\n", str);
 #endif
-		parsecmd(str);
-	}
-	return 0;
+      parsecmd(str);
+   }
+   return 0;
 }
diff -Naur ftpd/main.h ftpd-brcm/main.h
--- ftpd/main.h	2003-05-09 18:47:48.000000000 -0300
+++ ftpd-brcm/main.h	2018-11-23 22:28:25.144777681 -0400
@@ -7,19 +7,20 @@
 	pid_t pid;
 	int sock;
 };
-
+#if 0 //brcm
 extern int global_argc;
 extern char **global_argv;
-extern struct sockaddr_in name;
 extern FILE *passwdfile, *groupfile, *devnull;
+#endif //brcm
+extern struct sockaddr_in name;
 extern char *remotehostname;
 extern struct sockaddr_in remotename;
 extern int control_timeout, data_timeout;
 extern int alarm_type;
 
 /* Command line options */
-char *configpath;
-int daemonmode;
+extern char *configpath;
+extern int daemonmode;
 
 void print_file(int number, char *filename);
 
diff -Naur ftpd/Makefile ftpd-brcm/Makefile
--- ftpd/Makefile	1969-12-31 20:00:00.000000000 -0400
+++ ftpd-brcm/Makefile	2018-11-23 22:28:25.136777740 -0400
@@ -0,0 +1,123 @@
+# Makefile file for bftpd
+#
+# License:  GNU General Public License, Version 2.
+#
+EXE = bftpd
+
+
+OBJS=commands.o list.o login.o main.o mystring.o
+
+LIBS= -lcms_msg $(CMS_COMMON_LIBS)
+
+all dynamic: sanity_check $(EXE) generic_exe_install
+
+# Remove symlinks so customers do not import them into their source control systems
+clean: generic_clean
+	rm -f $(INSTALL_DIR)/bin/$(EXE)
+	rm -f INSTALL README
+
+# this removes all non-source controlled files (this list is not complete)
+distclean: clean
+	rm -rf doc CHANGELOG INSTALL install-sh .project .settings \
+	README Makefile.in debian .cdtproject configure configure.in \
+	targzip.h
+
+
+
+#
+# Set our CommEngine directory (by splitting the pwd into two words
+# at /userspace and taking the first word only).
+# Then include the common defines under CommEngine.
+#
+CURR_DIR := $(shell pwd)
+BUILD_DIR:=$(subst /userspace, /userspace,$(CURR_DIR))
+BUILD_DIR:=$(word 1, $(BUILD_DIR))
+
+include $(BUILD_DIR)/make.common
+
+
+
+#
+# GPL apps and libs are only allowed to include header files from the
+# gpl and public directories
+#
+# WARNING: Do not modify this section unless you understand the
+# license implications of what you are doing.
+#
+ALLOWED_INCLUDE_PATHS := -I.\
+                         -I$(BUILD_DIR)/userspace/gpl/include  \
+                         -I$(BUILD_DIR)/userspace/gpl/include/$(OALDIR) \
+                         -I$(BUILD_DIR)/userspace/public/include  \
+                         -I$(BUILD_DIR)/userspace/public/include/$(OALDIR)
+
+
+#
+# GPL apps and libs are only allowed to link with libraries from the
+# gpl and public directories.
+#
+# WARNING: Do not modify this section unless you understand the
+# license implications of what you are doing.
+#
+ALLOWED_LIB_DIRS := /lib:/lib/gpl:/lib/public
+
+
+
+#
+# Some additional tests for different ftp modes
+#
+ifeq ($(strip $(BUILD_FTPD_STORAGE)), y)
+	OBJS += cwd.o options.o dirlist.o
+ 	CFLAGS += -DSUPPORT_FTPD_STORAGE
+endif
+
+#
+# In CMS, we want a standalone ftpd app, so build dynamic
+# makemenuconfig should be changed so that static is not even an option
+#
+ifeq ($(strip $(BUILD_FTPD)), static)
+	CFLAGS += -DBUILD_STATIC
+endif
+
+#
+# Implicit rule will make the .c into a .o
+# Implicit rule is $(CC) -c $(CPPFLAGS) $(CFLAGS)
+# See Section 10.2 of Gnu Make manual
+# 
+$(EXE): CHANGELOG $(OBJS)
+	$(CC) -o $@ $(OBJS) -Wl,-rpath,$(CMS_LIB_RPATH) $(CMS_LIB_PATH) $(LIBS)
+
+
+#
+# If we have not untar'd the source, this file will be missing.
+# Go untar it now.
+#
+CHANGELOG:
+	@echo untaring source files
+	cd ..; (tar xkfj ftpd.tar.bz2 2> /dev/null || true)
+
+
+#
+# Some legacy targets.  Do we even support static mode anymore?
+#
+static: bftpd.a
+
+bftpd.a: $(OBJS)
+	$(CC) $(CFLAGS) -c -o $(OBJS)
+	$(AR) rcs bftpd.a $(OBJS) $(LIBS)
+
+
+
+#
+# Include the rule for making dependency files.
+# The '-' in front of the second include suppresses
+# error messages when make cannot find the .d files.
+# It will just regenerate them.
+# See Section 4.14 of Gnu Make.
+#
+
+include $(BUILD_DIR)/make.deprules
+
+-include $(OBJS:.o=.d)
+
+
+
diff -Naur ftpd/mystring.c ftpd-brcm/mystring.c
--- ftpd/mystring.c	2003-05-09 18:47:48.000000000 -0300
+++ ftpd-brcm/mystring.c	2018-11-23 22:28:25.144777681 -0400
@@ -36,6 +36,9 @@
     return i;
 }
 
+
+#ifdef SUPPORT_FTPD_STORAGE
+
 /* int_from_list(char *list, int n) 
  * returns the n'th integer element from a string like '2,5,12-15,20-23'
  * if n is out of range or *list is out of range, -1 is returned.
@@ -100,3 +103,5 @@
         firstrun = 0;
     }
 }
+
+#endif /* SUPPORT_FTPD_STORAGE */
diff -Naur ftpd/options.c ftpd-brcm/options.c
--- ftpd/options.c	2003-05-09 18:47:48.000000000 -0300
+++ ftpd-brcm/options.c	2018-11-23 22:28:25.144777681 -0400
@@ -4,10 +4,10 @@
 #include <grp.h>
 #include <unistd.h>
 
-#include <options.h>
-#include <mystring.h>
-#include <main.h>
-#include <login.h>
+#include "options.h"
+#include "mystring.h"
+#include "main.h"
+#include "login.h"
 #include <logging.h>
 
 struct global config_global;
diff -Naur ftpd/README ftpd-brcm/README
--- ftpd/README	2003-05-09 18:47:50.000000000 -0300
+++ ftpd-brcm/README	1969-12-31 20:00:00.000000000 -0400
@@ -1,405 +0,0 @@
-  bftpd documentation
-  written by Max-Wilhelm Bruker <brukie@gmx.net>
-
-
-  This document is the documentation for the bftpd FTP server.
-  ______________________________________________________________________
-
-  Table of Contents
-
-
-  1. Introduction
-  2. Installation
-     2.1 Compiling
-     2.2 Running the server
-
-  3. Configuration
-     3.1 User management
-     3.2 The configuration file
-        3.2.1 The global structure
-        3.2.2 User structures
-        3.2.3 Group structures
-        3.2.4 Directory structures
-
-  4. FAQ
-     4.1 Problems while compiling
-        4.1.1 I can't compile bftpd
-        4.1.2 There are strange warnings
-        4.1.3 Make tells me I can't use wtmp
-     4.2 Problems when trying to run it
-        4.2.1 I get a warning like "Could not get peer IP address."
-        4.2.2 I get an error like "Bind failed: Address already in use."
-     4.3 Problems during the FTP sessions
-        4.3.1 I get an error like "500 Unknown command: 'foo'"
-        4.3.2 The session terminates with a 421 error
-     4.4 Miscellaneous
-        4.4.1 How does the on-the-fly compression work?
-        4.4.2 My options for an anonymous user don't work
-        4.4.3 Why is there so little documentation?
-
-  5. Credits
-     5.1 Portability testing
-     5.2 Suggestions, bug reports & code contributions
-     5.3 Documentation contributions
-     5.4 Others
-
-
-  ______________________________________________________________________
-
-  [1m1.  Introduction[0m
-
-  bftpd is an FTP server for Linux, BSD/OS, FreeBSD, Solaris, DG-UX and
-  Tru64. (I don't know if it runs on other systems, please mail me if
-  you have tried it). It runs either with inetd or standalone.
-
-  It tries to be very configurable while being fast and small. You can
-  make defaults for each configuration option, and then override these
-  defaults in user-specific and directory-specific structures.
-
-  Features of bftpd include:
-
-  +o  Easy configuration
-
-  +o  Speed
-
-  +o  Support for most RFC FTP commands
-
-  +o  tar.gz on-the-fly compression/archiving
-
-  +o  Security with chroot without special setup
-
-  +o  No need for files (sh, ls...) in a chroot environment
-
-  +o  Logging to wtmp and to a logfile or syslog
-
-  +o  PAM and passwd/shadow support
-
-  +o  Support for SITE CHOWN/CHMOD
-
-  [1m2.  Installation[0m
-
-  [1m2.1.  Compiling[0m
-
-  First execute the following commands (replacing x.x.x by the version
-  number you are installing):
-
-
-       tar xzf bftpd-x.x.x.tar.gz
-       cd bftpd-x.x.x
-       ./configure
-       make
-       make install
-
-
-
-  Note that you have to copy bftpd.conf from the source directory to
-  /etc manually if you are upgrading from a previous version, as 'make
-  install' does not overwrite your existing configuration.
-
-  Note: If you want to use the 'tar.gz on-the-fly' feature of bftpd, you
-  must grab the source code of the program "pax" and extract it into a
-  subdirectory of the bftpd source directory. Then, instead of doing
-  "./configure", do "./configure --enable-pax=pax-sourcedir --enable-
-  libz".  You must also have the library libz and its header file,
-  /usr/include/zlib.h.
-
-  [1m2.2.  Running the server[0m
-
-  bftpd runs in either standalone or inetd mode.
-
-     [1mIf you want inetd mode[0m
-        Add the following to your /etc/inetd.conf:
-
-
-          ftp stream tcp nowait root /usr/sbin/bftpd bftpd
-
-
-
-     Give inetd a HUP or reboot your system. Your FTP server should work
-     now.
-
-     [1mIf you want inetd mode with xinetd[0m
-        Add the following to your /etc/xinetd.conf:
-
-
-
-     service ftp
-     {
-         disable = no
-         socket_type             = stream
-         wait                    = no
-         user                    = root
-         server                  = /usr/sbin/bftpd
-         log_on_success          += DURATION USERID
-         log_on_failure          += USERID
-         nice                    = 10
-     }
-
-
-
-     (contributed by JackRipper)
-
-     [1mIf you want standalone mode:[0m
-        Make the OS execute
-
-
-          /usr/sbin/bftpd -d
-
-
-
-     at bootup.
-
-  [1m3.  Configuration[0m
-
-  [1m3.1.  User management[0m
-
-  You can manage the users simply by editing /etc/passwd and, if your
-  system supports it, /etc/shadow. Any user existent in /etc/passwd can
-  connect to the FTP server if he has a usable password and meets
-  certain configurable criteria. Having anonymous users is possible by
-  setting a configuration variable called ANONYMOUS_USER to yes. PAM is
-  also supported.
-
-  [1m3.2.  The configuration file[0m
-
-  [1m3.2.1.  The global structure[0m
-
-  In the "global" structure, you can assign values to configuration
-  options. The syntax is like the following:
-
-
-       global {
-         name1="value1"
-         name2="value2"
-       }
-
-
-
-  [1m3.2.2.  User structures[0m
-
-  There are also user structures, in which you can override the global
-  settings for particular users. Example:
-
-
-
-  global {
-    name1="value1"
-    name2="value2"
-  }
-  user foo {
-    name1="value3"
-  }
-
-
-
-  If the user foo is logged in, name1 will be value3. If another user is
-  logged in, name1 will be value1. name2 is always value2.
-
-  [1m3.2.3.  Group structures[0m
-
-  You can also define options for groups of users. It is just as it
-  would be for one user, but you can put more than one user in a group.
-  You can also put system groups into them by using the @ character.
-  Example:
-
-
-       group foo,bar,@baz {
-         name1="value1"
-       }
-
-
-
-  This options affect the users foo and bar and every user who is in the
-  system group baz. A supplementary membership is sufficient.
-
-  [1m3.2.4.  Directory structures[0m
-
-  You can set options which affects only the users who are in a certain
-  directory, or in any subdirectory of it, recursively. Note that you
-  must put these structures [4minside[24m the global, user and group
-  structures. This way, you can also override directory-specific
-  settings for particular users. Example:
-
-
-       global {
-         name1="value1"
-         directory "/foo" {
-           name1="value2"
-         }
-       }
-       user bar {
-         directory "/foo" {
-           name1="value3"
-         }
-       }
-
-
-
-  In this example, name1 will be value3 if the user bar is in the direc-
-  tory /foo. It will be value2 if another user is in the directory /foo.
-  In any other case, it will be value1.
-
-  An explanation of the name/value pairs is in the example configuration
-  file supplied with bftpd (if you are not upgrading, this file has
-  already been copied to /etc on your system). Modify it so that it fits
-  your needs. The defaults should be OK though.
-
-
-  [1m4.  FAQ[0m
-
-  [1m4.1.  Problems while compiling[0m
-
-  [1m4.1.1.  I can't compile bftpd[0m
-
-  Let me know. Please tell me what architecture and operating system you
-  are using, and give me the output of the complete compilation process
-  (configure and make). I don't get a lot of mail, so I'll try to answer
-  your questions. If I don't reply, I have almost certainly forgotten
-  your mail, so please send it again :)
-
-  [1m4.1.2.  There are strange warnings[0m
-
-  It is likely that compiling bftpd on a platform I haven't tested may
-  give you some warnings. Even if it compiles successfully and runs
-  without crashing, please tell me, as compiler warnings [4mcan[24m cause
-  problems which are not obvious.
-
-  [1m4.1.3.  Make tells me I can't use wtmp[0m
-
-  You are probably running Solaris. As I don't have access to a Solaris
-  computer, I have never been able to test the wtmp functions in it. If
-  you get a warning like this and you don't know what wtmp is, just
-  don't care, else help me to fix the error.
-
-  [1m4.2.  Problems when trying to run it[0m
-
-  [1m4.2.1.  I get a warning like "Could not get peer IP address."[0m
-
-  You have started bftpd on the console. If you want to run it as a
-  standalone server, you have to invoke it with the "-d" option. If you
-  have set it up as an inetd server, you can test it with:
-
-
-       hostname:~$ ftp localhost
-
-
-
-  [1m4.2.2.  I get an error like "Bind failed: Address already in use."[0m
-
-  This error means that another process has bound itself to the port you
-  want to run bftpd on. You can set this port in bftpd.conf with the
-  option PORT in the global structure. It defaults to 21. If you have
-  not changed that, you probably forgot to turn off your old FTP server.
-  Look in /etc/inetd.conf and in "ps auxwww | grep ftp".
-
-  [1m4.3.  Problems during the FTP sessions[0m
-
-  [1m4.3.1.  I get an error like "500 Unknown command: 'foo'"[0m
-
-  Your client has sent a command to the server which it didn't
-  understand. This is my fault, unless you have written a really
-  inexistent command. Please check your command for typographic errors
-  and report the error to me if you are sure that the command was right.
-
-  [1m4.3.2.  The session terminates with a 421 error[0m
-
-  If you try to log in with a wrong password, bftpd will terminate the
-  connection. If you already had logged in before the error appeared, or
-  the error appeared before you could log in, it definitely is a bug.
-  Please tell me everything about it.
-
-
-
-  [1m4.4.  Miscellaneous[0m
-
-  [1m4.4.1.  How does the on-the-fly compression work?[0m
-
-  Let's say you have a directory called foo. Even if there is no file
-  called foo.tar.gz, you can RETR this file over FTP and it will contain
-  the contents of the directory foo, tar-gzipped. You can also RETR the
-  following files:
-
-  +o  dirname.tar
-
-  +o  filename.gz
-
-     If you want to use this, you must compile it in (see the
-     installation section).
-
-  [1m4.4.2.  My options for an anonymous user don't work[0m
-
-  If you have a structure with an ALIAS=... in it, you mustn't put any
-  more options in it. Instead, put them into the structure the alias
-  points to.
-
-  [1m4.4.3.  Why is there so little documentation?[0m
-
-  The answer is simple, nobody has written anything :)
-  I never know what to write, so if you have any idea of how to improve
-  the documentation, please tell me. The same applies to translations of
-  documentation. If you want to contribute something, just do it, but
-  [4mplease[24m care about typographic errors and grammar.
-
-  [1m5.  Credits[0m
-
-  [1m5.1.  Portability testing[0m
-
-
-  +o  David L. Nicol (david@kasey.umkc.edu) tested bftpd on Tru64.
-
-  +o  JackRipper (vic@altoona.net) tested bftpd on BSD/OS and DG-UX.
-
-  +o  Christian Beyerlein (christian@beyerlein.de) tested bftpd on
-     FreeBSD and Solaris.
-
-  +o  The people from #linux (IRCNet) tested bftpd on various operating
-     systems.
-
-  [1m5.2.  Suggestions, bug reports & code contributions[0m
-
-
-  +o  Josh Woodcock (josh@hamparts.com) gave some hints about Solaris 8.
-
-  +o  Floh (floh@maflohsoft.de) suggested the ASCII mode support.
-
-  +o  Erik Hensema (erik@hensema.xs4all.nl) found a Linux 2.4.0 netfilter
-     bug which affected bftpd.
-
-  +o  Heiko Rother (rother@cmsnet.de) suggested a lot of things (see
-     changelog).
-
-  +o  Christophe Bailleux (cb@grolier.fr) loves to find problems in the
-     directory listing routines. He also suggested a lot of things and
-     contributed some code.
-
-  +o  Jonathan Heusser (jonathanheusser@gyml.unibas.ch) found a buffer
-     overflow bug.
-
-
-  +o  Christian Beyerlein (christian@beyerlein.de) suggested to make user
-     aliases.
-
-  +o  Elmusafir (jslmarti@campus.cem.itesm.mx) reported the StarOffice
-     problem fixed in 1.0.8.
-
-  +o  Alex Madden (alexm@immstudios.com) and Daniel Mack
-     (daniel.mack@nextra.de) reported the Solaris imcompatibility fixed
-     in 1.0.8.
-
-  +o  Daniel Mack (daniel.mack@nextra.de) contributed a big patch (see
-     changelog).
-
-  [1m5.3.  Documentation contributions[0m
-
-
-  +o  Radek Michalski (radek@end.p-s.com.pl) translates the bftpd docs
-     into Polish and also contributes new text.
-
-  [1m5.4.  Others[0m
-
-
-  +o  Some ideas about code structure and portability where taken from
-     betaftpd bei Steinar H. Gunderson. But these were only a few lines!
-
-
-
diff -Naur ftpd/storage/cwd.c ftpd-brcm/storage/cwd.c
--- ftpd/storage/cwd.c	1969-12-31 20:00:00.000000000 -0400
+++ ftpd-brcm/storage/cwd.c	2018-11-23 22:28:25.144777681 -0400
@@ -0,0 +1,90 @@
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <pwd.h>
+#include <sys/types.h>
+
+#include "commands.h"
+#include "cwd.h"
+#include "logging.h"
+#include "mystring.h"
+
+char *cwd = NULL;
+
+int bftpd_cwd_chdir(char *dir)
+{
+	char *tmp = bftpd_cwd_mappath(dir);
+	if (chdir(tmp)) {
+		free(tmp);
+		return errno;
+	}
+	cwd = realloc(cwd, strlen(tmp) + 1);
+	strcpy(cwd, tmp);
+	new_umask();
+	free(tmp);
+	return 0;
+}
+
+char *bftpd_cwd_getcwd()
+{
+	return strdup(cwd);
+}
+
+void appendpath(char *result, char *tmp)
+{
+	if (!strcmp(tmp, "."))
+		return;
+	if (!strcmp(tmp, "..")) {
+        if (strcmp(result, "/")) {
+            if (result[strlen(result) - 1] == '/')
+                result[strlen(result) - 1] = '\0';
+            tmp = result;
+            while (strchr(tmp, '/'))
+                tmp = strchr(tmp, '/') + 1;
+            *tmp = '\0';
+            if ((result[strlen(result) - 1] == '/') && (strlen(result) > 1))
+                result[strlen(result) - 1] = '\0';
+        }
+	} else {
+		if (result[strlen(result) - 1] != '/')
+			strcat(result, "/");
+		strcat(result, tmp);
+	}
+}
+
+char *bftpd_cwd_mappath(char *path)
+{
+	char *result = malloc(strlen(path) + strlen(cwd) + 10);
+	char *path2 = strdup(path);
+	char *tmp;
+	if (path[0] == '/')
+		strcpy(result, "/");
+	else
+		strcpy(result, cwd);
+	while (strchr(path2, '/')) {
+		tmp = strdup(path2);
+		*strchr(tmp, '/') = '\0';
+		cutto(path2, strlen(tmp) + 1);
+		appendpath(result, tmp);
+		free(tmp);
+	}
+	appendpath(result, path2);
+	free(path2);
+	return result;
+}
+
+void bftpd_cwd_init()
+{
+	cwd = malloc(256);
+	getcwd(cwd, 255);
+}
+
+void bftpd_cwd_end()
+{
+	if (cwd) {
+		free(cwd);
+		cwd = NULL;
+	}
+}
diff -Naur ftpd/storage/cwd.h ftpd-brcm/storage/cwd.h
--- ftpd/storage/cwd.h	1969-12-31 20:00:00.000000000 -0400
+++ ftpd-brcm/storage/cwd.h	2018-11-23 22:28:25.144777681 -0400
@@ -0,0 +1,17 @@
+#ifndef __BFTPD_CWD_H
+#define __BFTPD_CWD_H
+
+// Changes the current working directory following symlinks
+int bftpd_cwd_chdir(char *dir);
+
+// Returns the current working directory
+char *bftpd_cwd_getcwd();
+
+// Makes a relative path absolute following symlinks
+char *bftpd_cwd_mappath(char *path);
+
+// Stuff
+void bftpd_cwd_init();
+void bftpd_cwd_end();
+
+#endif
diff -Naur ftpd/storage/dirlist.c ftpd-brcm/storage/dirlist.c
--- ftpd/storage/dirlist.c	1969-12-31 20:00:00.000000000 -0400
+++ ftpd-brcm/storage/dirlist.c	2018-11-23 22:28:25.144777681 -0400
@@ -0,0 +1,195 @@
+#include <config.h>
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+
+#ifdef HAVE_DIRENT_H
+#  include <dirent.h>
+#else
+#    define dirent direct
+#    define NAMLEN(dirent) (dirent)->d_namlen
+#  ifdef HAVE_SYS_NDIR_H
+#    include <sys/ndir.h>
+#  endif
+#  ifdef HAVE_SYS_DIR_H
+#    include <sys/dir.h>
+#  endif
+#  ifdef HAVE_NDIR_H
+#    include <ndir.h>
+#  endif
+#endif
+
+#include <unistd.h>
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <mystring.h>
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#ifdef HAVE_TIME_H
+#include <time.h>
+#endif
+#include <pwd.h>
+#include <grp.h>
+#include <errno.h>
+#include <glob.h>
+
+#include "cwd.h"
+#include "options.h"
+#include "main.h"
+#include "login.h"
+#include "dirlist.h"
+
+#if 0	//cbj
+struct hidegroup *hidegroups = NULL;
+
+void add_to_hidegroups(int gid)
+{
+    static struct hidegroup *tmp = NULL;
+    if (tmp)
+        tmp = tmp->next = malloc(sizeof(struct hidegroup));
+    else
+        hidegroups = tmp = malloc(sizeof(struct hidegroup));
+    tmp->next = NULL;
+    tmp->data = gid;
+}
+
+void hidegroups_init()
+{
+    char *foo = strdup(config_getoption("HIDE_GROUP"));
+	char *foo_save = foo;
+    char *bar;
+    struct group *tmpgrp;
+    while ((bar = strtok(foo, ","))) {
+        foo = NULL; /* strtok requirement */
+        if ((strcmp(bar, "0")) && (!strtoul(bar, NULL, 10))) {
+            /* bar is not numeric */
+            if ((tmpgrp = getgrnam(bar)))
+                add_to_hidegroups(tmpgrp->gr_gid);
+        } else
+            if (strtoul(bar, NULL, 10))
+                add_to_hidegroups(strtoul(bar, NULL, 10));
+    }
+	free(foo_save);
+}
+
+void hidegroups_end()
+{
+    struct hidegroup *tmp = hidegroups;
+    if (hidegroups)
+        while (hidegroups->next) {
+            tmp = hidegroups->next;
+            free(hidegroups);
+            hidegroups = tmp;
+        }
+}
+#endif	//cbj
+
+void bftpd_stat(char *name, FILE * client)
+{
+    struct stat statbuf;
+	char temp[MAXCMD + 3], linktarget[MAXCMD + 5], perm[11], timestr[17];
+	//char uid[USERLEN + 1], gid[USERLEN + 1];
+    struct tm filetime;
+    time_t t;
+    if (lstat(name, (struct stat *) &statbuf) == -1) { // used for command_stat
+        fprintf(client, "213-Error: %s.\n", strerror(errno));
+        return;
+    }
+#ifdef S_ISLNK
+	if (S_ISLNK(statbuf.st_mode)) {
+		strcpy(perm, "lrwxrwxrwx");
+		temp[readlink(name, temp, sizeof(temp) - 1)] = '\0';
+		sprintf(linktarget, " -> %s", temp);
+	} else {
+#endif
+		strcpy(perm, "----------");
+		if (S_ISDIR(statbuf.st_mode))
+			perm[0] = 'd';
+		if (statbuf.st_mode & S_IRUSR)
+			perm[1] = 'r';
+		if (statbuf.st_mode & S_IWUSR)
+			perm[2] = 'w';
+		if (statbuf.st_mode & S_IXUSR)
+			perm[3] = 'x';
+		if (statbuf.st_mode & S_IRGRP)
+			perm[4] = 'r';
+		if (statbuf.st_mode & S_IWGRP)
+			perm[5] = 'w';
+		if (statbuf.st_mode & S_IXGRP)
+			perm[6] = 'x';
+		if (statbuf.st_mode & S_IROTH)
+			perm[7] = 'r';
+		if (statbuf.st_mode & S_IWOTH)
+			perm[8] = 'w';
+		if (statbuf.st_mode & S_IXOTH)
+			perm[9] = 'x';
+		linktarget[0] = '\0';
+#ifdef S_ISLNK
+	}
+#endif
+    memcpy(&filetime, localtime(&(statbuf.st_mtime)), sizeof(struct tm));
+    time(&t);
+    if (filetime.tm_year == localtime(&t)->tm_year)
+    	mystrncpy(timestr, ctime(&(statbuf.st_mtime)) + 4, 12);
+    else
+        strftime(timestr, sizeof(timestr), "%b %d  %G", &filetime);
+    //cbj -- without authentication 	
+    //mygetpwuid(statbuf.st_uid, passwdfile, uid)[8] = 0;	
+    //mygetpwuid(statbuf.st_gid, groupfile, gid)[8] = 0;	
+	fprintf(client, "%s %3i %8lu %s %s%s\r\n", perm,
+			(int) statbuf.st_nlink,
+			(unsigned long) statbuf.st_size,
+			timestr, name, linktarget);
+}
+
+void dirlist_one_file(char *name, FILE *client, char verbose)
+{
+    struct stat statbuf;
+/*  cbj
+    struct hidegroup *tmp = hidegroups;
+    if (!stat(name, (struct stat *) &statbuf)) {
+        if (tmp)
+            do {
+                if (statbuf.st_gid == tmp->data)
+                    return;
+            } while ((tmp = tmp->next));
+    }
+*/
+    if (verbose)
+        bftpd_stat(name, client);
+    else
+        fprintf(client, "%s\r\n", name);
+}
+
+void dirlist(char *name, FILE * client, char verbose)
+{
+    DIR *directory;
+    char *cwd = NULL;
+    int i;
+	glob_t globbuf;
+    if ((strstr(name, "/.")) && strchr(name, '*'))
+        return; /* DoS protection */
+    if ((directory = opendir(name))) {
+	closedir(directory);
+        cwd = bftpd_cwd_getcwd();
+        chdir(name);
+        glob("*", 0, NULL, &globbuf);
+    } else
+    	glob(name, 0, NULL, &globbuf);
+    for (i = 0; i < globbuf.gl_pathc; i++)
+        dirlist_one_file(globbuf.gl_pathv[i], client, verbose);
+    globfree(&globbuf);
+    if (cwd) {
+	chdir(cwd);
+	free(cwd);
+    }
+}
diff -Naur ftpd/storage/dirlist.h ftpd-brcm/storage/dirlist.h
--- ftpd/storage/dirlist.h	1969-12-31 20:00:00.000000000 -0400
+++ ftpd-brcm/storage/dirlist.h	2018-11-23 22:28:25.144777681 -0400
@@ -0,0 +1,14 @@
+#ifndef __BFTPD_DIRLIST_H
+#define __BFTPD_DIRLIST_H
+
+struct hidegroup {
+    int data;
+    struct hidegroup *next;
+};
+
+//void hidegroups_init();
+//void hidegroups_end();
+//void bftpd_stat(char *name, FILE *client);
+void dirlist(char *name, FILE *client, char verbose);
+
+#endif
diff -Naur ftpd/storage/options.c ftpd-brcm/storage/options.c
--- ftpd/storage/options.c	1969-12-31 20:00:00.000000000 -0400
+++ ftpd-brcm/storage/options.c	2018-11-23 22:28:25.144777681 -0400
@@ -0,0 +1,309 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <grp.h>
+#include <unistd.h>
+
+#include "options.h"
+#include "mystring.h"
+#include "main.h"
+#include "login.h"
+#include <logging.h>
+
+struct global config_global;
+struct group_of_users *config_groups;
+struct user *config_users;
+
+char *config_read_line(FILE *configfile)
+{
+	static char str[256];
+	char *s = str;
+	if (!fgets(str, sizeof(str), configfile))
+		return NULL;
+	while ((strchr(s, '#') > strchr(s, '"')) && strchr(s, '"')) {
+		s = strchr(strchr(s, '"') + 1, '"');
+		if (!s) { // This means there is only one " in the string, which is a syntax error.
+			str[0] = 0; // So we empty the string in order not to confuse the parser.
+			return str;
+		}
+	}
+	if (strchr(s, '#'))
+		*strchr(s, '#') = 0;
+	s = str;
+	while ((s[0] == ' ') || (s[0] == '\t'))
+		s++;
+	return s;
+}
+
+void create_options(FILE *configfile, struct bftpd_option **options, struct directory **directories)
+{
+    char *str;
+    struct bftpd_option *opt = NULL;
+    struct directory *dir = NULL;
+	str = config_read_line(configfile);
+	while (!strchr(str, '}')) {
+  		if (str[0] != '\n') {
+            if ((strstr(str, "directory")) && (strchr(str, '{')) && (directories)) {
+                char *tmp;
+                if (dir) {
+                    dir = dir->next = malloc(sizeof(struct directory));
+                } else {
+                    *directories = dir = malloc(sizeof(struct directory));
+                }
+                tmp = strchr(str, '"') + 1;
+                *strchr(tmp, '"') = 0;
+                dir->path = strdup(tmp);
+                create_options(configfile, &(dir->options), NULL);
+            } else {
+       			if (opt) {
+       				opt = opt->next = malloc(sizeof(struct bftpd_option));
+       			} else {
+       				*options = opt = malloc(sizeof(struct bftpd_option));
+       			}
+       			opt->name = (char *) malloc(strlen(str));
+       			opt->value = (char *) malloc(strlen(str));
+       			sscanf(str, "%[^=]=\"%[^\n\"]", opt->name, opt->value);
+            }
+   		}
+		str = config_read_line(configfile);
+	}
+}
+
+void expand_groups()
+{
+    char foo[USERLEN + 1];
+    struct passwd *temp;
+    struct group_of_users *grp;
+    struct group *grpinfo;
+    struct list_of_struct_passwd *endp = NULL;
+    struct list_of_struct_group *endg = NULL;
+    uid_t uid;
+    int i;
+    if ((grp = config_groups)) {
+        do {
+            strcat(grp->temp_members, ",");
+            while (strchr(grp->temp_members, ',')) {
+                sscanf(grp->temp_members, "%[^,]", foo);
+                cutto(grp->temp_members, strlen(foo) + 1);
+                if (foo[0] == '@') {
+                    if (sscanf(foo + 1, "%i", &uid)) {
+                        if (!((grpinfo = getgrgid(uid))))
+                            continue;
+                    } else
+                        if (!((grpinfo = getgrnam(foo + 1))))
+                            continue;
+                    if (grp->groups)
+                        endg = endg->next = malloc(sizeof(struct list_of_struct_group));
+                    else
+                        grp->groups = endg = malloc(sizeof(struct list_of_struct_group));
+                    endg->grp.gr_name = strdup(grpinfo->gr_name);
+                    endg->grp.gr_passwd = strdup(grpinfo->gr_passwd);
+                    endg->grp.gr_gid = grpinfo->gr_gid;
+                    for (i = 0; grpinfo->gr_mem[i]; i++);
+                    endg->grp.gr_mem = malloc((i + 1) * sizeof(char *));
+                    for (i = 0; grpinfo->gr_mem[i]; i++)
+                        endg->grp.gr_mem[i] = strdup(grpinfo->gr_mem[i]);
+                    endg->grp.gr_mem[i] = NULL;
+                } 
+                if (sscanf(foo, "%i", &uid)) {
+                    if (!((temp = getpwuid(uid))))
+                        continue;
+                } else
+                    if (!((temp = getpwnam(foo))))
+                        continue;
+                if (grp->users)
+                    endp = endp->next = malloc(sizeof(struct list_of_struct_passwd));
+                else
+                    grp->users = endp = malloc(sizeof(struct list_of_struct_passwd));
+                /* This is ugly, but you can't just use memcpy()! */
+                endp->pwd.pw_name = strdup(temp->pw_name);
+                endp->pwd.pw_passwd = strdup(temp->pw_passwd);
+                endp->pwd.pw_uid = temp->pw_uid;
+                endp->pwd.pw_gid = temp->pw_gid;
+                endp->pwd.pw_gecos = strdup(temp->pw_gecos);
+                endp->pwd.pw_dir = strdup(temp->pw_dir);
+                endp->pwd.pw_shell = strdup(temp->pw_shell);
+            }
+            free(grp->temp_members);
+        } while ((grp = grp->next));
+    }
+}
+
+void config_init()
+{
+	FILE *configfile;
+	char *str;
+    struct group_of_users *grp = NULL;
+    struct user *usr = NULL;
+    config_global.options = NULL;
+    config_global.directories = NULL;
+	if (!configpath)
+		return;
+	configfile = fopen(configpath, "r");
+	if (!configfile) {
+		control_printf(SL_FAILURE, "421 Unable to open configuration file.");
+		exit(1);
+	}
+	while ((str = config_read_line(configfile))) {
+		if (strchr(str, '{')) {
+            replace(str, " {", "{");
+            replace(str, "{ ", "{");
+            replace(str, " }", "}");
+            replace(str, "} ", "}");
+            if (!strcasecmp(str, "global{\n")) {
+                create_options(configfile, &(config_global.options), &(config_global.directories));
+            } else if (strstr(str, "user ") == str) {
+                if (usr) {
+                    usr = usr->next = malloc(sizeof(struct user));
+                } else {
+                    config_users = usr = malloc(sizeof(struct user));
+                }
+                usr->name = strdup(str + 5);
+                *strchr(usr->name, '{') = 0;
+                create_options(configfile, &(usr->options), &(usr->directories));
+            } else if (strstr(str, "group ") == str) {
+                if (grp) {
+                    grp = grp->next = malloc(sizeof(struct group_of_users));
+                } else {
+                    config_groups = grp = malloc(sizeof(struct group_of_users));
+                }
+                cutto(str, 6);
+                *strchr(str, '{') = 0;
+                grp->users = NULL;
+                grp->next = NULL;
+                grp->temp_members = strdup(str);
+                create_options(configfile, &(grp->options), &(grp->directories));
+            }
+		}
+	}
+	fclose(configfile);
+}
+
+char *getoption(struct bftpd_option *opt, char *name)
+{
+	if (!opt)
+		return NULL;
+	do {
+		if (!strcasecmp(opt->name, name))
+			return opt->value;
+	} while ((opt = opt->next));
+    return NULL;
+}
+
+char *getoption_directories(struct directory *dir, char *name) {
+    char curpath[256], *bar;
+    struct directory *longest = NULL;
+    if(!dir)
+        return NULL;
+    getcwd(curpath, sizeof(curpath) - 1);
+    strcat(curpath, "/");
+    do {
+        bar = malloc(strlen(dir->path) + 2);
+        strcpy(bar, dir->path);
+        strcat(bar, "/");
+        if (!strncmp(curpath, bar, strlen(bar))) {
+            if (longest) {
+                if ((strlen(bar) > strlen(longest->path) + 1)
+                    && (getoption(dir->options, name)))
+                    longest = dir;
+            } else {
+                if (getoption(dir->options, name))
+                    longest = dir;
+            }
+        }
+        free(bar);
+    } while ((dir = dir->next));
+    if (longest)
+        return getoption(longest->options, name);
+    return NULL;
+}
+
+char user_is_in_group(struct group_of_users *grp) {
+    struct list_of_struct_group *grplist = grp->groups;
+    struct list_of_struct_passwd *pwdlist = grp->users;
+    int i;
+    if (pwdlist) {
+        do {
+            if (!strcmp(user, pwdlist->pwd.pw_name))
+                return 1;
+        } while ((pwdlist = pwdlist->next));
+    }
+    if (grplist) {
+        do {
+            if (userinfo.pw_gid == grplist->grp.gr_gid)
+                return 1;
+            for (i = 0; grplist->grp.gr_mem[i]; i++)
+                if (!strcmp(grplist->grp.gr_mem[i], user))
+                    return 1;
+        } while ((grplist = grplist->next));
+    }
+    return 0;
+}
+
+char *getoption_group(char *name)
+{
+    char *result;
+    struct group_of_users *grp;
+    if ((grp = config_groups)) {
+        do {
+            if (user_is_in_group(grp) && grp->options) {
+                if ((result = getoption_directories(grp->directories, name)))
+                    return result;
+                if ((result = getoption(grp->options, name)))
+                    return result;
+            }
+        } while ((grp = grp->next));
+    }
+    return NULL;
+}
+
+char *getoption_user(char *name)
+{
+    char *result;
+    struct user *usr;
+    if ((usr = config_users)) {
+        do {
+            if (!strcmp(user, usr->name)) {
+                if ((result = getoption_directories(usr->directories, name)))
+                    return result;
+                if ((result = getoption(usr->options, name)))
+                    return result;
+            }
+        } while ((usr = usr->next));
+    }
+    return NULL;
+}
+
+char *getoption_global(char *name)
+{
+    char *result;
+    if ((result = getoption_directories(config_global.directories, name)))
+        return result;
+    if (config_global.options) {
+        if ((result = getoption(config_global.options, name)))
+            return result;
+    }
+    return NULL;
+}
+
+char *config_getoption(char *name)
+{
+    static char empty = 0;
+    char *result;
+	char *foo;
+    if (userinfo_set) {
+        if ((foo = getoption_user(name)))
+            return foo;
+        if ((foo = getoption_group(name)))
+            return foo;
+    }
+    if ((result = getoption_global(name)))
+        return result;
+    else
+        return &empty;
+}
+
+void config_end()
+{
+    /* Needn't do anything ATM */
+}
diff -Naur ftpd/storage/options.h ftpd-brcm/storage/options.h
--- ftpd/storage/options.h	1969-12-31 20:00:00.000000000 -0400
+++ ftpd-brcm/storage/options.h	2018-11-23 22:28:25.144777681 -0400
@@ -0,0 +1,55 @@
+#ifndef __BFTPD_OPTIONS_H
+#define __BFTPD_OPTIONS_H
+
+#include "commands.h"
+#include "mypaths.h"
+
+#include <pwd.h>
+#include <grp.h>
+
+struct bftpd_option {
+  char *name, *value;
+  struct bftpd_option *next;
+};
+struct list_of_struct_passwd {
+    struct passwd pwd;
+    struct list_of_struct_passwd *next;
+};
+struct list_of_struct_group {
+    struct group grp;
+    struct list_of_struct_group *next;
+};
+
+struct directory {
+    char *path;
+    struct bftpd_option *options;
+    struct directory *next;
+};
+struct global {
+    struct bftpd_option *options;
+    struct directory *directories;
+};
+struct group_of_users {
+    struct list_of_struct_passwd *users;
+    struct list_of_struct_group *groups;
+    char *temp_members;
+    struct bftpd_option *options;
+    struct directory *directories;
+    struct group_of_users *next;
+};
+struct user {
+    char *name;
+    struct bftpd_option *options;
+    struct directory *directories;
+    struct user *next;
+};
+
+extern struct group_of_users *config_groups;
+extern struct user *config_users;
+
+void expand_groups();
+void config_init();
+char *config_getoption(char *name);
+void config_end();
+
+#endif
