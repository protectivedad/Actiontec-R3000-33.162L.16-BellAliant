diff -Naur zebra/config.h zebra-brcm/config.h
--- zebra/config.h	1969-12-31 20:00:00.000000000 -0400
+++ zebra-brcm/config.h	2018-11-23 18:54:26.905001430 -0400
@@ -0,0 +1,369 @@
+/* config.h.  Generated by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+/* accconfig.h -- `autoheader' will generate config.h.in for zebra.
+   Copyright (C) 1998, 1999 Kunihiro Ishiguro <kunihiro@zebra.org> */
+
+/* Version of GNU Zebra */
+#define VERSION "0.93"
+
+/* Solaris on x86. */
+/* #undef SOLARIS_X86 */
+
+/* Package name of GNU Zebra */
+#define PACKAGE "zebra"
+
+/* Define if host is GNU/Linux */
+#define GNU_LINUX 1
+
+/* Define if you have the AF_ROUTE socket.  */
+/* #undef HAVE_AF_ROUTE */
+
+/* Define if you have the inet_aton function.  */
+#define HAVE_INET_ATON 1
+
+/* Define if you have the inet_ntop function.  */
+#define HAVE_INET_NTOP 1
+
+/* Define if you have the inet_pton function.  */
+#define HAVE_INET_PTON 1
+
+/* Define if you have the setproctitle function.  */
+/* #undef HAVE_SETPROCTITLE */
+
+/* Define if you have ipv6 stack.  */
+/* #undef HAVE_IPV6 */
+
+/* Define if you wish to support ipv6 router advertisment.  */
+/* #undef HAVE_RTADV */
+
+/* whether system has GNU regex */
+#define HAVE_GNU_REGEX 1
+
+/* whether system has SNMP library */
+/* #undef HAVE_SNMP  */
+
+/* whether sockaddr has a sa_len field */
+/* #undef HAVE_SA_LEN */
+
+/* whether sockaddr_in has a sin_len field */
+/* #undef HAVE_SIN_LEN */
+
+/* whether sockaddr_un has a sun_len field */
+/* #undef HAVE_SUN_LEN */
+
+/* whether sockaddr_in6 has a sin6_scope_id field */
+/* #undef HAVE_SIN6_SCOPE_ID */
+
+/* Define if there is socklen_t. */
+#define HAVE_SOCKLEN_T 1
+
+/* Define if there is sockaddr_dl structure. */
+/* #undef HAVE_SOCKADDR_DL */
+
+/* Define if there is ifaliasreq structure. */
+/* #undef HAVE_IFALIASREQ */
+
+/* Define if there is in6_aliasreq structure. */
+/* #undef HAVE_IN6_ALIASREQ */
+
+/* Define if there is rt_addrinfo structure. */
+/* #undef HAVE_RT_ADDRINFO */
+
+/* Define if there is in_pktinfo structure. */
+#define HAVE_INPKTINFO 1
+
+/* Define if you have the getrusage function. */
+#define HAVE_RUSAGE 1
+
+/* Define if /proc/net/dev exists. */
+#define HAVE_PROC_NET_DEV 1
+
+/* Define if /proc/net/if_inet6 exists. */
+/* #undef HAVE_PROC_NET_IF_INET6 */
+
+/* Define if NET_RT_IFLIST exists in sys/socket.h. */
+#undef HAVE_NET_RT_IFLIST
+
+/* Define if you have INRIA ipv6 stack.  */
+/* #undef INRIA_IPV6 */
+
+/* Define if you have KAME project ipv6 stack.  */
+/* #undef KAME */
+
+/* Define if you have Linux ipv6 stack.  */
+/* #undef LINUX_IPV6 */
+
+/* Define if you have NRL ipv6 stack.  */
+/* #undef NRL */
+
+/* Define if you have BSDI NRL IPv6 stack. */
+/* #undef BSDI_NRL */
+
+/* Define if one-vty option is specified. */
+/* #undef VTYSH */
+
+/* Define if interface aliases don't have distinct indeces */
+/* #undef HAVE_BROKEN_ALIASES */
+
+/* Define if disable-bgp-announce option is specified. */
+#define DISABLE_BGP_ANNOUNCE 1
+
+/* PAM support */
+/* #undef USE_PAM */
+
+/* TCP/IP communication between zebra and protocol daemon. */
+/* #undef HAVE_TCP_ZEBRA  */
+#define HAVE_TCP_ZEBRA 1
+
+/* The OSPF NSSA option (RFC1587). */
+/* #undef HAVE_NSSA */
+
+/* The OSPF Opaque LSA option (RFC2370). */
+/* #undef HAVE_OPAQUE_LSA */
+
+/* Traffic Engineering Extension to OSPF
+   (draft-katz-yeung-ospf-traffic-06.txt). */
+/* #undef HAVE_OSPF_TE */
+
+/* Linux netlink. */
+#define HAVE_NETLINK 1
+
+/* PATHS */
+#define PATH_ZEBRA_PID "/var/run/zebra.pid"
+#define PATH_RIPD_PID "/var/run/ripd.pid"
+#define PATH_RIPNGD_PID "/var/run/ripngd.pid"
+#define PATH_BGPD_PID "/var/run/bgpd.pid"
+#define PATH_OSPFD_PID "/var/run/ospfd.pid"
+#define PATH_OSPF6D_PID "/var/run/ospf6d.pid"
+
+/* Define if Solaris */
+/* #undef SUNOS_5 */
+
+/* Define if FreeBSD 3.2 */
+/* #undef FREEBSD_32 */
+
+/* Define if OpenBSD */
+/* #undef OPEN_BSD */
+
+#ifdef HAVE_IPV6
+#ifdef KAME
+#ifndef INET6
+#define INET6
+#endif /* INET6 */
+#endif /* KAME */
+#endif /* HAVE_IPV6 */
+
+#ifdef SUNOS_5
+typedef unsigned int u_int32_t;
+typedef unsigned short u_int16_t;
+typedef unsigned short u_int8_t;
+#endif /* SUNOS_5 */
+
+#ifndef HAVE_SOCKLEN_T
+typedef int socklen_t;
+#endif /* HAVE_SOCKLEN_T */
+
+/* Define to 1 if you have the <asm/types.h> header file. */
+#define HAVE_ASM_TYPES_H 1
+
+/* Define to 1 if you have the `bcopy' function. */
+#define HAVE_BCOPY 1
+
+/* Define to 1 if you have the `bzero' function. */
+#define HAVE_BZERO 1
+
+/* Define to 1 if you have the `daemon' function. */
+#define HAVE_DAEMON 1
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#define HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `getifaddrs' function. */
+/* #undef HAVE_GETIFADDRS */
+
+/* Define to 1 if you have the `if_indextoname' function. */
+#define HAVE_IF_INDEXTONAME 1
+
+/* Define to 1 if you have the `if_nametoindex' function. */
+#define HAVE_IF_NAMETOINDEX 1
+
+/* Define to 1 if you have the `inet_aton' function. */
+#define HAVE_INET_ATON 1
+
+/* Define to 1 if you have the <inet/nd.h> header file. */
+/* #undef HAVE_INET_ND_H */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <kvm.h> header file. */
+/* #undef HAVE_KVM_H */
+
+/* Define to 1 if you have the `crypt' library (-lcrypt). */
+#define HAVE_LIBCRYPT 1
+
+/* Define to 1 if you have the `kvm' library (-lkvm). */
+/* #undef HAVE_LIBKVM */
+
+/* Define to 1 if you have the `m' library (-lm). */
+#define HAVE_LIBM 1
+
+/* Define to 1 if you have the `ncurses' library (-lncurses). */
+/* #undef HAVE_LIBNCURSES */
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+/* #undef HAVE_LIBNSL */
+
+/* Define to 1 if you have the `readline' library (-lreadline). */
+/* #undef HAVE_LIBREADLINE */
+
+/* Define to 1 if you have the `resolv' library (-lresolv). */
+/* #undef HAVE_LIBRESOLV */
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+/* #undef HAVE_LIBSOCKET */
+
+/* Define to 1 if you have the `tinfo' library (-ltinfo). */
+/* #undef HAVE_LIBTINFO */
+
+/* Define to 1 if you have the <libutil.h> header file. */
+/* #undef HAVE_LIBUTIL_H */
+
+/* Define to 1 if you have the `xnet' library (-lxnet). */
+/* #undef HAVE_LIBXNET */
+
+/* Define to 1 if you have the <linux/version.h> header file. */
+#define HAVE_LINUX_VERSION_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet6/nd6.h> header file. */
+/* #undef HAVE_NETINET6_ND6_H */
+
+/* Define to 1 if you have the <netinet/icmp6.h> header file. */
+#define HAVE_NETINET_ICMP6_H 1
+
+/* Define to 1 if you have the <netinet/in6.h> header file. */
+/* #undef HAVE_NETINET_IN6_H */
+
+/* Define to 1 if you have the <netinet/in6_var.h> header file. */
+/* #undef HAVE_NETINET_IN6_VAR_H */
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <netinet/in_var.h> header file. */
+/* #undef HAVE_NETINET_IN_VAR_H */
+
+/* Define to 1 if you have the <net/if_dl.h> header file. */
+/* #undef HAVE_NET_IF_DL_H */
+
+/* Define to 1 if you have the <net/if_var.h> header file. */
+/* #undef HAVE_NET_IF_VAR_H */
+
+/* Define to 1 if you have the <net/netopt.h> header file. */
+/* #undef HAVE_NET_NETOPT_H */
+
+/* Define to 1 if you have the `setproctitle' function. */
+/* #undef HAVE_SETPROCTITLE */
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+/* #undef HAVE_STRLCAT */
+
+/* Define to 1 if you have the `strlcpy' function. */
+/* #undef HAVE_STRLCPY */
+
+/* Define to 1 if you have the <stropts.h> header file. */
+/* #undef HAVE_STROPTS_H */
+
+/* Define to 1 if you have the <sys/conf.h> header file. */
+/* #undef HAVE_SYS_CONF_H */
+
+/* Define to 1 if you have the <sys/ksym.h> header file. */
+/* #undef HAVE_SYS_KSYM_H */
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/sockio.h> header file. */
+/* #undef HAVE_SYS_SOCKIO_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/sysctl.h> header file. */
+#define HAVE_SYS_SYSCTL_H 1
+
+/* Define to 1 if you have the <sys/times.h> header file. */
+#define HAVE_SYS_TIMES_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+/* Name of package */
+#define PACKAGE "zebra"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "0.93"
+
+/* Define to 1 if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* # undef _ALL_SOURCE */
+#endif
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
diff -Naur zebra/lib/buffer.c zebra-brcm/lib/buffer.c
--- zebra/lib/buffer.c	2002-06-21 17:00:38.000000000 -0300
+++ zebra-brcm/lib/buffer.c	2018-11-23 18:54:26.917001104 -0400
@@ -19,6 +19,7 @@
  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA. 
  */
+#if defined(BRCM_CMD_SUPPORT) || defined(BRCM_RIP_DEBUG)
 
 #include <zebra.h>
 
@@ -566,3 +567,5 @@
 
   return buffer_flush_vty (b, fd, size, erase, no_more);
 }
+
+#endif
diff -Naur zebra/lib/command.c zebra-brcm/lib/command.c
--- zebra/lib/command.c	2002-06-29 03:20:39.000000000 -0300
+++ zebra-brcm/lib/command.c	2018-11-23 18:54:26.921000996 -0400
@@ -32,6 +32,7 @@
 /* Host information structure. */
 struct host host;
 
+#ifdef BRCM_CMD_SUPPORT
 /* Default motd string. */
 char *default_motd = 
 "\r\n\
@@ -57,6 +58,7 @@
   AUTH_ENABLE_NODE,
   "Password: ",
 };
+#endif /* BRCM_CMD_SUPPORT */
 
 struct cmd_node enable_node =
 {
@@ -70,7 +72,10 @@
   "%s(config)# ",
   1
 };
+
 
+
+#ifdef BRCM_CMD_SUPPORT
 /* Utility function to concatenate argv argument into a single string
    with inserting ' ' character between each argument.  */
 char *
@@ -104,6 +109,7 @@
     }
   return str;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Install top node of command vector. */
 void
@@ -226,7 +232,7 @@
 
   vector_free (v);
 }
-
+#ifdef BRCM_CMD_SUPPORT
 /* Fetch next description.  Used in cmd_make_descvec(). */
 char *
 cmd_desc_str (char **string)
@@ -261,7 +267,7 @@
 
   return token;
 }
-
+#endif /* BRCM_CMD_SUPPORT */
 /* New string vector. */
 vector
 cmd_make_descvec (char *string, char *descstr)
@@ -334,8 +340,10 @@
 
       desc = XCALLOC (MTYPE_DESC, sizeof (struct desc));
       desc->cmd = token;
+#ifdef BRCM_CMD_SUPPORT
+      /* take out description of command */
       desc->str = cmd_desc_str (&dp);
-
+#endif
       if (multiple)
 	{
 	  if (multiple == 1)
@@ -385,6 +393,7 @@
   return size;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 /* Return prompt character of specified node. */
 char *
 cmd_prompt (enum node_type node)
@@ -394,6 +403,7 @@
   cnode = vector_slot (cmdvec, node);
   return cnode->prompt;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Install a command into a node. */
 void
@@ -416,6 +426,8 @@
   cmd->cmdsize = cmd_cmdsize (cmd->strvec);
 }
 
+#ifdef BRCM_CMD_SUPPORT
+
 static unsigned char itoa64[] =	
 "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
 
@@ -443,11 +455,13 @@
 
   return crypt (passwd, salt);
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* This function write configuration of this host. */
 int
 config_write_host (struct vty *vty)
 {
+#ifdef BRCM_RIP_DEBUG
   if (host.name)
     vty_out (vty, "hostname %s%s", host.name, VTY_NEWLINE);
 
@@ -493,6 +507,7 @@
 
   if (! host.motd)
     vty_out (vty, "no banner motd%s", VTY_NEWLINE);
+#endif
 
   return 1;
 }
@@ -505,6 +520,7 @@
   return cnode->cmd_vector;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 /* Filter command vector by symbol */
 int
 cmd_filter_by_symbol (char *command, char *symbol)
@@ -549,6 +565,7 @@
     }
   return 0;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Completion match types. */
 enum match_type 
@@ -565,6 +582,7 @@
   exact_match 
 };
 
+#ifdef BRCM_CMD_SUPPORT
 enum match_type
 cmd_ipv4_match (char *str)
 {
@@ -700,7 +718,9 @@
 
   return exact_match;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
+#if defined(BRCM_CMD_SUPPORT) && defined(HAVE_IPV6)
 #define IPV6_ADDR_STR		"0123456789abcdefABCDEF:.%"
 #define IPV6_PREFIX_STR		"0123456789abcdefABCDEF:.%/"
 #define STATE_START		1
@@ -936,7 +956,9 @@
 
   return exact_match;
 }
+#endif /* BRCM_CMD_SUPPORT and HAVE_IPV6 */
 
+#ifdef BRCM_CMD_SUPPORT
 #define DECIMAL_STRLEN_MAX 10
 
 int
@@ -1031,6 +1053,7 @@
 			matched++;
 		      }
 		  }
+#ifdef HAVE_IPV6
 		else if (CMD_IPV6 (str))
 		  {
 		    if (cmd_ipv6_match (command))
@@ -1051,6 +1074,7 @@
 			matched++;
 		      }
 		  }
+#endif
 		else if (CMD_IPV4 (str))
 		  {
 		    if (cmd_ipv4_match (command))
@@ -1096,9 +1120,10 @@
       }
   return match_type;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Filter vector by command character with index. */
-enum match_type
+enum match_type 
 cmd_filter_by_string (char *command, vector v, int index)
 {
   int i;
@@ -1129,7 +1154,7 @@
 	      {
 		desc = vector_slot (descvec, j);
 		str = desc->cmd;
-
+#ifdef BRCM_CMD_SUPPORT
 		if (CMD_VARARG (str))
 		  {
 		    if (match_type < vararg_match)
@@ -1145,6 +1170,7 @@
 			matched++;
 		      }
 		  }
+#ifdef HAVE_IPV6
 		else if (CMD_IPV6 (str))
 		  {
 		    if (cmd_ipv6_match (command) == exact_match)
@@ -1163,6 +1189,7 @@
 			matched++;
 		      }
 		  }
+#endif /* HAVE_IPV6 */
 		else if (CMD_IPV4 (str))
 		  {
 		    if (cmd_ipv4_match (command) == exact_match)
@@ -1182,6 +1209,9 @@
 		      }
 		  }
 		else if (CMD_OPTION (str) || CMD_VARIABLE (str))
+#else
+		if (CMD_OPTION (str) || CMD_VARIABLE (str))
+#endif /* BRCM_CMD_SUPPORT */
 		  {
 		    if (match_type < extend_match)
 		      match_type = extend_match;
@@ -1203,6 +1233,7 @@
   return match_type;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 /* Check ambiguous match */
 int
 is_cmd_ambiguous (char *command, vector v, int index, enum match_type type)
@@ -1258,10 +1289,13 @@
 		  }
 		break;
  	      case ipv6_match:
+#ifdef HAVE_IPV6
 		if (CMD_IPV6 (str))
 		  match++;
+#endif
 		break;
 	      case ipv6_prefix_match:
+#ifdef HAVE_IPV6
 		if ((ret = cmd_ipv6_prefix_match (command)) != no_match)
 		  {
 		    if (ret == partly_match)
@@ -1269,6 +1303,7 @@
 
 		    match++;
 		  }
+#endif
 		break;
 	      case ipv4_match:
 		if (CMD_IPV4 (str))
@@ -1334,7 +1369,7 @@
       else
 	return NULL;
     }
-
+#ifdef HAVE_IPV6
   if (CMD_IPV6 (dst))
     {
       if (cmd_ipv6_match (src))
@@ -1350,7 +1385,7 @@
       else
 	return NULL;
     }
-
+#endif
   if (CMD_IPV4 (dst))
     {
       if (cmd_ipv4_match (src))
@@ -1747,6 +1782,7 @@
       if (match == vararg_match)
 	break;
 
+#ifdef BRCM_CMD_SUPPORT 
       ret = is_cmd_ambiguous (command, cmd_vector, index, match);
 
       if (ret == 1)
@@ -1759,6 +1795,7 @@
 	  vector_free (cmd_vector);
 	  return CMD_ERR_NO_MATCH;
 	}
+#endif /* BRCM_CMD_SUPPORT */
     }
 
   /* Check matched count. */
@@ -1841,6 +1878,7 @@
   /* Execute matched command. */
   return (*matched_element->func) (matched_element, vty, argc, argv);
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Execute command by argument readline. */
 int
@@ -1864,8 +1902,6 @@
 
   for (index = 0; index < vector_max (vline); index++) 
     {
-      int ret;
-
       command = vector_slot (vline, index);
 
       match = cmd_filter_by_string (vector_slot (vline, index), 
@@ -1875,19 +1911,26 @@
       if (match == vararg_match)
 	break;
 
-      ret = is_cmd_ambiguous (command, cmd_vector, index, match);
-      if (ret == 1)
-	{
-	  vector_free (cmd_vector);
-	  return CMD_ERR_AMBIGUOUS;
-	}
-      if (ret == 2)
-	{
-	  vector_free (cmd_vector);
-	  return CMD_ERR_NO_MATCH;
-	}
+#ifdef BRCM_CMD_SUPPORT
+      {
+         int ret;
+
+         ret = is_cmd_ambiguous (command, cmd_vector, index, match);
+         if (ret == 1)
+         {
+            vector_free (cmd_vector);
+            return CMD_ERR_AMBIGUOUS;
+         }
+         if (ret == 2)
+         {
+            vector_free (cmd_vector);
+            return CMD_ERR_NO_MATCH;
+         }
+      }
+#endif /* BRCM_CMD_SUPPORT */
     }
 
+
   /* Check matched count. */
   matched_element = NULL;
   matched_count = 0;
@@ -1980,15 +2023,16 @@
       /* Execute configuration command : this is strict match */
       ret = cmd_execute_command_strict (vline, vty, NULL);
 
+
       /* Try again with setting node to CONFIG_NODE */
       if (ret != CMD_SUCCESS && ret != CMD_WARNING)
 	{
+#ifdef BRCM_CMD_SUPPORT
 	  if (vty->node == KEYCHAIN_KEY_NODE)
 	    {
 	      vty->node = KEYCHAIN_NODE;
 
 	      ret = cmd_execute_command_strict (vline, vty, NULL);
-
 	      if (ret != CMD_SUCCESS && ret != CMD_WARNING)
 		{
 		  vty->node = CONFIG_NODE;
@@ -1997,9 +2041,12 @@
 	    }
 	  else
 	    {
+#endif /* BRCM_CMD_SUPPORT */
 	      vty->node = CONFIG_NODE;
 	      ret = cmd_execute_command_strict (vline, vty, NULL);
+#ifdef BRCM_CMD_SUPPORT
 	    }
+#endif /* BRCM_CMD_SUPPORT */
 	}	  
 
       cmd_free_strvec (vline);
@@ -2010,6 +2057,7 @@
   return CMD_SUCCESS;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 /* Configration from terminal */
 DEFUN (config_terminal,
        config_terminal_cmd,
@@ -2699,7 +2747,9 @@
   host.lines = -1;
   return CMD_SUCCESS;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
+#ifdef BRCM_RIP_DEBUG
 DEFUN (config_log_stdout,
        config_log_stdout_cmd,
        "log stdout",
@@ -2801,7 +2851,9 @@
   host.log_syslog = 0;
   return CMD_SUCCESS;
 }
+#endif /* BRCM_RIP_DEBUG */
 
+#if defined(BRCM_CMD_SUPPORT) && defined(BRCM_RIP_DEBUG)
 DEFUN (config_log_trap,
        config_log_trap_cmd,
        "log trap (emergencies|alerts|critical|errors|warnings|notifications|informational|debugging)",
@@ -2877,6 +2929,8 @@
   return CMD_SUCCESS;
 }
 
+#endif /* BRCM_CMD_SUPPORT  and  BRCM_RIP_DEBUG */
+
 /* Set config filename.  Called from vty.c */
 void
 host_config_set (char *filename)
@@ -2887,6 +2941,7 @@
 void
 install_default (enum node_type node)
 {
+#ifdef BRCM_CMD_SUPPORT
   install_element (node, &config_exit_cmd);
   install_element (node, &config_quit_cmd);
   install_element (node, &config_end_cmd);
@@ -2897,6 +2952,7 @@
   install_element (node, &config_write_file_cmd);
   install_element (node, &config_write_memory_cmd);
   install_element (node, &config_write_cmd);
+#endif
 }
 
 /* Initialize command interface. Install basic nodes and commands. */
@@ -2913,16 +2969,26 @@
   host.logfile = NULL;
   host.config = NULL;
   host.lines = -1;
+#ifdef BRCM_CMD_SUPPORT
   host.motd = default_motd;
+#endif
 
   /* Install top nodes. */
+#ifdef BRCM_CMD_SUPPORT
   install_node (&view_node, NULL);
+#endif
+
   install_node (&enable_node, NULL);
+
+#ifdef BRCM_CMD_SUPPORT
   install_node (&auth_node, NULL);
   install_node (&auth_enable_node, NULL);
-  install_node (&config_node, config_write_host);
+#endif /* BRCM_CMD_SUPPORT */
+
+  install_node (&config_node, config_write_host); 
 
   /* Each node's basic commands. */
+#ifdef BRCM_CMD_SUPPORT
   install_element (VIEW_NODE, &show_version_cmd);
   if (terminal)
     {
@@ -2934,22 +3000,28 @@
       install_element (VIEW_NODE, &config_terminal_length_cmd);
       install_element (VIEW_NODE, &config_terminal_no_length_cmd);
     }
+#endif /* BRCM_CMD_COMMAND */
 
   if (terminal)
     {
       install_default (ENABLE_NODE);
+#ifdef BRCM_CMD_SUPPORT
       install_element (ENABLE_NODE, &config_disable_cmd);
       install_element (ENABLE_NODE, &config_terminal_cmd);
       install_element (ENABLE_NODE, &show_running_config_cmd);
       install_element (ENABLE_NODE, &copy_runningconfig_startupconfig_cmd);
+#endif
     }
+#ifdef BRCM_CMD_SUPPORT
   install_element (ENABLE_NODE, &show_startup_config_cmd);
   install_element (ENABLE_NODE, &show_version_cmd);
   install_element (ENABLE_NODE, &config_terminal_length_cmd);
   install_element (ENABLE_NODE, &config_terminal_no_length_cmd);
+#endif
 
   if (terminal)
     install_default (CONFIG_NODE);
+#ifdef BRCM_CMD_SUPPORT
   install_element (CONFIG_NODE, &hostname_cmd);
   install_element (CONFIG_NODE, &no_hostname_cmd);
   install_element (CONFIG_NODE, &password_cmd);
@@ -2957,25 +3029,32 @@
   install_element (CONFIG_NODE, &enable_password_cmd);
   install_element (CONFIG_NODE, &enable_password_text_cmd);
   install_element (CONFIG_NODE, &no_enable_password_cmd);
+#endif /* BRCM_CMD_SUPPORT */
+
   if (terminal)
     {
+#ifdef BRCM_RIP_DEBUG
       install_element (CONFIG_NODE, &config_log_stdout_cmd);
       install_element (CONFIG_NODE, &no_config_log_stdout_cmd);
       install_element (CONFIG_NODE, &config_log_file_cmd);
       install_element (CONFIG_NODE, &no_config_log_file_cmd);
       install_element (CONFIG_NODE, &config_log_syslog_cmd);
       install_element (CONFIG_NODE, &no_config_log_syslog_cmd);
+#endif
+#if defined (BRCM_CMD_SUPPORT) && defined(BRCM_RIP_DEBUG)
       install_element (CONFIG_NODE, &config_log_trap_cmd);
       install_element (CONFIG_NODE, &no_config_log_trap_cmd);
       install_element (CONFIG_NODE, &config_log_record_priority_cmd);
       install_element (CONFIG_NODE, &no_config_log_record_priority_cmd);
+#endif
+#if defined (BRCM_CMD_SUPPORT)
       install_element (CONFIG_NODE, &service_password_encrypt_cmd);
       install_element (CONFIG_NODE, &no_service_password_encrypt_cmd);
       install_element (CONFIG_NODE, &banner_motd_default_cmd);
       install_element (CONFIG_NODE, &no_banner_motd_cmd);
       install_element (CONFIG_NODE, &service_terminal_length_cmd);
       install_element (CONFIG_NODE, &no_service_terminal_length_cmd);
+#endif
     }
-
   srand(time(NULL));
 }
diff -Naur zebra/lib/distribute.c zebra-brcm/lib/distribute.c
--- zebra/lib/distribute.c	2001-08-27 05:48:23.000000000 -0300
+++ zebra-brcm/lib/distribute.c	2018-11-23 18:54:26.921000996 -0400
@@ -92,6 +92,7 @@
   distribute_delete_hook = func;
 }
 
+#ifdef BRCM_LIST_SUPPORT
 void *
 distribute_hash_alloc (struct distribute *arg)
 {
@@ -115,6 +116,7 @@
 
   return hash_get (disthash, &key, distribute_hash_alloc);
 }
+#endif /* BRCM_LIST_SUPPORT */
 
 unsigned int
 distribute_hash_make (struct distribute *dist)
@@ -143,6 +145,7 @@
   return 0;
 }
 
+#ifdef BRCM_LIST_SUPPORT
 /* Set access-list name to the distribute list. */
 struct distribute *
 distribute_list_set (char *ifname, enum distribute_type type, char *alist_name)
@@ -298,6 +301,7 @@
   return 1;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 DEFUN (distribute_list_all,
        distribute_list_all_cmd,
        "distribute-list WORD (in|out)",
@@ -626,6 +630,7 @@
       }
   return 0;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Configuration write function. */
 int
@@ -681,6 +686,7 @@
       }
   return write;
 }
+#endif /* BRCM_LIST_SUPPORT */
 
 /* Clear all distribute list. */
 void
@@ -695,6 +701,7 @@
 {
   disthash = hash_create (distribute_hash_make, distribute_cmp);
 
+#ifdef BRCM_CMD_SUPPORT
   install_element (node, &distribute_list_all_cmd);
   install_element (node, &no_distribute_list_all_cmd);
 
@@ -706,4 +713,6 @@
 
   install_element (node, &distribute_list_prefix_cmd);
   install_element (node, &no_distribute_list_prefix_cmd);
+#endif
 }
+
diff -Naur zebra/lib/filter.c zebra-brcm/lib/filter.c
--- zebra/lib/filter.c	2002-01-23 18:30:11.000000000 -0400
+++ zebra-brcm/lib/filter.c	2018-11-23 18:54:26.921000996 -0400
@@ -19,6 +19,7 @@
  * Boston, MA 02111-1307, USA.
  */
 
+#ifdef BRCM_LIST_SUPPORT
 #include <zebra.h>
 
 #include "prefix.h"
@@ -2056,3 +2057,4 @@
   access_list_reset_ipv6();
 #endif /* HAVE_IPV6 */
 }
+#endif /* BRCM_LIST_SUPPORT */
diff -Naur zebra/lib/if.c zebra-brcm/lib/if.c
--- zebra/lib/if.c	2002-06-21 17:47:08.000000000 -0300
+++ zebra-brcm/lib/if.c	2018-11-23 18:54:26.921000996 -0400
@@ -121,6 +121,7 @@
   return NULL;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 char *
 ifindex2ifname (unsigned int index)
 {
@@ -135,6 +136,7 @@
     }
   return "unknown";
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Interface existance check by interface name. */
 struct interface *
@@ -152,6 +154,7 @@
   return NULL;
 }
 
+#ifdef HAVE_SNMP
 /* Lookup interface by IPv4 address. */
 struct interface *
 if_lookup_exact_address (struct in_addr src)
@@ -181,6 +184,7 @@
     }
   return NULL;
 }
+#endif /* HAVE_SNMP */
 
 /* Lookup interface by IPv4 address. */
 struct interface *
@@ -194,6 +198,8 @@
   struct prefix *p;
   struct connected *c;
   struct interface *match;
+  //brcm
+  struct prefix_ipv4 *psrc;
 
   /* Zero structures - get rid of rubbish from stack */
   memset(&addr, 0, sizeof(addr));
@@ -216,18 +222,33 @@
 	  if (if_is_pointopoint (ifp))
 	    {
 	      p = c->address;
-
-	      if (p && p->family == AF_INET)
-		{
+	      
+	      //brcm -- src and destination are the same, it's ipoa, send broadcast instead
+	      psrc = (struct prefix_ipv4 *) c->destination;
+	      if (IPV4_ADDR_SAME(&((struct prefix_ipv4 *)p)->prefix, &psrc->prefix)) {
+		/* check prefix only */
+		if (p->family == AF_INET)
+		  {
+		    if (prefix_match (p, &addr) && p->prefixlen > best.prefixlen)
+		      {
+			best = *p;
+			match = ifp;
+		      }
+		  }
+	      } 
+	      else { //brcm
+		if (p && p->family == AF_INET)
+		  {
 #ifdef OLD_RIB	 /* PTP  links are conventionally identified 
-		     by the address of the far end - MAG */
-		  if (IPV4_ADDR_SAME (&p->u.prefix4, &src))
-		    return ifp;
+		    by the address of the far end - MAG */
+                    if (IPV4_ADDR_SAME (&p->u.prefix4, &src))
+		         return ifp;
 #endif
 		  p = c->destination;
 		  if (p && IPV4_ADDR_SAME (&p->u.prefix4, &src))
 		    return ifp;
-		}
+		 }
+	      }
 	    }
 	  else
 	    {
@@ -298,6 +319,7 @@
   return ifp->flags & IFF_MULTICAST;
 }
 
+#ifdef BRCM_RIP_DEBUG
 /* Printout flag information into log */
 const char *
 if_flag_dump (unsigned long flag)
@@ -337,17 +359,19 @@
 
   return logbuf;
 }
+#endif /* BRCM_RIP_DEBUG */
 
+#ifdef BRCM_CMD_SUPPORT
 /* For debugging */
 void
 if_dump (struct interface *ifp)
 {
   listnode node;
-
+#ifdef BRCM_RIP_DEBUG
   zlog_info ("Interface %s index %d metric %d mtu %d %s",
 	     ifp->name, ifp->ifindex, ifp->metric, ifp->mtu, 
 	     if_flag_dump (ifp->flags));
-  
+#endif  
   for (node = listhead (ifp->connected); node; nextnode (node))
     ;
 }
@@ -408,7 +432,7 @@
 
   return CMD_SUCCESS;
 }
-
+#endif /* BRCM_CMD_SUPPORT */
 
 /* See also wrapper function zebra_interface() in zebra/interface.c */
 DEFUN (interface,
@@ -432,6 +456,7 @@
   return CMD_SUCCESS;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 /* For debug purpose. */
 DEFUN (show_address,
        show_address_cmd,
@@ -461,6 +486,7 @@
     }
   return CMD_SUCCESS;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Allocate connected structure. */
 struct connected *
@@ -487,6 +513,7 @@
   XFREE (MTYPE_CONNECTED, connected);
 }
 
+#ifdef BRCM_RIP_DEBUG
 /* Print if_addr structure. */
 void
 connected_log (struct connected *connected, char *str)
@@ -512,6 +539,7 @@
     }
   zlog (NULL, LOG_INFO, logbuf);
 }
+#endif /* BRCM_RIP_DEBUG */
 
 /* If two connected address has same prefix return 1. */
 int
@@ -553,6 +581,7 @@
   return NULL;
 }
 
+#ifdef BRCM_SUPPORT
 /* Check the connected information is PtP style or not.  */
 int
 ifc_pointopoint (struct connected *ifc)
@@ -576,6 +605,7 @@
 
   return ptp;
 }
+#endif /* BRCM_SUPPORT */
 
 #ifndef HAVE_IF_NAMETOINDEX
 unsigned int
@@ -634,8 +664,10 @@
   if (rn)
     {
       route_unlock_node (rn);
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("ifaddr_ipv4_add(): address %s is already added",
 		 inet_ntoa (*ifaddr));
+#endif
       return;
     }
   rn->info = ifp;
@@ -654,8 +686,10 @@
   rn = route_node_lookup (ifaddr_ipv4_table, (struct prefix *) &p);
   if (! rn)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("ifaddr_ipv4_delete(): can't find address %s",
 		 inet_ntoa (*ifaddr));
+#endif
       return;
     }
   rn->info = NULL;
diff -Naur zebra/lib/if_rmap.c zebra-brcm/lib/if_rmap.c
--- zebra/lib/if_rmap.c	2001-08-27 05:48:23.000000000 -0300
+++ zebra-brcm/lib/if_rmap.c	2018-11-23 18:54:26.921000996 -0400
@@ -19,6 +19,8 @@
  * 02111-1307, USA.  
  */
 
+#ifdef BRCM_LIST_SUPPORT
+
 #include <zebra.h>
 
 #include "hash.h"
@@ -303,3 +305,4 @@
   install_element (node, &if_rmap_cmd);
   install_element (node, &no_if_rmap_cmd);
 }
+#endif /* BRCM_LIST_SUPPORT */
diff -Naur zebra/lib/log.c zebra-brcm/lib/log.c
--- zebra/lib/log.c	2001-11-15 04:00:12.000000000 -0400
+++ zebra-brcm/lib/log.c	2018-11-23 18:54:26.921000996 -0400
@@ -18,6 +18,7 @@
  * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  * 02111-1307, USA.  
  */
+#ifdef BRCM_RIP_DEBUG
 
 #include <zebra.h>
 
@@ -481,3 +482,5 @@
     }
   return meslist[index].str;
 }
+
+#endif /* BRCM_RIP_DEBUG */
diff -Naur zebra/lib/Makefile zebra-brcm/lib/Makefile
--- zebra/lib/Makefile	1969-12-31 20:00:00.000000000 -0400
+++ zebra-brcm/lib/Makefile	2018-11-23 18:54:26.917001104 -0400
@@ -0,0 +1,466 @@
+# Makefile.in generated by automake 1.6.2 from Makefile.am.
+# lib/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+SHELL = /bin/sh
+
+srcdir = .
+top_srcdir = ..
+
+#prefix = /usr/local
+#exec_prefix = ${prefix}
+
+#bindir = ${exec_prefix}/bin
+#sbindir = ${exec_prefix}/sbin
+#libexecdir = ${exec_prefix}/libexec
+#datadir = ${prefix}/share
+#sysconfdir = ${prefix}/etc
+#sharedstatedir = ${prefix}/com
+#localstatedir = ${prefix}/var
+#libdir = ${exec_prefix}/lib
+#infodir = ${prefix}/info
+#mandir = ${prefix}/man
+#includedir = ${prefix}/include
+#oldincludedir = /usr/include
+#pkgdatadir = $(datadir)/zebra
+#pkglibdir = $(libdir)/zebra
+pkgincludedir = $(includedir)/zebra
+top_builddir = ..
+
+ACLOCAL = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run aclocal-1.6
+AUTOCONF = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run autoconf
+AUTOMAKE = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run automake-1.6
+AUTOHEADER = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run autoheader
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /usr/bin/install -c
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_DATA = ${INSTALL} -m 644
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = s,x,x,
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_alias = 
+host_triplet = i686-pc-linux-gnu
+
+EXEEXT = 
+OBJEXT = o
+PATH_SEPARATOR = :
+AMTAR = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run tar
+
+#BRCM begin
+#AR = ar
+#AWK = gawk
+BGPD = 
+#CC = gcc
+#CPP = gcc -E
+
+#these will be removed since they are on the top /user96345/Makefile
+#TOOLCHAIN=/opt/toolchains/uclibc
+#CROSS_COMPILE = $(TOOLCHAIN)/bin/mips-uclibc-
+#AR              = $(CROSS_COMPILE)ar
+#AS              = $(CROSS_COMPILE)as
+#LD              = $(CROSS_COMPILE)ld
+#CC              = $(CROSS_COMPILE)gcc
+#CXX             = $(CROSS_COMPILE)g++
+#CPP             = $(CROSS_COMPILE)cpp
+#NM              = $(CROSS_COMPILE)nm
+#STRIP           = $(CROSS_COMPILE)strip
+#OBJCOPY         = $(CROSS_COMPILE)objcopy
+#OBJDUMP         = $(CROSS_COMPILE)objdump
+#RANLIB          = $(CROSS_COMPILE)ranlib
+#LIB_PATH        = $(TOOLCHAIN)/mips-linux/lib
+#LIBDIR          = $(TOOLCHAIN)/mips-linux/lib
+#LIBCDIR         = $(TOOLCHAIN)/mips-linux
+#BRCM end
+
+CURSES = 
+DEPDIR = .deps
+IF_METHOD = if_netlink.o
+IF_PROC = if_proc.o
+
+INCLUDES =  -I.. -I$(top_srcdir) -I$(top_srcdir)/lib
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+IPFORWARD = ipforward_proc.o
+KERNEL_METHOD = 
+LIBPAM = 
+LIB_IPV6 = 
+LIB_REGEX = 
+MULTIPATH_NUM = 1
+OSPF6D = 
+OSPFD = 
+OTHER_METHOD = 
+PACKAGE = zebra
+#BRCM begin
+#RANLIB = ranlib
+#BRCM end
+RIPD = ripd
+RIPNGD = 
+RTREAD_METHOD = rtread_netlink.o
+RT_METHOD = rt_netlink.o
+STRIP = 
+VERSION = 0.93a
+VTYSH = 
+ZEBRA = zebra
+am__include = include
+am__quote = 
+install_sh = /opt/user96345/src/zebra-0.93a/install-sh
+DEFS = -DHAVE_CONFIG_H -DSYSCONFDIR=\"$(sysconfdir)/\"
+
+noinst_LIBRARIES = libzebra.a
+
+libzebra_a_SOURCES = \
+	version.c network.c pid_output.c getopt.c getopt1.c daemon.c \
+	print_version.c checksum.c vector.c linklist.c vty.c command.c \
+	sockunion.c prefix.c thread.c if.c memory.c buffer.c table.c hash.c \
+	filter.c routemap.c distribute.c stream.c str.c log.c plist.c \
+	zclient.c sockopt.c smux.c md5.c if_rmap.c keychain.c
+
+libzebra_a_DEPENDENCIES = 
+
+libzebra_a_LIBADD = 
+
+noinst_HEADERS = \
+	buffer.h command.h filter.h getopt.h hash.h if.h linklist.h log.h \
+	memory.h network.h prefix.h routemap.h distribute.h sockunion.h \
+	str.h stream.h table.h thread.h vector.h version.h vty.h zebra.h \
+	plist.h zclient.h sockopt.h smux.h md5-gnu.h if_rmap.h keychain.h
+
+
+EXTRA_DIST = regex.c regex-gnu.h
+subdir = lib
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+
+#BRCM begin
+#libzebra_a_AR = $(AR) cru
+libzebra_a_AR = $(AR) rcs
+#BRCM end
+
+am_libzebra_a_OBJECTS = version.$(OBJEXT) network.$(OBJEXT) \
+	pid_output.$(OBJEXT) getopt.$(OBJEXT) getopt1.$(OBJEXT) \
+	daemon.$(OBJEXT) print_version.$(OBJEXT) checksum.$(OBJEXT) \
+	vector.$(OBJEXT) linklist.$(OBJEXT) vty.$(OBJEXT) \
+	command.$(OBJEXT) sockunion.$(OBJEXT) prefix.$(OBJEXT) \
+	thread.$(OBJEXT) if.$(OBJEXT) memory.$(OBJEXT) buffer.$(OBJEXT) \
+	table.$(OBJEXT) hash.$(OBJEXT) filter.$(OBJEXT) \
+	routemap.$(OBJEXT) distribute.$(OBJEXT) stream.$(OBJEXT) \
+	str.$(OBJEXT) log.$(OBJEXT) plist.$(OBJEXT) zclient.$(OBJEXT) \
+	sockopt.$(OBJEXT) smux.$(OBJEXT) md5.$(OBJEXT) \
+	if_rmap.$(OBJEXT) keychain.$(OBJEXT)
+
+libzebra_a_OBJECTS = $(am_libzebra_a_OBJECTS)
+DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
+CPPFLAGS = 
+
+#BRCM begin
+#LDFLAGS = -Wl,-warn-common -Wl,-allow-shlib-undefined
+#BRCM end
+#LIBS = -lm -lcrypt 
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+#BRCM begin
+#DEP_FILES = ./$(DEPDIR)/buffer.Po ./$(DEPDIR)/checksum.Po \
+#	./$(DEPDIR)/command.Po ./$(DEPDIR)/daemon.Po \
+#	./$(DEPDIR)/distribute.Po ./$(DEPDIR)/filter.Po \
+#	./$(DEPDIR)/getopt.Po ./$(DEPDIR)/getopt1.Po \
+#	./$(DEPDIR)/hash.Po ./$(DEPDIR)/if.Po \
+#	./$(DEPDIR)/if_rmap.Po ./$(DEPDIR)/keychain.Po \
+#	./$(DEPDIR)/linklist.Po ./$(DEPDIR)/log.Po \
+#	./$(DEPDIR)/md5.Po ./$(DEPDIR)/memory.Po \
+#	./$(DEPDIR)/network.Po ./$(DEPDIR)/pid_output.Po \
+#	./$(DEPDIR)/plist.Po ./$(DEPDIR)/prefix.Po \
+#	./$(DEPDIR)/print_version.Po \
+#	./$(DEPDIR)/routemap.Po ./$(DEPDIR)/smux.Po \
+#	./$(DEPDIR)/sockopt.Po ./$(DEPDIR)/sockunion.Po \
+#	./$(DEPDIR)/str.Po ./$(DEPDIR)/stream.Po \
+#	./$(DEPDIR)/table.Po ./$(DEPDIR)/thread.Po \
+#	./$(DEPDIR)/vector.Po ./$(DEPDIR)/version.Po \
+#	./$(DEPDIR)/vty.Po ./$(DEPDIR)/zclient.Po
+
+DEP_FILES = ./$(DEPDIR)/buffer.Po ./$(DEPDIR)/checksum.Po \
+	./$(DEPDIR)/command.Po ./$(DEPDIR)/daemon.Po \
+	./$(DEPDIR)/distribute.Po ./$(DEPDIR)/filter.Po \
+	./$(DEPDIR)/getopt.Po ./$(DEPDIR)/getopt1.Po \
+	./$(DEPDIR)/hash.Po ./$(DEPDIR)/if.Po \
+	./$(DEPDIR)/if_rmap.Po \
+	./$(DEPDIR)/linklist.Po ./$(DEPDIR)/log.Po \
+	./$(DEPDIR)/memory.Po \
+	./$(DEPDIR)/network.Po ./$(DEPDIR)/pid_output.Po \
+	./$(DEPDIR)/plist.Po ./$(DEPDIR)/prefix.Po \
+	./$(DEPDIR)/print_version.Po \
+	./$(DEPDIR)/routemap.Po ./$(DEPDIR)/smux.Po \
+	./$(DEPDIR)/sockopt.Po ./$(DEPDIR)/sockunion.Po \
+	./$(DEPDIR)/str.Po ./$(DEPDIR)/stream.Po \
+	./$(DEPDIR)/table.Po ./$(DEPDIR)/thread.Po \
+	./$(DEPDIR)/vector.Po ./$(DEPDIR)/version.Po \
+	./$(DEPDIR)/vty.Po ./$(DEPDIR)/zclient.Po
+#	./$(DEPDIR)/zclient.Po
+#BRCM end
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+#LINK = $(LD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+
+#BRCM begin
+#for debug, add -DBRCM_RIP_DEBUG; command support, add -DDBRCM_CMD_SUPPORT;
+#access/filter list support, add -DDBRCM_LIST_SUPPORT
+CFLAGS= -s -Os -fomit-frame-pointer -L$(LIB_PATH) $(CMS_COMPILE_FLAGS) $(CMS_INCLUDE_PATHS) 
+#BRCM end
+
+CFLAGS += -I$(TOOLCHAIN)/include
+
+DIST_SOURCES = $(libzebra_a_SOURCES)
+HEADERS = $(noinst_HEADERS)
+
+DIST_COMMON = $(noinst_HEADERS) ChangeLog Makefile.am Makefile.in
+SOURCES = $(libzebra_a_SOURCES)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .o .obj
+#$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+#	cd $(top_srcdir) && \
+#	  $(AUTOMAKE) --foreign  lib/Makefile
+#Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+#	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libzebra.a: $(libzebra_a_OBJECTS) $(libzebra_a_DEPENDENCIES) 
+	-rm -f libzebra.a
+	$(libzebra_a_AR) libzebra.a $(libzebra_a_OBJECTS) $(libzebra_a_LIBADD)
+#BRCM begin
+#	$(RANLIB) libzebra.a
+#BRCM end
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT) core *.core
+
+distclean-compile:
+	-rm -f *.tab.c
+
+
+#include ./$(DEPDIR)/buffer.Po
+#include ./$(DEPDIR)/checksum.Po
+#include ./$(DEPDIR)/command.Po
+#include ./$(DEPDIR)/daemon.Po
+#include ./$(DEPDIR)/distribute.Po
+#include ./$(DEPDIR)/filter.Po
+#include ./$(DEPDIR)/getopt.Po
+#include ./$(DEPDIR)/getopt1.Po
+#include ./$(DEPDIR)/hash.Po
+#include ./$(DEPDIR)/if.Po
+#include ./$(DEPDIR)/if_rmap.Po
+#include ./$(DEPDIR)/keychain.Po
+#include ./$(DEPDIR)/linklist.Po
+#include ./$(DEPDIR)/log.Po
+#include ./$(DEPDIR)/md5.Po
+#include ./$(DEPDIR)/memory.Po
+#include ./$(DEPDIR)/network.Po
+#include ./$(DEPDIR)/pid_output.Po
+#include ./$(DEPDIR)/plist.Po
+#include ./$(DEPDIR)/prefix.Po
+#include ./$(DEPDIR)/print_version.Po
+#include ./$(DEPDIR)/routemap.Po
+#include ./$(DEPDIR)/smux.Po
+#include ./$(DEPDIR)/sockopt.Po
+#include ./$(DEPDIR)/sockunion.Po
+#include ./$(DEPDIR)/str.Po
+#include ./$(DEPDIR)/stream.Po
+#include ./$(DEPDIR)/table.Po
+#include ./$(DEPDIR)/thread.Po
+#include ./$(DEPDIR)/vector.Po
+#include ./$(DEPDIR)/version.Po
+#include ./$(DEPDIR)/vty.Po
+#include ./$(DEPDIR)/zclient.Po
+
+
+distclean-depend:
+	-rm -rf ./$(DEPDIR)
+
+#.c.o:
+#	source='$<' object='$@' libtool=no \
+#	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' \
+#	$(CCDEPMODE) $(depcomp) \
+#	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+.c.o:
+	source='$<' object='$@' libtool=no \
+	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+
+.c.obj:
+	source='$<' object='$@' libtool=no \
+	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' \
+	$(CCDEPMODE) $(depcomp) \
+	$(COMPILE) -c `cygpath -w $<`
+CCDEPMODE = depmode=gcc3
+uninstall-info-am:
+
+ETAGS = etags
+ETAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@list='$(DISTFILES)'; for file in $$list; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES) $(HEADERS)
+
+installdirs:
+
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-compile distclean-depend \
+	distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+uninstall-am: uninstall-info-am
+
+.PHONY: GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES distclean distclean-compile \
+	distclean-depend distclean-generic distclean-tags distdir dvi \
+	dvi-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic tags uninstall uninstall-am \
+	uninstall-info-am
+
+
+version.c: Makefile
+#	echo '' >version.c
+#	echo 'char *host_name = "$(host_triplet)";' >>version.c
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur zebra/lib/memory.c zebra-brcm/lib/memory.c
--- zebra/lib/memory.c	2002-06-29 04:03:18.000000000 -0300
+++ zebra-brcm/lib/memory.c	2018-11-23 18:54:26.925000887 -0400
@@ -25,8 +25,11 @@
 #include "log.h"
 #include "memory.h"
 
+#ifdef BRCM_RIP_DEBUG
 void alloc_inc (int);
 void alloc_dec (int);
+#endif
+
 
 struct message mstr [] =
 {
@@ -37,7 +40,9 @@
   { MTYPE_IF, "interface" },
   { 0, NULL },
 };
+
 
+#ifdef BRCM_RIP_DEBUG
 /* Fatal memory allocation error occured. */
 static void
 zerror (const char *fname, int type, size_t size)
@@ -46,6 +51,7 @@
 	   fname, lookup (mstr, type), (int) size);
   exit (1);
 }
+#endif
 
 /* Memory allocation. */
 void *
@@ -54,12 +60,11 @@
   void *memory;
 
   memory = malloc (size);
-
+#ifdef BRCM_RIP_DEBUG
   if (memory == NULL)
     zerror ("malloc", type, size);
-
   alloc_inc (type);
-
+#endif
   return memory;
 }
 
@@ -70,11 +75,11 @@
   void *memory;
 
   memory = calloc (1, size);
-
+#ifdef BRCM_RIP_DEBUG
   if (memory == NULL)
     zerror ("calloc", type, size);
-
   alloc_inc (type);
+#endif
 
   return memory;
 }
@@ -86,8 +91,10 @@
   void *memory;
 
   memory = realloc (ptr, size);
+#ifdef BRCM_RIP_DEBUG
   if (memory == NULL)
     zerror ("realloc", type, size);
+#endif
   return memory;
 }
 
@@ -95,7 +102,9 @@
 void
 zfree (int type, void *ptr)
 {
+#ifdef BRCM_RIP_DEBUG
   alloc_dec (type);
+#endif
   free (ptr);
 }
 
@@ -106,9 +115,11 @@
   void *dup;
 
   dup = strdup (str);
+#ifdef BRCM_RIP_DEBUG
   if (dup == NULL)
     zerror ("strdup", type, strlen (str));
   alloc_inc (type);
+#endif
   return dup;
 }
 
@@ -129,7 +140,9 @@
 void
 mtype_log (char *func, void *memory, const char *file, int line, int type)
 {
+#ifdef BRCM_RIP_DEBUG
   zlog_info ("%s: %s %p %s %d", func, lookup (mstr, type), memory, file, line);
+#endif
 }
 
 void *
@@ -207,6 +220,7 @@
 } mstat [MTYPE_MAX];
 #endif /* MTPYE_LOG */
 
+#ifdef BRCM_RIP_DEBUG
 /* Increment allocation counter. */
 void
 alloc_inc (int type)
@@ -220,6 +234,9 @@
 {
   mstat[type].alloc--;
 }
+#endif
+
+#ifdef BRCM_CMD_SUPPORT
 
 /* Looking up memory status from vty interface. */
 #include "vector.h"
@@ -471,10 +488,12 @@
   show_memory_vty (vty, memory_list_ospf6);
   return CMD_SUCCESS;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 void
 memory_init ()
 {
+#ifdef BRCM_CMD_SUPPORT
   install_element (VIEW_NODE, &show_memory_cmd);
   install_element (VIEW_NODE, &show_memory_all_cmd);
   install_element (VIEW_NODE, &show_memory_lib_cmd);
@@ -490,4 +509,5 @@
   install_element (ENABLE_NODE, &show_memory_bgp_cmd);
   install_element (ENABLE_NODE, &show_memory_ospf_cmd);
   install_element (ENABLE_NODE, &show_memory_ospf6_cmd);
+#endif
 }
diff -Naur zebra/lib/plist.c zebra-brcm/lib/plist.c
--- zebra/lib/plist.c	2002-01-18 04:42:31.000000000 -0400
+++ zebra-brcm/lib/plist.c	2018-11-23 18:54:26.925000887 -0400
@@ -18,6 +18,7 @@
  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  * Boston, MA 02111-1307, USA.
  */
+#ifdef BRCM_LIST_SUPPORT
 
 #include <zebra.h>
 
@@ -2879,3 +2880,4 @@
 #endif /* HAVE_IPV6 */
   prefix_list_reset_orf ();
 }
+#endif /* BRCM_LIST_SUPPORT */
diff -Naur zebra/lib/prefix.c zebra-brcm/lib/prefix.c
--- zebra/lib/prefix.c	2001-09-18 01:31:27.000000000 -0300
+++ zebra-brcm/lib/prefix.c	2018-11-23 18:54:26.925000887 -0400
@@ -39,6 +39,7 @@
 
 #define MASKBIT(offset)  ((0xff << (PNBBY - (offset))) & 0xff)
 
+#ifdef BRCM_SUPPORT
 /* Address Famiy Identifier to Address Family converter. */
 int
 afi2family (int afi)
@@ -63,6 +64,7 @@
 #endif /* HAVE_IPV6 */
   return 0;
 }
+#endif /*  BRCM_SUPPORT */
 
 /* If n includes p prefix then return 1 else return 0. */
 int
@@ -112,8 +114,10 @@
     }
   else
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_INFO, "prefix_copy(): Unknown address family %d",
 	      src->family);
+#endif
       assert (0);
     }
 }
@@ -135,7 +139,7 @@
     }
   return 0;
 }
-
+#ifdef BRCM_SUPPORT
 /* When both prefix structure is not same, but will be same after
    applying mask, return 0. otherwise, return 1 */
 int
@@ -164,7 +168,9 @@
 
   return 0;
 }
+#endif
 
+#if defined(BRCM_CMD_SUPPORT) || defined(BRCM_RIP_DEBUG)
 /* Return prefix family type string. */
 char *
 prefix_family_str (struct prefix *p)
@@ -177,6 +183,7 @@
 #endif /* HAVE_IPV6 */
   return "unspec";
 }
+#endif /* BRCM_SUPPORT */
 
 /* Allocate new prefix_ipv4 structure. */
 struct prefix_ipv4 *
@@ -488,6 +495,8 @@
   return;
 }
 
+#ifdef BRCM_SUPPORT
+
 /* Utility function of convert between struct prefix <=> union sockunion */
 struct prefix *
 sockunion2prefix (union sockunion *dest,
@@ -546,6 +555,7 @@
 #endif /* HAVE_IPV6 */
   return NULL;
 }
+#endif /* BRCM_SUPPORT */
 
 int
 prefix_blen (struct prefix *p)
@@ -564,6 +574,7 @@
   return 0;
 }
 
+#ifdef BRCM_SUPPORT
 /* Generic function for conversion string to struct prefix. */
 int
 str2prefix (char *str, struct prefix *p)
@@ -594,6 +605,7 @@
   snprintf (str, size, "%s/%d", buf, p->prefixlen);
   return 0;
 }
+#endif /* BRCM_SUPPORT */
 
 struct prefix *
 prefix_new ()
@@ -611,6 +623,7 @@
   XFREE (MTYPE_PREFIX, p);
 }
 
+#ifdef BRCM_SUPPORT
 /* Utility function.  Check the string only contains digit
    character. */
 int
@@ -621,6 +634,7 @@
       return 0;
   return 1;
 }
+#endif /* BRCM_SUPPORT */
 
 /* Utility function to convert ipv4 prefixes to Classful prefixes */
 void apply_classful_mask_ipv4 (struct prefix_ipv4 *p)
@@ -648,7 +662,7 @@
       apply_mask_ipv4(p);
     }
 }
-
+#ifdef BRCM_SUPPORT 
 /* Utility function to convert ipv4 netmask to prefixes 
    ex.) "1.1.0.0" "255.255.0.0" => "1.1.0.0/16"
    ex.) "1.0.0.0" NULL => "1.0.0.0/8"                   */
@@ -694,3 +708,4 @@
   return 1;
 }
 
+#endif /* BRCM_SUPPORT */
diff -Naur zebra/lib/print_version.c zebra-brcm/lib/print_version.c
--- zebra/lib/print_version.c	2001-08-24 05:07:53.000000000 -0300
+++ zebra-brcm/lib/print_version.c	2018-11-23 18:54:26.925000887 -0400
@@ -18,7 +18,7 @@
  * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  * 02111-1307, USA.  
  */
-
+#ifdef BRCM_CMD_SUPPORT
 #include <zebra.h>
 
 #include "version.h"
@@ -29,3 +29,4 @@
   printf ("%s version %s (%s)\n", progname, ZEBRA_VERSION, host_name);
   printf ("Copyright 1996-2001, Kunihiro Ishiguro\n");
 }
+#endif /* BRCM_CMD_SUPPORT */
diff -Naur zebra/lib/routemap.c zebra-brcm/lib/routemap.c
--- zebra/lib/routemap.c	2002-06-29 03:20:39.000000000 -0300
+++ zebra-brcm/lib/routemap.c	2018-11-23 18:54:26.929000778 -0400
@@ -18,6 +18,8 @@
 Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 02111-1307, USA.  */
 
+#ifdef BRCM_LIST_SUPPORT
+
 #include <zebra.h>
 
 #include "linklist.h"
@@ -1075,3 +1077,4 @@
   install_element (RMAP_NODE, &rmap_onmatch_goto_cmd);
   install_element (RMAP_NODE, &no_rmap_onmatch_goto_cmd);
 }
+#endif /* BRCM_LIST_SUPPORT */
diff -Naur zebra/lib/sockunion.c zebra-brcm/lib/sockunion.c
--- zebra/lib/sockunion.c	2002-06-21 17:00:38.000000000 -0300
+++ zebra-brcm/lib/sockunion.c	2018-11-23 18:54:26.929000778 -0400
@@ -18,9 +18,7 @@
  * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  * 02111-1307, USA.  
  */
-
 #include <zebra.h>
-
 #include "prefix.h"
 #include "vty.h"
 #include "sockunion.h"
@@ -28,6 +26,7 @@
 #include "str.h"
 #include "log.h"
 
+#ifdef BRCM_SUPPORT
 #ifndef HAVE_INET_ATON
 int
 inet_aton (const char *cp, struct in_addr *inaddr)
@@ -236,7 +235,9 @@
   sock = socket (su->sa.sa_family, SOCK_STREAM, 0);
   if (sock < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_WARNING, "Can't make socket : %s", strerror (errno));
+#endif
       return -1;
     }
 
@@ -371,8 +372,10 @@
     {
       if (errno != EINPROGRESS)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog_info ("can't connect to %s fd %d : %s",
 		     sockunion_log (&su), fd, strerror (errno));
+#endif
 	  return connect_error;
 	}
     }
@@ -394,8 +397,9 @@
   sock = socket (su->sa.sa_family, SOCK_STREAM, 0);
 
   if (sock < 0)
+#ifdef BRCM_RIP_DEBUG
     zlog (NULL, LOG_WARNING, "can't make socket sockunion_stream_socket");
-
+#endif
   return sock;
 }
 
@@ -439,10 +443,12 @@
 
   ret = bind (sock, (struct sockaddr *)su, size);
   if (ret < 0)
+#ifdef BRCM_RIP_DEBUG
     zlog (NULL, LOG_WARNING, "can't bind socket : %s", strerror (errno));
-
+#endif
   return ret;
 }
+#endif /* BRCM_SUPPORT */
 
 int
 sockopt_reuseaddr (int sock)
@@ -454,7 +460,9 @@
 		    (void *) &on, sizeof (on));
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_WARNING, "can't set sockopt SO_REUSEADDR to socket %d", sock);
+#endif
       return -1;
     }
   return 0;
@@ -471,7 +479,9 @@
 		    (void *) &on, sizeof (on));
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_WARNING, "can't set sockopt SO_REUSEADDR to socket %d", sock);
+#endif
       return -1;
     }
   return 0;
@@ -484,6 +494,7 @@
 }
 #endif /* 0 */
 
+#ifdef BRCM_SUPPORT
 int
 sockopt_ttl (int family, int sock, int ttl)
 {
@@ -496,7 +507,9 @@
 			(void *) &ttl, sizeof (int));
       if (ret < 0)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog (NULL, LOG_WARNING, "can't set sockopt IP_TTL %d to socket %d", ttl, sock);
+#endif
 	  return -1;
 	}
       return 0;
@@ -509,8 +522,10 @@
 			(void *) &ttl, sizeof (int));
       if (ret < 0)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog (NULL, LOG_WARNING, "can't set sockopt IPV6_UNICAST_HOPS %d to socket %d",
 		    ttl, sock);
+#endif
 	  return -1;
 	}
       return 0;
@@ -570,8 +585,10 @@
   ret = getsockname (fd, (struct sockaddr *)&name, &len);
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("Can't get local address and port by getsockname: %s",
 		 strerror (errno));
+#endif
       return NULL;
     }
 
@@ -624,8 +641,10 @@
   ret = getpeername (fd, (struct sockaddr *)&name, &len);
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_WARNING, "Can't get remote address and port: %s",
 	    strerror (errno));
+#endif
       return NULL;
     }
 
@@ -754,3 +773,5 @@
 {
   XFREE (MTYPE_SOCKUNION, su);
 }
+
+#endif /* BRCM_SUPPORT */
diff -Naur zebra/lib/stream.c zebra-brcm/lib/stream.c
--- zebra/lib/stream.c	2002-06-21 17:00:38.000000000 -0300
+++ zebra-brcm/lib/stream.c	2018-11-23 18:54:26.929000778 -0400
@@ -60,6 +60,7 @@
   XFREE (MTYPE_STREAM_DATA, s->data);
   XFREE (MTYPE_STREAM, s);
 }
+#ifdef BRCM_SUPPORT
 
 unsigned long
 stream_get_getp (struct stream *s)
@@ -72,13 +73,13 @@
 {
   return s->putp;
 }
-
+#endif
 unsigned long
 stream_get_endp (struct stream *s)
 {
   return s->endp;
 }
-
+#ifdef BRCM_SUPPORT
 unsigned long
 stream_get_size (struct stream *s)
 {
@@ -97,7 +98,7 @@
 {
   s->putp = pos;
 }
-
+#endif
 /* Forward pointer. */
 void
 stream_forward (struct stream *s, int size)
@@ -124,6 +125,7 @@
   return c;
 }
 
+#ifdef BRCM_SUPPORT
 /* Get next character from the stream. */
 u_char
 stream_getc_from (struct stream *s, unsigned long from)
@@ -133,7 +135,7 @@
   c = s->data[from];
   return c;
 }
-
+#endif /* BRCM_SUPPORT */
 /* Get next word from the stream. */
 u_int16_t
 stream_getw (struct stream *s)
@@ -145,6 +147,7 @@
   return w;
 }
 
+#ifdef BRCM_SUPPORT
 /* Get next word from the stream. */
 u_int16_t
 stream_getw_from (struct stream *s, unsigned long from)
@@ -155,6 +158,7 @@
   w |= s->data[from];
   return w;
 }
+#endif /* BRCM_SUPPORT */
 
 /* Get next long word from the stream. */
 u_int32_t
@@ -255,7 +259,7 @@
   s->data[putp + 1] = (u_char) w;
   return 2;
 }
-
+#ifdef BRCM_SUPPORT
 int
 stream_putl_at (struct stream *s, unsigned long putp, u_int32_t l)
 {
@@ -265,7 +269,7 @@
   s->data[putp + 3] = (u_char)l;
   return 4;
 }
-
+#endif
 /* Put long word to the stream. */
 int
 stream_put_ipv4 (struct stream *s, u_int32_t l)
@@ -296,6 +300,7 @@
   return 4;
 }
 
+#ifdef BRCM_SUPPORT
 /* Put prefix by nlri type format. */
 int
 stream_put_prefix (struct stream *s, struct prefix *p)
@@ -315,6 +320,7 @@
 
   return psize;
 }
+#endif
 
 /* Read size from fd. */
 int
@@ -322,7 +328,7 @@
 {
   int nbytes;
 
-  nbytes = readn (fd, s->data + s->putp, size);
+  nbytes = readn (fd, (char *)(s->data) + s->putp, size);
 
   if (nbytes > 0)
     {
@@ -331,7 +337,7 @@
     }
   return nbytes;
 }
-
+#ifdef BRCM_SUPPORT
 /* Read size from fd. */
 int
 stream_read_unblock (struct stream *s, int fd, size_t size)
@@ -351,7 +357,7 @@
     }
   return nbytes;
 }
-
+#endif
 /* Write data to buffer. */
 int
 stream_write (struct stream *s, u_char *ptr, size_t size)
@@ -365,7 +371,7 @@
     s->endp = s->putp;
   return size;
 }
-
+#ifdef BRCM_SUPPORT
 /* Return current read pointer. */
 u_char *
 stream_pnt (struct stream *s)
@@ -382,7 +388,7 @@
   else
     return 0;
 }
-
+#endif /* BRCM_SUPPORT */
 /* Reset stream. */
 void
 stream_reset (struct stream *s)
@@ -403,6 +409,7 @@
   return nbytes;
 }
 
+#ifdef BRCM_SUPPORT
 /* Stream first in first out queue. */
 
 struct stream_fifo *
@@ -477,3 +484,5 @@
   stream_fifo_clean (fifo);
   XFREE (MTYPE_STREAM_FIFO, fifo);
 }
+
+#endif
diff -Naur zebra/lib/thread.c zebra-brcm/lib/thread.c
--- zebra/lib/thread.c	2002-01-07 05:14:46.000000000 -0400
+++ zebra-brcm/lib/thread.c	2018-11-23 18:54:26.929000778 -0400
@@ -61,6 +61,7 @@
 	  + (a.tv_usec - b.tv_usec));
 }
 
+#ifdef BRCM_RIP_DEBUG
 /* List allocation and head/tail print out. */
 static void
 thread_list_debug (struct thread_list *list)
@@ -87,6 +88,7 @@
   printf ("total alloc: [%ld]\n", m->alloc);
   printf ("-----------\n");
 }
+#endif /* #ifdef BRCM_RIP_DEBUG */
 
 /* Allocate new thread master.  */
 struct thread_master *
@@ -199,7 +201,7 @@
 {
   return  list->head ? 0 : 1;
 }
-
+#ifdef BRCM_SUPPORT
 /* Return remain time in second. */
 unsigned long
 thread_timer_remain_second (struct thread *thread)
@@ -213,6 +215,7 @@
   else
     return 0;
 }
+#endif /* #ifdef BRCM_SUPPORT */
 
 /* Get new thread.  */
 static struct thread *
@@ -247,7 +250,9 @@
 
   if (FD_ISSET (fd, &m->readfd))
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_WARNING, "There is already read fd [%d]", fd);
+#endif
       return NULL;
     }
 
@@ -270,7 +275,9 @@
 
   if (FD_ISSET (fd, &m->writefd))
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_WARNING, "There is already write fd [%d]", fd);
+#endif
       return NULL;
     }
 
@@ -544,8 +551,9 @@
 	{
 	  if (errno == EINTR)
 	    continue;
-
+#ifdef BRCM_RIP_DEBUG
 	  zlog_warn ("select() error: %s", strerror (errno));
+#endif
 	  return NULL;
 	}
 
@@ -576,7 +584,7 @@
 
   return thread_time;
 }
-
+#ifdef BRCM_SUPPORT
 /* We should aim to yield after THREAD_YIELD_TIME_SLOT
    milliseconds.  */
 int
@@ -591,6 +599,7 @@
   else
     return 0;
 }
+#endif /* #ifdef BRCM_SUPPORT*/
 
 /* We check thread consumed time. If the system has getrusage, we'll
    use that to get indepth stats on the performance of the thread.  If
@@ -617,10 +626,12 @@
        * Whinge about it now, so we're aware this is yet another task
        * to fix.
        */
+#ifdef BRCM_RIP_DEBUG
       zlog_err ("CPU HOG task %lx ran for %ldms",
                 /* FIXME: report the name of the function somehow */
 		(unsigned long) thread->func,
 		thread_time / 1000L);
+#endif
     }
 #endif /* THREAD_CONSUMED_TIME_CHECK */
 }
diff -Naur zebra/lib/vty.c zebra-brcm/lib/vty.c
--- zebra/lib/vty.c	2002-07-07 05:12:47.000000000 -0300
+++ zebra-brcm/lib/vty.c	2018-11-23 18:54:26.929000778 -0400
@@ -34,6 +34,7 @@
 #include "prefix.h"
 #include "filter.h"
 
+#if defined(BRCM_CMD_SUPPORT)
 /* Vty events */
 enum event 
 {
@@ -48,6 +49,7 @@
 };
 
 static void vty_event (enum event, int, struct vty *);
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Extern host structure from command.c */
 extern struct host host;
@@ -55,32 +57,41 @@
 /* Vector which store each vty structure. */
 static vector vtyvec;
 
+#if defined(BRCM_CMD_SUPPORT)
 /* Vty timeout value. */
 static unsigned long vty_timeout_val = VTY_TIMEOUT_DEFAULT;
 
 /* Vty access-class command */
 static char *vty_accesslist_name = NULL;
+#endif /* BRCM_CMD_SUPPORT */
 
+#ifdef HAVE_IPV6
 /* Vty access-calss for IPv6. */
 static char *vty_ipv6_accesslist_name = NULL;
+#endif
 
 /* VTY server thread. */
 vector Vvty_serv_thread;
 
+#if defined(BRCM_CMD_SUPPORT)
 /* Current directory. */
 char *vty_cwd = NULL;
+#endif
 
 /* Configure lock. */
 static int vty_config;
-
+#if defined(BRCM_CMD_SUPPORT)
 /* Login password check. */
 static int no_password_check = 0;
 
 /* Integrated configuration file path */
 char integrate_default[] = SYSCONFDIR INTEGRATE_DEFAULT_CONFIG;
+#endif /* BRCM_CMD_SUPPORT */
 
 
 /* VTY standard output function. */
+
+#if defined(BRCM_CMD_SUPPORT)
 int
 vty_out (struct vty *vty, const char *format, ...)
 {
@@ -139,7 +150,15 @@
 
   return len;
 }
+#else /* BRCM_CMD_SUPPORT */
+int
+vty_out (struct vty *vty, const char *format, ...)
+{
+  return 1;
+}
+#endif /* BRCM_CMD_SUPPORT */
 
+#if defined(BRCM_RIP_DEBUG) || defined(BRCM_CMD_SUPPORT)
 int
 vvty_out (struct vty *vty, const char *format, va_list va)
 {
@@ -151,14 +170,18 @@
 
   if (len < 0)
     {    
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_INFO, "Vty closed due to vty output buffer shortage.");
+#endif
       return -1;
     }
 
   buffer_write (vty->obuf, (u_char *)buf, len);
   return len;
 }
+#endif /* defined(BRCM_RIP_DEBUG) || defined(BRCM_CMD_SUPPORT) */
 
+#if defined(BRCM_CMD_SUPPORT) || defined(BRCM_RIP_DEBUG)
 /* Output current time to the vty. */
 void
 vty_time_print (struct vty *vty, int cr)
@@ -175,7 +198,9 @@
   ret = strftime (buf, TIME_BUF, "%Y/%m/%d %H:%M:%S", tm);
   if (ret == 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_INFO, "strftime error");
+#endif
       return;
     }
   if (cr)
@@ -185,7 +210,9 @@
 
   return;
 }
+#endif /* || defined(BRCM_RIP_DEBUG) */
 
+#if defined(BRCM_CMD_SUPPORT)
 /* Say hello to vty interface. */
 void
 vty_hello (struct vty *vty)
@@ -254,6 +281,7 @@
   vty_out (vty, "%s", cmd);
 }
 #endif /* 0 */
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Allocate new vty struct. */
 struct vty *
@@ -261,7 +289,9 @@
 {
   struct vty *new = XCALLOC (MTYPE_VTY, sizeof (struct vty));
 
+#if defined(BRCM_CMD_SUPPORT)
   new->obuf = (struct buffer *) buffer_new (100);
+#endif
   new->buf = XCALLOC (MTYPE_VTY, VTY_BUFSIZ);
   new->max = VTY_BUFSIZ;
   new->sb_buffer = NULL;
@@ -269,6 +299,7 @@
   return new;
 }
 
+#if defined(BRCM_CMD_SUPPORT)
 /* Authentication of vty */
 static void
 vty_auth (struct vty *vty, char *buf)
@@ -1634,10 +1665,13 @@
   vty_sock = sockunion_accept (accept_sock, &su);
   if (vty_sock < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("can't accept vty socket : %s", strerror (errno));
+#endif
       return -1;
     }
 
+#ifdef BRCM_LIST_SUPPORT
   p = sockunion2hostprefix (&su);
 
   /* VTY's accesslist apply. */
@@ -1647,8 +1681,10 @@
 	  (access_list_apply (acl, p) == FILTER_DENY))
 	{
 	  char *buf;
+#ifdef BRCM_RIP_DEBUG
 	  zlog (NULL, LOG_INFO, "Vty connection refused from %s",
 		(buf = sockunion_su2str (&su)));
+#endif
 	  free (buf);
 	  close (vty_sock);
 	  
@@ -1660,6 +1696,7 @@
 	  return 0;
 	}
     }
+#endif /* BRCM_LIST_SUPPORT */
 
 #ifdef HAVE_IPV6
   /* VTY's ipv6 accesslist apply. */
@@ -1669,8 +1706,10 @@
 	  (access_list_apply (acl, p) == FILTER_DENY))
 	{
 	  char *buf;
+#ifdef BRCM_RIP_DEBUG
 	  zlog (NULL, LOG_INFO, "Vty connection refused from %s",
 		(buf = sockunion_su2str (&su)));
+#endif
 	  free (buf);
 	  close (vty_sock);
 	  
@@ -1690,9 +1729,10 @@
   ret = setsockopt (vty_sock, IPPROTO_TCP, TCP_NODELAY, 
 		    (char *) &on, sizeof (on));
   if (ret < 0)
+#ifdef BRCM_RIP_DEBUG
     zlog (NULL, LOG_INFO, "can't set sockopt to vty_sock : %s", 
 	  strerror (errno));
-
+#endif
   vty = vty_create (vty_sock, &su);
 
   return 0;
@@ -1796,7 +1836,9 @@
   ret = listen (accept_sock, 3);
   if (ret < 0) 
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_WARNING, "can't listen socket");
+#endif
       close (accept_sock);	/* Avoid sd leak. */
       return;
     }
@@ -1885,7 +1927,9 @@
 
   if (sock < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("can't accept vty socket : %s", strerror (errno));
+#endif
       return -1;
     }
 
@@ -1978,6 +2022,7 @@
   vty_serv_un (path);
 #endif /* VTYSH */
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Close vty interface. */
 void
@@ -1985,6 +2030,7 @@
 {
   int i;
 
+#if defined(BRCM_CMD_SUPPORT)
   /* Cancel threads.*/
   if (vty->t_read)
     thread_cancel (vty->t_read);
@@ -2005,6 +2051,7 @@
   /* Free SB buffer. */
   if (vty->sb_buffer)
     buffer_free (vty->sb_buffer);
+#endif /* BRCM_CMD_SUPPORT */
 
   /* Free command history. */
   for (i = 0; i < VTY_MAXHIST; i++)
@@ -2030,6 +2077,7 @@
   XFREE (MTYPE_VTY, vty);
 }
 
+#if defined(BRCM_CMD_SUPPORT)
 /* When time out occur output message then close connection. */
 static int
 vty_timeout (struct thread *thread)
@@ -2050,6 +2098,8 @@
 
   return 0;
 }
+#endif /* BRCM_CMD_SUPPORT */
+
 
 /* Read up configuration file from file_name. */
 static void
@@ -2086,6 +2136,7 @@
   vty_close (vty);
 }
 
+#if defined(BRCM_CMD_SUPPORT)
 FILE *
 vty_use_backup_config (char *fullpath)
 {
@@ -2141,6 +2192,7 @@
   free (fullpath_tmp);
   return fopen (fullpath, "r");
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Read up configuration file from file_name. */
 void
@@ -2150,7 +2202,7 @@
 {
   char *cwd;
   FILE *confp = NULL;
-  char *fullpath;
+  char *fullpath = NULL;
 
   /* If -f flag specified. */
   if (config_file != NULL)
@@ -2169,6 +2221,7 @@
 
       if (confp == NULL)
 	{
+#if defined(BRCM_CMD_SUPPORT)
 	  confp = vty_use_backup_config (fullpath);
 	  if (confp)
 	    fprintf (stderr, "WARNING: using backup configuration file!\n");
@@ -2176,8 +2229,11 @@
 	    {
 	      fprintf (stderr, "can't open configuration file [%s]\n", 
 		       config_file);
+#endif /* BRCM_CMD_SUPPORT */
 	      exit(1);
+#if defined(BRCM_CMD_SUPPORT)
 	    }
+#endif
 	}
     }
   else
@@ -2186,12 +2242,14 @@
       if (config_current_dir)
 	{
 	  confp = fopen (config_current_dir, "r");
+#if defined(BRCM_CMD_SUPPORT)
 	  if (confp == NULL)
 	    {
 	      confp = vty_use_backup_config (config_current_dir);
 	      if (confp)
 		fprintf (stderr, "WARNING: using backup configuration file!\n");
 	    }
+#endif /* BRCM_CMD_SUPPORT */
 	}
 
       /* If there is no relative path exists, open system default file. */
@@ -2223,6 +2281,7 @@
 	    }
 #endif /* VTYSH */
 
+#if defined(BRCM_CMD_SUPPORT)
 	  confp = fopen (config_default_dir, "r");
 	  if (confp == NULL)
 	    {
@@ -2241,6 +2300,7 @@
 	    }      
 	  else
 	    fullpath = config_default_dir;
+#endif /* BRCM_CMD_SUPPORT */
 	}
       else
 	{
@@ -2258,6 +2318,7 @@
   host_config_set (fullpath);
 }
 
+#if defined(BRCM_CMD_SUPPORT) || defined(BRCM_RIP_DEBUG)
 /* Small utility function which output loggin to the VTY. */
 void
 vty_log (const char *proto_str, const char *format, va_list va)
@@ -2275,6 +2336,7 @@
 	  vty_out (vty, "\r\n");
 	}
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 int
 vty_config_lock (struct vty *vty)
@@ -2302,6 +2364,7 @@
 extern struct thread_master *master;
 /* struct thread_master *master; */
 
+#if defined(BRCM_CMD_SUPPORT)
 static void
 vty_event (enum event event, int sock, struct vty *vty)
 {
@@ -2607,9 +2670,11 @@
     vty_out (vty, " access-class %s%s",
 	     vty_accesslist_name, VTY_NEWLINE);
 
+#ifdef HAVE_IPV6
   if (vty_ipv6_accesslist_name)
     vty_out (vty, " ipv6 access-class %s%s",
 	     vty_ipv6_accesslist_name, VTY_NEWLINE);
+#endif
 
   /* exec-timeout */
   if (vty_timeout_val != VTY_TIMEOUT_DEFAULT)
@@ -2664,11 +2729,13 @@
       vty_accesslist_name = NULL;
     }
 
+#ifdef BRCM_LIST_SUPPORT
   if (vty_ipv6_accesslist_name)
     {
       XFREE(MTYPE_VTY, vty_ipv6_accesslist_name);
       vty_ipv6_accesslist_name = NULL;
     }
+#endif
 }
 
 /* for ospf6d easy temprary reload function */
@@ -2698,6 +2765,7 @@
 
   vty_timeout_val = VTY_TIMEOUT_DEFAULT;
 
+#ifdef BRCM_LIST_SUPPORT
   if (vty_accesslist_name)
     {
       XFREE(MTYPE_VTY, vty_accesslist_name);
@@ -2709,6 +2777,7 @@
       XFREE(MTYPE_VTY, vty_ipv6_accesslist_name);
       vty_ipv6_accesslist_name = NULL;
     }
+#endif
 }
 
 void
@@ -2745,19 +2814,23 @@
 {
   vtyvec = vector_init (VECTOR_MIN_SIZE);
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Install vty's own commands like `who' command. */
 void
 vty_init ()
 {
   /* For further configuration read, preserve current directory. */
+#if defined(BRCM_CMD_SUPPORT)
   vty_save_cwd ();
+#endif
 
   vtyvec = vector_init (VECTOR_MIN_SIZE);
 
   /* Initilize server thread vector. */
   Vvty_serv_thread = vector_init (VECTOR_MIN_SIZE);
 
+#if defined(BRCM_CMD_SUPPORT)
   /* Install bgp top node. */
   install_node (&vty_node, vty_config_write);
 
@@ -2784,4 +2857,6 @@
   install_element (VTY_NODE, &vty_ipv6_access_class_cmd);
   install_element (VTY_NODE, &no_vty_ipv6_access_class_cmd);
 #endif /* HAVE_IPV6 */
+#endif /* BRCM_CMD_SUPPORT */
 }
+
diff -Naur zebra/lib/zclient.c zebra-brcm/lib/zclient.c
--- zebra/lib/zclient.c	2001-08-12 01:03:38.000000000 -0300
+++ zebra-brcm/lib/zclient.c	2018-11-23 18:54:26.929000778 -0400
@@ -90,9 +90,10 @@
   zclient->default_information = 0;
 
   /* Schedule first zclient connection. */
+#ifdef BRCM_RIP_DEBUG
   if (zclient_debug)
     zlog_info ("zclient start scheduled");
-
+#endif
   zclient_event (ZCLIENT_SCHEDULE, zclient);
 }
 
@@ -101,8 +102,9 @@
 zclient_stop (struct zclient *zclient)
 {
   if (zclient_debug)
+#ifdef BRCM_RIP_DEBUG
     zlog_info ("zclient stopped");
-
+#endif
   /* Stop threads. */
   if (zclient->t_read)
     {
@@ -162,7 +164,7 @@
     }
   return sock;
 }
-
+#ifdef BRCM_SUPPORT
 /* For sockaddr_un. */
 #include <sys/un.h>
 
@@ -195,7 +197,7 @@
     }
   return sock;
 }
-
+#endif /* #ifdef BRCM_SUPPORT */
 /* Send simple Zebra message. */
 int
 zebra_message_send (struct zclient *zclient, int command)
@@ -210,7 +212,7 @@
   stream_putw (s, 3);
   stream_putc (s, command);
 
-  return writen (zclient->sock, s->data, 3);
+  return writen (zclient->sock, (char *)(s->data), 3);
 }
 
 /* Make connection to zebra daemon. */
@@ -219,9 +221,10 @@
 {
   int i;
 
+#ifdef BRCM_RIP_DEBUG
   if (zclient_debug)
     zlog_info ("zclient_start is called");
-
+#endif
   /* zclient is disabled. */
   if (! zclient->enable)
     return 0;
@@ -242,8 +245,10 @@
 #endif /* HAVE_TCP_ZEBRA */
   if (zclient->sock < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       if (zclient_debug)
 	zlog_info ("zclient connection fail");
+#endif
       zclient->fail++;
       zclient_event (ZCLIENT_CONNECT, zclient);
       return -1;
@@ -251,9 +256,10 @@
 
   /* Clear fail count. */
   zclient->fail = 0;
+#ifdef BRCM_RIP_DEBUG
   if (zclient_debug)
     zlog_info ("zclient connect success with socket [%d]", zclient->sock);
-      
+#endif      
   /* Create read thread. */
   zclient_event (ZCLIENT_READ, zclient);
 
@@ -281,10 +287,10 @@
 
   zclient = THREAD_ARG (t);
   zclient->t_connect = NULL;
-
+#ifdef BRCM_RIP_DEBUG
   if (zclient_debug)
     zlog_info ("zclient_connect is called");
-
+#endif
   return zclient_start (zclient);
 }
 
@@ -339,7 +345,7 @@
   /* Put length at the first point of the stream. */
   stream_putw_at (s, 0, stream_get_endp (s));
 
-  return writen (zclient->sock, s->data, stream_get_endp (s));
+  return writen (zclient->sock, (char *)(s->data), stream_get_endp (s));
 }
 
 int
@@ -393,7 +399,7 @@
   /* Put length at the first point of the stream. */
   stream_putw_at (s, 0, stream_get_endp (s));
 
-  return writen (zclient->sock, s->data, stream_get_endp (s));
+  return writen (zclient->sock, (char *)(s->data), stream_get_endp (s));
 }
 
 #ifdef HAVE_IPV6
@@ -448,7 +454,7 @@
   /* Put length at the first point of the stream. */
   stream_putw_at (s, 0, stream_get_endp (s));
 
-  return writen (zclient->sock, s->data, stream_get_endp (s));
+  return writen (zclient->sock, (char *)(s->data), stream_get_endp (s));
 }
 
 int
@@ -502,7 +508,7 @@
   /* Put length at the first point of the stream. */
   stream_putw_at (s, 0, stream_get_endp (s));
 
-  return writen (zclient->sock, s->data, stream_get_endp (s));
+  return writen (zclient->sock, (char *)(s->data), stream_get_endp (s));
 }
 
 #endif /* HAVE_IPV6 */
@@ -521,7 +527,7 @@
   stream_putc (s, command);
   stream_putc (s, type);
 
-  ret = writen (sock, s->data, 4);
+  ret = writen (sock, (char *)(s->data), 4);
 
   stream_free (s);
 
@@ -539,13 +545,13 @@
   stream_get (ifname_tmp, s, INTERFACE_NAMSIZ);
 
   /* Lookup this by interface name. */
-  ifp = if_lookup_by_name (ifname_tmp);
+  ifp = if_lookup_by_name ((char *)ifname_tmp);
 
   /* If such interface does not exist, make new one. */
   if (! ifp)
     {
       ifp = if_create ();
-      strncpy (ifp->name, ifname_tmp, IFNAMSIZ);
+      strncpy (ifp->name, (char *)ifname_tmp, IFNAMSIZ);
     }
 
   /* Read interface's index. */
@@ -578,7 +584,7 @@
   stream_get (ifname_tmp, s, INTERFACE_NAMSIZ);
 
   /* Lookup this by interface index. */
-  ifp = if_lookup_by_name (ifname_tmp);
+  ifp = if_lookup_by_name ((char *)ifname_tmp);
 
   /* If such interface does not exist, indicate an error */
   if (! ifp)
@@ -613,7 +619,9 @@
   ifp = if_lookup_by_index (ifindex);
   if (ifp == NULL)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("zebra_interface_address_add_read: Can't find interface by ifindex: %d ", ifindex);
+#endif
       return NULL;
     }
 
@@ -667,7 +675,9 @@
   ifp = if_lookup_by_index (ifindex);
   if (ifp == NULL)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("zebra_interface_address_delete_read: Can't find interface by ifindex: %d ", ifindex);
+#endif
       return NULL;
     }
 
@@ -715,8 +725,10 @@
   /* zebra socket is closed. */
   if (nbytes == 0) 
     {
+#ifdef BRCM_RIP_DEBUG
       if (zclient_debug)
 	zlog_info ("zclient connection closed socket [%d].", sock);
+#endif
       zclient->fail++;
       zclient_stop (zclient);
       zclient_event (ZCLIENT_CONNECT, zclient);
@@ -726,8 +738,10 @@
   /* zebra read error. */
   if (nbytes < 0 || nbytes != ZEBRA_HEADER_SIZE)
     {
+#ifdef BRCM_RIP_DEBUG
       if (zclient_debug)
 	zlog_info ("Can't read all packet (length %d).", nbytes);
+#endif
       zclient->fail++;
       zclient_stop (zclient);
       zclient_event (ZCLIENT_CONNECT, zclient);
@@ -750,8 +764,10 @@
   nbytes = stream_read (zclient->ibuf, sock, length);
  if (nbytes != length)
    {
+#ifdef BRCM_RIP_DEBUG
      if (zclient_debug)
        zlog_info ("zclient connection closed socket [%d].", sock);
+#endif
      zclient->fail++;
      zclient_stop (zclient);
      zclient_event (ZCLIENT_CONNECT, zclient);
@@ -792,6 +808,7 @@
       if (zclient->ipv4_route_delete)
 	ret = (*zclient->ipv4_route_delete) (command, zclient, length);
       break;
+#ifdef HAVE_IPV6
     case ZEBRA_IPV6_ROUTE_ADD:
       if (zclient->ipv6_route_add)
 	ret = (*zclient->ipv6_route_add) (command, zclient, length);
@@ -800,6 +817,7 @@
       if (zclient->ipv6_route_delete)
 	ret = (*zclient->ipv6_route_delete) (command, zclient, length);
       break;
+#endif /* HAVE_IPV6 */
     default:
       break;
     }
@@ -873,9 +891,11 @@
     case ZCLIENT_CONNECT:
       if (zclient->fail >= 10)
 	return;
+#ifdef BRCM_RIP_DEBUG
       if (zclient_debug)
 	zlog_info ("zclient connect schedule interval is %d", 
 		   zclient->fail < 3 ? 10 : 60);
+#endif
       if (! zclient->t_connect)
 	zclient->t_connect = 
 	  thread_add_timer (master, zclient_connect, zclient,
diff -Naur zebra/Makefile zebra-brcm/Makefile
--- zebra/Makefile	1969-12-31 20:00:00.000000000 -0400
+++ zebra-brcm/Makefile	2018-11-23 18:54:26.873002299 -0400
@@ -0,0 +1,517 @@
+# Makefile.in generated by automake 1.6.2 from Makefile.am.
+# Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+SHELL = /bin/sh
+srcdir = .
+top_srcdir = .
+prefix = /usr/local
+exec_prefix = ${prefix}
+bindir = ${exec_prefix}/bin
+sbindir = ${exec_prefix}/sbin
+libexecdir = ${exec_prefix}/libexec
+datadir = ${prefix}/share
+sysconfdir = ${prefix}/etc
+sharedstatedir = ${prefix}/com
+localstatedir = ${prefix}/var
+libdir = ${exec_prefix}/lib
+infodir = ${prefix}/info
+mandir = ${prefix}/man
+includedir = ${prefix}/include
+oldincludedir = /usr/include
+pkgdatadir = $(datadir)/zebra
+pkglibdir = $(libdir)/zebra
+pkgincludedir = $(includedir)/zebra
+top_builddir = .
+
+ACLOCAL = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run aclocal-1.6
+AUTOCONF = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run autoconf
+AUTOMAKE = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run automake-1.6
+AUTOHEADER = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run autoheader
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /usr/bin/install -c
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_DATA = ${INSTALL} -m 644
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = s,x,x,
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_alias = 
+host_triplet = i686-pc-linux-gnu
+
+EXEEXT = 
+OBJEXT = o
+PATH_SEPARATOR = :
+AMTAR = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run tar
+
+#BRCM begin
+#AR = ar
+#AWK = gawk
+BGPD = 
+#CC = gcc
+#CPP = gcc -E
+#for debug, add -DBRCM_RIP_DEBUG; command support, add -DDBRCM_CMD_SUPPORT;
+#access/filter list support, add -DDBRCM_LIST_SUPPORT
+CFLAGS= -s -Os -fomit-frame-pointer
+#these will be removed since they are on the top /user96345/Makefile
+#TOOLCHAIN=/opt/toolchains/uclibc
+#CROSS_COMPILE = $(TOOLCHAIN)/bin/mips-uclibc-
+#AR              = $(CROSS_COMPILE)ar
+#AS              = $(CROSS_COMPILE)as
+#LD              = $(CROSS_COMPILE)ld
+#CC              = $(CROSS_COMPILE)gcc
+#CXX             = $(CROSS_COMPILE)g++
+#CPP             = $(CROSS_COMPILE)cpp
+#NM              = $(CROSS_COMPILE)nm
+#STRIP           = $(CROSS_COMPILE)strip
+#OBJCOPY         = $(CROSS_COMPILE)objcopy
+#OBJDUMP         = $(CROSS_COMPILE)objdump
+#RANLIB          = $(CROSS_COMPILE)ranlib
+#LIB_PATH        = $(TOOLCHAIN)/mips-linux/lib
+#LIBDIR          = $(TOOLCHAIN)/mips-linux/lib
+#LIBCDIR         = $(TOOLCHAIN)/mips-linux
+#BRCM end
+
+CURSES = 
+DEPDIR = .deps
+IF_METHOD = if_netlink.o
+IF_PROC = if_proc.o
+INCLUDES = 
+
+#BRCM begin
+#INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+INSTALL_STRIP_PROGRAM = $(STRIP)
+#BRCM end
+
+IPFORWARD = ipforward_proc.o
+KERNEL_METHOD = 
+LIBPAM = 
+LIB_IPV6 = 
+LIB_REGEX = 
+MULTIPATH_NUM = 1
+OSPF6D = 
+OSPFD = 
+OTHER_METHOD = 
+PACKAGE = zebra
+RANLIB = ranlib
+RIPD = ripd
+RIPNGD = 
+RTREAD_METHOD = rtread_netlink.o
+RT_METHOD = rt_netlink.o
+#STRIP = 
+VERSION = 0.93a
+VTYSH = 
+ZEBRA = zebra
+am__include = include
+am__quote = 
+install_sh = /opt/user96345/src/zebra-0.93a/install-sh
+
+#SUBDIRS = lib zebra  ripd     doc
+SUBDIRS = lib zebra  ripd
+
+EXTRA_DIST = aclocal.m4 SERVICES TODO REPORTING-BUGS vtysh/Makefile.in \
+	vtysh/Makefile.am update-autotools
+
+subdir = .
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+
+RECURSIVE_TARGETS = info-recursive dvi-recursive install-info-recursive \
+	uninstall-info-recursive all-recursive install-data-recursive \
+	install-exec-recursive installdirs-recursive install-recursive \
+	uninstall-recursive check-recursive installcheck-recursive
+DIST_COMMON = README AUTHORS COPYING COPYING.LIB ChangeLog INSTALL \
+	Makefile.am Makefile.in NEWS TODO acconfig.h aclocal.m4 \
+	config.guess config.h.in config.sub configure configure.in \
+	depcomp install-sh missing mkinstalldirs
+DIST_SUBDIRS = $(SUBDIRS)
+
+#BCRM begin
+#all: config.h
+#	$(MAKE) $(AM_MAKEFLAGS) all-recursive
+ifeq ($(strip $(BUILD_ZEBRA)), static)
+CFLAGS += -DBUILD_STATIC
+endif
+
+CFLAGS += -I$(TOOLCHAIN)/include
+CFLAGS += $(BRCM_WERROR_CFLAGS)
+
+all dynamic install: 
+	$(MAKE) $(AM_MAKEFLAGS) -C lib
+	$(MAKE) $(AM_MAKEFLAGS) -C zebra install
+	$(MAKE) $(AM_MAKEFLAGS) -C ripd install
+
+clean:
+	$(MAKE) -C lib clean
+	$(MAKE) -C zebra clean
+	$(MAKE) -C ripd clean
+
+lib/libzebra.a: 
+	$(MAKE) $(AM_MAKEFLAGS) -C lib
+zebra/zebra.a:
+	$(MAKE) $(AM_MAKEFLAGS) -C zebra $(BUILD_ZEBRA)
+ripd/ripd.a:
+	$(MAKE) $(AM_MAKEFLAGS) -C ripd $(BUILD_ZEBRA)
+#BCRM end
+
+.SUFFIXES:
+
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log
+
+#BRCM begin
+#$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+#	cd $(top_srcdir) && \
+#	  $(AUTOMAKE) --foreign  Makefile
+#Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+#	cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)
+#BRCM end
+
+$(top_builddir)/config.status: $(srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+$(srcdir)/configure:  $(srcdir)/configure.in $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)
+	cd $(srcdir) && $(AUTOCONF)
+
+$(ACLOCAL_M4):  configure.in 
+	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+
+config.h: stamp-h1
+	@if test ! -f $@; then \
+	  rm -f stamp-h1; \
+	  $(MAKE) stamp-h1; \
+	else :; fi
+
+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status config.h
+
+$(srcdir)/config.h.in:  $(top_srcdir)/configure.in $(ACLOCAL_M4) $(top_srcdir)/acconfig.h
+	cd $(top_srcdir) && $(AUTOHEADER)
+	touch $(srcdir)/config.h.in
+
+distclean-hdr:
+	-rm -f config.h stamp-h1
+uninstall-info-am:
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $$MAKEFLAGS; amf=$$2; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = .
+distdir = $(PACKAGE)-$(VERSION)
+
+am__remove_distdir = \
+  { test ! -d $(distdir) \
+    || { find $(distdir) -type d ! -perm -200 -exec chmod u+w {} ';' \
+         && rm -fr $(distdir); }; }
+
+GZIP_ENV = --best
+distcleancheck_listfiles = find . -type f -print
+
+distdir: $(DISTFILES)
+	$(am__remove_distdir)
+	mkdir $(distdir)
+	$(mkinstalldirs) $(distdir)/vtysh
+	@list='$(DISTFILES)'; for file in $$list; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d $(distdir)/$$subdir \
+	    || mkdir $(distdir)/$$subdir \
+	    || exit 1; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$(top_distdir)" \
+	        distdir=../$(distdir)/$$subdir \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+	$(MAKE) $(AM_MAKEFLAGS) \
+	  top_distdir="${top_distdir}" distdir="$(distdir)" \
+	  dist-hook
+	-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(SHELL) $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r $(distdir)
+dist-gzip: distdir
+	$(AMTAR) chof - $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+dist dist-all: distdir
+	$(AMTAR) chof - $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	$(am__remove_distdir)
+	GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(AMTAR) xf -
+	chmod -R a-w $(distdir); chmod a+w $(distdir)
+	mkdir $(distdir)/=build
+	mkdir $(distdir)/=inst
+	chmod a-w $(distdir)
+	dc_install_base=`$(am__cd) $(distdir)/=inst && pwd` \
+	  && cd $(distdir)/=build \
+	  && ../configure --srcdir=.. --prefix=$$dc_install_base \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && (test `find $$dc_install_base -type f -print | wc -l` -le 1 \
+	      || { echo "ERROR: files left after uninstall:" ; \
+	           find $$dc_install_base -type f -print ; \
+	           exit 1; } >&2 ) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist-gzip \
+	  && rm -f $(distdir).tar.gz \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck
+	$(am__remove_distdir)
+	@echo "$(distdir).tar.gz is ready for distribution" | \
+	  sed 'h;s/./=/g;p;x;p;x'
+distcleancheck: distclean
+	if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-recursive
+#BRCM begin
+#all-am: Makefile config.h
+#BRCM end
+installdirs: installdirs-recursive
+installdirs-am:
+
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+#BRCM begin
+#distclean-generic:
+#	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+#clean: clean-recursive
+#BRCM end
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+
+clean-am: clean-generic mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+distclean-am: clean-am distclean-generic distclean-hdr distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-recursive
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf autom4te.cache
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic
+
+uninstall-am: uninstall-info-am
+
+uninstall-info: uninstall-info-recursive
+
+.PHONY: $(RECURSIVE_TARGETS) GTAGS all all-am check check-am clean \
+	clean-generic clean-recursive dist dist-all dist-gzip distcheck \
+	distclean distclean-generic distclean-hdr distclean-recursive \
+	distclean-tags distcleancheck distdir dvi dvi-am dvi-recursive \
+	info info-am info-recursive install install-am install-data \
+	install-data-am install-data-recursive install-exec \
+	install-exec-am install-exec-recursive install-info \
+	install-info-am install-info-recursive install-man \
+	install-recursive install-strip installcheck installcheck-am \
+	installdirs installdirs-am installdirs-recursive \
+	maintainer-clean maintainer-clean-generic \
+	maintainer-clean-recursive mostlyclean mostlyclean-generic \
+	mostlyclean-recursive tags tags-recursive uninstall \
+	uninstall-am uninstall-info-am uninstall-info-recursive \
+	uninstall-recursive
+
+
+dist-hook:
+	mkdir $(distdir)/tools
+	cp -p $(srcdir)/tools/*.pl $(distdir)/tools
+	cp -p $(srcdir)/tools/*.el $(distdir)/tools
+	cp -p $(srcdir)/tools/*.cgi $(distdir)/tools
+	mkdir $(distdir)/init
+	mkdir $(distdir)/init/redhat
+	cp -p $(srcdir)/init/redhat/*.init $(distdir)/init/redhat
+	cp -p $(srcdir)/init/redhat/zebra.* $(distdir)/init/redhat
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur zebra/ripd/Makefile zebra-brcm/ripd/Makefile
--- zebra/ripd/Makefile	1969-12-31 20:00:00.000000000 -0400
+++ zebra-brcm/ripd/Makefile	2018-11-23 18:54:26.960999909 -0400
@@ -0,0 +1,493 @@
+# Makefile.in generated by automake 1.6.2 from Makefile.am.
+# ripd/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+#BRCM begin
+#for debug, add -DBRCM_RIP_DEBUG; command support, add -DDBRCM_CMD_SUPPORT;
+#access/filter list support, add -DDBRCM_LIST_SUPPORT
+CFLAGS= -s -Os -fomit-frame-pointer -I$(BUILD_DIR)/userspace/public/include -I$(BUILD_DIR)/userspace/public/include/linux
+CFLAGS += -Werror -Wfatal-errors
+ifeq ($(strip $(BUILD_ZEBRA)), static)
+CFLAGS += -DBUILD_STATIC
+endif
+
+CFLAGS += -I$(TOOLCHAIN)/include
+
+SHELL = /bin/sh
+srcdir = .
+top_srcdir = ..
+#prefix = /usr/local
+#exec_prefix = ${prefix}
+#bindir = ${exec_prefix}/bin
+#bindir = ${exec_prefix}/sbin
+#libexecdir = ${exec_prefix}/libexec
+#datadir = ${prefix}/share
+#sysconfdir = ${prefix}/etc
+#sharedstatedir = ${prefix}/com
+#localstatedir = ${prefix}/var
+#libdir = ${exec_prefix}/lib
+#infodir = ${prefix}/info
+#mandir = ${prefix}/man
+#includedir = ${prefix}/include
+#oldincludedir = /usr/include
+#pkgdatadir = $(datadir)/zebra
+#pkglibdir = $(libdir)/zebra
+pkgincludedir = $(includedir)/zebra
+top_builddir = ..
+
+#these will be removed since they are on the top /user96345/Makefile
+#TOOLCHAIN=/opt/toolchains/uclibc
+#CROSS_COMPILE = $(TOOLCHAIN)/bin/mips-uclibc-
+#AR              = $(CROSS_COMPILE)ar
+#AS              = $(CROSS_COMPILE)as
+#LD              = $(CROSS_COMPILE)ld
+#CC              = $(CROSS_COMPILE)gcc
+#CXX             = $(CROSS_COMPILE)g++
+#CPP             = $(CROSS_COMPILE)cpp
+#NM              = $(CROSS_COMPILE)nm
+#STRIP           = $(CROSS_COMPILE)strip
+#OBJCOPY         = $(CROSS_COMPILE)objcopy
+#OBJDUMP         = $(CROSS_COMPILE)objdump
+#RANLIB          = $(CROSS_COMPILE)ranlib
+#LIB_PATH        = $(TOOLCHAIN)/mips-linux/lib
+#LIBDIR          = $(TOOLCHAIN)/mips-linux/lib
+#LIBCDIR         = $(TOOLCHAIN)/mips-linux
+#BRCM end
+
+ACLOCAL = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run aclocal-1.6
+AUTOCONF = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run autoconf
+AUTOMAKE = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run automake-1.6
+AUTOHEADER = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run autoheader
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /usr/bin/install -c
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_DATA = ${INSTALL} -m 644
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = s,x,x,
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_alias = 
+host_triplet = i686-pc-linux-gnu
+
+EXEEXT = 
+OBJEXT = o
+PATH_SEPARATOR = :
+AMTAR = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run tar
+
+#BRCM begin
+#AR = ar
+#AWK = gawk
+#BGPD = 
+#CC = gcc
+#CPP = gcc -E
+#BRCM end
+CURSES = 
+DEPDIR = .deps
+IF_METHOD = if_netlink.o
+IF_PROC = if_proc.o
+
+
+INCLUDES =  -I.. -I$(top_srcdir) -I$(top_srcdir)/lib
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+IPFORWARD = ipforward_proc.o
+KERNEL_METHOD = 
+LIBPAM = 
+LIB_IPV6 = 
+LIB_REGEX = 
+MULTIPATH_NUM = 1
+OSPF6D = 
+OSPFD = 
+OTHER_METHOD = 
+PACKAGE = zebra
+#RANLIB = ranlib
+RIPD = ripd
+RIPNGD = 
+RTREAD_METHOD = rtread_netlink.o
+RT_METHOD = rt_netlink.o
+#STRIP = 
+VERSION = 0.93a
+VTYSH = 
+ZEBRA = zebra
+am__include = include
+am__quote = 
+install_sh = /opt/user96345/src/zebra-0.93a/install-sh
+DEFS = -DHAVE_CONFIG_H -DSYSCONFDIR=\"$(sysconfdir)/\"
+INSTALL_SDATA = /usr/bin/install -c -m 600
+
+noinst_LIBRARIES = librip.a
+sbin_PROGRAMS = ripd
+
+#BRCM begin -- take out rip_offset.c and rip_routemap.c
+#librip_a_SOURCES = \
+#	ripd.c rip_zebra.c rip_interface.c rip_debug.c rip_snmp.c \
+#	rip_routemap.c rip_peer.c rip_offset.c
+librip_a_SOURCES = \
+	ripd.c rip_zebra.c rip_interface.c rip_debug.c rip_snmp.c \
+	rip_peer.c
+
+
+noinst_HEADERS = \
+	ripd.h rip_debug.h
+
+
+ripd_SOURCES = \
+	rip_main.c $(librip_a_SOURCES)
+
+
+ripd_LDADD = ../lib/libzebra.a
+
+sysconf_DATA = ripd.conf.sample
+
+EXTRA_DIST = $(sysconf_DATA) RIPv2-MIB.txt
+subdir = ripd
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+
+librip_a_AR = $(AR) cru
+librip_a_LIBADD =
+am_librip_a_OBJECTS = ripd.$(OBJEXT) rip_zebra.$(OBJEXT) \
+	rip_interface.$(OBJEXT) rip_debug.$(OBJEXT) rip_snmp.$(OBJEXT) \
+	rip_routemap.$(OBJEXT) rip_peer.$(OBJEXT) rip_offset.$(OBJEXT)
+
+librip_a_OBJECTS = $(am_librip_a_OBJECTS)
+sbin_PROGRAMS = ripd$(EXEEXT)
+PROGRAMS = $(sbin_PROGRAMS)
+
+am__objects_1 = ripd.$(OBJEXT) rip_zebra.$(OBJEXT) \
+	rip_interface.$(OBJEXT) rip_debug.$(OBJEXT) rip_snmp.$(OBJEXT) \
+	rip_routemap.$(OBJEXT) rip_peer.$(OBJEXT) rip_offset.$(OBJEXT)
+
+am_ripd_OBJECTS = rip_main.$(OBJEXT) $(am__objects_1)
+ripd_OBJECTS = $(am_ripd_OBJECTS)
+ripd_DEPENDENCIES = ../lib/libzebra.a
+#BRCM begin
+#ripd_LDFLAGS =
+ripd_LDFLAGS = -Wl,-warn-common -Wl,-allow-shlib-undefined
+#LDFLAGS = 
+LDFLAGS = -Wl,-warn-common -Wl,-allow-shlib-undefined -L$(LIB_PATH)
+#BRCM end
+#LIBS = -lm -lcrypt 
+LIBS = -lm -lcrypt -L$(INSTALL_DIR)/lib/public -lcms_msg $(CMS_COMMON_LIBS)
+DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
+CPPFLAGS = 
+
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+DEP_FILES = ./$(DEPDIR)/rip_debug.Po \
+	./$(DEPDIR)/rip_interface.Po \
+	./$(DEPDIR)/rip_main.Po ./$(DEPDIR)/rip_offset.Po \
+	./$(DEPDIR)/rip_peer.Po ./$(DEPDIR)/rip_routemap.Po \
+	./$(DEPDIR)/rip_snmp.Po ./$(DEPDIR)/rip_zebra.Po \
+	./$(DEPDIR)/ripd.Po
+
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+#BRCM begin
+#CFLAGS = -g -O2 -Wall
+#BRCM end
+DIST_SOURCES = $(librip_a_SOURCES) $(ripd_SOURCES)
+DATA = $(sysconf_DATA)
+
+HEADERS = $(noinst_HEADERS)
+
+DIST_COMMON = $(noinst_HEADERS) ChangeLog Makefile.am Makefile.in
+SOURCES = $(librip_a_SOURCES) $(ripd_SOURCES)
+
+#
+#all: Makefile $(sbin_PROGRAMS) $(HEADERS)
+
+all install: $(sbin_PROGRAMS)
+	install -m 755 $(sbin_PROGRAMS) $(INSTALL_DIR)/bin
+	$(STRIP) $(INSTALL_DIR)/bin/$(sbin_PROGRAMS)
+
+
+.SUFFIXES:
+.SUFFIXES: .c .o .obj
+#$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+#	cd $(top_srcdir) && \
+#	  $(AUTOMAKE) --foreign  ripd/Makefile
+#Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+#	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+librip.a: $(librip_a_OBJECTS) $(librip_a_DEPENDENCIES) 
+	-rm -f librip.a
+	$(librip_a_AR) librip.a $(librip_a_OBJECTS) $(librip_a_LIBADD)
+	$(RANLIB) librip.a
+sbinPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+install-sbinPROGRAMS: $(sbin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(sbindir)
+	@list='$(sbin_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	  ; then \
+	    p1=`echo "$$p1" | sed -e 's,^.*/,,'`; \
+	    f=`echo $$p1|sed '$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(sbinPROGRAMS_INSTALL) $$p $(DESTDIR)$(sbindir)/$$f"; \
+	   $(INSTALL_PROGRAM_ENV) $(sbinPROGRAMS_INSTALL) $$p $(DESTDIR)$(sbindir)/$$f; \
+	  else :; fi; \
+	done
+
+uninstall-sbinPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(sbin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo $$p|sed 's/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  f=`echo "$$f" | sed -e 's,^.*/,,'`; \
+	  echo " rm -f $(DESTDIR)$(sbindir)/$$f"; \
+	  rm -f $(DESTDIR)$(sbindir)/$$f; \
+	done
+
+clean-sbinPROGRAMS:
+	-test -z "$(sbin_PROGRAMS)" || rm -f $(sbin_PROGRAMS)
+ripd$(EXEEXT): $(ripd_OBJECTS) $(ripd_DEPENDENCIES) 
+	@rm -f ripd$(EXEEXT)
+	$(LINK) $(ripd_LDFLAGS) $(ripd_OBJECTS) $(ripd_LDADD) $(LIBS)
+
+#BRCM begin
+ripd.a: $(ripd_OBJECTS) $(ripd_DEPENDENCIES) 
+	@rm -f ripd$(EXEEXT).a
+	$(AR) rcs ripd.a $(ripd_OBJECTS) $(ripd_LDADD)
+
+#BRCM end
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT) core *.core
+
+distclean-compile:
+	-rm -f *.tab.c
+
+#BRCM begin-- take out ./deps/*.Po dependicies
+#include ./$(DEPDIR)/rip_debug.Po
+#include ./$(DEPDIR)/rip_interface.Po
+#include ./$(DEPDIR)/rip_main.Po
+#include ./$(DEPDIR)/rip_offset.Po
+#include ./$(DEPDIR)/rip_peer.Po
+#include ./$(DEPDIR)/rip_routemap.Po
+#include ./$(DEPDIR)/rip_snmp.Po
+#include ./$(DEPDIR)/rip_zebra.Po
+#include ./$(DEPDIR)/ripd.Po
+
+distclean-depend:
+	-rm -rf ./$(DEPDIR)
+
+#.c.o:
+#	source='$<' object='$@' libtool=no \
+#	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' \
+#	$(CCDEPMODE) $(depcomp) \
+#	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+.c.o:
+	source='$<' object='$@' libtool=no \
+	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+
+#BRCM end
+
+.c.obj:
+	source='$<' object='$@' libtool=no \
+	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' \
+	$(CCDEPMODE) $(depcomp) \
+	$(COMPILE) -c `cygpath -w $<`
+CCDEPMODE = depmode=gcc3
+uninstall-info-am:
+sysconfDATA_INSTALL = $(INSTALL_DATA)
+
+uninstall-sysconfDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(sysconf_DATA)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(sysconfdir)/$$f"; \
+	  rm -f $(DESTDIR)$(sysconfdir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@list='$(DISTFILES)'; for file in $$list; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES) $(PROGRAMS) $(DATA) $(HEADERS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(sbindir) $(DESTDIR)$(sysconfdir)
+
+#BRCM begin
+#install: install-am
+#BRCM end
+
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+
+#BRCM begin
+#clean: clean-am
+clean: mostlyclean-compile
+	-test -z "$(sbin_PROGRAMS)" || rm -f $(sbin_PROGRAMS)
+	rm -f $(sbin_PROGRAMS).a
+#BRCM end
+
+clean-am: clean-generic clean-noinstLIBRARIES clean-sbinPROGRAMS \
+	mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-compile distclean-depend \
+	distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am: install-sbinPROGRAMS install-sysconfDATA
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+uninstall-am: uninstall-info-am uninstall-sbinPROGRAMS \
+	uninstall-sysconfDATA
+
+.PHONY: GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES clean-sbinPROGRAMS distclean \
+	distclean-compile distclean-depend distclean-generic \
+	distclean-tags distdir dvi dvi-am info info-am install \
+	install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-sbinPROGRAMS install-strip install-sysconfDATA \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic tags uninstall uninstall-am \
+	uninstall-info-am uninstall-sbinPROGRAMS uninstall-sysconfDATA
+
+
+install-sysconfDATA: $(sysconf_DATA)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(sysconfdir)
+	@list='$(sysconf_DATA)'; for p in $$list; do \
+	  if test -f $(srcdir)/$$p; then \
+	    echo " $(INSTALL_SDATA) $(srcdir)/$$p $(DESTDIR)$(sysconfdir)/$$p"; \
+	    $(INSTALL_SDATA) $(srcdir)/$$p $(DESTDIR)$(sysconfdir)/$$p; \
+	  else if test -f $$p; then \
+	    echo " $(INSTALL_SDATA) $$p $(DESTDIR)$(sysconfdir)/$$p"; \
+	    $(INSTALL_SDATA) $$p $(DESTDIR)$(sysconfdir)/$$p; \
+	  fi; fi; \
+	done
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur zebra/ripd/ripd.c zebra-brcm/ripd/ripd.c
--- zebra/ripd/ripd.c	2002-07-02 23:23:53.000000000 -0300
+++ zebra-brcm/ripd/ripd.c	2018-11-23 18:54:26.964999801 -0400
@@ -43,6 +43,9 @@
 /* RIP Structure. */
 struct rip *rip = NULL;
 
+//brcm 
+u_char ripDebug=0;
+
 /* RIP neighbor address table. */
 struct route_table *rip_neighbor_table;
 
@@ -106,7 +109,11 @@
   ret = setsockopt (sock, SOL_SOCKET, SO_BROADCAST, (char *) &on, sizeof on);
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("can't set sockopt SO_BROADCAST to socket %d", sock);
+#else
+      syslog(LOG_WARNING,"can't set sockopt SO_BROADCAST to socket %d\n",sock);
+#endif
       return -1;
     }
   return 0;
@@ -203,6 +210,7 @@
     }
 }
 
+#ifdef BRCM_LIST_SUPPORT
 int
 rip_incoming_filter (struct prefix_ipv4 *p, struct rip_interface *ri)
 {
@@ -216,9 +224,11 @@
       if (access_list_apply (ri->list[RIP_FILTER_IN], 
 			     (struct prefix *) p) == FILTER_DENY)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_RIP_DEBUG_PACKET)
 	    zlog_info ("%s/%d filtered by distribute in",
 		       inet_ntoa (p->prefix), p->prefixlen);
+#endif
 	  return -1;
 	}
     }
@@ -227,9 +237,11 @@
       if (prefix_list_apply (ri->prefix[RIP_FILTER_IN], 
 			     (struct prefix *) p) == PREFIX_DENY)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_RIP_DEBUG_PACKET)
 	    zlog_info ("%s/%d filtered by prefix-list in",
 		       inet_ntoa (p->prefix), p->prefixlen);
+#endif
 	  return -1;
 	}
     }
@@ -247,9 +259,11 @@
 	      if (access_list_apply (alist,
 				     (struct prefix *) p) == FILTER_DENY)
 		{
+#ifdef BRCM_RIP_DEBUG
 		  if (IS_RIP_DEBUG_PACKET)
 		    zlog_info ("%s/%d filtered by distribute in",
 			       inet_ntoa (p->prefix), p->prefixlen);
+#endif
 		  return -1;
 		}
 	    }
@@ -263,9 +277,11 @@
 	      if (prefix_list_apply (plist,
 				     (struct prefix *) p) == PREFIX_DENY)
 		{
+#ifdef BRCM_RIP_DEBUG
 		  if (IS_RIP_DEBUG_PACKET)
 		    zlog_info ("%s/%d filtered by prefix-list in",
 			       inet_ntoa (p->prefix), p->prefixlen);
+#endif
 		  return -1;
 		}
 	    }
@@ -286,9 +302,11 @@
       if (access_list_apply (ri->list[RIP_FILTER_OUT],
 			     (struct prefix *) p) == FILTER_DENY)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_RIP_DEBUG_PACKET)
 	    zlog_info ("%s/%d is filtered by distribute out",
 		       inet_ntoa (p->prefix), p->prefixlen);
+#endif
 	  return -1;
 	}
     }
@@ -297,9 +315,11 @@
       if (prefix_list_apply (ri->prefix[RIP_FILTER_OUT],
 			     (struct prefix *) p) == PREFIX_DENY)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_RIP_DEBUG_PACKET)
 	    zlog_info ("%s/%d is filtered by prefix-list out",
 		       inet_ntoa (p->prefix), p->prefixlen);
+#endif
 	  return -1;
 	}
     }
@@ -317,9 +337,11 @@
 	      if (access_list_apply (alist,
 				     (struct prefix *) p) == FILTER_DENY)
 		{
+#ifdef BRCM_RIP_DEBUG
 		  if (IS_RIP_DEBUG_PACKET)
 		    zlog_info ("%s/%d filtered by distribute out",
 			       inet_ntoa (p->prefix), p->prefixlen);
+#endif
 		  return -1;
 		}
 	    }
@@ -333,9 +355,11 @@
 	      if (prefix_list_apply (plist,
 				     (struct prefix *) p) == PREFIX_DENY)
 		{
+#ifdef BRCM_RIP_DEBUG
 		  if (IS_RIP_DEBUG_PACKET)
 		    zlog_info ("%s/%d filtered by prefix-list out",
 			       inet_ntoa (p->prefix), p->prefixlen);
+#endif
 		  return -1;
 		}
 	    }
@@ -343,6 +367,7 @@
     }
   return 0;
 }
+#endif /* BRCM_LIST_SUPPORT */
 
 /* Check nexthop address validity. */
 static int
@@ -400,6 +425,7 @@
   /* Apply input filters. */
   ri = ifp->info;
 
+#ifdef BRCM_LIST_SUPPORT
   ret = rip_incoming_filter (&p, ri);
   if (ret < 0)
     return;
@@ -414,6 +440,7 @@
   /* If offset-list does not modify the metric use interface's
      metric. */
   if (! ret)
+#endif
     rte->metric += ifp->metric;
 
   if (rte->metric > RIP_METRIC_INFINITY)
@@ -428,8 +455,14 @@
   /* Check nexthop address. */
   if (rip_nexthop_check (nexthop) < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_RIP_DEBUG_PACKET)
 	zlog_info ("Nexthop address %s is invalid", inet_ntoa (*nexthop));
+#else
+      if (ripDebug)
+	syslog(LOG_DEBUG,"Bad route: nexthop address %s is invalid\n",inet_ntoa (*nexthop));
+#endif
+      ri->recv_badroutes++;
       return;
     }
 
@@ -443,14 +476,17 @@
     {
       /* Redistributed route check. */
       if (rinfo->type != ZEBRA_ROUTE_RIP
-	  && rinfo->metric != RIP_METRIC_INFINITY)
+	  && rinfo->metric != RIP_METRIC_INFINITY) {
+	ri->recv_badroutes++;
 	return;
-
+      }
       /* Local static route. */
       if (rinfo->type == ZEBRA_ROUTE_RIP
 	  && rinfo->sub_type == RIP_ROUTE_STATIC
-	  && rinfo->metric != RIP_METRIC_INFINITY)
+	  && rinfo->metric != RIP_METRIC_INFINITY) {
+	ri->recv_badroutes++;
 	return;
+      }
     }
   
   if (! rinfo)
@@ -616,6 +652,7 @@
     }
 }
 
+#ifdef BRCM_RIP_DEBUG
 /* Dump RIP packet */
 void
 rip_packet_dump (struct rip_packet *packet, int size, char *sndrcv)
@@ -701,6 +738,7 @@
 	}
     }
 }
+#endif
 
 /* Check if the destination address is valid (unicast; not net 0
    or 127) (RFC2453 Section 3.9.2 - Page 26).  But we don't
@@ -731,6 +769,7 @@
   return 0;
 }
 
+#ifdef BRCM_AUTH_SUPPORT
 /* RIP version 2 authentication. */
 int
 rip_auth_simple_password (struct rte *rte, struct sockaddr_in *from,
@@ -739,10 +778,11 @@
   struct rip_interface *ri;
   char *auth_str;
 
+#ifdef BRCM_RIP_DEBUG
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("RIPv2 simple password authentication from %s",
 	       inet_ntoa (from->sin_addr));
-
+#endif
   ri = ifp->info;
 
   if (ri->auth_type != RIP_AUTH_SIMPLE_PASSWORD
@@ -788,9 +828,11 @@
   u_char digest[RIP_AUTH_MD5_SIZE];
   u_int16_t packet_len;
   char *auth_str = NULL;
-  
+
+#ifdef BRCM_RIP_DEBUG  
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("RIPv2 MD5 authentication from %s", inet_ntoa (from->sin_addr));
+#endif
 
   ri = ifp->info;
   md5 = (struct rip_md5_info *) &packet->rte;
@@ -888,7 +930,9 @@
   /* Check packet length. */
   if (len < (RIP_HEADER_SIZE + RIP_RTE_SIZE))
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_err ("rip_auth_md5_set(): packet length %ld is less than minimum length.", len);
+#endif
       return;
     }
 
@@ -947,6 +991,7 @@
   /* Copy the digest to the packet. */
   stream_write (s, digest, RIP_AUTH_MD5_SIZE);
 }
+#endif /* BRCM_AUTH_SUPPORT */
 
 /* RIP routing information. */
 void
@@ -955,14 +1000,20 @@
 {
   caddr_t lim;
   struct rte *rte;
-      
+
   /* The Response must be ignored if it is not from the RIP
      port. (RFC2453 - Sec. 3.9.2)*/
   if (ntohs (from->sin_port) != RIP_PORT_DEFAULT) 
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("response doesn't come from RIP port: %d",
 		 from->sin_port);
       rip_peer_bad_packet (from);
+#else
+      if (ripDebug)
+	syslog(LOG_DEBUG,"response doesn't come from RIP port: %d\n",
+	       from->sin_port);
+#endif
       return;
     }
 
@@ -971,9 +1022,15 @@
      datagram must be on a directly connected network  */
   if (! if_valid_neighbor (from->sin_addr)) 
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("This datagram doesn't came from a valid neighbor: %s",
 		 inet_ntoa (from->sin_addr));
       rip_peer_bad_packet (from);
+#else
+      if (ripDebug)
+	syslog(LOG_DEBUG,"datagram doesn't come from valid neighbor: %s\n",
+	       inet_ntoa (from->sin_addr));
+#endif
       return;
     }
 
@@ -982,8 +1039,10 @@
 
   ; /* Alredy done in rip_read () */
 
+#ifdef BRCM_RIP_DEBUG
   /* Update RIP peer. */
   rip_peer_update (from, packet->version);
+#endif
 
   /* Set RTE pointer. */
   rte = packet->rte;
@@ -1004,8 +1063,14 @@
       if (ntohs (rte->family) != AF_INET)
 	{
 	  /* Address family check.  RIP only supports AF_INET. */
+#ifdef BRCM_RIP_DEBUG
 	  zlog_info ("Unsupported family %d from %s.",
 		     ntohs (rte->family), inet_ntoa (from->sin_addr));
+#else
+	  if (ripDebug)
+	    syslog(LOG_DEBUG,"Unsupported family %d from %s.\n",ntohs (rte->family),
+		   inet_ntoa (from->sin_addr));
+#endif
 	  continue;
 	}
 
@@ -1013,8 +1078,13 @@
          or 127) */
       if (! rip_destination_check (rte->prefix))
         {
+#ifdef BRCM_RIP_DEBUG
 	  zlog_info ("Network is net 0 or net 127 or it is not unicast network");
 	  rip_peer_bad_route (from);
+#else
+	  if (ripDebug)
+	    syslog(LOG_DEBUG,"Network is net 0 or net 127 or it is not unicast network\n");
+#endif
 	  continue;
 	} 
 
@@ -1024,17 +1094,27 @@
       /* - is the metric valid (i.e., between 1 and 16, inclusive) */
       if (! (rte->metric >= 1 && rte->metric <= 16))
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog_info ("Route's metric is not in the 1-16 range.");
 	  rip_peer_bad_route (from);
+#else
+	  if (ripDebug)
+	    syslog(LOG_DEBUG,"Route's metric is not in the 1-16 range.\n");
+#endif
 	  continue;
 	}
 
       /* RIPv1 does not have nexthop value. */
       if (packet->version == RIPv1 && rte->nexthop.s_addr != 0)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog_info ("RIPv1 packet with nexthop value %s",
 		     inet_ntoa (rte->nexthop));
 	  rip_peer_bad_route (from);
+#else
+	  if (ripDebug)
+	    syslog(LOG_DEBUG,"RIPv1 packet with nexthop value %s\n",inet_ntoa (rte->nexthop));
+#endif
 	  continue;
 	}
 
@@ -1050,8 +1130,10 @@
 	  addrval = ntohl (rte->nexthop.s_addr);
 	  if (IN_CLASSD (addrval))
 	    {
+#ifdef BRCM_RIP_DEBUG
 	      zlog_info ("Nexthop %s is multicast address, skip this rte",
 			 inet_ntoa (rte->nexthop));
+#endif
 	      continue;
 	    }
 
@@ -1069,14 +1151,18 @@
 		  if (rinfo->type == ZEBRA_ROUTE_RIP
 		      && rinfo->sub_type == RIP_ROUTE_RTE)
 		    {
+#ifdef BRCM_RIP_DEBUG
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_info ("Next hop %s is on RIP network.  Set nexthop to the packet's originator", inet_ntoa (rte->nexthop));
+#endif
 		      rte->nexthop = rinfo->from;
 		    }
 		  else
 		    {
+#ifdef BRCM_RIP_DEBUG
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_info ("Next hop %s is not directly reachable. Treat it as 0.0.0.0", inet_ntoa (rte->nexthop));
+#endif
 		      rte->nexthop.s_addr = 0;
 		    }
 
@@ -1084,8 +1170,10 @@
 		}
 	      else
 		{
+#ifdef BRCM_RIP_DEBUG
 		  if (IS_RIP_DEBUG_EVENT)
 		    zlog_info ("Next hop %s is not directly reachable. Treat it as 0.0.0.0", inet_ntoa (rte->nexthop));
+#endif
 		  rte->nexthop.s_addr = 0;
 		}
 
@@ -1134,9 +1222,15 @@
 	  && (rte->mask.s_addr != 0) 
 	  && ((rte->prefix.s_addr & rte->mask.s_addr) != rte->prefix.s_addr))
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog_warn ("RIPv2 address %s is not mask /%d applied one",
 		     inet_ntoa (rte->prefix), ip_masklen (rte->mask));
 	  rip_peer_bad_route (from);
+#else
+	  if (ripDebug)
+	    syslog(LOG_DEBUG,"RIPv2 address %s is not mask /%d applied one\n",
+		   inet_ntoa (rte->prefix), ip_masklen (rte->mask));
+#endif
 	  continue;
 	}
 
@@ -1145,8 +1239,10 @@
 	  && (rte->prefix.s_addr == 0)
 	  && (rte->mask.s_addr != 0))
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_RIP_DEBUG_EVENT)
 	    zlog_info ("Default route with non-zero netmask.  Set zero to netmask");
+#endif
 	  rte->mask.s_addr = 0;
 	}
 	  
@@ -1196,13 +1292,20 @@
 
   ret = sendto (sock, buf, size, 0, (struct sockaddr *)&sin,
 		sizeof (struct sockaddr_in));
-
+#ifdef BRCM_RIP_DEBUG
   if (IS_RIP_DEBUG_EVENT)
       zlog_info ("SEND to socket %d port %d addr %s",
                  sock, ntohs (sin.sin_port), inet_ntoa(sin.sin_addr));
-
-  if (ret < 0)
+  if (ret < 0) {
     zlog_warn ("can't send packet : %s", strerror (errno));
+  }
+#else
+  if (ret < 0) {
+    if (ripDebug)
+      syslog(LOG_DEBUG,"Cannot send RIP packet to socket %d, port %d, addr %s, to %x\n",
+	     sock,(ntohs (sin.sin_port)), inet_ntoa(sin.sin_addr), to);
+  }
+#endif /* BRCM_RIP_DEBUG */
 
   if (! to)
     close (sock);
@@ -1333,8 +1436,10 @@
   if (ri->passive)
     return;
 
+#ifdef BRCM_RIP_DEBUG
   /* RIP peer update. */
   rip_peer_update (from, packet->version);
+#endif
 
   lim = ((caddr_t) packet) + size;
   rte = packet->rte;
@@ -1400,7 +1505,9 @@
     
   ret = setsockopt(sock, IPPROTO_IP, IP_PKTINFO, &val, sizeof(val));
   if (ret < 0)
+#ifdef BRCM_RIP_DEBUG
     zlog_warn ("Can't setsockopt IP_PKTINFO : %s", strerror (errno));
+#endif
   return ret;
 }
 
@@ -1449,7 +1556,7 @@
   char buf[RIP_PACKET_MAXSIZ];
   struct sockaddr_in from;
   unsigned int ifindex;
-  
+
   /* Fetch socket then register myself. */
   sock = THREAD_FD (t);
   rip_event (RIP_READ, sock);
@@ -1458,7 +1565,9 @@
   ret = rip_recvmsg (sock, buf, RIP_PACKET_MAXSIZ, &from, (int *)&ifindex);
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("Can't read RIP packet: %s", strerror (errno));
+#endif
       return ret;
     }
 
@@ -1495,15 +1604,22 @@
 		  (struct sockaddr *) &from, &fromlen);
   if (len < 0) 
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("recvfrom failed: %s", strerror (errno));
+#else
+      if (ripDebug)
+	syslog(LOG_DEBUG,"recvfrom failed: %s\n", strerror (errno));
+#endif
       return len;
     }
 
   /* Check is this packet comming from myself? */
   if (if_check_address (from.sin_addr)) 
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_RIP_DEBUG_PACKET)
 	zlog_warn ("ignore packet comes from myself");
+#endif
       return -1;
     }
 
@@ -1511,39 +1627,63 @@
   ifp = if_lookup_address (from.sin_addr);
 
   /* RIP packet received */
+#ifdef BRCM_RIP_DEBUG
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("RECV packet from %s port %d on %s",
 	       inet_ntoa (from.sin_addr), ntohs (from.sin_port),
 	       ifp ? ifp->name : "unknown");
+#else
+  if (ripDebug)
+    syslog(LOG_DEBUG,"RECV packet from %s port %d on %s\n",
+	       inet_ntoa (from.sin_addr), ntohs (from.sin_port),
+	       ifp ? ifp->name : "unknown");
+#endif
 
   /* If this packet come from unknown interface, ignore it. */
   if (ifp == NULL)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("packet comes from unknown interface");
+#endif
       return -1;
     }
 
   /* Packet length check. */
   if (len < RIP_PACKET_MINSIZ)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("packet size %d is smaller than minimum size %d",
 		 len, RIP_PACKET_MINSIZ);
       rip_peer_bad_packet (&from);
+#else
+      if (ripDebug)
+	syslog(LOG_DEBUG,"packet size %d is smaller than minimum size %d\n");
+#endif
       return len;
     }
   if (len > RIP_PACKET_MAXSIZ)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("packet size %d is larger than max size %d",
 		 len, RIP_PACKET_MAXSIZ);
       rip_peer_bad_packet (&from);
+#else
+      if (ripDebug)
+	syslog(LOG_DEBUG,"packet size %d is larger than max size %d\n",len, RIP_PACKET_MAXSIZ);
+#endif
       return len;
     }
 
   /* Packet alignment check. */
   if ((len - RIP_PACKET_MINSIZ) % 20)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("packet size %d is wrong for RIP packet alignment", len);
       rip_peer_bad_packet (&from);
+#else
+      if (ripDebug)
+	syslog(LOG_DEBUG,"packet size %d is wrong for RIP packet alignment\n", len);
+#endif
       return len;
     }
 
@@ -1556,14 +1696,20 @@
   /* RIP version check. */
   if (packet->version == 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("version 0 with command %d received.", packet->command);
       rip_peer_bad_packet (&from);
+#else
+      if (ripDebug)
+	syslog(LOG_DEBUG,"version 0 with command %d received.\n", packet->command);
+#endif
       return -1;
     }
-
+#ifdef BRCM_RIP_DEBUG
   /* Dump RIP packet. */
   if (IS_RIP_DEBUG_RECV)
     rip_packet_dump (packet, len, "RECV");
+#endif
 
   /* RIP version adjust.  This code should rethink now.  RFC1058 says
      that "Version 1 implementations are to ignore this extra data and
@@ -1574,11 +1720,18 @@
 
   /* Is RIP running or is this RIP neighbor ?*/
   ri = ifp->info;
+  ri->recv_updates++;
   if (! ri->running && ! rip_neighbor_lookup (&from))
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("RIP is not enabled on interface %s.", ifp->name);
       rip_peer_bad_packet (&from);
+#else
+      if (ripDebug) 
+	syslog(LOG_DEBUG,"RIP is not enabled on interface %s.\n", packet->command);
+#endif
+      ri->recv_badpackets++;
       return -1;
     }
 
@@ -1589,10 +1742,13 @@
 	{
 	  if (packet->version != rip->version) 
 	    {
+#ifdef BRCM_RIP_DEBUG
 	      if (IS_RIP_DEBUG_PACKET)
 		zlog_warn ("  packet's v%d doesn't fit to my version %d", 
 			   packet->version, rip->version);
 	      rip_peer_bad_packet (&from);
+#endif
+	      ri->recv_badpackets++;
 	      return -1;
 	    }
 	}
@@ -1601,19 +1757,31 @@
 	  if (packet->version == RIPv1)
 	    if (! (ri->ri_receive & RIPv1))
 	      {
+#ifdef BRCM_RIP_DEBUG
 		if (IS_RIP_DEBUG_PACKET)
 		  zlog_warn ("  packet's v%d doesn't fit to if version spec", 
 			     packet->version);
 		rip_peer_bad_packet (&from);
+#else
+		if (ripDebug)
+		  syslog(LOG_DEBUG,"  packet's v%d doesn't fit to if version spec\n",packet->version);
+#endif
+		ri->recv_badpackets++;
 		return -1;
 	      }
 	  if (packet->version == RIPv2)
 	    if (! (ri->ri_receive & RIPv2))
 	      {
+#ifdef BRCM_RIP_DEBUG
 		if (IS_RIP_DEBUG_PACKET)
 		  zlog_warn ("  packet's v%d doesn't fit to if version spec", 
 			     packet->version);
 		rip_peer_bad_packet (&from);
+#else
+		if (ripDebug)
+		  syslog(LOG_DEBUG,"  packet's v%d doesn't fit to if version spec\n",packet->version);
+#endif
+		ri->recv_badpackets++;
 		return -1;
 	      }
 	}
@@ -1627,10 +1795,13 @@
       && rtenum 
       && (packet->version == RIPv2) && (packet->rte->family == 0xffff))
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_RIP_DEBUG_EVENT)
 	zlog_warn ("packet RIPv%d is dropped because authentication disabled", 
 		   packet->version);
       rip_peer_bad_packet (&from);
+#endif
+      ri->recv_badpackets++;
       return -1;
     }
 
@@ -1643,6 +1814,7 @@
      authenticated messages will be propagated by RIP-1 routers in an
      unauthenticated manner. */
 
+#ifdef BRCM_AUTH_SUPPORT
   if ((ri->auth_type == RIP_AUTH_SIMPLE_PASSWORD 
        || ri->auth_type == RIP_AUTH_MD5)
       && rtenum)
@@ -1650,9 +1822,12 @@
       /* We follow maximum security. */
       if (packet->version == RIPv1 && packet->rte->family == 0xffff)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_RIP_DEBUG_PACKET)
 	    zlog_warn ("packet RIPv%d is dropped because authentication enabled", packet->version);
 	  rip_peer_bad_packet (&from);
+#endif
+	  ri->recv_badpackets++;f
 	  return -1;
 	}
 
@@ -1666,15 +1841,20 @@
 		  ret = rip_auth_simple_password (packet->rte, &from, ifp);
 		  if (! ret)
 		    {
+#ifdef BRCM_RIP_DEBUG
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_warn ("RIPv2 simple password authentication failed");
 		      rip_peer_bad_packet (&from);
+#endif
+		      ri->recv_badpackets++;
 		      return -1;
 		    }
 		  else
 		    {
+#ifdef BRCM_RIP_DEBUG
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_info ("RIPv2 simple password authentication success");
+#endif
 		    }
                 }
 	      else if (ntohs (packet->rte->tag) == RIP_AUTH_MD5)
@@ -1682,25 +1862,33 @@
 		  ret = rip_auth_md5 (packet, &from, ifp);
 		  if (! ret)
 		    {
+#ifdef BRCM_RIP_DEBUG
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_warn ("RIPv2 MD5 authentication failed");
 		      rip_peer_bad_packet (&from);
+#endif
+		      ri->recv_badpackets++;
 		      return -1;
 		    }
 		  else
 		    {
+#ifdef BRCM_RIP_DEBUG
 		      if (IS_RIP_DEBUG_EVENT)
 			zlog_info ("RIPv2 MD5 authentication success");
+#endif
 		    }
 		  /* Reset RIP packet length to trim MD5 data. */
 		  len = ret; 
                 }
 	      else
 		{
+#ifdef BRCM_RIP_DEBUG
 		  if (IS_RIP_DEBUG_EVENT)
 		    zlog_warn ("Unknown authentication type %d",
 			       ntohs (packet->rte->tag));
 		  rip_peer_bad_packet (&from);
+#endif
+		  ri->recv_badpackets++;
 		  return -1;
 		}
 	    }
@@ -1709,14 +1897,18 @@
 	      /* There is no authentication in the packet. */
 	      if (ri->auth_str || ri->key_chain)
 		{
+#ifdef BRCM_RIP_DEBUG
 		  if (IS_RIP_DEBUG_EVENT)
 		    zlog_warn ("RIPv2 authentication failed: no authentication in packet");
 		  rip_peer_bad_packet (&from);
+#endif
+		  ri->recv_badpackets++;
 		  return -1;
 		}
 	    }
 	}
     }
+#endif /* BRCM_AUTH_SUPPORT */
   
   /* Process each command. */
   switch (packet->command)
@@ -1730,18 +1922,27 @@
       break;
     case RIP_TRACEON:
     case RIP_TRACEOFF:
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("Obsolete command %s received, please sent it to routed", 
 		 lookup (rip_msg, packet->command));
       rip_peer_bad_packet (&from);
+#endif
+      ri->recv_badpackets++;
       break;
     case RIP_POLL_ENTRY:
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("Obsolete command %s received", 
 		 lookup (rip_msg, packet->command));
       rip_peer_bad_packet (&from);
+#endif
+      ri->recv_badpackets++;
       break;
     default:
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("Unknown RIP command %d received", packet->command);
       rip_peer_bad_packet (&from);
+#endif
+      ri->recv_badpackets++;
       break;
     }
 
@@ -1811,6 +2012,7 @@
       stream_putc (s, version);
       stream_putw (s, 0);
 
+#ifdef BRCM_AUTH_SUPPORT
       /* In case of we need RIPv2 authentication. */
       if (version == RIPv2 && ifp)
 	{
@@ -1855,6 +2057,7 @@
 		}
 	    }
 	}
+#endif /* BRCM_AUTH_SUPPORT */
     }
 
   /* Write routing table entry. */
@@ -1897,6 +2100,7 @@
   int num;
   int rtemax;
 
+#ifdef BRCM_RIP_DEBUG
   /* Logging output event. */
   if (IS_RIP_DEBUG_EVENT)
     {
@@ -1906,6 +2110,15 @@
 	zlog_info ("update routes on interface %s ifindex %d",
 		   ifp->name, ifp->ifindex);
     }
+#else
+  if (ripDebug) {
+    if (to)
+      syslog(LOG_DEBUG,"update routes to neighbor %s\n", inet_ntoa (to->sin_addr));
+    else
+      syslog(LOG_DEBUG,"rip_output_process(): update routes on interface %s ifindex %d\n",
+	     ifp->name, ifp->ifindex);
+  }
+#endif /* BRCM_RIP_DEBUG */
 
   /* Set output stream. */
   s = rip->obuf;
@@ -1917,7 +2130,8 @@
 
   /* Get RIP interface. */
   ri = ifp->info;
-    
+
+#ifdef BRCM_AUTH_SUPPORT    
   /* If output interface is in simple password authentication mode, we
      need space for authentication data.  */
   if (ri->auth_type == RIP_AUTH_SIMPLE_PASSWORD)
@@ -1945,6 +2159,7 @@
        if (ri->auth_str)
          rtemax -=1;
     }
+#endif /* BRCM_AUTH_SUPPORT */
 
   for (rp = route_top (rip->table); rp; rp = route_next (rp))
     if ((rinfo = rp->info) != NULL)
@@ -1958,25 +2173,28 @@
 	if (version == RIPv1)
 	  {
 	    memcpy (&classfull, &rp->p, sizeof (struct prefix_ipv4));
-
+#ifdef BRCM_RIP_DEBUG
 	    if (IS_RIP_DEBUG_PACKET)
 	      zlog_info("%s/%d before RIPv1 mask check ",
 			inet_ntoa (classfull.prefix), classfull.prefixlen);
-
+#endif
 	    apply_classful_mask_ipv4 (&classfull);
 	    p = &classfull;
-
+#ifdef BRCM_RIP_DEBUG
 	    if (IS_RIP_DEBUG_PACKET)
 	      zlog_info("%s/%d after RIPv1 mask check",
 			inet_ntoa (p->prefix), p->prefixlen);
+#endif
 	  }
 	else 
 	  p = (struct prefix_ipv4 *) &rp->p;
 
+#ifdef BRCM_LIST_SUPPORT
 	/* Apply output filters. */
 	ret = rip_outgoing_filter (p, ri);
 	if (ret < 0)
 	  continue;
+#endif
 
 	/* Changed route only output. */
 	if (route_type == rip_changed_route &&
@@ -1990,7 +2208,7 @@
 	    /* We perform split horizon for RIP and connected route. */
 	    if ((rinfo->type == ZEBRA_ROUTE_RIP ||
 		 rinfo->type == ZEBRA_ROUTE_CONNECT) &&
-		rinfo->ifindex == ifp->ifindex)
+		rinfo->ifindex == ifp->ifindex) 
 	      continue;
 	  }
 
@@ -2013,7 +2231,8 @@
 	    && rinfo->type != ZEBRA_ROUTE_CONNECT
 	    && rinfo->ifindex == ifp->ifindex)
 	  rinfo->nexthop_out = rinfo->nexthop;
-           
+
+#ifdef BRCM_LIST_SUPPORT           
 	/* Apply route map - continue, if deny */
 	if (rip->route_map[rinfo->type].name
 	    && rinfo->sub_type != RIP_ROUTE_INTERFACE)
@@ -2023,16 +2242,19 @@
 
 	    if (ret == RMAP_DENYMATCH) 
 	      {
+#ifdef BRCM_RIP_DEBUG
 		if (IS_RIP_DEBUG_PACKET)
 		  zlog_info ("%s/%d is filtered by route-map",
 			     inet_ntoa (p->prefix), p->prefixlen);
+#endif
 		continue;
 	      }
 	  }
-
+#endif /* BRCM_LIST_SUPPORT */
 	/* When route-map does not set metric. */
 	if (! rinfo->metric_set)
 	  {
+#ifdef BRCM_LIST_SUPPORT
 	    /* If redistribute metric is set. */
 	    if (rip->route_map[rinfo->type].metric_config
 		&& rinfo->metric != RIP_METRIC_INFINITY)
@@ -2041,35 +2263,41 @@
 	      }
 	    else
 	      {
+#endif /* BRCM_LIST_SUPPORT */
 		/* If the route is not connected or localy generated
 		   one, use default-metric value*/
 		if (rinfo->type != ZEBRA_ROUTE_RIP 
 		    && rinfo->type != ZEBRA_ROUTE_CONNECT
 		    && rinfo->metric != RIP_METRIC_INFINITY)
 		  rinfo->metric_out = rip->default_metric;
+#ifdef BRCM_LIST_SUPPORT
 	      }
+#endif
 	  }
 
+#ifdef BRCM_LIST_SUPPORT
 	/* Apply offset-list */
 	if (rinfo->metric != RIP_METRIC_INFINITY)
 	  rip_offset_list_apply_out (p, ifp, &rinfo->metric_out);
 
 	if (rinfo->metric_out > RIP_METRIC_INFINITY)
 	  rinfo->metric_out = RIP_METRIC_INFINITY;
-	  
+#endif	  
 	/* Write RTE to the stream. */
 	num = rip_write_rte (num, s, p, version, rinfo, to ? NULL : ifp);
 	if (num == rtemax)
 	  {
+#ifdef BRCM_AUTH_SUPPORT
 	    if (version == RIPv2 && ri->auth_type == RIP_AUTH_MD5)
 	      rip_auth_md5_set (s, ifp);
-
+#endif /* BRCM_AUTH_SUPPORT */
 	    ret = rip_send_packet (STREAM_DATA (s), stream_get_endp (s),
 				   to, ifp);
-
+#ifdef BRCM_RIP_DEBUG
 	    if (ret >= 0 && IS_RIP_DEBUG_SEND)
 	      rip_packet_dump ((struct rip_packet *)STREAM_DATA (s),
 			       stream_get_endp(s), "SEND");
+#endif
 	    num = 0;
 	    stream_reset (s);
 	  }
@@ -2078,14 +2306,17 @@
   /* Flush unwritten RTE. */
   if (num != 0)
     {
+#ifdef BRCM_AUTH_SUPPORT
       if (version == RIPv2 && ri->auth_type == RIP_AUTH_MD5)
 	rip_auth_md5_set (s, ifp);
+#endif /* BRCM_AUTH_SUPPORT */
 
       ret = rip_send_packet (STREAM_DATA (s), stream_get_endp (s), to, ifp);
-
+#ifdef BRCM_RIP_DEBUG
       if (ret >= 0 && IS_RIP_DEBUG_SEND)
 	rip_packet_dump ((struct rip_packet *)STREAM_DATA (s),
 			 stream_get_endp (s), "SEND");
+#endif
       num = 0;
       stream_reset (s);
     }
@@ -2103,12 +2334,16 @@
   listnode node;
   struct sockaddr_in to;
 
+  //brcm
+  struct prefix_ipv4 *src;
+
   /* When RIP version is 2 and multicast enable interface. */
   if (version == RIPv2 && if_is_multicast (ifp)) 
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("multicast announce on %s ", ifp->name);
-
+#endif
       rip_output_process (ifp, NULL, route_type, version);
       return;
     }
@@ -2124,22 +2359,55 @@
              address . */
 	  p = (struct prefix_ipv4 *) connected->destination;
 
+	  //brcm -- src and destination are the same, it's ipoa, send broadcast instead
+	  src = (struct prefix_ipv4 *) connected->address;
+
+	  if (IPV4_ADDR_SAME(&p->prefix, &src->prefix)) {
+#ifdef BRCM_RIP_DEBUG
+	    if (IS_RIP_DEBUG_EVENT)
+	      zlog_info ("update_intf():ifc->name %s, ptop->src %s, dest %s; do broadcast later",
+			 ifp->name,inet_ntoa(p->prefix),inet_ntoa(src->prefix));
+#endif
+	    continue;
+	  }
+	  //brcm
+
 	  if (p->family == AF_INET)
 	    {
 	      /* Destination address and port setting. */
 	      memset (&to, 0, sizeof (struct sockaddr_in));
 	      to.sin_addr = p->prefix;
 	      to.sin_port = htons (RIP_PORT_DEFAULT);
-
+#ifdef BRCM_RIP_DEBUG
 	      if (IS_RIP_DEBUG_EVENT)
 		zlog_info ("%s announce to %s on %s",
 			   if_is_pointopoint (ifp) ? "unicast" : "broadcast",
 			   inet_ntoa (to.sin_addr), ifp->name);
-
+#endif
 	      rip_output_process (ifp, &to, route_type, version);
+	      //brcm
+	      return;
 	    }
 	}
     }
+
+  //brcm (ptop IPoA doesn't have remote IP addr), we send broadcast (255.255.255.255)
+  if (version == RIPv1 && if_is_pointopoint(ifp)) 
+    {
+#ifdef BRCM_RIP_DEBUG
+      if (IS_RIP_DEBUG_EVENT)
+	zlog_info ("broadcast announce on %s ", ifp->name);
+#endif
+      memset (&to, 0, sizeof (struct sockaddr_in));
+      to.sin_addr.s_addr = htonl(0xffffffff);
+      to.sin_port = htons (RIP_PORT_DEFAULT);
+#ifdef BRCM_RIP_DEBUG
+      if (IS_RIP_DEBUG_EVENT)
+	zlog_info ("%s announce to %s on %s",
+		   "broadcast", inet_ntoa (to.sin_addr), ifp->name);
+#endif
+      rip_output_process (ifp, &to, route_type, version);
+    }
 }
 
 /* Update send to all interface and neighbor. */
@@ -2174,6 +2442,7 @@
 
       if (ri->running)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_RIP_DEBUG_EVENT) 
 	    {
 	      if (ifp->name) 
@@ -2183,7 +2452,7 @@
 		zlog_info ("SEND UPDATE to _unknown_ ifindex %d",
 			   ifp->ifindex);
 	    }
-
+#endif
 	  /* If there is no version configuration in the interface,
              use rip's version setting. */
 	  if (ri->ri_send == RI_RIP_UNSPEC)
@@ -2213,8 +2482,10 @@
 	ifp = if_lookup_address (p->prefix);
 	if (! ifp)
 	  {
+#ifdef BRCM_RIP_DEBUG
 	    zlog_warn ("Neighbor %s doesn't exist direct connected network",
 		       inet_ntoa (p->prefix));
+#endif
 	    continue;
 	  }
 
@@ -2235,8 +2506,10 @@
   /* Clear timer pointer. */
   rip->t_update = NULL;
 
+#ifdef BRCM_RIP_DEBUG
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("update timer fire!");
+#endif
 
   /* Process update output. */
   rip_update_process (rip_all_route);
@@ -2302,9 +2575,11 @@
     }
   rip->trigger = 0;
 
+#ifdef BRCM_RIP_DEBUG
   /* Logging triggered update. */
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("triggered update!");
+#endif
 
   /* Split Horizon processing is done when generating triggered
      updates as well as normal updates (see section 2.6). */
@@ -2397,7 +2672,6 @@
   struct rip_packet rip_packet;
 
   memset (&rip_packet, 0, sizeof (rip_packet));
-
   rip_packet.command = RIP_REQUEST;
   rip_packet.version = version;
   rte = rip_packet.rte;
@@ -2459,7 +2733,11 @@
       ret = rip_create ();
       if (ret < 0)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog_info ("Can't create RIP");
+#else
+	  syslog(LOG_ERR,"Can't create RIP\n");
+#endif
 	  return CMD_WARNING;
 	}
     }
@@ -2481,6 +2759,7 @@
   return CMD_SUCCESS;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 DEFUN (rip_version,
        rip_version_cmd,
        "version <1-2>",
@@ -2591,7 +2870,7 @@
 
   return CMD_SUCCESS;
 }
-
+#endif /* BRCM_CMD_SUPPORT */
 void
 rip_update_default_metric ()
 {
@@ -2852,6 +3131,7 @@
   p.prefix = rinfo->from;
   p.prefixlen = IPV4_MAX_BITLEN;
 
+#ifdef BRCM_LIST_SUPPORT
   /* Check source address. */
   rn = route_node_match (rip_distance_table, (struct prefix *) &p);
   if (rn)
@@ -2872,6 +3152,7 @@
       else
 	return rdistance->distance;
     }
+#endif
 
   if (rip->distance)
     return rip->distance;
@@ -2879,6 +3160,7 @@
   return 0;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 void
 rip_distance_show (struct vty *vty)
 {
@@ -2976,6 +3258,7 @@
   rip_distance_unset (vty, argv[0], argv[1], argv[2]);
   return CMD_SUCCESS;
 }
+
 
 /* Print out routes update time. */
 void
@@ -3179,11 +3462,13 @@
 
   return CMD_SUCCESS;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* RIP configuration write function. */
 int
 config_write_rip (struct vty *vty)
 {
+#ifdef BRCM_CMD_SUPPORT
   int write = 0;
   struct route_node *rn;
   struct rip_distance *rdistance;
@@ -3223,8 +3508,10 @@
       /* Redistribute configuration. */
       config_write_rip_redistribute (vty, 1);
 
+#ifdef BRCM_LIST_SUPPORT
       /* RIP offset-list configuration. */
       config_write_rip_offset_list (vty);
+#endif
 
       /* RIP enabled network and interface configuration. */
       config_write_rip_network (vty, 1);
@@ -3259,6 +3546,7 @@
 
     }
   return write;
+#endif /* BRCM_CMD_SUPPORT */
 }
 
 /* RIP node structure. */
@@ -3289,10 +3577,12 @@
 
   if (dist->list[DISTRIBUTE_IN])
     {
+#ifdef BRCM_LIST_SUPPORT
       alist = access_list_lookup (AFI_IP, dist->list[DISTRIBUTE_IN]);
       if (alist)
 	ri->list[RIP_FILTER_IN] = alist;
       else
+#endif
 	ri->list[RIP_FILTER_IN] = NULL;
     }
   else
@@ -3300,10 +3590,12 @@
 
   if (dist->list[DISTRIBUTE_OUT])
     {
+#ifdef BRCM_LIST_SUPPORT
       alist = access_list_lookup (AFI_IP, dist->list[DISTRIBUTE_OUT]);
       if (alist)
 	ri->list[RIP_FILTER_OUT] = alist;
       else
+#endif
 	ri->list[RIP_FILTER_OUT] = NULL;
     }
   else
@@ -3311,10 +3603,12 @@
 
   if (dist->prefix[DISTRIBUTE_IN])
     {
+#ifdef BRCM_LIST_SUPPORT
       plist = prefix_list_lookup (AFI_IP, dist->prefix[DISTRIBUTE_IN]);
       if (plist)
 	ri->prefix[RIP_FILTER_IN] = plist;
       else
+#endif
 	ri->prefix[RIP_FILTER_IN] = NULL;
     }
   else
@@ -3322,10 +3616,12 @@
 
   if (dist->prefix[DISTRIBUTE_OUT])
     {
+#ifdef BRCM_LIST_SUPPORT
       plist = prefix_list_lookup (AFI_IP, dist->prefix[DISTRIBUTE_OUT]);
       if (plist)
 	ri->prefix[RIP_FILTER_OUT] = plist;
       else
+#endif
 	ri->prefix[RIP_FILTER_OUT] = NULL;
     }
   else
@@ -3437,7 +3733,9 @@
 
   rip_clean_network ();
   rip_passive_interface_clean ();
+#ifdef BRCM_LIST_SUPPORT
   rip_offset_clean ();
+#endif
   rip_interface_clean ();
   rip_distance_reset ();
   rip_redistribute_clean ();
@@ -3452,13 +3750,16 @@
   rip_global_queries = 0;
 
   /* Call ripd related reset functions. */
+#ifdef BRCM_RIP_DEBUG
   rip_debug_reset ();
+#endif
+#ifdef BRCM_LIST_SUPPORT
   rip_route_map_reset ();
-
   /* Call library reset functions. */
   vty_reset ();
   access_list_reset ();
   prefix_list_reset ();
+#endif /* BRCM_LIST_SUPPORT */
 
   distribute_list_reset ();
 
@@ -3478,16 +3779,21 @@
   /* Install top nodes. */
   install_node (&rip_node, config_write_rip);
 
+#ifdef BRCM_CMD_SUPPORT
   /* Install rip commands. */
   install_element (VIEW_NODE, &show_ip_rip_cmd);
   install_element (VIEW_NODE, &show_ip_protocols_rip_cmd);
   install_element (ENABLE_NODE, &show_ip_rip_cmd);
   install_element (ENABLE_NODE, &show_ip_protocols_rip_cmd);
+#endif /* BRCM_CMD_SUPPORT */
   install_element (CONFIG_NODE, &router_rip_cmd);
   install_element (CONFIG_NODE, &no_router_rip_cmd);
-
   install_default (RIP_NODE);
+#ifdef BRCM_CMD_SUPPORT
   install_element (RIP_NODE, &rip_version_cmd);
+#endif
+
+#ifdef BRCM_CMD_SUPPORT
   install_element (RIP_NODE, &no_rip_version_cmd);
   install_element (RIP_NODE, &no_rip_version_val_cmd);
   install_element (RIP_NODE, &rip_default_metric_cmd);
@@ -3503,19 +3809,26 @@
   install_element (RIP_NODE, &no_rip_distance_source_cmd);
   install_element (RIP_NODE, &rip_distance_source_access_list_cmd);
   install_element (RIP_NODE, &no_rip_distance_source_access_list_cmd);
+#endif /* BRCM_CMD_SUPPORT */
 
+#ifdef BRCM_RIP_DEBUG
   /* Debug related init. */
   rip_debug_init ();
-
+#endif /* BRCM_RIP_DEBUG */
+   
+#ifdef BRCM_LIST_SUPPORT
   /* Filter related init. */
   rip_route_map_init ();
+
   rip_offset_init ();
+#endif
 
   /* SNMP init. */
 #ifdef HAVE_SNMP
   rip_snmp_init ();
 #endif /* HAVE_SNMP */
 
+#ifdef BRCM_LIST_SUPPORT
   /* Access list install. */
   access_list_init ();
   access_list_add_hook (rip_distribute_update_all);
@@ -3525,6 +3838,7 @@
   prefix_list_init ();
   prefix_list_add_hook (rip_distribute_update_all);
   prefix_list_delete_hook (rip_distribute_update_all);
+#endif /* BRCM_LIST_SUPPORT */
 
   /* Distribute list install. */
   distribute_list_init (RIP_NODE);
@@ -3534,3 +3848,29 @@
   /* Distance control. */
   rip_distance_table = route_table_init ();
 }
+
+void
+rip_dump_stats()
+{
+  struct interface *ifp;
+  struct rip_interface *ri;
+  listnode node;
+
+  if (rip) {
+    printf("\n");
+    for (node = listhead (iflist); node; nextnode (node)) {
+      ifp = getdata (node);
+      if (ifp) {
+	ri = ifp->info;
+	if (ri && ri->running) {
+	  printf("interface %s: recv_updates %d, recv_badpackets %d, recv_badroutes %d, sent_updates %d\n",
+		 ifp->name,ri->recv_updates,ri->recv_badpackets,ri->recv_badroutes,ri->sent_updates);
+	  syslog(LOG_DEBUG,"%s: recv_updates %d, recv_badpackets %d, recv_badroutes %d, sent_updates %d\n",
+		 ifp->name,ri->recv_updates,ri->recv_badpackets,ri->recv_badroutes,ri->sent_updates);
+	} /* ri */
+      } /* ifp */
+    } /* for */
+  }
+  else
+    printf("rip is not running.\n");
+}
diff -Naur zebra/ripd/rip_debug.c zebra-brcm/ripd/rip_debug.c
--- zebra/ripd/rip_debug.c	2001-10-24 07:04:48.000000000 -0300
+++ zebra-brcm/ripd/rip_debug.c	2018-11-23 18:54:26.960999909 -0400
@@ -19,6 +19,8 @@
  * 02111-1307, USA.  
  */
 
+#ifdef BRCM_RIP_DEBUG
+
 #include <zebra.h>
 #include "command.h"
 #include "ripd/rip_debug.h"
@@ -267,7 +269,9 @@
 
   install_node (&debug_node, config_write_debug);
 
+#ifdef BRCM_CMD_SUPPORT
   install_element (ENABLE_NODE, &show_debugging_rip_cmd);
+#endif
   install_element (ENABLE_NODE, &debug_rip_events_cmd);
   install_element (ENABLE_NODE, &debug_rip_packet_cmd);
   install_element (ENABLE_NODE, &debug_rip_packet_direct_cmd);
@@ -288,3 +292,4 @@
   install_element (CONFIG_NODE, &no_debug_rip_packet_direct_cmd);
   install_element (CONFIG_NODE, &no_debug_rip_zebra_cmd);
 }
+#endif /* RIP_DEBUG */
diff -Naur zebra/ripd/rip_debug.h zebra-brcm/ripd/rip_debug.h
--- zebra/ripd/rip_debug.h	2000-07-05 17:12:36.000000000 -0300
+++ zebra-brcm/ripd/rip_debug.h	2018-11-23 18:54:26.960999909 -0400
@@ -35,6 +35,7 @@
 #define RIP_DEBUG_ZEBRA   0x01
 
 /* Debug related macro. */
+#ifdef BRCM_RIP_DEBUG
 #define IS_RIP_DEBUG_EVENT  (rip_debug_event & RIP_DEBUG_EVENT)
 
 #define IS_RIP_DEBUG_PACKET (rip_debug_packet & RIP_DEBUG_PACKET)
@@ -44,6 +45,16 @@
 
 #define IS_RIP_DEBUG_ZEBRA  (rip_debug_zebra & RIP_DEBUG_ZEBRA)
 
+#else
+#define IS_RIP_DEBUG_PACKET 0
+#define IS_RIP_DEBUG_SEND   0
+#define IS_RIP_DEBUG_RECV   0
+#define IS_RIP_DEBUG_DETAIL 0
+
+#define IS_RIP_DEBUG_ZEBRA  0
+
+#endif /* BRCM_RIP_DEBUG */
+
 extern unsigned long rip_debug_event;
 extern unsigned long rip_debug_packet;
 extern unsigned long rip_debug_zebra;
diff -Naur zebra/ripd/ripd.h zebra-brcm/ripd/ripd.h
--- zebra/ripd/ripd.h	2001-01-27 05:24:23.000000000 -0400
+++ zebra-brcm/ripd/ripd.h	2018-11-23 18:54:26.964999801 -0400
@@ -261,6 +261,7 @@
   int recv_badpackets;
   int recv_badroutes;
   int sent_updates;
+  int recv_updates;
 
   /* Passive interface. */
   int passive;
@@ -395,6 +396,10 @@
 void rip_ifaddr_add (struct interface *, struct connected *);
 void rip_ifaddr_delete (struct interface *, struct connected *);
 
+//brcm
+void rip_dump_stats();
+extern u_char ripDebug;
+
 /* There is only one rip strucutre. */
 extern struct rip *rip;
 
diff -Naur zebra/ripd/rip_interface.c zebra-brcm/ripd/rip_interface.c
--- zebra/ripd/rip_interface.c	2001-10-03 09:16:04.000000000 -0300
+++ zebra-brcm/ripd/rip_interface.c	2018-11-23 18:54:26.960999909 -0400
@@ -77,9 +77,10 @@
 				   ifindex); 
 
   if (ret < 0) 
+#ifdef BRCM_RIP_DEBUG
     zlog (NULL, LOG_INFO, "can't setsockopt IP_ADD_MEMBERSHIP %s",
 	  strerror (errno));
-
+#endif
   return ret;
 }
 
@@ -99,7 +100,9 @@
 				   ifindex);
 
   if (ret < 0) 
+#ifdef BRCM_RIP_DEBUG
     zlog (NULL, LOG_INFO, "can't setsockopt IP_DROP_MEMBERSHIP");
+#endif
 
   return ret;
 }
@@ -115,8 +118,12 @@
 
   /* Default authentication type is simple password for Cisco
      compatibility. */
+#if !defined(BRCM_AUTH_SUPPORT)
+  ri->auth_type = RIP_NO_AUTH; 
+#else
   /* ri->auth_type = RIP_NO_AUTH; */
   ri->auth_type = RIP_AUTH_SIMPLE_PASSWORD;
+#endif
 
   /* Set default split-horizon behavior.  If the interface is Frame
      Relay or SMDS is enabled, the default value for split-horizon is
@@ -152,7 +159,9 @@
 	  if (setsockopt_multicast_ipv4 (sock, IP_MULTICAST_IF,
 					 addr, 0, ifp->ifindex) < 0) 
 	    {
+#ifdef BRCM_RIP_DEBUG
 	      zlog_warn ("Can't setsockopt IP_MULTICAST_IF to fd %d", sock);
+#endif
 	      return;
 	    }
 
@@ -177,7 +186,9 @@
 		      sizeof (struct sockaddr_in));
 	  if (ret < 0)
 	    {
+#ifdef BRCM_RIP_DEBUG
 	      zlog_warn ("Can't bind socket: %s", strerror (errno));
+#endif
 	      return;
 	    }
 
@@ -196,10 +207,10 @@
   /* RIPv2 support multicast. */
   if (version == RIPv2 && if_is_multicast (ifp))
     {
-      
+#ifdef BRCM_RIP_DEBUG      
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("multicast request on %s", ifp->name);
-
+#endif
       rip_request_send (NULL, ifp, version);
       return;
     }
@@ -208,10 +219,10 @@
   if (if_is_pointopoint (ifp) || if_is_broadcast (ifp))
     {
       listnode cnode;
-
+#ifdef BRCM_RIP_DEBUG
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("broadcast request to %s", ifp->name);
-
+#endif
       for (cnode = listhead (ifp->connected); cnode; nextnode (cnode))
 	{
 	  struct prefix_ipv4 *p;
@@ -274,6 +285,7 @@
     }
 }
 
+#ifdef BRCM_CMD_SUPPORT
 /* Send RIP request to the neighbor. */
 void
 rip_request_neighbor (struct in_addr addr)
@@ -296,14 +308,16 @@
   if (! rip)
     return;
 
+#ifdef BRCM_RIP_DEBUG
   if (IS_RIP_DEBUG_EVENT)
     zlog_info ("request to the all neighbor");
-
+#endif
   /* Send request to all neighbor. */
   for (rp = route_top (rip->neighbor); rp; rp = route_next (rp))
     if (rp->info)
       rip_request_neighbor (rp->p.u.prefix4);
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Multicast packet receive socket. */
 int
@@ -313,9 +327,10 @@
 
   if (if_is_up (ifp) && if_is_multicast (ifp))
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("multicast join at %s", ifp->name);
-
+#endif
       for (cnode = listhead (ifp->connected); cnode; nextnode (cnode))
 	{
 	  struct prefix_ipv4 *p;
@@ -346,9 +361,10 @@
 
   if (if_is_up (ifp) && if_is_multicast (ifp))
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_RIP_DEBUG_EVENT)
 	zlog_info ("multicast leave from %s", ifp->name);
-
+#endif
       for (cnode = listhead (ifp->connected); cnode; nextnode (cnode))
 	{
 	  struct prefix_ipv4 *p;
@@ -391,9 +407,7 @@
 						
   return count;
 }
-						
-						
-						
+
 
 /* Does this address belongs to me ? */
 int
@@ -433,6 +447,8 @@
   listnode node;
   struct connected *connected = NULL;
   struct prefix_ipv4 *p;
+  //brcm
+  struct prefix_ipv4 *src;
 
   for (node = listhead (iflist); node; nextnode (node))
     {
@@ -452,6 +468,18 @@
 	    {
 	      p = (struct prefix_ipv4 *) connected->address;
 
+	      //brcm -- src and destination are the same, it's ipoa, 
+	      src = (struct prefix_ipv4 *) connected->destination;
+	      if (IPV4_ADDR_SAME(&p->prefix, &src->prefix)) {
+#ifdef BRCM_RIP_DEBUG
+		if (IS_RIP_DEBUG_EVENT)
+		  zlog_info ("valid_neigh():ifc->name %s, ptop->src %s, dest %s; do broadcast later",
+			     ifp->name,inet_ntoa(p->prefix),inet_ntoa(src->prefix));
+#endif
+		return 1;
+	      }
+	      //brcm
+
 	      if (p && p->family == AF_INET)
 		{
 		  if (IPV4_ADDR_SAME (&p->prefix, &addr))
@@ -509,11 +537,11 @@
     return 0;
 
   rip_if_down(ifp);
- 
+#ifdef BRCM_RIP_DEBUG 
   if (IS_RIP_DEBUG_ZEBRA)
     zlog_info ("interface %s index %d flags %ld metric %d mtu %d is down",
 	       ifp->name, ifp->ifindex, ifp->flags, ifp->metric, ifp->mtu);
-
+#endif
   return 0;
 }
 
@@ -530,10 +558,11 @@
   if (ifp == NULL)
     return 0;
 
+#ifdef BRCM_RIP_DEBUG
   if (IS_RIP_DEBUG_ZEBRA)
     zlog_info ("interface %s index %d flags %ld metric %d mtu %d is up",
 	       ifp->name, ifp->ifindex, ifp->flags, ifp->metric, ifp->mtu);
-
+#endif
   /* Check if this interface is RIP enabled or not.*/
   rip_enable_apply (ifp);
  
@@ -554,10 +583,11 @@
 
   ifp = zebra_interface_add_read (zclient->ibuf);
 
+#ifdef BRCM_RIP_DEBUG
   if (IS_RIP_DEBUG_ZEBRA)
     zlog_info ("interface add %s index %d flags %ld metric %d mtu %d",
 	       ifp->name, ifp->ifindex, ifp->flags, ifp->metric, ifp->mtu);
-
+#endif
   /* Check if this interface is RIP enabled or not.*/
   rip_enable_apply (ifp);
 
@@ -587,10 +617,10 @@
   if (if_is_up (ifp)) {
     rip_if_down(ifp);
   } 
-  
+#ifdef BRCM_RIP_DEBUG  
   zlog_info("interface delete %s index %d flags %ld metric %d mtu %d",
 	    ifp->name, ifp->ifindex, ifp->flags, ifp->metric, ifp->mtu);  
-  
+#endif  
   /* To support pseudo interface do not free interface structure.  */
   /* if_delete(ifp); */
 
@@ -640,8 +670,12 @@
       ri->ri_send = RI_RIP_UNSPEC;
       ri->ri_receive = RI_RIP_UNSPEC;
 
+#if !defined(BRCM_AUTH_SUPPORT)
+      ri->auth_type = RIP_NO_AUTH;
+#else
       /* ri->auth_type = RIP_NO_AUTH; */
       ri->auth_type = RIP_AUTH_SIMPLE_PASSWORD;
+#endif
 
       if (ri->auth_str)
 	{
@@ -654,8 +688,10 @@
 	  ri->key_chain = NULL;
 	}
 
-      ri->split_horizon = 0;
-      ri->split_horizon_default = 0;
+      /* brcm - bug fix, split_horizon is default to 1 to begin with, after reset, it should 
+         remain 1; not 0. */
+      ri->split_horizon = 1;
+      ri->split_horizon_default = 1;
 
       ri->list[RIP_FILTER_IN] = NULL;
       ri->list[RIP_FILTER_OUT] = NULL;
@@ -718,9 +754,10 @@
   
   if (ri->running)
    {
+#ifdef BRCM_RIP_DEBUG
      if (IS_RIP_DEBUG_EVENT)
        zlog_info ("turn off %s", ifp->name);
-
+#endif
      /* Leave from multicast group. */
      rip_multicast_leave (ifp, rip->sock);
 
@@ -760,10 +797,11 @@
 
   if (p->family == AF_INET)
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_RIP_DEBUG_ZEBRA)
 	zlog_info ("connected address %s/%d is added", 
 		   inet_ntoa (p->u.prefix4), p->prefixlen);
-      
+#endif      
       /* Check is this interface is RIP enabled or not.*/
       rip_enable_apply (ifc->ifp);
 
@@ -789,10 +827,12 @@
       p = ifc->address;
       if (p->family == AF_INET)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_RIP_DEBUG_ZEBRA)
 
 	    zlog_info ("connected address %s/%d is deleted",
 		       inet_ntoa (p->u.prefix4), p->prefixlen);
+#endif
 
 #ifdef HAVE_SNMP
 	  rip_ifaddr_delete (ifc->ifp, ifc);
@@ -947,7 +987,9 @@
   /* Join to multicast group. */
   if (rip_multicast_join (ifp, rip->sock) < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_err ("multicast join failed, interface %s not running", ifp->name);
+#endif
       return 0;
     }
 
@@ -1041,9 +1083,10 @@
     {
       if (! ri->running)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_RIP_DEBUG_EVENT)
 	    zlog_info ("turn on %s", ifp->name);
-
+#endif
 	  /* Add interface wake up thread. */
 	  if (! ri->t_wakeup)
 	    ri->t_wakeup = thread_add_timer (master, rip_interface_wakeup,
@@ -1055,9 +1098,10 @@
     {
       if (ri->running)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_RIP_DEBUG_EVENT)
 	    zlog_info ("turn off %s", ifp->name);
-
+#endif
 	  /* Might as well clean up the route table as well */ 
 	  rip_if_down(ifp);
 
@@ -1101,7 +1145,7 @@
     }
   return 0;
 }
-
+#ifdef BRCM_CMD_SUPPORT
 /* Add new RIP neighbor to the neighbor tree. */
 int
 rip_neighbor_add (struct prefix_ipv4 *p)
@@ -1139,6 +1183,7 @@
 
   return 0;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Clear all network and neighbor configuration. */
 void
@@ -1188,9 +1233,9 @@
   ri = ifp->info;
 
   ret = rip_passive_interface_lookup (ifp->name);
-  if (ret < 0)
+  if (ret < 0) 
     ri->passive = 0;
-  else
+  else 
     ri->passive = 1;
 }
 
@@ -1211,7 +1256,7 @@
 int
 rip_passive_interface_set (struct vty *vty, char *ifname)
 {
-  if (rip_passive_interface_lookup (ifname) >= 0)
+  if (rip_passive_interface_lookup (ifname) >= 0) 
     return CMD_WARNING;
 
   vector_set (Vrip_passive_interface, strdup (ifname));
@@ -1269,9 +1314,9 @@
 
   ret = str2prefix_ipv4 (argv[0], &p);
 
-  if (ret)
+  if (ret) 
     ret = rip_enable_network_add ((struct prefix *) &p);
-  else
+  else 
     ret = rip_enable_if_add (argv[0]);
 
   if (ret < 0)
@@ -1317,6 +1362,7 @@
   return CMD_SUCCESS;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 /* RIP neighbor configuration set. */
 DEFUN (rip_neighbor,
        rip_neighbor_cmd,
@@ -1363,6 +1409,7 @@
   
   return CMD_SUCCESS;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 DEFUN (ip_rip_receive_version,
        ip_rip_receive_version_cmd,
@@ -1568,6 +1615,7 @@
        "Version 1\n"
        "Version 2\n")
 
+#if defined(BRCM_AUTH_SUPPORT) && defined(BRCM_CMD_SUPPORT)
 DEFUN (ip_rip_authentication_mode,
        ip_rip_authentication_mode_cmd,
        "ip rip authentication mode (md5|text)",
@@ -1612,9 +1660,12 @@
   ifp = (struct interface *)vty->index;
   ri = ifp->info;
 
+#if !defined(BRCM_AUTH_SUPPORT)
+  ri->auth_type = RIP_NO_AUTH;
+#else
   /* ri->auth_type = RIP_NO_AUTH; */
   ri->auth_type = RIP_AUTH_SIMPLE_PASSWORD;
-
+#endif
   return CMD_SUCCESS;
 }
 
@@ -1760,7 +1811,9 @@
        "Authentication control\n"
        "Authentication key-chain\n"
        "name of key-chain\n")
+#endif /* defined(BRCM_AUTH_SUPPORT) && defined(BRCM_CMD_SUPPORT) */
 
+#ifdef BRCM_CMD_SUPPORT
 DEFUN (rip_split_horizon,
        rip_split_horizon_cmd,
        "ip split-horizon",
@@ -1793,6 +1846,7 @@
   ri->split_horizon = 0;
   return CMD_SUCCESS;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 DEFUN (rip_passive_interface,
        rip_passive_interface_cmd,
@@ -1812,11 +1866,13 @@
 {
   return rip_passive_interface_unset (vty, argv[0]);
 }
+
 
 /* Write rip configuration of each interface. */
 int
 rip_interface_config_write (struct vty *vty)
 {
+#ifdef BRCM_CMD_SUPPORT
   listnode node;
   struct interface *ifp;
 
@@ -1845,14 +1901,18 @@
 
       /* RIP version setting. */
       if (ri->ri_send != RI_RIP_UNSPEC)
+#ifdef BRCM_RIP_DEBUG
 	vty_out (vty, " ip rip send version %s%s",
 		 lookup (ri_version_msg, ri->ri_send),
 		 VTY_NEWLINE);
+#endif
 
       if (ri->ri_receive != RI_RIP_UNSPEC)
+#ifdef BRCM_RIP_DEBUG
 	vty_out (vty, " ip rip receive version %s%s",
 		 lookup (ri_version_msg, ri->ri_receive),
 		 VTY_NEWLINE);
+#endif
 
       /* RIP authentication. */
 #if 0 
@@ -1873,12 +1933,14 @@
 
       vty_out (vty, "!%s", VTY_NEWLINE);
     }
+#endif
   return 0;
 }
 
 int
 config_write_rip_network (struct vty *vty, int config_mode)
 {
+#ifdef BRCM_CMD_SUPPORT
   int i;
   char *ifname;
   struct route_node *node;
@@ -1913,6 +1975,7 @@
     for (i = 0; i < vector_max (Vrip_passive_interface); i++)
       if ((ifname = vector_slot (Vrip_passive_interface, i)) != NULL)
 	vty_out (vty, " passive-interface %s%s", ifname, VTY_NEWLINE);
+#endif /* BRCM_CMD_SUPPORT */
 
   return 0;
 }
@@ -1962,12 +2025,18 @@
   /* Install commands. */
   install_element (CONFIG_NODE, &interface_cmd);
   install_default (INTERFACE_NODE);
+#ifdef BRCM_CMD_SUPPORT
   install_element (INTERFACE_NODE, &interface_desc_cmd);
   install_element (INTERFACE_NODE, &no_interface_desc_cmd);
+#endif
+
   install_element (RIP_NODE, &rip_network_cmd);
   install_element (RIP_NODE, &no_rip_network_cmd);
+
+#ifdef BRCM_CMD_SUPPORT
   install_element (RIP_NODE, &rip_neighbor_cmd);
   install_element (RIP_NODE, &no_rip_neighbor_cmd);
+#endif
 
   install_element (RIP_NODE, &rip_passive_interface_cmd);
   install_element (RIP_NODE, &no_rip_passive_interface_cmd);
@@ -1984,6 +2053,7 @@
   install_element (INTERFACE_NODE, &no_ip_rip_receive_version_cmd);
   install_element (INTERFACE_NODE, &no_ip_rip_receive_version_num_cmd);
 
+#if defined(BRCM_CMD_SUPPORT) && defined(BRCM_AUTH_SUPPORT)
   install_element (INTERFACE_NODE, &ip_rip_authentication_mode_cmd);
   install_element (INTERFACE_NODE, &no_ip_rip_authentication_mode_cmd);
   install_element (INTERFACE_NODE, &no_ip_rip_authentication_mode_type_cmd);
@@ -1998,4 +2068,5 @@
 
   install_element (INTERFACE_NODE, &rip_split_horizon_cmd);
   install_element (INTERFACE_NODE, &no_rip_split_horizon_cmd);
+#endif /* BRCM_CMD_SUPPORT */
 }
diff -Naur zebra/ripd/rip_main.c zebra-brcm/ripd/rip_main.c
--- zebra/ripd/rip_main.c	2002-06-21 17:18:41.000000000 -0300
+++ zebra-brcm/ripd/rip_main.c	2018-11-23 18:54:26.964999801 -0400
@@ -33,6 +33,9 @@
 
 #include "ripd/ripd.h"
 
+#include "cms_msg.h"
+static void *msgHandle=NULL;
+
 /* ripd options. */
 static struct option longopts[] = 
 {
@@ -121,16 +124,21 @@
 void 
 sighup (int sig)
 {
+#ifdef BRCM_RIP_DEBUG
   zlog_info ("SIGHUP received");
+#endif
   rip_clean ();
   rip_reset ();
+#ifdef BRCM_RIP_DEBUG
   zlog_info ("ripd restarting!");
-
+#endif
   /* Reload config file. */
   vty_read_config (config_file, config_current, config_default);
 
+#ifdef BRCM_CMD_SUPPORT
   /* Create VTY's socket */
   vty_serv_sock (vty_addr, vty_port, RIP_VTYSH_PATH);
+#endif
 
   /* Try to return to normal operation. */
 }
@@ -139,8 +147,9 @@
 void
 sigint (int sig)
 {
+#ifdef BRCM_RIP_DEBUG
   zlog (NULL, LOG_INFO, "Terminating on signal");
-
+#endif
   if (! retain_mode)
     rip_clean ();
 
@@ -151,23 +160,62 @@
 void
 sigusr1 (int sig)
 {
+#ifdef BRCM_RIP_DEBUG
   zlog_rotate (NULL);
+#endif
+}
+
+/* SIGUSR2 handler. */
+void
+sigusr2 (int sig)
+{
+  rip_dump_stats();
+}
+
+void
+sigalrm (int sig)
+{
+  if (ripDebug) {
+    ripDebug=0;
+    printf("***ripDebug off***\n");
+  }
+  else {
+    ripDebug=1;
+    printf("***ripDebug on***\n");
+  }
 }
 
 /* Initialization of signal handles. */
 void
 signal_init ()
 {
+   /*
+    * detach from the terminal so we don't catch the user typing control-c.
+    */
+   if (setsid() == -1)
+   {
+      printf("Could not detach from terminal");
+   }
+   
   signal_set (SIGHUP, sighup);
   signal_set (SIGINT, sigint);
   signal_set (SIGTERM, sigint);
   signal_set (SIGPIPE, SIG_IGN);
   signal_set (SIGUSR1, sigusr1);
+  //brcm: usr2 is used to signal display global RIP stats
+  signal_set (SIGUSR2, sigusr2); 
+  //brcm: alrm is used to toggle ripDebug flag
+  signal_set (SIGALRM, sigalrm);
 }
 
 /* Main routine of ripd. */
+#ifdef BUILD_STATIC
+int
+ripd_main (int argc, char **argv)
+#else
 int
 main (int argc, char **argv)
+#endif
 {
   char *p;
   int daemon_mode = 0;
@@ -180,9 +228,13 @@
   /* Get program name. */
   progname = ((p = strrchr (argv[0], '/')) ? ++p : argv[0]);
 
+#ifdef BRCM_RIP_DEBUG
   /* First of all we need logging init. */
   zlog_default = openzlog (progname, ZLOG_NOLOG, ZLOG_RIP,
 			   LOG_CONS|LOG_NDELAY|LOG_PID, LOG_DAEMON);
+#else
+  openlog (progname, LOG_CONS|LOG_NDELAY|LOG_PID, LOG_DAEMON);
+#endif
 
   /* Command line option parse. */
   while (1) 
@@ -217,7 +269,9 @@
 	  retain_mode = 1;
 	  break;
 	case 'v':
+#ifdef BRCM_CMD_SUPPORT
 	  print_version (progname);
+#endif
 	  exit (0);
 	  break;
 	case 'h':
@@ -229,6 +283,9 @@
 	}
     }
 
+  /* initialize the message pipe with smd */
+  cmsMsg_init(EID_RIPD, &msgHandle);
+  
   /* Prepare master thread. */
   master = thread_master_create ();
 
@@ -236,33 +293,48 @@
   signal_init ();
   cmd_init (1);
   vty_init ();
+#ifdef BRCM_CMD_SUPPORT
   memory_init ();
+#endif
+#ifdef BRCM_AUTH_SUPPORT
   keychain_init ();
+#endif
 
   /* RIP related initialization. */
   rip_init ();
   rip_if_init ();
   rip_zclient_init ();
+#ifdef BRCM_RIP_DEBUG
   rip_peer_init ();
+#endif
 
+  //#if defined(BRCM_CMD_SUPPORT)
   /* Sort all installed commands. */
   sort_node ();
 
   /* Get configuration file. */
   vty_read_config (config_file, config_current, config_default);
+  //#endif
 
   /* Change to the daemon program. */
+  /* BRCM begin */
   if (daemon_mode)
-    daemon (0, 0);
+    /*    daemon (0, 0); */
+#if !defined(__UCLIBC__) || defined(__UCLIBC_HAS_MMU__)
+    if (daemon(0, 1) < 0)
+      printf("daemon failed\n");
+#endif
+  /* BRCM end */
 
   /* Pid file create. */
   pid_output (pid_file);
-
+#ifdef BRCM_CMD_SUPPORT
   /* Create VTY's socket */
   vty_serv_sock (vty_addr, vty_port, RIP_VTYSH_PATH);
+#endif /* BRCM_CMD_SUPPORT */
 
   /* Execute each thread. */
-  while (thread_fetch (master, &thread))
+  while (thread_fetch (master, &thread)) 
     thread_call (&thread);
 
   /* Not reached. */
diff -Naur zebra/ripd/rip_offset.c zebra-brcm/ripd/rip_offset.c
--- zebra/ripd/rip_offset.c	2001-08-12 00:53:09.000000000 -0300
+++ zebra-brcm/ripd/rip_offset.c	2018-11-23 18:54:26.964999801 -0400
@@ -19,6 +19,8 @@
  * 02111-1307, USA.  
  */
 
+#ifdef BRCM_LIST_SUPPORT
+
 #include <zebra.h>
 
 #include "if.h"
@@ -358,10 +360,12 @@
   rip_offset_list_master->cmp = (int (*)(void *, void *)) offset_list_cmp;
   rip_offset_list_master->del = (void (*)(void *)) offset_list_del;
 
+#ifdef BRCM_CMD_SUPPORT
   install_element (RIP_NODE, &rip_offset_list_cmd);
   install_element (RIP_NODE, &rip_offset_list_ifname_cmd);
   install_element (RIP_NODE, &no_rip_offset_list_cmd);
   install_element (RIP_NODE, &no_rip_offset_list_ifname_cmd);
+#endif
 }
 
 void
@@ -412,3 +416,5 @@
 
   return 0;
 }
+
+#endif /* BRCM_LIST_SUPPORT */
diff -Naur zebra/ripd/rip_peer.c zebra-brcm/ripd/rip_peer.c
--- zebra/ripd/rip_peer.c	2000-10-17 10:09:10.000000000 -0300
+++ zebra-brcm/ripd/rip_peer.c	2018-11-23 18:54:26.964999801 -0400
@@ -18,7 +18,7 @@
  * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  * 02111-1307, USA.  
  */
-
+#ifdef BRCM_RIP_DEBUG
 #include <zebra.h>
 
 #include "if.h"
@@ -209,3 +209,4 @@
   peer_list = list_new ();
   peer_list->cmp = (int (*)(void *, void *)) rip_peer_list_cmp;
 }
+#endif /* BRCM_RIP_DEBUG */
diff -Naur zebra/ripd/rip_routemap.c zebra-brcm/ripd/rip_routemap.c
--- zebra/ripd/rip_routemap.c	2001-08-12 00:53:09.000000000 -0300
+++ zebra-brcm/ripd/rip_routemap.c	2018-11-23 18:54:26.964999801 -0400
@@ -18,6 +18,7 @@
  * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  * 02111-1307, USA.  
  */
+#ifdef BRCM_LIST_SUPPORT
 
 #include <zebra.h>
 
@@ -870,6 +871,7 @@
   route_map_install_set (&route_set_metric_cmd);
   route_map_install_set (&route_set_ip_nexthop_cmd);
 
+#ifdef BRCM_CMD_SUPPORT
   install_element (RMAP_NODE, &match_metric_cmd);
   install_element (RMAP_NODE, &no_match_metric_cmd);
   install_element (RMAP_NODE, &no_match_metric_val_cmd);
@@ -895,4 +897,6 @@
   install_element (RMAP_NODE, &set_ip_nexthop_cmd);
   install_element (RMAP_NODE, &no_set_ip_nexthop_cmd);
   install_element (RMAP_NODE, &no_set_ip_nexthop_val_cmd);
+#endif
 }
+#endif /* BRCM_LIST_SUPPORT */
diff -Naur zebra/ripd/rip_zebra.c zebra-brcm/ripd/rip_zebra.c
--- zebra/ripd/rip_zebra.c	2001-09-14 17:50:21.000000000 -0300
+++ zebra-brcm/ripd/rip_zebra.c	2018-11-23 18:54:26.964999801 -0400
@@ -152,6 +152,7 @@
   zclient_reset (zclient);
 }
 
+#ifdef BRCM_LIST_SUPPORT
 /* RIP route-map set for redistribution */
 void
 rip_routemap_set (int type, char *name)
@@ -196,7 +197,9 @@
 
   return 0;
 }
+#endif /* BRCM_LIST_SUPPORT */
 
+
 /* Redistribution types */
 static struct {
   int type;
@@ -211,6 +214,7 @@
   {0, 0, NULL}
 };
 
+#ifdef BRCM_CMD_SUPPORT
 DEFUN (router_zebra,
        router_zebra_cmd,
        "router zebra",
@@ -234,6 +238,7 @@
   zclient_stop (zclient);
   return CMD_SUCCESS;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 int
 rip_redistribute_set (int type)
@@ -249,6 +254,7 @@
   return CMD_SUCCESS;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 int
 rip_redistribute_unset (int type)
 {
@@ -265,6 +271,7 @@
 
   return CMD_SUCCESS;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 int
 rip_redistribute_check (int type)
@@ -293,6 +300,7 @@
     }
 }
 
+#ifdef BRCM_CMD_SUPPORT
 DEFUN (rip_redistribute_rip,
        rip_redistribute_rip_cmd,
        "redistribute rip",
@@ -313,6 +321,7 @@
   zclient->redist[ZEBRA_ROUTE_RIP] = 0;
   return CMD_SUCCESS;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 DEFUN (rip_redistribute_type,
        rip_redistribute_type_cmd,
@@ -342,6 +351,7 @@
   return CMD_WARNING;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 DEFUN (no_rip_redistribute_type,
        no_rip_redistribute_type_cmd,
        "no redistribute (kernel|connected|static|ospf|bgp)",
@@ -360,8 +370,10 @@
       if (strncmp(redist_type[i].str, argv[0], 
 		  redist_type[i].str_min_len) == 0) 
 	{
+#if defined(BRCM_LIST_SUPPORT) 
 	  rip_metric_unset (redist_type[i].type, DONT_CARE_METRIC_RIP);
 	  rip_routemap_unset (redist_type[i].type,NULL);
+#endif
 	  rip_redistribute_unset (redist_type[i].type);
 	  return CMD_SUCCESS;
         }
@@ -372,7 +384,9 @@
 
   return CMD_WARNING;
 }
+#endif
 
+#if defined(BRCM_LIST_SUPPORT) && defined(BRCM_CMD_SUPPORT)
 DEFUN (rip_redistribute_type_routemap,
        rip_redistribute_type_routemap_cmd,
        "redistribute (kernel|connected|static|ospf|bgp) route-map WORD",
@@ -586,11 +600,14 @@
 
   return CMD_SUCCESS;
 }
+#endif /* BRCM_LIST_SUPPORT && BRCM_CMD_SUPPORT */
+
 
 /* RIP configuration write function. */
 int
 config_write_zebra (struct vty *vty)
 {
+#ifdef BRCM_CMD_SUPPORT
   if (! zclient->enable)
     {
       vty_out (vty, "no router zebra%s", VTY_NEWLINE);
@@ -602,12 +619,14 @@
       vty_out (vty, " no redistribute rip%s", VTY_NEWLINE);
       return 1;
     }
+#endif /* BRCM_CMD_SUPPORT */
   return 0;
 }
 
 int
 config_write_rip_redistribute (struct vty *vty, int config_mode)
 {
+#ifdef BRCM_CMD_SUPPORT
   int i;
   char *str[] = { "system", "kernel", "connected", "static", "rip",
 		  "ripng", "ospf", "ospf6", "bgp"};
@@ -643,15 +662,18 @@
 	else
 	  vty_out (vty, " %s", str[i]);
       }
+#endif
   return 0;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 /* Zebra node structure. */
 struct cmd_node zebra_node =
 {
   ZEBRA_NODE,
   "%s(config-router)# ",
 };
+#endif
 
 void
 rip_zclient_init ()
@@ -668,6 +690,7 @@
   zclient->interface_up = rip_interface_up;
   zclient->interface_down = rip_interface_down;
   
+#if defined(BRCM_CMD_SUPPORT) && defined(BRCM_LIST_SUPPORT)
   /* Install zebra node. */
   install_node (&zebra_node, config_write_zebra);
 
@@ -677,15 +700,22 @@
   install_default (ZEBRA_NODE);
   install_element (ZEBRA_NODE, &rip_redistribute_rip_cmd);
   install_element (ZEBRA_NODE, &no_rip_redistribute_rip_cmd);
+#endif
 
   /* Install command elements to rip node. */
   install_element (RIP_NODE, &rip_redistribute_type_cmd);
+
+#if defined(BRCM_CMD_SUPPORT) && defined(BRCM_LIST_SUPPORT)
   install_element (RIP_NODE, &rip_redistribute_type_routemap_cmd);
   install_element (RIP_NODE, &rip_redistribute_type_metric_cmd);
   install_element (RIP_NODE, &no_rip_redistribute_type_cmd);
+#endif 
+
+#if defined(BRCM_CMD_SUPPORT) && defined(BRCM_LIST_SUPPORT)
   install_element (RIP_NODE, &no_rip_redistribute_type_routemap_cmd);
   install_element (RIP_NODE, &no_rip_redistribute_type_metric_cmd);
   install_element (RIP_NODE, &no_rip_redistribute_type_metric_routemap_cmd);
   install_element (RIP_NODE, &rip_default_information_originate_cmd);
   install_element (RIP_NODE, &no_rip_default_information_originate_cmd);
+#endif /* BRCM_CMD_SUPPORT */
 }
diff -Naur zebra/zebra/debug.c zebra-brcm/zebra/debug.c
--- zebra/zebra/debug.c	2000-10-03 05:07:13.000000000 -0300
+++ zebra-brcm/zebra/debug.c	2018-11-23 18:54:26.972999583 -0400
@@ -20,6 +20,8 @@
  * Boston, MA 02111-1307, USA.  
  */
 
+#ifdef BRCM_RIP_DEBUG
+
 #include <zebra.h>
 #include "command.h"
 #include "debug.h"
@@ -29,6 +31,7 @@
 unsigned long zebra_debug_packet;
 unsigned long zebra_debug_kernel;
 
+#ifdef BRCM_CMD_SUPPORT
 DEFUN (show_debugging_zebra,
        show_debugging_zebra_cmd,
        "show debugging zebra",
@@ -67,6 +70,7 @@
 
   return CMD_SUCCESS;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 DEFUN (debug_zebra_events,
        debug_zebra_events_cmd,
@@ -201,6 +205,7 @@
   1
 };
 
+#ifdef BRCM_CMD_SUPPORT
 int
 config_write_debug (struct vty *vty)
 {
@@ -240,6 +245,7 @@
     }
   return write;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 void
 zebra_debug_init ()
@@ -247,11 +253,12 @@
   zebra_debug_event = 0;
   zebra_debug_packet = 0;
 
+#ifdef BRCM_CMD_SUPPORT
   install_node (&debug_node, config_write_debug);
-
   install_element (VIEW_NODE, &show_debugging_zebra_cmd);
-
   install_element (ENABLE_NODE, &show_debugging_zebra_cmd);
+#endif
+
   install_element (ENABLE_NODE, &debug_zebra_events_cmd);
   install_element (ENABLE_NODE, &debug_zebra_packet_cmd);
   install_element (ENABLE_NODE, &debug_zebra_packet_direct_cmd);
@@ -270,3 +277,5 @@
   install_element (CONFIG_NODE, &no_debug_zebra_packet_cmd);
   install_element (CONFIG_NODE, &no_debug_zebra_kernel_cmd);
 }
+
+#endif /* BRCM_RIP_DEBUG */
diff -Naur zebra/zebra/if_ioctl.c zebra-brcm/zebra/if_ioctl.c
--- zebra/zebra/if_ioctl.c	2001-07-24 16:37:24.000000000 -0300
+++ zebra-brcm/zebra/if_ioctl.c	2018-11-23 18:54:26.972999583 -0400
@@ -50,7 +50,9 @@
   sock = socket (AF_INET, SOCK_DGRAM, 0);
   if (sock < 0) 
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("Can't make AF_INET socket stream: %s", strerror (errno));
+#endif
       return -1;
     }
 
@@ -79,7 +81,9 @@
 
       if (ret < 0) 
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog_warn ("SIOCGIFCONF: %s", strerror(errno));
+#endif
 	  goto end;
 	}
       /* Repeatedly get info til buffer fails to grow. */
@@ -213,7 +217,9 @@
   ret = getifaddrs (&ifap); 
   if (ret != 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_err ("getifaddrs(): %s", strerror (errno));
+#endif
       return -1;
     }
 
@@ -222,8 +228,10 @@
       ifp = if_lookup_by_name (ifap->ifa_name);
       if (ifp == NULL)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog_err ("if_getaddrs(): Can't lookup interface %s\n",
 		    ifap->ifa_name);
+#endif
 	  continue;
 	}
 
@@ -320,7 +328,9 @@
     {
       if (errno != EADDRNOTAVAIL)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog_warn ("SIOCGIFADDR fail: %s", strerror (errno));
+#endif
 	  return ret;
 	}
       return 0;
@@ -333,7 +343,9 @@
     {
       if (errno != EADDRNOTAVAIL) 
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog_warn ("SIOCGIFNETMASK fail: %s", strerror (errno));
+#endif
 	  return ret;
 	}
       return 0;
@@ -355,7 +367,9 @@
 	{
 	  if (errno != EADDRNOTAVAIL) 
 	    {
+#ifdef BRCM_RIP_DEBUG
 	      zlog_warn ("SIOCGIFDSTADDR fail: %s", strerror (errno));
+#endif
 	      return ret;
 	    }
 	  return 0;
@@ -370,7 +384,9 @@
 	{
 	  if (errno != EADDRNOTAVAIL) 
 	    {
+#ifdef BRCM_RIP_DEBUG
 	      zlog_warn ("SIOCGIFBRDADDR fail: %s", strerror (errno));
+#endif
 	      return ret;
 	    }
 	  return 0;
@@ -418,7 +434,9 @@
   /* Linux can do both proc & ioctl, ioctl is the only way to get
      interface aliases in 2.2 series kernels. */
 #ifdef HAVE_PROC_NET_DEV
+#ifdef BRCM_LIST_SUPPORT
   interface_list_proc ();
+#endif
 #endif /* HAVE_PROC_NET_DEV */
   interface_list_ioctl ();
 
diff -Naur zebra/zebra/if_proc.c zebra-brcm/zebra/if_proc.c
--- zebra/zebra/if_proc.c	2001-01-23 04:28:17.000000000 -0400
+++ zebra-brcm/zebra/if_proc.c	2018-11-23 18:54:26.972999583 -0400
@@ -19,6 +19,8 @@
  * 02111-1307, USA.  
  */
 
+#ifdef BRCM_LIST_SUPPORT
+
 #include <zebra.h>
 
 #include "if.h"
@@ -244,3 +246,5 @@
   return 0;
 }
 #endif /* HAVE_IPV6 && HAVE_PROC_NET_IF_INET6 */
+
+#endif /* BRCM_LIST_SUPPORT */
diff -Naur zebra/zebra/interface.c zebra-brcm/zebra/interface.c
--- zebra/zebra/interface.c	2002-01-16 14:26:34.000000000 -0400
+++ zebra-brcm/zebra/interface.c	2018-11-23 18:54:26.976999474 -0400
@@ -30,7 +30,9 @@
 #include "memory.h"
 #include "ioctl.h"
 #include "connected.h"
+#ifdef BRCM_RIP_DEBUG
 #include "log.h"
+#endif
 #include "zclient.h"
 
 #include "zebra/interface.h"
@@ -38,8 +40,12 @@
 #include "zebra/rib.h"
 #include "zebra/zserv.h"
 #include "zebra/redistribute.h"
+#ifdef BRCM_RIP_DEBUG
 #include "zebra/debug.h"
+#endif
 
+
+#ifdef BRCM_CMD_SUPPORT
 /* Allocate a new internal interface index 
  * This works done from the top so that %d macros
  * print a - sign! 
@@ -60,6 +66,7 @@
        return ifindex;
     }
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Called when new interface is added. */
 int
@@ -139,8 +146,10 @@
 	      ret = if_set_prefix (ifp, ifc);
 	      if (ret < 0)
 		{
+#ifdef BRCM_RIP_DEBUG
 		  zlog_warn ("Can't set interface's address: %s", 
 			     strerror(errno));
+#endif
 		  continue;
 		}
 	      SET_FLAG (ifc->conf, ZEBRA_IFC_REAL);
@@ -162,8 +171,10 @@
 	      ret = if_prefix_add_ipv6 (ifp, ifc);
 	      if (ret < 0)
 		{
+#ifdef BRCM_RIP_DEBUG
 		  zlog_warn ("Can't set interface's address: %s", 
 			     strerror(errno));
+#endif
 		  continue;
 		}
 	      SET_FLAG (ifc->conf, ZEBRA_IFC_REAL);
@@ -189,15 +200,18 @@
       SET_FLAG (ifp->status, ZEBRA_INTERFACE_ACTIVE);
 
       if_addr_wakeup (ifp);
-
+#ifdef BRCM_RIP_DEBUG
       if (IS_ZEBRA_DEBUG_KERNEL)
 	zlog_info ("interface %s index %d becomes active.", 
 		   ifp->name, ifp->ifindex);
+#endif
     }
   else
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_ZEBRA_DEBUG_KERNEL)
 	zlog_info ("interface %s index %d is added.", ifp->name, ifp->ifindex);
+#endif
     }
 }
 
@@ -212,17 +226,21 @@
 
   if (if_is_up(ifp))
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_err ("interface %s index %d is still up while being deleted.",
 	    ifp->name, ifp->ifindex);
+#endif
       return;
     }
 
   /* Mark interface as inactive */
   UNSET_FLAG (ifp->status, ZEBRA_INTERFACE_ACTIVE);
-  
+
+#ifdef BRCM_RIP_DEBUG  
   if (IS_ZEBRA_DEBUG_KERNEL)
     zlog_info ("interface %s index %d is now inactive.",
 	       ifp->name, ifp->ifindex);
+#endif
 
   /* Delete connected routes from the kernel. */
   if (ifp->connected)
@@ -340,6 +358,7 @@
     }
 }
 
+#ifdef BRCM_CMD_SUPPORT
 /* Printout flag information into vty */
 void
 if_flag_dump_vty (struct vty *vty, unsigned long flag)
@@ -1341,6 +1360,7 @@
     }
   return 0;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Allocate and initialize interface vector. */
 void
@@ -1350,7 +1370,8 @@
   if_init ();
   if_add_hook (IF_NEW_HOOK, if_zebra_new_hook);
   if_add_hook (IF_DELETE_HOOK, if_zebra_delete_hook);
-  
+
+#ifdef BRCM_CMD_SUPPORT  
   /* Install configuration write function. */
   install_node (&interface_node, if_config_write);
 
@@ -1384,4 +1405,5 @@
   install_element (INTERFACE_NODE, &no_ip_address_secondary_cmd);
   install_element (INTERFACE_NODE, &no_ip_address_label_cmd);
 #endif /* HAVE_NETLINK */
+#endif /* BRCM_CMD_SUPPORT */
 }
diff -Naur zebra/zebra/ioctl.c zebra-brcm/zebra/ioctl.c
--- zebra/zebra/ioctl.c	2001-10-23 05:43:55.000000000 -0300
+++ zebra-brcm/zebra/ioctl.c	2018-11-23 18:54:26.976999474 -0400
@@ -19,7 +19,6 @@
  * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  * 02111-1307, USA.  
  */
-
 #include <zebra.h>
 
 #include "linklist.h"
@@ -99,6 +98,7 @@
 }
 #endif /* HAVE_IPV6 */
 
+#ifdef BRCM_CMD_SUPPORT
 /*
  * get interface metric
  *   -- if value is not avaliable set -1
@@ -132,7 +132,9 @@
 #if defined(SIOCGIFMTU)
   if (if_ioctl (SIOCGIFMTU, (caddr_t) & ifreq) < 0) 
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("Can't lookup mtu by ioctl(SIOCGIFMTU)");
+#endif
       ifp->mtu = -1;
       return;
     }
@@ -144,10 +146,13 @@
 #endif /* SUNOS_5 */
 
 #else
+#ifdef BRCM_RIP_DEBUG
   zlog (NULL, LOG_INFO, "Can't lookup mtu on this system");
+#endif
   ifp->mtu = -1;
 #endif
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 #ifdef HAVE_NETLINK
 /* Interface address setting via netlink interface. */
@@ -358,7 +363,9 @@
 
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("can't set interface flags");
+#endif
       return ret;
     }
   return 0;
@@ -380,7 +387,9 @@
 
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("can't unset interface flags");
+#endif
       return ret;
     }
   return 0;
diff -Naur zebra/zebra/ipforward_proc.c zebra-brcm/zebra/ipforward_proc.c
--- zebra/zebra/ipforward_proc.c	2000-01-11 03:11:49.000000000 -0400
+++ zebra-brcm/zebra/ipforward_proc.c	2018-11-23 18:54:26.976999474 -0400
@@ -20,6 +20,8 @@
  * 02111-1307, USA.  
  */
 
+#if BRCM_CMD_SUPPORT
+
 #include <zebra.h>
 
 char proc_net_snmp[] = "/proc/net/snmp";
@@ -153,3 +155,5 @@
   return ipforward_ipv6 ();
 }
 #endif /* HAVE_IPV6 */
+
+#endif /* BRCM_CMD_SUPPORT */
diff -Naur zebra/zebra/irdp.c zebra-brcm/zebra/irdp.c
--- zebra/zebra/irdp.c	2001-02-09 02:55:05.000000000 -0400
+++ zebra-brcm/zebra/irdp.c	2018-11-23 18:54:26.976999474 -0400
@@ -559,6 +559,7 @@
 void
 irdp_init ()
 {
+#ifdef BRCM_CMD_SUPPORT
   install_element (INTERFACE_NODE, &ip_irdp_cmd);
   install_element (INTERFACE_NODE, &ip_irdp_multicast_cmd);
   install_element (INTERFACE_NODE, &ip_irdp_holdtime_cmd);
@@ -566,4 +567,5 @@
   install_element (INTERFACE_NODE, &ip_irdp_minadvertinterval_cmd);
   install_element (INTERFACE_NODE, &ip_irdp_preference_cmd);
   install_element (INTERFACE_NODE, &ip_irdp_address_preference_cmd);
+#endif
 }
diff -Naur zebra/zebra/main.c zebra-brcm/zebra/main.c
--- zebra/zebra/main.c	2002-06-21 17:18:41.000000000 -0300
+++ zebra-brcm/zebra/main.c	2018-11-23 18:54:26.976999474 -0400
@@ -29,13 +29,19 @@
 #include "filter.h"
 #include "memory.h"
 #include "prefix.h"
+#ifdef BRCM_RIP_DEBUG
 #include "log.h"
-
+#endif
 #include "zebra/rib.h"
 #include "zebra/zserv.h"
+#ifdef BRCM_RIP_DEBUG
 #include "zebra/debug.h"
+#endif
 #include "zebra/rib.h"
 
+#include "cms_msg.h"
+static void *msgHandle=NULL;
+
 /* Master of threads. */
 struct thread_master *master;
 
@@ -102,12 +108,14 @@
   exit (status);
 }
 
+
 /* SIGHUP handler. */
 void 
 sighup (int sig)
 {
+#ifdef BRCM_RIP_DEBUG
   zlog_info ("SIGHUP received");
-
+#endif
   /* Reload of config file. */
   ;
 }
@@ -118,9 +126,9 @@
 {
   /* Decrared in rib.c */
   void rib_close ();
-
+#ifdef BRCM_RIP_DEBUG
   zlog_info ("Terminating on signal");
-
+#endif
   if (!retain_mode)
     rib_close ();
 
@@ -131,7 +139,9 @@
 void
 sigusr1 (int sig)
 {
+#ifdef BRCM_RIP_DEBUG
   zlog_rotate (NULL);
+#endif
 }
 
 /* Signale wrapper. */
@@ -161,6 +171,14 @@
 void
 signal_init ()
 {
+   /*
+    * detach from the terminal so we don't catch the user typing control-c.
+    */
+   if (setsid() == -1)
+   {
+      printf("Could not detach from terminal");
+   }
+
   signal_set (SIGHUP, sighup);
   signal_set (SIGINT, sigint);
   signal_set (SIGTERM, sigint);
@@ -169,8 +187,13 @@
 }
 
 /* Main startup routine. */
+#ifdef BUILD_STATIC
+int
+zebra_main (int argc, char **argv)
+#else
 int
 main (int argc, char **argv)
+#endif
 {
   char *p;
   char *vty_addr = NULL;
@@ -188,9 +211,10 @@
   /* preserve my name */
   progname = ((p = strrchr (argv[0], '/')) ? ++p : argv[0]);
 
+#ifdef BRCM_RIP_DEBUG
   zlog_default = openzlog (progname, ZLOG_STDOUT, ZLOG_ZEBRA,
 			   LOG_CONS|LOG_NDELAY|LOG_PID, LOG_DAEMON);
-
+#endif
   while (1) 
     {
       int opt;
@@ -231,7 +255,9 @@
 	  retain_mode = 1;
 	  break;
 	case 'v':
+#ifdef BRCM_CMD_SUPPORT
 	  print_version (progname);
+#endif
 	  exit (0);
 	  break;
 	case 'h':
@@ -243,6 +269,9 @@
 	}
     }
 
+  /* initialize the message pipe with smd */
+  cmsMsg_init(EID_ZEBRA, &msgHandle);
+
   /* Make master thread emulator. */
   master = thread_master_create ();
 
@@ -250,15 +279,27 @@
   signal_init ();
   cmd_init (1);
   vty_init ();
+
+#ifdef BRCM_CMD_SUPPORT
   memory_init ();
+#endif
 
   /* Zebra related initialize. */
   zebra_init ();
   rib_init ();
   zebra_if_init ();
+
+#ifdef BRCM_RIP_DEBUG
   zebra_debug_init ();
+#endif
+
+#ifdef BRCM_LIST_SUPPORT
   access_list_init ();
+#endif
+
+#ifdef RTADV
   rtadv_init ();
+#endif
 
   /* For debug purpose. */
   /* SET_FLAG (zebra_debug_event, ZEBRA_DEBUG_EVENT); */
@@ -302,9 +343,11 @@
   /* Needed for BSD routing socket. */
   pid = getpid ();
 
+#ifdef BRCM_CMD_SUPPORT
   /* Make vty server socket. */
   vty_serv_sock (vty_addr,
 		 vty_port ? vty_port : ZEBRA_VTY_PORT, ZEBRA_VTYSH_PATH);
+#endif
 
   while (thread_fetch (master, &thread))
     thread_call (&thread);
diff -Naur zebra/zebra/Makefile zebra-brcm/zebra/Makefile
--- zebra/zebra/Makefile	1969-12-31 20:00:00.000000000 -0400
+++ zebra-brcm/zebra/Makefile	2018-11-23 18:54:26.972999583 -0400
@@ -0,0 +1,501 @@
+# Makefile.in generated by automake 1.6.2 from Makefile.am.
+# zebra/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+#BRCM begin
+#for debug, add -DBRCM_RIP_DEBUG; command support, add -DDBRCM_CMD_SUPPORT;
+#access/filter list support, add -DDBRCM_LIST_SUPPORT
+CFLAGS= -s -Os -fomit-frame-pointer -L$(LIB_PATH) -I$(BUILD_DIR)/userspace/public/include -I$(BUILD_DIR)/userspace/public/include/linux
+CFLAGS += -I$(TOOLCHAIN)/include
+CFLAGS += -Werror -Wfatal-errors
+
+ifeq ($(strip $(BUILD_ZEBRA)), static)
+CFLAGS += -DBUILD_STATIC
+endif
+
+SHELL = /bin/sh
+
+srcdir = .
+top_srcdir = ..
+
+prefix = /usr/local
+exec_prefix = ${prefix}
+
+bindir = ${exec_prefix}/bin
+sbindir = ${exec_prefix}/sbin
+libexecdir = ${exec_prefix}/libexec
+datadir = ${prefix}/share
+sysconfdir = ${prefix}/etc
+sharedstatedir = ${prefix}/com
+localstatedir = ${prefix}/var
+libdir = ${exec_prefix}/lib
+infodir = ${prefix}/info
+mandir = ${prefix}/man
+includedir = ${prefix}/include
+oldincludedir = /usr/include
+pkgdatadir = $(datadir)/zebra
+pkglibdir = $(libdir)/zebra
+pkgincludedir = $(includedir)/zebra
+top_builddir = ..
+
+ACLOCAL = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run aclocal-1.6
+AUTOCONF = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run autoconf
+AUTOMAKE = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run automake-1.6
+AUTOHEADER = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run autoheader
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /usr/bin/install -c
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_DATA = ${INSTALL} -m 644
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = s,x,x,
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+host_alias = 
+host_triplet = i686-pc-linux-gnu
+
+EXEEXT = 
+OBJEXT = o
+PATH_SEPARATOR = :
+AMTAR = ${SHELL} /opt/user96345/src/zebra-0.93a/missing --run tar
+
+#BRCM begin
+#AR = ar
+#AWK = gawk
+BGPD = 
+#CC = gcc
+#CPP = gcc -E
+#CFLAGS= -DBRCM_CMD_SUPPORT -Wl,-allow-shlib-undefined -s -Os -fomit-frame-pointer -L$(LIB_PATH)
+#these will be removed since they are on the top /user96345/Makefile
+#TOOLCHAIN=/opt/toolchains/uclibc
+#CROSS_COMPILE = $(TOOLCHAIN)/bin/mips-uclibc-
+#AR              = $(CROSS_COMPILE)ar
+#AS              = $(CROSS_COMPILE)as
+#LD              = $(CROSS_COMPILE)ld
+#CC              = $(CROSS_COMPILE)gcc
+#CXX             = $(CROSS_COMPILE)g++
+#CPP             = $(CROSS_COMPILE)cpp
+#NM              = $(CROSS_COMPILE)nm
+#STRIP           = $(CROSS_COMPILE)strip
+#OBJCOPY         = $(CROSS_COMPILE)objcopy
+#OBJDUMP         = $(CROSS_COMPILE)objdump
+#RANLIB          = $(CROSS_COMPILE)ranlib
+#LIB_PATH        = $(TOOLCHAIN)/mips-linux/lib
+#LIBDIR          = $(TOOLCHAIN)/mips-linux/lib
+#LIBCDIR         = $(TOOLCHAIN)/mips-linux
+#BRCM end
+
+CURSES = 
+DEPDIR = .deps
+IF_METHOD = if_netlink.o
+IF_PROC = if_proc.o
+
+INCLUDES =  -I.. -I$(top_srcdir) -I$(top_srcdir)/lib
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+IPFORWARD = ipforward_proc.o
+KERNEL_METHOD = 
+LIBPAM = 
+
+LIB_IPV6 = 
+LIB_REGEX = 
+MULTIPATH_NUM = 1
+OSPF6D = 
+OSPFD = 
+OTHER_METHOD = 
+PACKAGE = zebra
+RANLIB = ranlib
+RIPD = ripd
+RIPNGD = 
+RTREAD_METHOD = rtread_netlink.o
+RT_METHOD = rt_netlink.o
+#STRIP = 
+VERSION = 0.93a
+VTYSH = 
+ZEBRA = zebra
+am__include = include
+am__quote = 
+install_sh = /opt/user96345/src/zebra-0.93a/install-sh
+DEFS = -DHAVE_CONFIG_H -DSYSCONFDIR=\"$(sysconfdir)/\" -DMULTIPATH_NUM=1
+INSTALL_SDATA = /usr/bin/install -c -m 600
+
+ipforward = ipforward_proc.o
+if_method = if_netlink.o
+if_proc = if_proc.o
+rt_method = rt_netlink.o
+rtread_method = rtread_netlink.o
+kernel_method = 
+other_method = 
+
+otherobj = $(ipforward) $(if_method) $(if_proc) $(rt_method) \
+	$(rtread_method) $(kernel_method) $(other_method)
+
+
+sbin_PROGRAMS = zebra
+
+zebra_SOURCES = \
+	zserv.c main.c interface.c connected.c ioctl.c rib.c redistribute.c \
+	debug.c rtadv.c zebra_snmp.c
+
+
+noinst_HEADERS = \
+	connected.h ioctl.h rib.h rt.h zserv.h redistribute.h debug.h rtadv.h \
+	interface.h ipforward.h irdp.h
+
+
+zebra_LDADD = ../lib/libzebra.a $(otherobj) $(LIB_IPV6)
+
+zebra_DEPENDENCIES = $(otherobj)
+
+sysconf_DATA = zebra.conf.sample
+
+EXTRA_DIST = $(sysconf_DATA) if_ioctl.c if_netlink.c if_proc.c if_sysctl.c \
+	ipforward_aix.c ipforward_ews.c ipforward_proc.c \
+	ipforward_solaris.c ipforward_sysctl.c rt_ioctl.c rt_netlink.c \
+	rt_socket.c rtread_netlink.c rtread_proc.c rtread_sysctl.c \
+	rtread_getmsg.c kernel_socket.c kernel_netlink.c mtu_kvm.c \
+	GNOME-SMI GNOME-PRODUCT-ZEBRA-MIB irdp.c
+
+subdir = zebra
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+#sbin_PROGRAMS = zebra$(EXEEXT)
+PROGRAMS = $(sbin_PROGRAMS)
+am_zebra_OBJECTS = zserv.$(OBJEXT) main.$(OBJEXT) interface.$(OBJEXT) \
+	connected.$(OBJEXT) ioctl.$(OBJEXT) rib.$(OBJEXT) \
+	redistribute.$(OBJEXT) debug.$(OBJEXT) rtadv.$(OBJEXT) \
+	zebra_snmp.$(OBJEXT)
+
+zebra_OBJECTS = $(am_zebra_OBJECTS)
+zebra_LDFLAGS =
+DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
+CPPFLAGS =
+#BRCM begin 
+#LDFLAGS = 
+LDFLAGS = -Wl,-warn-common -Wl,-allow-shlib-undefined
+#BRCM end
+#LIBS = -lm -lcrypt
+LIBS = -lm -lcrypt -L$(INSTALL_DIR)/lib/public -lcms_msg $(CMS_COMMON_LIBS)
+
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+DEP_FILES = ./$(DEPDIR)/connected.Po ./$(DEPDIR)/debug.Po \
+	./$(DEPDIR)/interface.Po ./$(DEPDIR)/ioctl.Po \
+	./$(DEPDIR)/main.Po ./$(DEPDIR)/redistribute.Po \
+	./$(DEPDIR)/rib.Po ./$(DEPDIR)/rtadv.Po \
+	./$(DEPDIR)/zebra_snmp.Po ./$(DEPDIR)/zserv.Po
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+
+#BRCM begin
+#CFLAGS = -g -O2 -Wall 
+#BRCM end
+
+DIST_SOURCES = $(zebra_SOURCES)
+DATA = $(sysconf_DATA)
+
+HEADERS = $(noinst_HEADERS)
+
+DIST_COMMON = $(noinst_HEADERS) ChangeLog Makefile.am Makefile.in
+SOURCES = $(zebra_SOURCES)
+
+#BRCM begin
+#all: all-am
+#BRCM end
+#all: Makefile $(sbin_PROGRAMS) $(HEADERS)
+
+all install: $(sbin_PROGRAMS)
+	install -m 755 $(sbin_PROGRAMS) $(INSTALL_DIR)/bin
+	$(STRIP) $(INSTALL_DIR)/bin/$(sbin_PROGRAMS)
+
+
+.SUFFIXES:
+.SUFFIXES: .c .o .obj
+#BRCM begin 
+#$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+#	cd $(top_srcdir) && \
+#	  $(AUTOMAKE) --foreign  zebra/Makefile
+#Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+#	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+#
+sbinPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+install-sbinPROGRAMS: $(sbin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(sbindir)
+	@list='$(sbin_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	  ; then \
+	    p1=`echo "$$p1" | sed -e 's,^.*/,,'`; \
+	    f=`echo $$p1|sed '$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(sbinPROGRAMS_INSTALL) $$p $(DESTDIR)$(sbindir)/$$f"; \
+	   $(INSTALL_PROGRAM_ENV) $(sbinPROGRAMS_INSTALL) $$p $(DESTDIR)$(sbindir)/$$f; \
+	  else :; fi; \
+	done
+
+uninstall-sbinPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(sbin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo $$p|sed 's/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  f=`echo "$$f" | sed -e 's,^.*/,,'`; \
+	  echo " rm -f $(DESTDIR)$(sbindir)/$$f"; \
+	  rm -f $(DESTDIR)$(sbindir)/$$f; \
+	done
+
+#BRCM begin
+#clean-sbinPROGRAMS:
+#BRCM end
+clean: mostlyclean-compile
+	-test -z "$(sbin_PROGRAMS)" || rm -f $(sbin_PROGRAMS)
+	rm -f $(sbin_PROGRAMS).a
+
+#BRCM begin
+#zebra$(EXEEXT): $(zebra_OBJECTS) $(zebra_DEPENDENCIES) 
+#	@rm -f zebra$(EXEEXT)
+#	$(LINK) $(zebra_LDFLAGS) $(zebra_OBJECTS) $(zebra_LDADD) $(LIBS)
+$(sbin_PROGRAMS): $(zebra_OBJECTS) $(zebra_DEPENDENCIES)
+		@rm -f zebra
+		$(LINK) $(zebra_LDFLAGS) $(zebra_OBJECTS) $(zebra_LDADD) $(LIBS)
+$(sbin_PROGRAMS).a: $(zebra_OBJECTS) $(zebra_DEPENDENCIES) $(zebra_LDADD) $(LIBS)
+		@rm -f zebra.a
+		$(AR) rcs zebra.a $(zebra_OBJECTS) $(zebra_DEPENDENCIES) $(zebra_LDADD)
+#BRCM end
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT) core *.core
+
+distclean-compile:
+	-rm -f *.tab.c
+
+#include ./$(DEPDIR)/connected.Po
+#include ./$(DEPDIR)/debug.Po
+#include ./$(DEPDIR)/interface.Po
+#include ./$(DEPDIR)/ioctl.Po
+#include ./$(DEPDIR)/main.Po
+#include ./$(DEPDIR)/redistribute.Po
+#include ./$(DEPDIR)/rib.Po
+#include ./$(DEPDIR)/rtadv.Po
+#include ./$(DEPDIR)/zebra_snmp.Po
+#include ./$(DEPDIR)/zserv.Po
+
+distclean-depend:
+	-rm -rf ./$(DEPDIR)
+
+#BRCM begin remove dependencies file
+#.c.o:
+#	source='$<' object='$@' libtool=no \
+#	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' \
+#	$(CCDEPMODE) $(depcomp) \
+#	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+.c.o:
+	source='$<' object='$@' libtool=no \
+	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+
+.c.obj:
+	source='$<' object='$@' libtool=no \
+	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' \
+	$(CCDEPMODE) $(depcomp) \
+	$(COMPILE) -c `cygpath -w $<`
+CCDEPMODE = depmode=gcc3
+uninstall-info-am:
+sysconfDATA_INSTALL = $(INSTALL_DATA)
+
+uninstall-sysconfDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(sysconf_DATA)'; for p in $$list; do \
+	  f="`echo $$p | sed -e 's|^.*/||'`"; \
+	  echo " rm -f $(DESTDIR)$(sysconfdir)/$$f"; \
+	  rm -f $(DESTDIR)$(sysconfdir)/$$f; \
+	done
+
+ETAGS = etags
+ETAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@list='$(DISTFILES)'; for file in $$list; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+
+#BRCM begin
+#all-am: Makefile $(PROGRAMS) $(DATA) $(HEADERS)
+#BRCM end
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(sbindir) $(DESTDIR)$(sysconfdir)
+
+#BRCM begin
+#install: install-am
+#BRCM end
+
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+
+#BRCM begin
+#clean: clean-am
+#clean-am: clean-generic clean-sbinPROGRAMS mostlyclean-am
+#BRCM end
+
+distclean: distclean-am
+
+distclean-am: distclean-compile distclean-depend \
+	distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+#BRCM begin-- don't need to instal sysconfig data
+#install-exec-am: install-sbinPROGRAMS install-sysconfDATA
+install-exec-am: install-sbinPROGRAMS
+#BRCM end-- don't need to instal sysconfig data
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+uninstall-am: uninstall-info-am uninstall-sbinPROGRAMS \
+	uninstall-sysconfDATA
+
+.PHONY: GTAGS all all-am check check-am clean clean-generic \
+	clean-sbinPROGRAMS distclean distclean-compile distclean-depend \
+	distclean-generic distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-man install-sbinPROGRAMS install-strip \
+	install-sysconfDATA installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic tags uninstall \
+	uninstall-am uninstall-info-am uninstall-sbinPROGRAMS \
+	uninstall-sysconfDATA
+
+
+#client : client_main.o ../lib/libzebra.a
+#	$(CC) -g -o client client_main.o ../lib/libzebra.a $(LIBS) $(LIB_IPV6)
+
+install-sysconfDATA: $(sysconf_DATA)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(sysconfdir)
+	@list='$(sysconf_DATA)'; for p in $$list; do \
+	  if test -f $(srcdir)/$$p; then \
+	    echo " $(INSTALL_SDATA) $(srcdir)/$$p $(DESTDIR)$(sysconfdir)/$$p"; \
+	    $(INSTALL_SDATA) $(srcdir)/$$p $(DESTDIR)$(sysconfdir)/$$p; \
+	  else if test -f $$p; then \
+	    echo " $(INSTALL_SDATA) $$p $(DESTDIR)$(sysconfdir)/$$p"; \
+	    $(INSTALL_SDATA) $$p $(DESTDIR)$(sysconfdir)/$$p; \
+	  fi; fi; \
+	done
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur zebra/zebra/redistribute.c zebra-brcm/zebra/redistribute.c
--- zebra/zebra/redistribute.c	2001-12-04 18:53:26.000000000 -0400
+++ zebra-brcm/zebra/redistribute.c	2018-11-23 18:54:26.976999474 -0400
@@ -290,9 +290,10 @@
   listnode node;
   struct zserv *client;
 
+#ifdef BRCM_RIP_DEBUG
   if (IS_ZEBRA_DEBUG_EVENT)
     zlog_info ("MESSAGE: ZEBRA_INTERFACE_UP %s", ifp->name);
-
+#endif
   for (node = listhead (client_list); node; nextnode (node))
     if ((client = getdata (node)) != NULL)
       zsend_interface_up (client, ifp);
@@ -305,8 +306,10 @@
   listnode node;
   struct zserv *client;
 
+#ifdef BRCM_RIP_DEBUG
   if (IS_ZEBRA_DEBUG_EVENT)
     zlog_info ("MESSAGE: ZEBRA_INTERFACE_DOWN %s", ifp->name);
+#endif
 
   for (node = listhead (client_list); node; nextnode (node))
     if ((client = getdata (node)) != NULL)
@@ -320,8 +323,10 @@
   listnode node;
   struct zserv *client;
 
+#ifdef BRCM_RIP_DEBUG
   if (IS_ZEBRA_DEBUG_EVENT)
     zlog_info ("MESSAGE: ZEBRA_INTERFACE_ADD %s", ifp->name);
+#endif
     
   for (node = listhead (client_list); node; nextnode (node))
     if ((client = getdata (node)) != NULL)
@@ -335,8 +340,10 @@
   listnode node;
   struct zserv *client;
 
+#ifdef BRCM_RIP_DEBUG
   if (IS_ZEBRA_DEBUG_EVENT)
     zlog_info ("MESSAGE: ZEBRA_INTERFACE_DELETE %s", ifp->name);
+#endif
 
   for (node = listhead (client_list); node; nextnode (node))
     if ((client = getdata (node)) != NULL)
@@ -354,6 +361,7 @@
   struct prefix *p;
   char buf[BUFSIZ];
 
+#ifdef BRCM_RIP_DEBUG
   if (IS_ZEBRA_DEBUG_EVENT)
     {
       p = ifc->address;
@@ -361,6 +369,7 @@
 		 inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
 		 p->prefixlen, ifc->ifp->name);
     }
+#endif
 
   for (node = listhead (client_list); node; nextnode (node))
     if ((client = getdata (node)) != NULL)
@@ -378,6 +387,7 @@
   struct prefix *p;
   char buf[BUFSIZ];
 
+#ifdef BRCM_RIP_DEBUG
   if (IS_ZEBRA_DEBUG_EVENT)
     {
       p = ifc->address;
@@ -385,7 +395,7 @@
 		 inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
 		 p->prefixlen, ifc->ifp->name);
     }
-
+#endif
   for (node = listhead (client_list); node; nextnode (node))
     if ((client = getdata (node)) != NULL)
       if (client->ifinfo && CHECK_FLAG (ifc->conf, ZEBRA_IFC_REAL))
diff -Naur zebra/zebra/rib.c zebra-brcm/zebra/rib.c
--- zebra/zebra/rib.c	2002-01-23 18:58:37.000000000 -0400
+++ zebra-brcm/zebra/rib.c	2018-11-23 18:54:26.976999474 -0400
@@ -247,68 +247,81 @@
   p.prefix = nexthop->gate.ipv4;
 
   rn = route_node_match (rib_table_ipv4, (struct prefix *) &p);
+
   while (rn)
     {
       route_unlock_node (rn);
-      
+
       /* If lookup self prefix return immidiately. */
       if (rn == top)
-	return 0;
+         return 0;
 
       /* Pick up selected route. */
       for (match = rn->info; match; match = match->next)
-	if (CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
-	  break;
+         if (CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
+            break;
+
+#ifdef BRCM_BGP_SUPPORT
 
       /* If there is no selected route or matched route is EGP, go up
          tree. */
-      if (! match 
-	  || match->type == ZEBRA_ROUTE_BGP)
-	{
-	  do {
-	    rn = rn->parent;
-	  } while (rn && rn->info == NULL);
-	  if (rn)
-	    route_lock_node (rn);
-	}
+      if ((!match) || (match->type == ZEBRA_ROUTE_BGP))
+      {
+         do {
+            rn = rn->parent;
+         } while (rn && rn->info == NULL);
+         if (rn)
+            route_lock_node (rn);
+      }
       else
-	{
-	  if (match->type == ZEBRA_ROUTE_CONNECT)
-	    {
-	      /* Directly point connected route. */
-	      newhop = match->nexthop;
-	      if (newhop && nexthop->type == NEXTHOP_TYPE_IPV4)
-		nexthop->ifindex = newhop->ifindex;
-	      
-	      return 1;
-	    }
-	  else if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_INTERNAL))
-	    {
-	      for (newhop = match->nexthop; newhop; newhop = newhop->next)
-		if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB)
-		    && ! CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_RECURSIVE))
-		  {
-		    if (set)
-		      {
-			SET_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE);
-			nexthop->rtype = newhop->type;
-			if (newhop->type == NEXTHOP_TYPE_IPV4 ||
-			    newhop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
-			  nexthop->rgate.ipv4 = newhop->gate.ipv4;
-			if (newhop->type == NEXTHOP_TYPE_IFINDEX
-			    || newhop->type == NEXTHOP_TYPE_IFNAME
-			    || newhop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
-			  nexthop->rifindex = newhop->ifindex;
-		      }
-		    return 1;
-		  }
-	      return 0;
-	    }
-	  else
-	    {
-	      return 0;
-	    }
-	}
+      {
+#endif /* BRCM_BGP_SUPPORT */
+         if (match)
+         {
+            if (match->type == ZEBRA_ROUTE_CONNECT)
+            {
+               /* Directly point connected route. */
+               newhop = match->nexthop;
+               if (newhop && nexthop->type == NEXTHOP_TYPE_IPV4)
+                  nexthop->ifindex = newhop->ifindex;
+               
+               return 1;
+            }
+            else if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_INTERNAL))
+            {
+               for (newhop = match->nexthop; newhop; newhop = newhop->next)
+                  if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB)
+                      && ! CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_RECURSIVE))
+                  {
+                     if (set)
+                     {
+                        SET_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE);
+                        nexthop->rtype = newhop->type;
+                        if (newhop->type == NEXTHOP_TYPE_IPV4 ||
+                            newhop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
+                           nexthop->rgate.ipv4 = newhop->gate.ipv4;
+                        if (newhop->type == NEXTHOP_TYPE_IFINDEX
+                            || newhop->type == NEXTHOP_TYPE_IFNAME
+                            || newhop->type == NEXTHOP_TYPE_IPV4_IFINDEX)
+                           nexthop->rifindex = newhop->ifindex;
+                     } /* set */
+                     return 1;
+                  } /* flag_fib */
+               return 0;
+            } /* internal flag */
+            else
+            {
+               return 0;
+            } /* other flag */
+         } /* match */
+         else
+         {
+            /* match is not found */
+            break;
+         }
+#ifdef BRCM_BGP_SUPPORT
+      } /* not bgp */
+#endif
     }
   return 0;
 }
@@ -339,71 +352,78 @@
 
   rn = route_node_match (rib_table_ipv6, (struct prefix *) &p);
   while (rn)
-    {
-      route_unlock_node (rn);
+  {
+     route_unlock_node (rn);
       
-      /* If lookup self prefix return immidiately. */
-      if (rn == top)
-	return 0;
-
-      /* Pick up selected route. */
-      for (match = rn->info; match; match = match->next)
-	if (CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
-	  break;
-
-      /* If there is no selected route or matched route is EGP, go up
-         tree. */
-      if (! match
-	  || match->type == ZEBRA_ROUTE_BGP)
-	{
-	  do {
-	    rn = rn->parent;
-	  } while (rn && rn->info == NULL);
-	  if (rn)
-	    route_lock_node (rn);
-	}
-      else
-	{
-	  if (match->type == ZEBRA_ROUTE_CONNECT)
-	    {
-	      /* Directly point connected route. */
-	      newhop = match->nexthop;
-
-	      if (newhop && nexthop->type == NEXTHOP_TYPE_IPV6)
-		nexthop->ifindex = newhop->ifindex;
-	      
-	      return 1;
-	    }
-	  else if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_INTERNAL))
-	    {
-	      for (newhop = match->nexthop; newhop; newhop = newhop->next)
-		if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB)
-		    && ! CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_RECURSIVE))
-		  {
-		    if (set)
-		      {
-			SET_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE);
-			nexthop->rtype = newhop->type;
-			if (newhop->type == NEXTHOP_TYPE_IPV6
-			    || newhop->type == NEXTHOP_TYPE_IPV6_IFINDEX
-			    || newhop->type == NEXTHOP_TYPE_IPV6_IFNAME)
-			  nexthop->rgate.ipv6 = newhop->gate.ipv6;
-			if (newhop->type == NEXTHOP_TYPE_IFINDEX
-			    || newhop->type == NEXTHOP_TYPE_IFNAME
-			    || newhop->type == NEXTHOP_TYPE_IPV6_IFINDEX
-			    || newhop->type == NEXTHOP_TYPE_IPV6_IFNAME)
-			  nexthop->rifindex = newhop->ifindex;
-		      }
-		    return 1;
-		  }
-	      return 0;
-	    }
-	  else
-	    {
-	      return 0;
-	    }
-	}
-    }
+     /* If lookup self prefix return immidiately. */
+     if (rn == top)
+        return 0;
+
+     /* Pick up selected route. */
+     for (match = rn->info; match; match = match->next)
+        if (CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
+           break;
+
+     /* If there is no selected route or matched route is EGP, go up
+        tree. */
+     if ((!match) || (match->type == ZEBRA_ROUTE_BGP))
+        {
+           do {
+              rn = rn->parent;
+           } while (rn && rn->info == NULL);
+           if (rn)
+              route_lock_node (rn);
+        }
+     else
+     {
+        if (match)
+        {
+           if (match->type == ZEBRA_ROUTE_CONNECT)
+           {
+              /* Directly point connected route. */
+              newhop = match->nexthop;
+
+              if (newhop && nexthop->type == NEXTHOP_TYPE_IPV6)
+                 nexthop->ifindex = newhop->ifindex;
+              
+              return 1;
+           }
+           else if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_INTERNAL))
+           {
+              for (newhop = match->nexthop; newhop; newhop = newhop->next)
+                 if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB)
+                     && ! CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_RECURSIVE))
+                 {
+                    if (set)
+                    {
+                       SET_FLAG (nexthop->flags, NEXTHOP_FLAG_RECURSIVE);
+                       nexthop->rtype = newhop->type;
+                       if (newhop->type == NEXTHOP_TYPE_IPV6
+                           || newhop->type == NEXTHOP_TYPE_IPV6_IFINDEX
+                           || newhop->type == NEXTHOP_TYPE_IPV6_IFNAME)
+                          nexthop->rgate.ipv6 = newhop->gate.ipv6;
+                       if (newhop->type == NEXTHOP_TYPE_IFINDEX
+                           || newhop->type == NEXTHOP_TYPE_IFNAME
+                           || newhop->type == NEXTHOP_TYPE_IPV6_IFINDEX
+                           || newhop->type == NEXTHOP_TYPE_IPV6_IFNAME)
+                          nexthop->rifindex = newhop->ifindex;
+                    }
+                    return 1;
+                 }
+              return 0;
+           }
+           else
+           {
+              return 0;
+           }
+        } /* match */
+        else
+        {
+           /* no match */
+           break;
+        }
+     } /* not bgp */
+  } /* while */
   return 0;
 }
 #endif /* HAVE_IPV6 */
@@ -424,39 +444,51 @@
   rn = route_node_match (rib_table_ipv4, (struct prefix *) &p);
 
   while (rn)
-    {
-      route_unlock_node (rn);
+  {
+     route_unlock_node (rn);
       
-      /* Pick up selected route. */
-      for (match = rn->info; match; match = match->next)
-	if (CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
-	  break;
-
-      /* If there is no selected route or matched route is EGP, go up
-         tree. */
-      if (! match 
-	  || match->type == ZEBRA_ROUTE_BGP)
-	{
-	  do {
-	    rn = rn->parent;
-	  } while (rn && rn->info == NULL);
-	  if (rn)
-	    route_lock_node (rn);
-	}
-      else
-	{
-	  if (match->type == ZEBRA_ROUTE_CONNECT)
-	    /* Directly point connected route. */
-	    return match;
-	  else
-	    {
-	      for (newhop = match->nexthop; newhop; newhop = newhop->next)
-		if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB))
-		  return match;
-	      return NULL;
-	    }
-	}
-    }
+     /* Pick up selected route. */
+     for (match = rn->info; match; match = match->next)
+        if (CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
+           break;
+
+#ifdef BRCM_BGP_SUPPORT
+     /* If there is no selected route or matched route is EGP, go up
+        tree. */
+
+     if ((!match) || (match->type == ZEBRA_ROUTE_BGP))
+     {
+        do {
+           rn = rn->parent;
+        } while (rn && rn->info == NULL);
+        if (rn)
+           route_lock_node (rn);
+     }
+     else
+     {
+#endif /* BRCM_BGP_SUPPORT */
+        if (match)
+        {
+           if (match->type == ZEBRA_ROUTE_CONNECT)
+              /* Directly point connected route. */
+              return match;
+           else
+           {
+              for (newhop = match->nexthop; newhop; newhop = newhop->next)
+                 if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB))
+                    return match;
+              return NULL;
+           }
+        }/* match */
+        else
+        {
+           /* no match */
+           break;
+        }
+#ifdef BRCM_BGP_SUPPORT
+     }
+#endif
+  }
   return NULL;
 }
 
@@ -481,16 +513,20 @@
     if (CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
       break;
 
-  if (! match || match->type == ZEBRA_ROUTE_BGP)
-    return NULL;
-
-  if (match->type == ZEBRA_ROUTE_CONNECT)
-    return match;
+#ifdef BRCM_BGP_SUPPORT
+  if ((!match) || (match->type == ZEBRA_ROUTE_BGP))
+        return NULL;
+#endif
+
+  if (match)
+  {
+     if (match->type == ZEBRA_ROUTE_CONNECT)
+        return match;
   
-  for (nexthop = match->nexthop; nexthop; nexthop = nexthop->next)
-    if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
-      return match;
-
+     for (nexthop = match->nexthop; nexthop; nexthop = nexthop->next)
+        if (CHECK_FLAG (nexthop->flags, NEXTHOP_FLAG_FIB))
+           return match;
+  } /* match */
   return NULL;
 }
 
@@ -511,39 +547,46 @@
   rn = route_node_match (rib_table_ipv6, (struct prefix *) &p);
 
   while (rn)
-    {
-      route_unlock_node (rn);
+  {
+     route_unlock_node (rn);
       
-      /* Pick up selected route. */
-      for (match = rn->info; match; match = match->next)
-	if (CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
-	  break;
-
-      /* If there is no selected route or matched route is EGP, go up
-         tree. */
-      if (! match 
-	  || match->type == ZEBRA_ROUTE_BGP)
-	{
-	  do {
-	    rn = rn->parent;
-	  } while (rn && rn->info == NULL);
-	  if (rn)
-	    route_lock_node (rn);
-	}
-      else
-	{
-	  if (match->type == ZEBRA_ROUTE_CONNECT)
-	    /* Directly point connected route. */
-	    return match;
-	  else
-	    {
-	      for (newhop = match->nexthop; newhop; newhop = newhop->next)
-		if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB))
-		  return match;
-	      return NULL;
-	    }
-	}
-    }
+     /* Pick up selected route. */
+     for (match = rn->info; match; match = match->next)
+        if (CHECK_FLAG (match->flags, ZEBRA_FLAG_SELECTED))
+           break;
+
+     /* If there is no selected route or matched route is EGP, go up
+        tree. */
+     if ((!match) || (match->type == ZEBRA_ROUTE_BGP))
+     {
+        do {
+           rn = rn->parent;
+        } while (rn && rn->info == NULL);
+        if (rn)
+           route_lock_node (rn);
+     }
+     else
+     {
+        if (match)
+        {
+           if (match->type == ZEBRA_ROUTE_CONNECT)
+              /* Directly point connected route. */
+              return match;
+           else
+           {
+              for (newhop = match->nexthop; newhop; newhop = newhop->next)
+                 if (CHECK_FLAG (newhop->flags, NEXTHOP_FLAG_FIB))
+                    return match;
+              return NULL;
+           }
+        } /* match */
+        else
+        {
+           /* no match */
+           break;
+        }
+     }
+  }/* while */
   return NULL;
 }
 #endif /* HAVE_IPV6 */
@@ -582,9 +625,9 @@
     case NEXTHOP_TYPE_IPV4:
     case NEXTHOP_TYPE_IPV4_IFINDEX:
       if (nexthop_active_ipv4 (rib, nexthop, set, rn))
-	SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+         SET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
       else
-	UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
+         UNSET_FLAG (nexthop->flags, NEXTHOP_FLAG_ACTIVE);
       break;
 #ifdef HAVE_IPV6
     case NEXTHOP_TYPE_IPV6:
@@ -728,11 +771,9 @@
   for (rib = rn->info; rib; rib = next)
     {
       next = rib->next;
-
       /* Currently installed rib. */
       if (CHECK_FLAG (rib->flags, ZEBRA_FLAG_SELECTED))
 	fib = rib;
-
       /* Skip unreachable nexthop. */
       if (! nexthop_active_update (rn, rib, 0))
 	continue;
@@ -837,9 +878,11 @@
     {
       distance = route_info[type].distance;
 
+#ifdef BRCM_BGP_SUPPORT
       /* iBGP distance is 200. */
       if (type == ZEBRA_ROUTE_BGP && CHECK_FLAG (flags, ZEBRA_FLAG_IBGP))
 	distance = 200;
+#endif
     }
 
   /* Lookup route node.*/
@@ -928,10 +971,12 @@
     {
       rib->distance = route_info[rib->type].distance;
 
+#ifdef BRCM_BGP_SUPPORT
       /* iBGP distance is 200. */
       if (rib->type == ZEBRA_ROUTE_BGP 
 	  && CHECK_FLAG (rib->flags, ZEBRA_FLAG_IBGP))
 	rib->distance = 200;
+#endif /* BRCM_BGP_SUPPORT */
     }
 
   /* Lookup route node.*/
@@ -987,6 +1032,7 @@
   rn = route_node_lookup (rib_table_ipv4, (struct prefix *) p);
   if (! rn)
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_ZEBRA_DEBUG_KERNEL)
 	{
 	  if (gate)
@@ -1001,6 +1047,7 @@
 		       p->prefixlen,
 		       ifindex);
 	}
+#endif /* BRCM_RIP_DEBUG */
       return ZEBRA_ERR_RTNOEXIST;
     }
 
@@ -1055,6 +1102,7 @@
 	}
       else
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_ZEBRA_DEBUG_KERNEL)
 	    {
 	      if (gate)
@@ -1071,6 +1119,7 @@
 			   ifindex,
 			   type);
 	    }
+#endif /* BRCM_RIP_DEBUG */
 	  route_unlock_node (rn);
 	  return ZEBRA_ERR_RTNOEXIST;
 	}
@@ -1365,6 +1414,7 @@
   return 1;
 }
 
+#ifdef BRCM_CMD_SUPPORT
 /* Write IPv4 static route configuration. */
 int
 static_ipv4_write (struct vty *vty)
@@ -1988,6 +2038,7 @@
 
   return CMD_SUCCESS;
 }
+#endif /* BRCM_CMD_SUPPORT */
 
 #ifdef HAVE_IPV6
 int
@@ -2123,6 +2174,7 @@
   rn = route_node_lookup (rib_table_ipv6, (struct prefix *) p);
   if (! rn)
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_ZEBRA_DEBUG_KERNEL)
 	{
 	  if (gate)
@@ -2137,6 +2189,7 @@
 		       p->prefixlen,
 		       ifindex);
 	}
+#endif
       return ZEBRA_ERR_RTNOEXIST;
     }
 
@@ -2191,6 +2244,7 @@
 	}
       else
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_ZEBRA_DEBUG_KERNEL)
 	    {
 	      if (gate)
@@ -2207,6 +2261,7 @@
 			   ifindex,
 			   type);
 	    }
+#endif /* BRCM_RIP_DEBUG */
 	  route_unlock_node (rn);
 	  return ZEBRA_ERR_RTNOEXIST;
 	}
@@ -3229,6 +3284,7 @@
 #endif /* HAVE_IPV6 */
 }
 
+#ifdef BRCM_CMD_SUPPORT
 /* Static ip route configuration write function. */
 int
 config_write_ip (struct vty *vty)
@@ -3250,16 +3306,20 @@
   "",				/* This node has no interface. */
   1
 };
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Routing information base initialize. */
 void
 rib_init ()
 {
+#ifdef BRCM_CMD_SUPPORT
   install_node (&ip_node, config_write_ip);
+#endif
 
   rib_table_ipv4 = route_table_init ();
   static_table_ipv4 = route_table_init ();
 
+#ifdef BRCM_CMD_SUPPORT
   install_element (VIEW_NODE, &show_ip_route_cmd);
   install_element (VIEW_NODE, &show_ip_route_addr_cmd);
   install_element (VIEW_NODE, &show_ip_route_prefix_cmd);
@@ -3280,11 +3340,13 @@
   install_element (CONFIG_NODE, &ip_route_mask_pref_cmd);
   install_element (CONFIG_NODE, &no_ip_route_pref_cmd);
   install_element (CONFIG_NODE, &no_ip_route_mask_pref_cmd);
+#endif /* BRCM_CMD_SUPPORT */
 
 #ifdef HAVE_IPV6
   rib_table_ipv6 = route_table_init ();
   static_table_ipv6 = route_table_init ();
 
+#ifdef BRCM_CMD_SUPPORT
   install_element (CONFIG_NODE, &ipv6_route_cmd);
   install_element (CONFIG_NODE, &ipv6_route_ifname_cmd);
   install_element (CONFIG_NODE, &no_ipv6_route_cmd);
@@ -3303,5 +3365,6 @@
   install_element (ENABLE_NODE, &show_ipv6_route_addr_cmd);
   install_element (ENABLE_NODE, &show_ipv6_route_prefix_cmd);
   install_element (ENABLE_NODE, &show_ipv6_route_prefix_longer_cmd);
+#endif /* BRCM_CMD_SUPPORT */
 #endif /* HAVE_IPV6 */
 }
diff -Naur zebra/zebra/rtadv.c zebra-brcm/zebra/rtadv.c
--- zebra/zebra/rtadv.c	2002-02-09 16:43:25.000000000 -0400
+++ zebra-brcm/zebra/rtadv.c	2018-11-23 18:54:26.976999474 -0400
@@ -19,6 +19,7 @@
  * 02111-1307, USA.  
  */
 
+#if defined (HAVE_IPV6) && defined (RTADV)
 #include <zebra.h>
 
 #include "memory.h"
@@ -34,8 +35,6 @@
 #include "zebra/rtadv.h"
 #include "zebra/debug.h"
 
-#if defined (HAVE_IPV6) && defined (RTADV)
-
 /* If RFC2133 definition is used. */
 #ifndef IPV6_JOIN_GROUP
 #define IPV6_JOIN_GROUP  IPV6_ADD_MEMBERSHIP 
@@ -1042,6 +1041,7 @@
   rtadv = rtadv_new ();
   rtadv->sock = sock;
 
+#ifdef BRCM_CMD_SUPPORT
   install_element (INTERFACE_NODE, &ipv6_nd_suppress_ra_cmd);
   install_element (INTERFACE_NODE, &no_ipv6_nd_suppress_ra_cmd);
   install_element (INTERFACE_NODE, &ipv6_nd_send_ra_cmd);
@@ -1059,6 +1059,7 @@
   install_element (INTERFACE_NODE, &ipv6_nd_prefix_advertisement_cmd);
   install_element (INTERFACE_NODE, &ipv6_nd_prefix_advertisement_no_val_cmd);
   install_element (INTERFACE_NODE, &no_ipv6_nd_prefix_advertisement_cmd);
+#endif
 }
 
 int
diff -Naur zebra/zebra/rt_netlink.c zebra-brcm/zebra/rt_netlink.c
--- zebra/zebra/rt_netlink.c	2002-07-06 04:37:00.000000000 -0300
+++ zebra-brcm/zebra/rt_netlink.c	2018-11-23 18:54:26.976999474 -0400
@@ -78,16 +78,20 @@
   sock = socket (AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
   if (sock < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_ERR, "Can't open %s socket: %s", nl->name,
 	    strerror (errno));
+#endif
       return -1;
     }
 
   ret = fcntl (sock, F_SETFL, O_NONBLOCK);
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_ERR, "Can't set %s socket flags: %s", nl->name,
 	    strerror (errno));
+#endif
       close (sock);
       return -1;
     }
@@ -100,8 +104,10 @@
   ret = bind (sock, (struct sockaddr *) &snl, sizeof snl);
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_ERR, "Can't bind %s socket to group 0x%x: %s", 
 	    nl->name, snl.nl_groups, strerror (errno));
+#endif
       close (sock);
       return -1;
     }
@@ -111,8 +117,10 @@
   ret = getsockname (sock, (struct sockaddr *) &snl, &namelen);
   if (ret < 0 || namelen != sizeof snl)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_ERR, "Can't get %s socket name: %s", nl->name,
 	    strerror (errno));
+#endif
       close (sock);
       return -1;
     }
@@ -139,7 +147,9 @@
   /* Check netlink socket. */
   if (nl->sock < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_ERR, "%s socket isn't active.", nl->name);
+#endif
       return -1;
     }
 
@@ -157,7 +167,9 @@
 		(struct sockaddr*) &snl, sizeof snl);
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_ERR, "%s sendto failed: %s", nl->name, strerror (errno));
+#endif
       return -1;
     }
   return 0;
@@ -189,20 +201,26 @@
 	    continue;
 	  if (errno == EWOULDBLOCK)
 	    break;
+#ifdef BRCM_RIP_DEBUG
 	  zlog (NULL, LOG_ERR, "%s recvmsg overrun", nl->name);
+#endif
 	  continue;
 	}
 
       if (status == 0)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog (NULL, LOG_ERR, "%s EOF", nl->name);
+#endif
 	  return -1;
 	}
 
       if (msg.msg_namelen != sizeof snl)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog (NULL, LOG_ERR, "%s sender address length error: length %d",
 	       nl->name, msg.msg_namelen);
+#endif
 	  return -1;
 	}
 
@@ -221,6 +239,7 @@
               /* If the error field is zero, then this is an ACK */
               if (err->error == 0) 
                 {
+#ifdef BRCM_RIP_DEBUG
                   if (IS_ZEBRA_DEBUG_KERNEL) 
                     {  
                       zlog_info("%s: %s ACK: type=%s(%u), seq=%u, pid=%d", 
@@ -229,7 +248,7 @@
                         err->msg.nlmsg_type, err->msg.nlmsg_seq,
 		        err->msg.nlmsg_pid);
                     }
-                
+#endif                
                   /* return if not a multipart message, otherwise continue */  
                   if(!(h->nlmsg_flags & NLM_F_MULTI)) 
                     { 
@@ -240,42 +259,50 @@
               
               if (h->nlmsg_len < NLMSG_LENGTH (sizeof (struct nlmsgerr)))
 		{
+#ifdef BRCM_RIP_DEBUG
 		  zlog (NULL, LOG_ERR, "%s error: message truncated",
 			nl->name);
+#endif
 		  return -1;
 		}
+#ifdef BRCM_RIP_DEBUG
 	      zlog (NULL, LOG_ERR, "%s error: %s, type=%s(%u), seq=%u, pid=%d",
 		    nl->name, strerror (-err->error),
 		    lookup (nlmsg_str, err->msg.nlmsg_type),
 		    err->msg.nlmsg_type, err->msg.nlmsg_seq,
 		    err->msg.nlmsg_pid);
+#endif
 	      /*
 	      ret = -1;
 	      continue;
 	      */
 	      return -1;
 	    }
-
+#ifdef BRCM_RIP_DEBUG
 	  /* OK we got netlink message. */
 	  if (IS_ZEBRA_DEBUG_KERNEL)
 	    zlog_info ("netlink_parse_info: %s type %s(%u), seq=%u, pid=%d",
 		      nl->name,
 		      lookup (nlmsg_str, h->nlmsg_type), h->nlmsg_type,
 		      h->nlmsg_seq, h->nlmsg_pid);
-
+#endif
 	  /* skip unsolicited messages originating from command socket */
 	  if (nl != &netlink_cmd && h->nlmsg_pid == netlink_cmd.snl.nl_pid)
 	    {
+#ifdef BRCM_RIP_DEBUG
 	      if (IS_ZEBRA_DEBUG_KERNEL)
 		zlog_info ("netlink_parse_info: %s packet comes from %s",
 			  nl->name, netlink_cmd.name);
+#endif
 	      continue;
 	    }
 
 	  error = (*filter) (&snl, h);
 	  if (error < 0)
 	    {
+#ifdef BRCM_RIP_DEBUG
 	      zlog (NULL, LOG_ERR, "%s filter function error", nl->name);
+#endif
 	      ret = error;
 	    }
 	}
@@ -283,13 +310,17 @@
       /* After error care. */
       if (msg.msg_flags & MSG_TRUNC)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog (NULL, LOG_ERR, "%s error: message truncated", nl->name);
+#endif
 	  continue;
 	}
       if (status)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog (NULL, LOG_ERR, "%s error: data remnant size %d", nl->name,
 		status);
+#endif
 	  return -1;
 	}
     }
@@ -353,8 +384,11 @@
 
       hw_addr_len = RTA_PAYLOAD(tb[IFLA_ADDRESS]);
 
-      if (hw_addr_len > INTERFACE_HWADDR_MAX)
+      if (hw_addr_len > INTERFACE_HWADDR_MAX) {
+#ifdef BRCM_RIP_DEBUG
 	zlog_warn ("Hardware address is too large: %d", hw_addr_len);
+#endif
+      }
       else
 	{      
 	  ifp->hw_addr_len = hw_addr_len;
@@ -411,8 +445,10 @@
   ifp = if_lookup_by_index (ifa->ifa_index);
   if (ifp == NULL)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_err ("netlink_interface_addr can't find interface by index %d",
 		ifa->ifa_index);
+#endif
       return -1;
     }
 
@@ -580,6 +616,7 @@
   return 0;
 }
 
+#if defined(BRCM_RIP_DEBUG) || defined(BRCM_CMD_DEBUG)
 struct message rtproto_str [] = 
 {
   {RTPROT_REDIRECT, "redirect"},
@@ -595,6 +632,7 @@
 #endif /* RTPROT_BIRD */
   {0,               NULL}
 };
+#endif /* BRCM_RIP_DEBUG */
 
 /* Routing information change from the kernel. */
 int
@@ -616,10 +654,12 @@
   if (! (h->nlmsg_type == RTM_NEWROUTE || h->nlmsg_type == RTM_DELROUTE))
     {
       /* If this is not route add/delete message print warning. */
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("Kernel message: %d\n", h->nlmsg_type);
+#endif
       return 0;
     }
-
+#ifdef BRCM_RIP_DEBUG
   /* Connected route. */
   if (IS_ZEBRA_DEBUG_KERNEL)
     zlog_info ("%s %s %s proto %s",
@@ -627,7 +667,7 @@
 	       rtm->rtm_family == AF_INET ? "ipv4" : "ipv6",
 	       rtm->rtm_type == RTN_UNICAST ? "unicast" : "multicast",
 	       lookup (rtproto_str, rtm->rtm_protocol));
-
+#endif
   if (rtm->rtm_type != RTN_UNICAST)
     {
       return 0;
@@ -658,7 +698,9 @@
 
   if (rtm->rtm_src_len != 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("netlink_route_change(): no src len");
+#endif
       return 0;
     }
   
@@ -684,15 +726,17 @@
       memcpy (&p.prefix, dest, 4);
       p.prefixlen = rtm->rtm_dst_len;
 
+#ifdef BRCM_RIP_DEBUG
       if (IS_ZEBRA_DEBUG_KERNEL)
 	{
-	  if (h->nlmsg_type == RTM_NEWROUTE)
+	  if (h->nlmsg_type == RTM_NEWROUTE) 
 	    zlog_info ("RTM_NEWROUTE %s/%d",
 		       inet_ntoa (p.prefix), p.prefixlen);
-	  else
+	  else 
 	    zlog_info ("RTM_DELROUTE %s/%d",
 		       inet_ntoa (p.prefix), p.prefixlen);
 	}
+#endif /* BRCM_RIP_DEBUG */
 
       if (h->nlmsg_type == RTM_NEWROUTE)
 	rib_add_ipv4 (ZEBRA_ROUTE_KERNEL, 0, &p, gate, index, table, 0, 0);
@@ -710,18 +754,19 @@
       memcpy (&p.prefix, dest, 16);
       p.prefixlen = rtm->rtm_dst_len;
 
+#ifdef BRCM_RIP_DEBUG
       if (IS_ZEBRA_DEBUG_KERNEL)
 	{
-	  if (h->nlmsg_type == RTM_NEWROUTE)
+	  if (h->nlmsg_type == RTM_NEWROUTE) 
 	    zlog_info ("RTM_NEWROUTE %s/%d",
 		       inet_ntop (AF_INET6, &p.prefix, buf, BUFSIZ),
 		       p.prefixlen);
-	  else
+	  else 
 	    zlog_info ("RTM_DELROUTE %s/%d",
 		       inet_ntop (AF_INET6, &p.prefix, buf, BUFSIZ),
 		       p.prefixlen);
 	}
-
+#endif
       if (h->nlmsg_type == RTM_NEWROUTE)
 	rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, 0, &p, gate, index, 0);
       else
@@ -745,9 +790,11 @@
 
   if (! (h->nlmsg_type == RTM_NEWLINK || h->nlmsg_type == RTM_DELLINK))
     {
+#ifdef BRCM_RIP_DEBUG
       /* If this is not link add/delete message so print warning. */
       zlog_warn ("netlink_link_change: wrong kernel message %d\n",
 		 h->nlmsg_type);
+#endif
       return 0;
     }
 
@@ -808,8 +855,10 @@
 
       if (ifp == NULL)
 	{
+#ifdef BRCM_RIP_DEBUG
 	  zlog (NULL, LOG_WARNING, "interface %s is deleted but can't find",
 		ifp->name);
+#endif
 	  return 0;
 	}
       
@@ -843,7 +892,9 @@
       return netlink_interface_addr (snl, h);
       break;
     default:
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("Unknown netlink nlmsg_type %d\n", h->nlmsg_type);
+#endif
       break;
     }
   return 0;
@@ -979,7 +1030,9 @@
 static int
 netlink_talk_filter (struct sockaddr_nl *snl, struct nlmsghdr *h)
 {
+#ifdef BRCM_RIP_DEBUG
   zlog_warn ("netlink_talk: ignoring message type 0x%04x", h->nlmsg_type);
+#endif
   return 0;
 }
 
@@ -1000,18 +1053,21 @@
 
   /* Request an acknowledgement by setting NLM_F_ACK */
   n->nlmsg_flags |= NLM_F_ACK;
-  
+
+#ifdef BRCM_RIP_DEBUG  
   if (IS_ZEBRA_DEBUG_KERNEL) 
     zlog_info ("netlink_talk: %s type %s(%u), seq=%u", netlink_cmd.name,
 	      lookup (nlmsg_str, n->nlmsg_type), n->nlmsg_type,
 	      n->nlmsg_seq);
-
+#endif
   /* Send message to netlink interface. */
   status = sendmsg (nl->sock, &msg, 0);
   if (status < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_ERR, "netlink_talk sendmsg() error: %s",
 	    strerror (errno));
+#endif
       return -1;
     }
   
@@ -1021,14 +1077,18 @@
    */
   if((flags = fcntl(nl->sock, F_GETFL, 0)) < 0) 
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_ERR, "%s:%i F_GETFL error: %s", 
               __FUNCTION__, __LINE__, strerror (errno));
+#endif
     }
   flags &= ~O_NONBLOCK;
   if(fcntl(nl->sock, F_SETFL, flags) < 0) 
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_ERR, "%s:%i F_SETFL error: %s", 
               __FUNCTION__, __LINE__, strerror (errno));
+#endif
     }
 
   /* 
@@ -1041,8 +1101,10 @@
   flags |= O_NONBLOCK;
   if(fcntl(nl->sock, F_SETFL, flags) < 0) 
     {
+#ifdef BRCM_RIP_DEBUG
       zlog (NULL, LOG_ERR, "%s:%i F_SETFL error: %s", 
               __FUNCTION__, __LINE__, strerror (errno));
+#endif
     }
   
   return status;
@@ -1328,8 +1390,10 @@
   /* If there is no useful nexthop then return. */
   if (nexthop_num == 0)
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_ZEBRA_DEBUG_KERNEL)
 	zlog_info ("netlink_route_multipath(): No useful nexthop.");
+#endif
       return 0;
     }
 
diff -Naur zebra/zebra/zserv.c zebra-brcm/zebra/zserv.c
--- zebra/zebra/zserv.c	2002-07-08 10:32:30.000000000 -0300
+++ zebra-brcm/zebra/zserv.c	2018-11-23 18:54:26.976999474 -0400
@@ -793,7 +793,7 @@
   
   return writen (client->sock, s->data, stream_get_endp (s));
 }
-
+#ifdef BRCM_SUPPORT
 int
 zsend_ipv4_import_lookup (struct zserv *client, struct prefix_ipv4 *p)
 {
@@ -849,6 +849,7 @@
   
   return writen (client->sock, s->data, stream_get_endp (s));
 }
+#endif /* BRCM_SUPPORT */
 
 /* Register zebra server interface information.  Send current all
    interface and address information. */
@@ -1047,6 +1048,7 @@
   zsend_ipv4_nexthop_lookup (client, addr);
 }
 
+#ifdef BRCM_SUPPORT
 /* Nexthop lookup for IPv4. */
 void
 zread_ipv4_import_lookup (struct zserv *client, u_short length)
@@ -1059,6 +1061,7 @@
 
   zsend_ipv4_import_lookup (client, &p);
 }
+#endif /* BRCM_SUPPORT */
 
 #ifdef HAVE_IPV6
 /* Zebra server IPv6 prefix add function. */
@@ -1313,8 +1316,10 @@
   nbyte = stream_read (client->ibuf, sock, 3);
   if (nbyte <= 0) 
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_ZEBRA_DEBUG_EVENT)
 	zlog_info ("connection closed socket [%d]", sock);
+#endif
       zebra_client_close (client);
       return -1;
     }
@@ -1323,8 +1328,10 @@
 
   if (length < 3) 
     {
+#ifdef BRCM_RIP_DEBUG
       if (IS_ZEBRA_DEBUG_EVENT)
 	zlog_info ("length %d is less than 3 ", length);
+#endif
       zebra_client_close (client);
       return -1;
     }
@@ -1337,13 +1344,15 @@
       nbyte = stream_read (client->ibuf, sock, length);
       if (nbyte <= 0) 
 	{
+#ifdef BRCM_RIP_DEBUG
 	  if (IS_ZEBRA_DEBUG_EVENT)
 	    zlog_info ("connection closed [%d] when reading zebra data", sock);
+#endif
 	  zebra_client_close (client);
 	  return -1;
 	}
     }
-
+#ifdef BRCM_RIP_DEBUG
   /* Debug packet information. */
   if (IS_ZEBRA_DEBUG_EVENT)
     zlog_info ("zebra message comes from socket [%d]", sock);
@@ -1351,7 +1360,7 @@
   if (IS_ZEBRA_DEBUG_PACKET && IS_ZEBRA_DEBUG_RECV)
     zlog_info ("zebra message received [%s] %d", 
 	       zebra_command_str[command], length);
-
+#endif /* BRCM_RIP_DEBUG */
   switch (command) 
     {
     case ZEBRA_INTERFACE_ADD:
@@ -1394,11 +1403,15 @@
       zread_ipv6_nexthop_lookup (client, length);
       break;
 #endif /* HAVE_IPV6 */
+#ifdef BRCM_SUPPORT
     case ZEBRA_IPV4_IMPORT_LOOKUP:
       zread_ipv4_import_lookup (client, length);
       break;
+#endif /* BRCM_SUPPORT */
     default:
+#ifdef BRCM_RIP_DEBUG
       zlog_info ("Zebra received unknown command %d", command);
+#endif
       break;
     }
 
@@ -1439,7 +1452,9 @@
 
   if (client_sock < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("Can't accept zebra socket: %s", strerror (errno));
+#endif
       return -1;
     }
 
@@ -1464,8 +1479,10 @@
 
   if (accept_sock < 0) 
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("Can't bind to socket: %s", strerror (errno));
       zlog_warn ("zebra can't provice full functionality due to above error");
+#endif
       return;
     }
 
@@ -1484,8 +1501,10 @@
 	       sizeof (struct sockaddr_in));
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("Can't bind to socket: %s", strerror (errno));
       zlog_warn ("zebra can't provice full functionality due to above error");
+#endif
       close (accept_sock);      /* Avoid sd leak. */
       return;
     }
@@ -1493,8 +1512,10 @@
   ret = listen (accept_sock, 1);
   if (ret < 0)
     {
+#ifdef BRCM_RIP_DEBUG
       zlog_warn ("Can't listen to socket: %s", strerror (errno));
       zlog_warn ("zebra can't provice full functionality due to above error");
+#endif
       close (accept_sock);	/* Avoid sd leak. */
       return;
     }
@@ -1502,6 +1523,7 @@
   zebra_event (ZEBRA_SERV, accept_sock, NULL);
 }
 
+#if !defined(HAVE_TCP_ZEBRA)
 /* For sockaddr_un. */
 #include <sys/un.h>
 
@@ -1558,6 +1580,8 @@
 
   zebra_event (ZEBRA_SERV, sock, NULL);
 }
+#endif /* !defined(HAVE_TCP_ZEBRA) */
+
 
 /* Zebra's event management function. */
 extern struct thread_master *master;
@@ -1580,6 +1604,8 @@
     }
 }
 
+
+#ifdef BRCM_CMD_SUPPORT
 /* Display default rtm_table for all clients. */
 DEFUN (show_table,
        show_table_cmd,
@@ -1587,9 +1613,11 @@
        SHOW_STR
        "default routing table to use for all clients\n")
 {
+#ifdef BRCM_CMD_SUPPORT
   vty_out (vty, "table %d%s", rtm_table_default,
 	   VTY_NEWLINE);
   return CMD_SUCCESS;
+#endif
 }
 
 DEFUN (config_table, 
@@ -1613,6 +1641,7 @@
 
   ret = ipforward ();
 
+#ifdef BRCM_CMD_SUPPORT
   if (ret == 0)
     {
       vty_out (vty, "IP forwarding is already off%s", VTY_NEWLINE); 
@@ -1625,7 +1654,7 @@
       vty_out (vty, "Can't turn off IP forwarding%s", VTY_NEWLINE);
       return CMD_WARNING;
     }
-
+#endif
   return CMD_SUCCESS;
 }
 
@@ -1666,6 +1695,7 @@
   1
 };
 
+
 /* Only display ip forwarding is enabled or not. */
 DEFUN (show_ip_forwarding,
        show_ip_forwarding_cmd,
@@ -1677,7 +1707,6 @@
   int ret;
 
   ret = ipforward ();
-
   if (ret == 0)
     vty_out (vty, "IP forwarding is off%s", VTY_NEWLINE);
   else
@@ -1697,7 +1726,6 @@
   int ret;
 
   ret = ipforward_ipv6 ();
-
   switch (ret)
     {
     case -1:
@@ -1726,6 +1754,7 @@
   int ret;
 
   ret = ipforward_ipv6_off ();
+
   if (ret != 0)
     {
       vty_out (vty, "Can't turn off IPv6 forwarding%s", VTY_NEWLINE);
@@ -1737,6 +1766,7 @@
 
 #endif /* HAVE_IPV6 */
 
+
 /* IPForwarding configuration write function. */
 int
 config_write_forwarding (struct vty *vty)
@@ -1758,7 +1788,7 @@
   "",				/* This node has no interface. */
   1
 };
-
+#endif /* BRCM_CMD_SUPPORT */
 
 /* Initialisation of zebra and installation of commands. */
 void
@@ -1767,8 +1797,11 @@
   /* Client list init. */
   client_list = list_new ();
 
+#ifdef BRCM_CDM_SUPPORT
   /* Forwarding is on by default. */
   ipforward_on ();
+#endif 
+
 #ifdef HAVE_IPV6
   ipforward_ipv6_on ();
 #endif /* HAVE_IPV6 */
@@ -1780,6 +1813,7 @@
   zebra_serv_un (ZEBRA_SERV_PATH);
 #endif /* HAVE_TCP_ZEBRA */
 
+#ifdef BRCM_CMD_SUPPORT
   /* Install configuration write function. */
   install_node (&table_node, config_write_table);
   install_node (&forwarding_node, config_write_forwarding);
@@ -1800,4 +1834,5 @@
   install_element (ENABLE_NODE, &show_ipv6_forwarding_cmd);
   install_element (CONFIG_NODE, &no_ipv6_forwarding_cmd);
 #endif /* HAVE_IPV6 */
+#endif  /* BRCM_CMD_SUPPORT */
 }
