diff -Naur radvd-1.8/config.h radvd-1.8-brcm/config.h
--- radvd-1.8/config.h	1969-12-31 20:00:00.000000000 -0400
+++ radvd-1.8-brcm/config.h	2018-11-24 16:42:07.681994362 -0400
@@ -0,0 +1,112 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define to 1 if you have the `getopt_long' function. */
+#define HAVE_GETOPT_LONG 1
+
+/* Define to 1 if you have the <ifaddrs.h> header file. */
+/* #undef HAVE_IFADDRS_H */
+
+/* whether struct in6_addr has u6_addrXX and defines s6_addrXX */
+#define HAVE_IN6_ADDR_S6_ADDR 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `c' library (-lc). */
+#define HAVE_LIBC 1
+
+/* Define to 1 if you have the <machine/limits.h> header file. */
+/* #undef HAVE_MACHINE_LIMITS_H */
+
+/* Define to 1 if you have the <machine/param.h> header file. */
+/* #undef HAVE_MACHINE_PARAM_H */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Linux netlink */
+#define HAVE_NETLINK 1
+
+/* Define to 1 if you have the <net/if_arp.h> header file. */
+#define HAVE_NET_IF_ARP_H 1
+
+/* Define to 1 if you have the <net/if_dl.h> header file. */
+/* #undef HAVE_NET_IF_DL_H */
+
+/* Define to 1 if you have the <net/if_types.h> header file. */
+/* #undef HAVE_NET_IF_TYPES_H */
+
+/* whether struct sockaddr_in6 has sin6_scope_id */
+#define HAVE_SIN6_SCOPE_ID 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/sockio.h> header file. */
+/* #undef HAVE_SYS_SOCKIO_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <time.h> header file. */
+#define HAVE_TIME_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME ""
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING ""
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME ""
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION ""
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
+   `char[]'. */
+/* #undef YYTEXT_POINTER */
+
+/* whether compiling on Linux, glibc>=2.8 doesn't expose in6_pktinfo
+   otherwise.. */
+#define _GNU_SOURCE /**/
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
diff -Naur radvd-1.8/gram.c radvd-1.8-brcm/gram.c
--- radvd-1.8/gram.c	1969-12-31 20:00:00.000000000 -0400
+++ radvd-1.8-brcm/gram.c	2018-11-24 16:42:07.693984085 -0400
@@ -0,0 +1,2952 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 189 of yacc.c  */
+#line 16 "gram.y"
+
+#include "config.h"
+#include "includes.h"
+#include "radvd.h"
+#include "defaults.h"
+
+extern struct Interface *IfaceList;
+struct Interface *iface = NULL;
+struct AdvPrefix *prefix = NULL;
+struct AdvRoute *route = NULL;
+struct AdvRDNSS *rdnss = NULL;
+struct AdvDNSSL *dnssl = NULL;
+
+extern char *conf_file;
+extern int num_lines;
+extern char *yytext;
+
+static void cleanup(void);
+static void yyerror(char *msg);
+static int countbits(int b);
+static int count_mask(struct sockaddr_in6 *m);
+static struct in6_addr get_prefix6(struct in6_addr const *addr, struct in6_addr const *mask);
+
+#if 0 /* no longer necessary? */
+#ifndef HAVE_IN6_ADDR_S6_ADDR
+# ifdef __FreeBSD__
+#  define s6_addr32 __u6_addr.__u6_addr32
+#  define s6_addr16 __u6_addr.__u6_addr16
+# endif
+#endif
+#endif
+
+#define ABORT	do { cleanup(); YYABORT; } while (0);
+#define ADD_TO_LL(type, list, value) \
+	do { \
+		if (iface->list == NULL) \
+			iface->list = value; \
+		else { \
+			type *current = iface->list; \
+			while (current->next != NULL) \
+				current = current->next; \
+			current->next = value; \
+		} \
+	} while (0)
+
+
+
+
+/* Line 189 of yacc.c  */
+#line 122 "gram.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_INTERFACE = 258,
+     T_PREFIX = 259,
+     T_ROUTE = 260,
+     T_RDNSS = 261,
+     T_DNSSL = 262,
+     T_CLIENTS = 263,
+     STRING = 264,
+     NUMBER = 265,
+     SIGNEDNUMBER = 266,
+     DECIMAL = 267,
+     SWITCH = 268,
+     IPV6ADDR = 269,
+     INFINITY = 270,
+     T_IgnoreIfMissing = 271,
+     T_AdvSendAdvert = 272,
+     T_MaxRtrAdvInterval = 273,
+     T_MinRtrAdvInterval = 274,
+     T_MinDelayBetweenRAs = 275,
+     T_AdvManagedFlag = 276,
+     T_AdvOtherConfigFlag = 277,
+     T_AdvLinkMTU = 278,
+     T_AdvReachableTime = 279,
+     T_AdvRetransTimer = 280,
+     T_AdvCurHopLimit = 281,
+     T_AdvDefaultLifetime = 282,
+     T_AdvDefaultPreference = 283,
+     T_AdvSourceLLAddress = 284,
+     T_AdvOnLink = 285,
+     T_AdvAutonomous = 286,
+     T_AdvValidLifetime = 287,
+     T_AdvPreferredLifetime = 288,
+     T_DeprecatePrefix = 289,
+     T_DecrementLifetimes = 290,
+     T_AdvRouterAddr = 291,
+     T_AdvHomeAgentFlag = 292,
+     T_AdvIntervalOpt = 293,
+     T_AdvHomeAgentInfo = 294,
+     T_Base6Interface = 295,
+     T_Base6to4Interface = 296,
+     T_UnicastOnly = 297,
+     T_HomeAgentPreference = 298,
+     T_HomeAgentLifetime = 299,
+     T_AdvRoutePreference = 300,
+     T_AdvRouteLifetime = 301,
+     T_RemoveRoute = 302,
+     T_AdvRDNSSPreference = 303,
+     T_AdvRDNSSOpenFlag = 304,
+     T_AdvRDNSSLifetime = 305,
+     T_FlushRDNSS = 306,
+     T_AdvDNSSLLifetime = 307,
+     T_FlushDNSSL = 308,
+     T_AdvMobRtrSupportFlag = 309,
+     T_BAD_TOKEN = 310
+   };
+#endif
+/* Tokens.  */
+#define T_INTERFACE 258
+#define T_PREFIX 259
+#define T_ROUTE 260
+#define T_RDNSS 261
+#define T_DNSSL 262
+#define T_CLIENTS 263
+#define STRING 264
+#define NUMBER 265
+#define SIGNEDNUMBER 266
+#define DECIMAL 267
+#define SWITCH 268
+#define IPV6ADDR 269
+#define INFINITY 270
+#define T_IgnoreIfMissing 271
+#define T_AdvSendAdvert 272
+#define T_MaxRtrAdvInterval 273
+#define T_MinRtrAdvInterval 274
+#define T_MinDelayBetweenRAs 275
+#define T_AdvManagedFlag 276
+#define T_AdvOtherConfigFlag 277
+#define T_AdvLinkMTU 278
+#define T_AdvReachableTime 279
+#define T_AdvRetransTimer 280
+#define T_AdvCurHopLimit 281
+#define T_AdvDefaultLifetime 282
+#define T_AdvDefaultPreference 283
+#define T_AdvSourceLLAddress 284
+#define T_AdvOnLink 285
+#define T_AdvAutonomous 286
+#define T_AdvValidLifetime 287
+#define T_AdvPreferredLifetime 288
+#define T_DeprecatePrefix 289
+#define T_DecrementLifetimes 290
+#define T_AdvRouterAddr 291
+#define T_AdvHomeAgentFlag 292
+#define T_AdvIntervalOpt 293
+#define T_AdvHomeAgentInfo 294
+#define T_Base6Interface 295
+#define T_Base6to4Interface 296
+#define T_UnicastOnly 297
+#define T_HomeAgentPreference 298
+#define T_HomeAgentLifetime 299
+#define T_AdvRoutePreference 300
+#define T_AdvRouteLifetime 301
+#define T_RemoveRoute 302
+#define T_AdvRDNSSPreference 303
+#define T_AdvRDNSSOpenFlag 304
+#define T_AdvRDNSSLifetime 305
+#define T_FlushRDNSS 306
+#define T_AdvDNSSLLifetime 307
+#define T_FlushDNSSL 308
+#define T_AdvMobRtrSupportFlag 309
+#define T_BAD_TOKEN 310
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 214 of yacc.c  */
+#line 137 "gram.y"
+
+	unsigned int		num;
+	int			snum;
+	double			dec;
+	struct in6_addr		*addr;
+	char			*str;
+	struct AdvPrefix	*pinfo;
+	struct AdvRoute		*rinfo;
+	struct AdvRDNSS		*rdnssinfo;
+	struct AdvDNSSL		*dnsslinfo;
+	struct Clients		*ainfo;
+
+
+
+/* Line 214 of yacc.c  */
+#line 283 "gram.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 264 of yacc.c  */
+#line 295 "gram.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  7
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   200
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  60
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  35
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  92
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  206
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   310
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,    59,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,    58,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    56,     2,    57,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
+      55
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     8,    14,    17,    19,    20,    23,
+      25,    27,    29,    31,    33,    35,    39,    43,    47,    51,
+      55,    59,    63,    67,    71,    75,    79,    83,    87,    91,
+      95,    99,   103,   107,   111,   115,   119,   123,   127,   131,
+     137,   140,   144,   148,   153,   154,   157,   161,   164,   166,
+     170,   174,   178,   182,   186,   190,   194,   198,   202,   208,
+     213,   214,   216,   219,   221,   225,   229,   233,   239,   242,
+     244,   246,   249,   250,   252,   255,   257,   261,   265,   269,
+     273,   279,   282,   284,   286,   289,   290,   292,   295,   297,
+     301,   305,   307
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      61,     0,    -1,    61,    62,    -1,    62,    -1,    63,    56,
+      65,    57,    58,    -1,     3,    64,    -1,     9,    -1,    -1,
+      66,    65,    -1,    67,    -1,    70,    -1,    68,    -1,    75,
+      -1,    80,    -1,    87,    -1,    19,    10,    58,    -1,    18,
+      10,    58,    -1,    20,    10,    58,    -1,    19,    12,    58,
+      -1,    18,    12,    58,    -1,    20,    12,    58,    -1,    16,
+      13,    58,    -1,    17,    13,    58,    -1,    21,    13,    58,
+      -1,    22,    13,    58,    -1,    23,    10,    58,    -1,    24,
+      10,    58,    -1,    25,    10,    58,    -1,    27,    10,    58,
+      -1,    28,    11,    58,    -1,    26,    10,    58,    -1,    29,
+      13,    58,    -1,    38,    13,    58,    -1,    39,    13,    58,
+      -1,    37,    13,    58,    -1,    43,    10,    58,    -1,    44,
+      10,    58,    -1,    42,    13,    58,    -1,    54,    13,    58,
+      -1,     8,    56,    69,    57,    58,    -1,    14,    58,    -1,
+      69,    14,    58,    -1,    71,    72,    58,    -1,     4,    14,
+      59,    10,    -1,    -1,    56,    57,    -1,    56,    73,    57,
+      -1,    73,    74,    -1,    74,    -1,    30,    13,    58,    -1,
+      31,    13,    58,    -1,    36,    13,    58,    -1,    32,    94,
+      58,    -1,    33,    94,    58,    -1,    34,    13,    58,    -1,
+      35,    13,    58,    -1,    40,    64,    58,    -1,    41,    64,
+      58,    -1,    76,    56,    77,    57,    58,    -1,     5,    14,
+      59,    10,    -1,    -1,    78,    -1,    78,    79,    -1,    79,
+      -1,    45,    11,    58,    -1,    46,    94,    58,    -1,    47,
+      13,    58,    -1,    83,    56,    84,    57,    58,    -1,    81,
+      82,    -1,    82,    -1,    14,    -1,     6,    81,    -1,    -1,
+      85,    -1,    85,    86,    -1,    86,    -1,    48,    10,    58,
+      -1,    49,    13,    58,    -1,    50,    94,    58,    -1,    51,
+      13,    58,    -1,    90,    56,    91,    57,    58,    -1,    88,
+      89,    -1,    89,    -1,     9,    -1,     7,    88,    -1,    -1,
+      92,    -1,    92,    93,    -1,    93,    -1,    52,    94,    58,
+      -1,    53,    13,    58,    -1,    10,    -1,    15,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   152,   152,   153,   156,   202,   217,   224,   226,   229,
+     230,   231,   232,   233,   234,   237,   241,   245,   249,   253,
+     257,   261,   265,   269,   273,   277,   281,   285,   289,   293,
+     297,   301,   305,   309,   313,   317,   321,   325,   329,   335,
+     341,   352,   367,   465,   562,   563,   564,   567,   568,   571,
+     585,   599,   608,   624,   640,   644,   648,   661,   675,   683,
+     707,   708,   711,   712,   716,   720,   724,   730,   737,   738,
+     741,   776,   785,   786,   789,   790,   794,   798,   802,   813,
+     819,   826,   827,   830,   872,   881,   882,   885,   886,   890,
+     901,   907,   911
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_INTERFACE", "T_PREFIX", "T_ROUTE",
+  "T_RDNSS", "T_DNSSL", "T_CLIENTS", "STRING", "NUMBER", "SIGNEDNUMBER",
+  "DECIMAL", "SWITCH", "IPV6ADDR", "INFINITY", "T_IgnoreIfMissing",
+  "T_AdvSendAdvert", "T_MaxRtrAdvInterval", "T_MinRtrAdvInterval",
+  "T_MinDelayBetweenRAs", "T_AdvManagedFlag", "T_AdvOtherConfigFlag",
+  "T_AdvLinkMTU", "T_AdvReachableTime", "T_AdvRetransTimer",
+  "T_AdvCurHopLimit", "T_AdvDefaultLifetime", "T_AdvDefaultPreference",
+  "T_AdvSourceLLAddress", "T_AdvOnLink", "T_AdvAutonomous",
+  "T_AdvValidLifetime", "T_AdvPreferredLifetime", "T_DeprecatePrefix",
+  "T_DecrementLifetimes", "T_AdvRouterAddr", "T_AdvHomeAgentFlag",
+  "T_AdvIntervalOpt", "T_AdvHomeAgentInfo", "T_Base6Interface",
+  "T_Base6to4Interface", "T_UnicastOnly", "T_HomeAgentPreference",
+  "T_HomeAgentLifetime", "T_AdvRoutePreference", "T_AdvRouteLifetime",
+  "T_RemoveRoute", "T_AdvRDNSSPreference", "T_AdvRDNSSOpenFlag",
+  "T_AdvRDNSSLifetime", "T_FlushRDNSS", "T_AdvDNSSLLifetime",
+  "T_FlushDNSSL", "T_AdvMobRtrSupportFlag", "T_BAD_TOKEN", "'{'", "'}'",
+  "';'", "'/'", "$accept", "grammar", "ifacedef", "ifacehead", "name",
+  "ifaceparams", "ifaceparam", "ifaceval", "clientslist", "v6addrlist",
+  "prefixdef", "prefixhead", "optional_prefixplist", "prefixplist",
+  "prefixparms", "routedef", "routehead", "optional_routeplist",
+  "routeplist", "routeparms", "rdnssdef", "rdnssaddrs", "rdnssaddr",
+  "rdnsshead", "optional_rdnssplist", "rdnssplist", "rdnssparms",
+  "dnssldef", "dnsslsuffixes", "dnsslsuffix", "dnsslhead",
+  "optional_dnsslplist", "dnsslplist", "dnsslparms", "number_or_infinity", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
+     305,   306,   307,   308,   309,   310,   123,   125,    59,    47
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    60,    61,    61,    62,    63,    64,    65,    65,    66,
+      66,    66,    66,    66,    66,    67,    67,    67,    67,    67,
+      67,    67,    67,    67,    67,    67,    67,    67,    67,    67,
+      67,    67,    67,    67,    67,    67,    67,    67,    67,    68,
+      69,    69,    70,    71,    72,    72,    72,    73,    73,    74,
+      74,    74,    74,    74,    74,    74,    74,    74,    75,    76,
+      77,    77,    78,    78,    79,    79,    79,    80,    81,    81,
+      82,    83,    84,    84,    85,    85,    86,    86,    86,    86,
+      87,    88,    88,    89,    90,    91,    91,    92,    92,    93,
+      93,    94,    94
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     5,     2,     1,     0,     2,     1,
+       1,     1,     1,     1,     1,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     3,     5,
+       2,     3,     3,     4,     0,     2,     3,     2,     1,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     5,     4,
+       0,     1,     2,     1,     3,     3,     3,     5,     2,     1,
+       1,     2,     0,     1,     2,     1,     3,     3,     3,     3,
+       5,     2,     1,     1,     2,     0,     1,     2,     1,     3,
+       3,     1,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,     0,     0,     3,     0,     6,     5,     1,     2,     7,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     7,     9,    11,
+      10,    44,    12,     0,    13,     0,    14,     0,     0,     0,
+      70,    71,    69,    83,    84,    82,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     8,     0,     0,    60,    72,    85,     0,     0,
+      68,    81,     0,     0,    21,    22,    16,    19,    15,    18,
+      17,    20,    23,    24,    25,    26,    27,    30,    28,    29,
+      31,    34,    32,    33,    37,    35,    36,    38,     4,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    45,     0,
+      48,    42,     0,     0,     0,     0,    61,    63,     0,     0,
+       0,     0,     0,    73,    75,     0,     0,     0,    86,    88,
+      43,    59,    40,     0,     0,     0,     0,    91,    92,     0,
+       0,     0,     0,     0,     0,     0,    46,    47,     0,     0,
+       0,     0,    62,     0,     0,     0,     0,     0,    74,     0,
+       0,     0,    87,    41,    39,    49,    50,    52,    53,    54,
+      55,    51,    56,    57,    64,    65,    66,    58,    76,    77,
+      78,    79,    67,    89,    90,    80
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     2,     3,     4,     6,    36,    37,    38,    39,    93,
+      40,    41,    84,   129,   130,    42,    43,   135,   136,   137,
+      44,    51,    52,    45,   142,   143,   144,    46,    54,    55,
+      47,   147,   148,   149,   159
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -117
+static const yytype_int16 yypact[] =
+{
+      29,    28,    27,  -117,   -20,  -117,  -117,  -117,  -117,    -4,
+      47,    48,    51,    57,    22,    68,    69,    63,    64,    67,
+      70,    71,    75,    76,    77,    78,    79,    80,    81,    82,
+      83,    84,    85,    89,    90,    88,    33,    -4,  -117,  -117,
+    -117,    36,  -117,    37,  -117,    46,  -117,    49,    44,    45,
+    -117,    51,  -117,  -117,    57,  -117,    92,    50,    52,    53,
+      54,    55,    56,    58,    59,    60,    61,    62,    65,    66,
+      72,    73,    74,    86,    87,    91,    93,    94,    95,    96,
+      97,    98,  -117,    11,    99,    24,   -42,   -24,   105,   111,
+    -117,  -117,   100,    -9,  -117,  -117,  -117,  -117,  -117,  -117,
+    -117,  -117,  -117,  -117,  -117,  -117,  -117,  -117,  -117,  -117,
+    -117,  -117,  -117,  -117,  -117,  -117,  -117,  -117,  -117,   109,
+     112,    16,    16,   113,   114,   115,    28,    28,  -117,    23,
+    -117,  -117,   118,    16,   120,   102,    24,  -117,   124,   122,
+      16,   123,   103,   -42,  -117,    16,   125,   104,   -24,  -117,
+    -117,  -117,  -117,   106,   107,   108,   110,  -117,  -117,   116,
+     117,   119,   121,   126,   127,   128,  -117,  -117,   129,   130,
+     131,   132,  -117,   133,   134,   135,   136,   137,  -117,   138,
+     139,   140,  -117,  -117,  -117,  -117,  -117,  -117,  -117,  -117,
+    -117,  -117,  -117,  -117,  -117,  -117,  -117,  -117,  -117,  -117,
+    -117,  -117,  -117,  -117,  -117,  -117
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -117,  -117,   141,  -117,  -116,   143,  -117,  -117,  -117,  -117,
+    -117,  -117,  -117,  -117,   -22,  -117,  -117,  -117,  -117,   -27,
+    -117,  -117,   148,  -117,  -117,  -117,    -6,  -117,  -117,   146,
+    -117,  -117,  -117,    -8,   -73
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -1
+static const yytype_uint8 yytable[] =
+{
+      10,    11,    12,    13,    14,   153,   138,   139,   140,   141,
+     164,   165,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    24,    25,    26,    27,    28,   157,     7,   145,   146,
+       1,   158,     1,    29,    30,    31,     9,     5,    32,    33,
+      34,   119,   120,   121,   122,   123,   124,   125,   154,   160,
+      35,   126,   127,   119,   120,   121,   122,   123,   124,   125,
+     169,    48,    49,   126,   127,    50,    53,   175,   128,   132,
+     133,   134,   179,    59,    61,    60,    62,    63,    56,    64,
+     166,    57,    58,    65,    66,    67,    68,    69,    70,    71,
+      81,    72,    83,    85,    73,    74,    75,    76,    77,    78,
+      79,    80,    86,    88,    89,    87,    92,   167,    94,   172,
+      95,    96,    97,    98,    99,   150,   100,   101,   102,   103,
+     104,   151,   155,   105,   106,   156,   161,   162,   163,   168,
+     107,   108,   109,   170,   173,   174,   176,   178,   180,     0,
+     182,     0,     0,     8,   110,   111,     0,     0,     0,   112,
+       0,   113,   114,   115,   116,   117,   118,   131,   152,   171,
+     177,   181,     0,     0,   183,   184,   185,     0,   186,     0,
+       0,     0,     0,     0,   187,   188,     0,   189,     0,   190,
+      82,     0,     0,     0,   191,   192,   193,   194,   195,   196,
+     197,   198,   199,   200,   201,   202,   203,   204,   205,    90,
+      91
+};
+
+static const yytype_int16 yycheck[] =
+{
+       4,     5,     6,     7,     8,    14,    48,    49,    50,    51,
+     126,   127,    16,    17,    18,    19,    20,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    10,     0,    52,    53,
+       3,    15,     3,    37,    38,    39,    56,     9,    42,    43,
+      44,    30,    31,    32,    33,    34,    35,    36,    57,   122,
+      54,    40,    41,    30,    31,    32,    33,    34,    35,    36,
+     133,    14,    14,    40,    41,    14,     9,   140,    57,    45,
+      46,    47,   145,    10,    10,    12,    12,    10,    56,    12,
+      57,    13,    13,    13,    13,    10,    10,    10,    10,    10,
+      57,    11,    56,    56,    13,    13,    13,    13,    13,    10,
+      10,    13,    56,    59,    59,    56,    14,   129,    58,   136,
+      58,    58,    58,    58,    58,    10,    58,    58,    58,    58,
+      58,    10,    13,    58,    58,    13,    13,    13,    13,    11,
+      58,    58,    58,    13,    10,    13,    13,   143,    13,    -1,
+     148,    -1,    -1,     2,    58,    58,    -1,    -1,    -1,    58,
+      -1,    58,    58,    58,    58,    58,    58,    58,    58,    57,
+      57,    57,    -1,    -1,    58,    58,    58,    -1,    58,    -1,
+      -1,    -1,    -1,    -1,    58,    58,    -1,    58,    -1,    58,
+      37,    -1,    -1,    -1,    58,    58,    58,    58,    58,    58,
+      58,    58,    58,    58,    58,    58,    58,    58,    58,    51,
+      54
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    61,    62,    63,     9,    64,     0,    62,    56,
+       4,     5,     6,     7,     8,    16,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    37,
+      38,    39,    42,    43,    44,    54,    65,    66,    67,    68,
+      70,    71,    75,    76,    80,    83,    87,    90,    14,    14,
+      14,    81,    82,     9,    88,    89,    56,    13,    13,    10,
+      12,    10,    12,    10,    12,    13,    13,    10,    10,    10,
+      10,    10,    11,    13,    13,    13,    13,    13,    10,    10,
+      13,    57,    65,    56,    72,    56,    56,    56,    59,    59,
+      82,    89,    14,    69,    58,    58,    58,    58,    58,    58,
+      58,    58,    58,    58,    58,    58,    58,    58,    58,    58,
+      58,    58,    58,    58,    58,    58,    58,    58,    58,    30,
+      31,    32,    33,    34,    35,    36,    40,    41,    57,    73,
+      74,    58,    45,    46,    47,    77,    78,    79,    48,    49,
+      50,    51,    84,    85,    86,    52,    53,    91,    92,    93,
+      10,    10,    58,    14,    57,    13,    13,    10,    15,    94,
+      94,    13,    13,    13,    64,    64,    57,    74,    11,    94,
+      13,    57,    79,    10,    13,    94,    13,    57,    86,    94,
+      13,    57,    93,    58,    58,    58,    58,    58,    58,    58,
+      58,    58,    58,    58,    58,    58,    58,    58,    58,    58,
+      58,    58,    58,    58,    58,    58
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+				       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 4:
+
+/* Line 1455 of yacc.c  */
+#line 157 "gram.y"
+    {
+			struct Interface *iface2;
+
+			iface2 = IfaceList;
+			while (iface2)
+			{
+				if (!strcmp(iface2->Name, iface->Name))
+				{
+					flog(LOG_ERR, "duplicate interface "
+						"definition for %s", iface->Name);
+					ABORT;
+				}
+				iface2 = iface2->next;
+			}
+
+			if (check_device(iface) < 0) {
+				if (iface->IgnoreIfMissing) {
+					dlog(LOG_DEBUG, 4, "interface %s did not exist, ignoring the interface", iface->Name);
+				}
+				else {
+					flog(LOG_ERR, "interface %s does not exist", iface->Name);
+					ABORT;
+				}
+			}
+			if (setup_deviceinfo(iface) < 0)
+				if (!iface->IgnoreIfMissing)
+				ABORT;
+			if (check_iface(iface) < 0)
+				if (!iface->IgnoreIfMissing)
+				ABORT;
+			if (setup_linklocal_addr(iface) < 0)
+				if (!iface->IgnoreIfMissing)
+				ABORT;
+			if (setup_allrouters_membership(iface) < 0)
+				if (!iface->IgnoreIfMissing)
+				ABORT;
+
+			dlog(LOG_DEBUG, 4, "interface definition for %s is ok", iface->Name);
+
+			iface->next = IfaceList;
+			IfaceList = iface;
+
+			iface = NULL;
+		}
+    break;
+
+  case 5:
+
+/* Line 1455 of yacc.c  */
+#line 203 "gram.y"
+    {
+			iface = malloc(sizeof(struct Interface));
+
+			if (iface == NULL) {
+				flog(LOG_CRIT, "malloc failed: %s", strerror(errno));
+				ABORT;
+			}
+
+			iface_init_defaults(iface);
+			strncpy(iface->Name, (yyvsp[(2) - (2)].str), IFNAMSIZ-1);
+			iface->Name[IFNAMSIZ-1] = '\0';
+		}
+    break;
+
+  case 6:
+
+/* Line 1455 of yacc.c  */
+#line 218 "gram.y"
+    {
+			/* check vality */
+			(yyval.str) = (yyvsp[(1) - (1)].str);
+		}
+    break;
+
+  case 10:
+
+/* Line 1455 of yacc.c  */
+#line 230 "gram.y"
+    { ADD_TO_LL(struct AdvPrefix, AdvPrefixList, (yyvsp[(1) - (1)].pinfo)); }
+    break;
+
+  case 11:
+
+/* Line 1455 of yacc.c  */
+#line 231 "gram.y"
+    { ADD_TO_LL(struct Clients, ClientList, (yyvsp[(1) - (1)].ainfo)); }
+    break;
+
+  case 12:
+
+/* Line 1455 of yacc.c  */
+#line 232 "gram.y"
+    { ADD_TO_LL(struct AdvRoute, AdvRouteList, (yyvsp[(1) - (1)].rinfo)); }
+    break;
+
+  case 13:
+
+/* Line 1455 of yacc.c  */
+#line 233 "gram.y"
+    { ADD_TO_LL(struct AdvRDNSS, AdvRDNSSList, (yyvsp[(1) - (1)].rdnssinfo)); }
+    break;
+
+  case 14:
+
+/* Line 1455 of yacc.c  */
+#line 234 "gram.y"
+    { ADD_TO_LL(struct AdvDNSSL, AdvDNSSLList, (yyvsp[(1) - (1)].dnsslinfo)); }
+    break;
+
+  case 15:
+
+/* Line 1455 of yacc.c  */
+#line 238 "gram.y"
+    {
+			iface->MinRtrAdvInterval = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 16:
+
+/* Line 1455 of yacc.c  */
+#line 242 "gram.y"
+    {
+			iface->MaxRtrAdvInterval = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 17:
+
+/* Line 1455 of yacc.c  */
+#line 246 "gram.y"
+    {
+			iface->MinDelayBetweenRAs = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 18:
+
+/* Line 1455 of yacc.c  */
+#line 250 "gram.y"
+    {
+			iface->MinRtrAdvInterval = (yyvsp[(2) - (3)].dec);
+		}
+    break;
+
+  case 19:
+
+/* Line 1455 of yacc.c  */
+#line 254 "gram.y"
+    {
+			iface->MaxRtrAdvInterval = (yyvsp[(2) - (3)].dec);
+		}
+    break;
+
+  case 20:
+
+/* Line 1455 of yacc.c  */
+#line 258 "gram.y"
+    {
+			iface->MinDelayBetweenRAs = (yyvsp[(2) - (3)].dec);
+		}
+    break;
+
+  case 21:
+
+/* Line 1455 of yacc.c  */
+#line 262 "gram.y"
+    {
+			iface->IgnoreIfMissing = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 22:
+
+/* Line 1455 of yacc.c  */
+#line 266 "gram.y"
+    {
+			iface->AdvSendAdvert = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 23:
+
+/* Line 1455 of yacc.c  */
+#line 270 "gram.y"
+    {
+			iface->AdvManagedFlag = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 24:
+
+/* Line 1455 of yacc.c  */
+#line 274 "gram.y"
+    {
+			iface->AdvOtherConfigFlag = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 25:
+
+/* Line 1455 of yacc.c  */
+#line 278 "gram.y"
+    {
+			iface->AdvLinkMTU = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 26:
+
+/* Line 1455 of yacc.c  */
+#line 282 "gram.y"
+    {
+			iface->AdvReachableTime = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 27:
+
+/* Line 1455 of yacc.c  */
+#line 286 "gram.y"
+    {
+			iface->AdvRetransTimer = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 28:
+
+/* Line 1455 of yacc.c  */
+#line 290 "gram.y"
+    {
+			iface->AdvDefaultLifetime = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 29:
+
+/* Line 1455 of yacc.c  */
+#line 294 "gram.y"
+    {
+			iface->AdvDefaultPreference = (yyvsp[(2) - (3)].snum);
+		}
+    break;
+
+  case 30:
+
+/* Line 1455 of yacc.c  */
+#line 298 "gram.y"
+    {
+			iface->AdvCurHopLimit = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 31:
+
+/* Line 1455 of yacc.c  */
+#line 302 "gram.y"
+    {
+			iface->AdvSourceLLAddress = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 32:
+
+/* Line 1455 of yacc.c  */
+#line 306 "gram.y"
+    {
+			iface->AdvIntervalOpt = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 33:
+
+/* Line 1455 of yacc.c  */
+#line 310 "gram.y"
+    {
+			iface->AdvHomeAgentInfo = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 34:
+
+/* Line 1455 of yacc.c  */
+#line 314 "gram.y"
+    {
+			iface->AdvHomeAgentFlag = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 35:
+
+/* Line 1455 of yacc.c  */
+#line 318 "gram.y"
+    {
+			iface->HomeAgentPreference = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 36:
+
+/* Line 1455 of yacc.c  */
+#line 322 "gram.y"
+    {
+			iface->HomeAgentLifetime = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 37:
+
+/* Line 1455 of yacc.c  */
+#line 326 "gram.y"
+    {
+			iface->UnicastOnly = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 38:
+
+/* Line 1455 of yacc.c  */
+#line 330 "gram.y"
+    {
+			iface->AdvMobRtrSupportFlag = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 39:
+
+/* Line 1455 of yacc.c  */
+#line 336 "gram.y"
+    {
+			(yyval.ainfo) = (yyvsp[(3) - (5)].ainfo);
+		}
+    break;
+
+  case 40:
+
+/* Line 1455 of yacc.c  */
+#line 342 "gram.y"
+    {
+			struct Clients *new = calloc(1, sizeof(struct Clients));
+			if (new == NULL) {
+				flog(LOG_CRIT, "calloc failed: %s", strerror(errno));
+				ABORT;
+			}
+
+			memcpy(&(new->Address), (yyvsp[(1) - (2)].addr), sizeof(struct in6_addr));
+			(yyval.ainfo) = new;
+		}
+    break;
+
+  case 41:
+
+/* Line 1455 of yacc.c  */
+#line 353 "gram.y"
+    {
+			struct Clients *new = calloc(1, sizeof(struct Clients));
+			if (new == NULL) {
+				flog(LOG_CRIT, "calloc failed: %s", strerror(errno));
+				ABORT;
+			}
+
+			memcpy(&(new->Address), (yyvsp[(2) - (3)].addr), sizeof(struct in6_addr));
+			new->next = (yyvsp[(1) - (3)].ainfo);
+			(yyval.ainfo) = new;
+		}
+    break;
+
+  case 42:
+
+/* Line 1455 of yacc.c  */
+#line 368 "gram.y"
+    {
+			if (prefix) {
+				unsigned int dst;
+
+				if (prefix->AdvPreferredLifetime > prefix->AdvValidLifetime)
+				{
+					flog(LOG_ERR, "AdvValidLifeTime must be "
+						"greater than AdvPreferredLifetime in %s, line %d",
+						conf_file, num_lines);
+					ABORT;
+				}
+
+				if ( prefix->if6[0] && prefix->if6to4[0]) {
+					flog(LOG_ERR, "Base6Interface and Base6to4Interface are mutually exclusive at this time.");
+					ABORT;
+				}
+
+				if ( prefix->if6to4[0] )
+				{
+					if (get_v4addr(prefix->if6to4, &dst) < 0)
+					{
+						flog(LOG_ERR, "interface %s has no IPv4 addresses, disabling 6to4 prefix", prefix->if6to4 );
+						prefix->enabled = 0;
+					}
+					else
+					{
+						*((uint16_t *)(prefix->Prefix.s6_addr)) = htons(0x2002);
+						memcpy( prefix->Prefix.s6_addr + 2, &dst, sizeof( dst ) );
+					}
+				}
+
+				if ( prefix->if6[0] )
+				{
+#ifndef HAVE_IFADDRS_H
+					flog(LOG_ERR, "invalid all-zeros prefix in %s, line %d", conf_file, num_lines);
+					ABORT;
+#else
+					struct ifaddrs *ifap = 0, *ifa = 0;
+					struct AdvPrefix *next = prefix->next;
+
+					if (prefix->PrefixLen != 64) {
+						flog(LOG_ERR, "Only /64 is allowed with Base6Interface.  %s:%d", conf_file, num_lines);
+						ABORT;
+					}
+
+					if (getifaddrs(&ifap) != 0)
+						flog(LOG_ERR, "getifaddrs failed: %s", strerror(errno));
+
+					for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+						struct sockaddr_in6 *s6 = 0;
+						struct sockaddr_in6 *mask = (struct sockaddr_in6 *)ifa->ifa_netmask;
+						struct in6_addr base6prefix;
+						char buf[INET6_ADDRSTRLEN];
+						int i;
+
+						if (strncmp(ifa->ifa_name, prefix->if6, IFNAMSIZ))
+							continue;
+
+						if (ifa->ifa_addr->sa_family != AF_INET6)
+							continue;
+
+						s6 = (struct sockaddr_in6 *)(ifa->ifa_addr);
+
+						if (IN6_IS_ADDR_LINKLOCAL(&s6->sin6_addr))
+							continue;
+
+						base6prefix = get_prefix6(&s6->sin6_addr, &mask->sin6_addr);
+						for (i = 0; i < 8; ++i) {
+							prefix->Prefix.s6_addr[i] &= ~mask->sin6_addr.s6_addr[i];
+							prefix->Prefix.s6_addr[i] |= base6prefix.s6_addr[i];
+						}
+						memset(&prefix->Prefix.s6_addr[8], 0, 8);
+						prefix->AdvRouterAddr = 1;
+						prefix->AutoSelected = 1;
+						prefix->next = next;
+
+						if (inet_ntop(ifa->ifa_addr->sa_family, (void *)&(prefix->Prefix), buf, sizeof(buf)) == NULL)
+							flog(LOG_ERR, "%s: inet_ntop failed in %s, line %d!", ifa->ifa_name, conf_file, num_lines);
+						else
+							dlog(LOG_DEBUG, 3, "auto-selected prefix %s/%d on interface %s from interface %s",
+								buf, prefix->PrefixLen, iface->Name, ifa->ifa_name);
+
+						/* Taking only one prefix from the Base6Interface.  Taking more than one would require allocating new
+						   prefixes and building a list.  I'm not sure how to do that from here. So for now, break. */
+						break;
+					}
+
+					if (ifap)
+						freeifaddrs(ifap);
+#endif
+				}
+			}
+			(yyval.pinfo) = prefix;
+			prefix = NULL;
+		}
+    break;
+
+  case 43:
+
+/* Line 1455 of yacc.c  */
+#line 466 "gram.y"
+    {
+			struct in6_addr zeroaddr;
+			memset(&zeroaddr, 0, sizeof(zeroaddr));
+
+			if (!memcmp((yyvsp[(2) - (4)].addr), &zeroaddr, sizeof(struct in6_addr))) {
+				//struct ifaddrs *ifap = 0, *ifa = 0;
+				struct AdvPrefix *next = iface->AdvPrefixList;
+#ifndef HAVE_IFADDRS_H
+				flog(LOG_ERR, "invalid all-zeros prefix in %s, line %d", conf_file, num_lines);
+				ABORT;
+#else
+				struct ifaddrs *ifap = 0, *ifa = 0;
+				while (next) {
+					if (next->AutoSelected) {
+						flog(LOG_ERR, "auto selecting prefixes works only once per interface.  See %s, line %d", conf_file, num_lines);
+						ABORT;
+					}
+					next = next->next;
+				}
+				next = 0;
+
+				dlog(LOG_DEBUG, 5, "all-zeros prefix in %s, line %d, parsing..", conf_file, num_lines);
+
+				if (getifaddrs(&ifap) != 0)
+					flog(LOG_ERR, "getifaddrs failed: %s", strerror(errno));
+
+				for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+					struct sockaddr_in6 *s6 = (struct sockaddr_in6 *)ifa->ifa_addr;
+					struct sockaddr_in6 *mask = (struct sockaddr_in6 *)ifa->ifa_netmask;
+					char buf[INET6_ADDRSTRLEN];
+
+					if (strncmp(ifa->ifa_name, iface->Name, IFNAMSIZ))
+						continue;
+
+					if (ifa->ifa_addr->sa_family != AF_INET6)
+						continue;
+
+					s6 = (struct sockaddr_in6 *)(ifa->ifa_addr);
+
+					if (IN6_IS_ADDR_LINKLOCAL(&s6->sin6_addr))
+						continue;
+
+					prefix = malloc(sizeof(struct AdvPrefix));
+
+					if (prefix == NULL) {
+						flog(LOG_CRIT, "malloc failed: %s", strerror(errno));
+						ABORT;
+					}
+
+					prefix_init_defaults(prefix);
+					prefix->Prefix = get_prefix6(&s6->sin6_addr, &mask->sin6_addr);
+					prefix->AdvRouterAddr = 1;
+					prefix->AutoSelected = 1;
+					prefix->next = next;
+					next = prefix;
+
+					if (prefix->PrefixLen == 0)
+						prefix->PrefixLen = count_mask(mask);
+
+					if (inet_ntop(ifa->ifa_addr->sa_family, (void *)&(prefix->Prefix), buf, sizeof(buf)) == NULL)
+						flog(LOG_ERR, "%s: inet_ntop failed in %s, line %d!", ifa->ifa_name, conf_file, num_lines);
+					else
+						dlog(LOG_DEBUG, 3, "auto-selected prefix %s/%d on interface %s", buf, prefix->PrefixLen, ifa->ifa_name);
+				}
+
+				if (!prefix) {
+					flog(LOG_WARNING, "no auto-selected prefix on interface %s, disabling advertisements",  iface->Name);
+				}
+
+				if (ifap)
+					freeifaddrs(ifap);
+#endif /* ifndef HAVE_IFADDRS_H */
+			}
+			else {
+				prefix = malloc(sizeof(struct AdvPrefix));
+
+				if (prefix == NULL) {
+					flog(LOG_CRIT, "malloc failed: %s", strerror(errno));
+					ABORT;
+				}
+
+				prefix_init_defaults(prefix);
+
+				if ((yyvsp[(4) - (4)].num) > MAX_PrefixLen)
+				{
+					flog(LOG_ERR, "invalid prefix length in %s, line %d", conf_file, num_lines);
+					ABORT;
+				}
+
+				prefix->PrefixLen = (yyvsp[(4) - (4)].num);
+
+				memcpy(&prefix->Prefix, (yyvsp[(2) - (4)].addr), sizeof(struct in6_addr));
+			}
+		}
+    break;
+
+  case 49:
+
+/* Line 1455 of yacc.c  */
+#line 572 "gram.y"
+    {
+			if (prefix) {
+				if (prefix->AutoSelected) {
+					struct AdvPrefix *p = prefix;
+					do {
+						p->AdvOnLinkFlag = (yyvsp[(2) - (3)].num);
+						p = p->next;
+					} while (p && p->AutoSelected);
+				}
+				else
+					prefix->AdvOnLinkFlag = (yyvsp[(2) - (3)].num);
+			}
+		}
+    break;
+
+  case 50:
+
+/* Line 1455 of yacc.c  */
+#line 586 "gram.y"
+    {
+			if (prefix) {
+				if (prefix->AutoSelected) {
+					struct AdvPrefix *p = prefix;
+					do {
+						p->AdvAutonomousFlag = (yyvsp[(2) - (3)].num);
+						p = p->next;
+					} while (p && p->AutoSelected);
+				}
+				else
+					prefix->AdvAutonomousFlag = (yyvsp[(2) - (3)].num);
+			}
+		}
+    break;
+
+  case 51:
+
+/* Line 1455 of yacc.c  */
+#line 600 "gram.y"
+    {
+			if (prefix) {
+				if (prefix->AutoSelected && (yyvsp[(2) - (3)].num) == 0)
+					flog(LOG_WARNING, "prefix automatically selected, AdvRouterAddr always enabled, ignoring config line %d", num_lines);
+				else
+					prefix->AdvRouterAddr = (yyvsp[(2) - (3)].num);
+			}
+		}
+    break;
+
+  case 52:
+
+/* Line 1455 of yacc.c  */
+#line 609 "gram.y"
+    {
+			if (prefix) {
+				if (prefix->AutoSelected) {
+					struct AdvPrefix *p = prefix;
+					do {
+						p->AdvValidLifetime = (yyvsp[(2) - (3)].num);
+						p->curr_validlft = (yyvsp[(2) - (3)].num);
+						p = p->next;
+					} while (p && p->AutoSelected);
+				}
+				else
+					prefix->AdvValidLifetime = (yyvsp[(2) - (3)].num);
+					prefix->curr_validlft = (yyvsp[(2) - (3)].num);
+			}
+		}
+    break;
+
+  case 53:
+
+/* Line 1455 of yacc.c  */
+#line 625 "gram.y"
+    {
+			if (prefix) {
+				if (prefix->AutoSelected) {
+					struct AdvPrefix *p = prefix;
+					do {
+						p->AdvPreferredLifetime = (yyvsp[(2) - (3)].num);
+						p->curr_preferredlft = (yyvsp[(2) - (3)].num);
+						p = p->next;
+					} while (p && p->AutoSelected);
+				}
+				else
+					prefix->AdvPreferredLifetime = (yyvsp[(2) - (3)].num);
+					prefix->curr_preferredlft = (yyvsp[(2) - (3)].num);
+			}
+		}
+    break;
+
+  case 54:
+
+/* Line 1455 of yacc.c  */
+#line 641 "gram.y"
+    {
+			prefix->DeprecatePrefixFlag = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 55:
+
+/* Line 1455 of yacc.c  */
+#line 645 "gram.y"
+    {
+			prefix->DecrementLifetimesFlag = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 56:
+
+/* Line 1455 of yacc.c  */
+#line 649 "gram.y"
+    {
+			if (prefix) {
+				if (prefix->AutoSelected) {
+					flog(LOG_ERR, "automatically selecting the prefix and Base6to4Interface are mutually exclusive");
+					ABORT;
+				} /* fallthrough */
+				dlog(LOG_DEBUG, 4, "using prefixes on interface %s for prefixes on interface %s", (yyvsp[(2) - (3)].str), iface->Name);
+				strncpy(prefix->if6, (yyvsp[(2) - (3)].str), IFNAMSIZ-1);
+				prefix->if6[IFNAMSIZ-1] = '\0';
+			}
+		}
+    break;
+
+  case 57:
+
+/* Line 1455 of yacc.c  */
+#line 662 "gram.y"
+    {
+			if (prefix) {
+				if (prefix->AutoSelected) {
+					flog(LOG_ERR, "automatically selecting the prefix and Base6to4Interface are mutually exclusive");
+					ABORT;
+				} /* fallthrough */
+				dlog(LOG_DEBUG, 4, "using interface %s for 6to4 prefixes on interface %s", (yyvsp[(2) - (3)].str), iface->Name);
+				strncpy(prefix->if6to4, (yyvsp[(2) - (3)].str), IFNAMSIZ-1);
+				prefix->if6to4[IFNAMSIZ-1] = '\0';
+			}
+		}
+    break;
+
+  case 58:
+
+/* Line 1455 of yacc.c  */
+#line 676 "gram.y"
+    {
+			(yyval.rinfo) = route;
+			route = NULL;
+		}
+    break;
+
+  case 59:
+
+/* Line 1455 of yacc.c  */
+#line 684 "gram.y"
+    {
+			route = malloc(sizeof(struct AdvRoute));
+
+			if (route == NULL) {
+				flog(LOG_CRIT, "malloc failed: %s", strerror(errno));
+				ABORT;
+			}
+
+			route_init_defaults(route, iface);
+
+			if ((yyvsp[(4) - (4)].num) > MAX_PrefixLen)
+			{
+				flog(LOG_ERR, "invalid route prefix length in %s, line %d", conf_file, num_lines);
+				ABORT;
+			}
+
+			route->PrefixLen = (yyvsp[(4) - (4)].num);
+
+			memcpy(&route->Prefix, (yyvsp[(2) - (4)].addr), sizeof(struct in6_addr));
+		}
+    break;
+
+  case 64:
+
+/* Line 1455 of yacc.c  */
+#line 717 "gram.y"
+    {
+			route->AdvRoutePreference = (yyvsp[(2) - (3)].snum);
+		}
+    break;
+
+  case 65:
+
+/* Line 1455 of yacc.c  */
+#line 721 "gram.y"
+    {
+			route->AdvRouteLifetime = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 66:
+
+/* Line 1455 of yacc.c  */
+#line 725 "gram.y"
+    {
+			route->RemoveRouteFlag = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 67:
+
+/* Line 1455 of yacc.c  */
+#line 731 "gram.y"
+    {
+			(yyval.rdnssinfo) = rdnss;
+			rdnss = NULL;
+		}
+    break;
+
+  case 70:
+
+/* Line 1455 of yacc.c  */
+#line 742 "gram.y"
+    {
+			if (!rdnss) {
+				/* first IP found */
+				rdnss = malloc(sizeof(struct AdvRDNSS));
+
+				if (rdnss == NULL) {
+					flog(LOG_CRIT, "malloc failed: %s", strerror(errno));
+					ABORT;
+				}
+
+				rdnss_init_defaults(rdnss, iface);
+			}
+
+			switch (rdnss->AdvRDNSSNumber) {
+				case 0:
+					memcpy(&rdnss->AdvRDNSSAddr1, (yyvsp[(1) - (1)].addr), sizeof(struct in6_addr));
+					rdnss->AdvRDNSSNumber++;
+					break;
+				case 1:
+					memcpy(&rdnss->AdvRDNSSAddr2, (yyvsp[(1) - (1)].addr), sizeof(struct in6_addr));
+					rdnss->AdvRDNSSNumber++;
+					break;
+				case 2:
+					memcpy(&rdnss->AdvRDNSSAddr3, (yyvsp[(1) - (1)].addr), sizeof(struct in6_addr));
+					rdnss->AdvRDNSSNumber++;
+					break;
+				default:
+					flog(LOG_CRIT, "Too many addresses in RDNSS section");
+					ABORT;
+			}
+
+		}
+    break;
+
+  case 71:
+
+/* Line 1455 of yacc.c  */
+#line 777 "gram.y"
+    {
+			if (!rdnss) {
+				flog(LOG_CRIT, "No address specified in RDNSS section");
+				ABORT;
+			}
+		}
+    break;
+
+  case 76:
+
+/* Line 1455 of yacc.c  */
+#line 795 "gram.y"
+    {
+			flog(LOG_WARNING, "Ignoring deprecated RDNSS preference.");
+		}
+    break;
+
+  case 77:
+
+/* Line 1455 of yacc.c  */
+#line 799 "gram.y"
+    {
+			flog(LOG_WARNING, "Ignoring deprecated RDNSS open flag.");
+		}
+    break;
+
+  case 78:
+
+/* Line 1455 of yacc.c  */
+#line 803 "gram.y"
+    {
+			if ((yyvsp[(2) - (3)].num) < iface->MaxRtrAdvInterval && (yyvsp[(2) - (3)].num) != 0) {
+				flog(LOG_ERR, "AdvRDNSSLifetime must be at least MaxRtrAdvInterval");
+				ABORT;
+			}
+			if ((yyvsp[(2) - (3)].num) > 2*(iface->MaxRtrAdvInterval))
+				flog(LOG_WARNING, "Warning: AdvRDNSSLifetime <= 2*MaxRtrAdvInterval would allow stale DNS servers to be deleted faster");
+
+			rdnss->AdvRDNSSLifetime = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 79:
+
+/* Line 1455 of yacc.c  */
+#line 814 "gram.y"
+    {
+			rdnss->FlushRDNSSFlag = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 80:
+
+/* Line 1455 of yacc.c  */
+#line 820 "gram.y"
+    {
+			(yyval.dnsslinfo) = dnssl;
+			dnssl = NULL;
+		}
+    break;
+
+  case 83:
+
+/* Line 1455 of yacc.c  */
+#line 831 "gram.y"
+    {
+			char *ch;
+			for (ch = (yyvsp[(1) - (1)].str);*ch != '\0';ch++) {
+				if (*ch >= 'A' && *ch <= 'Z')
+					continue;
+				if (*ch >= 'a' && *ch <= 'z')
+					continue;
+				if (*ch >= '0' && *ch <= '9')
+					continue;
+				if (*ch == '-' || *ch == '.')
+					continue;
+
+				flog(LOG_CRIT, "Invalid domain suffix specified");
+				ABORT;
+			}
+
+			if (!dnssl) {
+				/* first domain found */
+				dnssl = malloc(sizeof(struct AdvDNSSL));
+
+				if (dnssl == NULL) {
+					flog(LOG_CRIT, "malloc failed: %s", strerror(errno));
+					ABORT;
+				}
+
+				dnssl_init_defaults(dnssl, iface);
+			}
+
+			dnssl->AdvDNSSLNumber++;
+			dnssl->AdvDNSSLSuffixes =
+				realloc(dnssl->AdvDNSSLSuffixes,
+					dnssl->AdvDNSSLNumber * sizeof(char*));
+			if (dnssl->AdvDNSSLSuffixes == NULL) {
+				flog(LOG_CRIT, "realloc failed: %s", strerror(errno));
+				ABORT;
+			}
+
+			dnssl->AdvDNSSLSuffixes[dnssl->AdvDNSSLNumber - 1] = strdup((yyvsp[(1) - (1)].str));
+		}
+    break;
+
+  case 84:
+
+/* Line 1455 of yacc.c  */
+#line 873 "gram.y"
+    {
+			if (!dnssl) {
+				flog(LOG_CRIT, "No domain specified in DNSSL section");
+				ABORT;
+			}
+		}
+    break;
+
+  case 89:
+
+/* Line 1455 of yacc.c  */
+#line 891 "gram.y"
+    {
+			if ((yyvsp[(2) - (3)].num) < iface->MaxRtrAdvInterval && (yyvsp[(2) - (3)].num) != 0) {
+				flog(LOG_ERR, "AdvDNSSLLifetime must be at least MaxRtrAdvInterval");
+				ABORT;
+			}
+			if ((yyvsp[(2) - (3)].num) > 2*(iface->MaxRtrAdvInterval))
+				flog(LOG_WARNING, "Warning: AdvDNSSLLifetime <= 2*MaxRtrAdvInterval would allow stale DNS suffixes to be deleted faster");
+
+			dnssl->AdvDNSSLLifetime = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 90:
+
+/* Line 1455 of yacc.c  */
+#line 902 "gram.y"
+    {
+			dnssl->FlushDNSSLFlag = (yyvsp[(2) - (3)].num);
+		}
+    break;
+
+  case 91:
+
+/* Line 1455 of yacc.c  */
+#line 908 "gram.y"
+    {
+				(yyval.num) = (yyvsp[(1) - (1)].num);
+			}
+    break;
+
+  case 92:
+
+/* Line 1455 of yacc.c  */
+#line 912 "gram.y"
+    {
+				(yyval.num) = (uint32_t)~0;
+			}
+    break;
+
+
+
+/* Line 1455 of yacc.c  */
+#line 2671 "gram.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 1675 of yacc.c  */
+#line 917 "gram.y"
+
+
+static
+int countbits(int b)
+{
+	int count;
+
+	for (count = 0; b != 0; count++) {
+		b &= b - 1; // this clears the LSB-most set bit
+	}
+
+	return (count);
+}
+
+static
+int count_mask(struct sockaddr_in6 *m)
+{
+	struct in6_addr *in6 = &m->sin6_addr;
+	int i;
+	int count = 0;
+
+	for (i = 0; i < 16; ++i) {
+		count += countbits(in6->s6_addr[i]);
+	}
+	return count;
+}
+
+static
+struct in6_addr get_prefix6(struct in6_addr const *addr, struct in6_addr const *mask)
+{
+	struct in6_addr prefix = *addr;
+	int i = 0;
+
+	for (; i < 16; ++i) {
+		prefix.s6_addr[i] &= mask->s6_addr[i];
+	}
+
+	return prefix;
+}
+
+static
+void cleanup(void)
+{
+	if (iface)
+		free(iface);
+
+	if (prefix)
+		free(prefix);
+
+	if (route)
+		free(route);
+
+	if (rdnss)
+		free(rdnss);
+
+	if (dnssl) {
+		int i;
+		for (i = 0;i < dnssl->AdvDNSSLNumber;i++)
+			free(dnssl->AdvDNSSLSuffixes[i]);
+		free(dnssl->AdvDNSSLSuffixes);
+		free(dnssl);
+	}
+}
+
+static void
+yyerror(char *msg)
+{
+	cleanup();
+	flog(LOG_ERR, "%s in %s, line %d: %s", msg, conf_file, num_lines, yytext);
+}
diff -Naur radvd-1.8/gram.h radvd-1.8-brcm/gram.h
--- radvd-1.8/gram.h	1969-12-31 20:00:00.000000000 -0400
+++ radvd-1.8-brcm/gram.h	2018-11-24 16:42:07.693984085 -0400
@@ -0,0 +1,183 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_INTERFACE = 258,
+     T_PREFIX = 259,
+     T_ROUTE = 260,
+     T_RDNSS = 261,
+     T_DNSSL = 262,
+     T_CLIENTS = 263,
+     STRING = 264,
+     NUMBER = 265,
+     SIGNEDNUMBER = 266,
+     DECIMAL = 267,
+     SWITCH = 268,
+     IPV6ADDR = 269,
+     INFINITY = 270,
+     T_IgnoreIfMissing = 271,
+     T_AdvSendAdvert = 272,
+     T_MaxRtrAdvInterval = 273,
+     T_MinRtrAdvInterval = 274,
+     T_MinDelayBetweenRAs = 275,
+     T_AdvManagedFlag = 276,
+     T_AdvOtherConfigFlag = 277,
+     T_AdvLinkMTU = 278,
+     T_AdvReachableTime = 279,
+     T_AdvRetransTimer = 280,
+     T_AdvCurHopLimit = 281,
+     T_AdvDefaultLifetime = 282,
+     T_AdvDefaultPreference = 283,
+     T_AdvSourceLLAddress = 284,
+     T_AdvOnLink = 285,
+     T_AdvAutonomous = 286,
+     T_AdvValidLifetime = 287,
+     T_AdvPreferredLifetime = 288,
+     T_DeprecatePrefix = 289,
+     T_DecrementLifetimes = 290,
+     T_AdvRouterAddr = 291,
+     T_AdvHomeAgentFlag = 292,
+     T_AdvIntervalOpt = 293,
+     T_AdvHomeAgentInfo = 294,
+     T_Base6Interface = 295,
+     T_Base6to4Interface = 296,
+     T_UnicastOnly = 297,
+     T_HomeAgentPreference = 298,
+     T_HomeAgentLifetime = 299,
+     T_AdvRoutePreference = 300,
+     T_AdvRouteLifetime = 301,
+     T_RemoveRoute = 302,
+     T_AdvRDNSSPreference = 303,
+     T_AdvRDNSSOpenFlag = 304,
+     T_AdvRDNSSLifetime = 305,
+     T_FlushRDNSS = 306,
+     T_AdvDNSSLLifetime = 307,
+     T_FlushDNSSL = 308,
+     T_AdvMobRtrSupportFlag = 309,
+     T_BAD_TOKEN = 310
+   };
+#endif
+/* Tokens.  */
+#define T_INTERFACE 258
+#define T_PREFIX 259
+#define T_ROUTE 260
+#define T_RDNSS 261
+#define T_DNSSL 262
+#define T_CLIENTS 263
+#define STRING 264
+#define NUMBER 265
+#define SIGNEDNUMBER 266
+#define DECIMAL 267
+#define SWITCH 268
+#define IPV6ADDR 269
+#define INFINITY 270
+#define T_IgnoreIfMissing 271
+#define T_AdvSendAdvert 272
+#define T_MaxRtrAdvInterval 273
+#define T_MinRtrAdvInterval 274
+#define T_MinDelayBetweenRAs 275
+#define T_AdvManagedFlag 276
+#define T_AdvOtherConfigFlag 277
+#define T_AdvLinkMTU 278
+#define T_AdvReachableTime 279
+#define T_AdvRetransTimer 280
+#define T_AdvCurHopLimit 281
+#define T_AdvDefaultLifetime 282
+#define T_AdvDefaultPreference 283
+#define T_AdvSourceLLAddress 284
+#define T_AdvOnLink 285
+#define T_AdvAutonomous 286
+#define T_AdvValidLifetime 287
+#define T_AdvPreferredLifetime 288
+#define T_DeprecatePrefix 289
+#define T_DecrementLifetimes 290
+#define T_AdvRouterAddr 291
+#define T_AdvHomeAgentFlag 292
+#define T_AdvIntervalOpt 293
+#define T_AdvHomeAgentInfo 294
+#define T_Base6Interface 295
+#define T_Base6to4Interface 296
+#define T_UnicastOnly 297
+#define T_HomeAgentPreference 298
+#define T_HomeAgentLifetime 299
+#define T_AdvRoutePreference 300
+#define T_AdvRouteLifetime 301
+#define T_RemoveRoute 302
+#define T_AdvRDNSSPreference 303
+#define T_AdvRDNSSOpenFlag 304
+#define T_AdvRDNSSLifetime 305
+#define T_FlushRDNSS 306
+#define T_AdvDNSSLLifetime 307
+#define T_FlushDNSSL 308
+#define T_AdvMobRtrSupportFlag 309
+#define T_BAD_TOKEN 310
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1676 of yacc.c  */
+#line 137 "gram.y"
+
+	unsigned int		num;
+	int			snum;
+	double			dec;
+	struct in6_addr		*addr;
+	char			*str;
+	struct AdvPrefix	*pinfo;
+	struct AdvRoute		*rinfo;
+	struct AdvRDNSS		*rdnssinfo;
+	struct AdvDNSSL		*dnsslinfo;
+	struct Clients		*ainfo;
+
+
+
+/* Line 1676 of yacc.c  */
+#line 177 "gram.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
diff -Naur radvd-1.8/gram.y radvd-1.8-brcm/gram.y
--- radvd-1.8/gram.y	2011-05-06 23:26:39.000000000 -0300
+++ radvd-1.8-brcm/gram.y	2018-11-24 16:42:07.693984085 -0400
@@ -1,5 +1,5 @@
 /*
- *   $Id: gram.y,v 1.39 2011/05/06 13:58:57 reubenhwk Exp $
+ *   $Id: gram.y,v 1.1.2.1 2011/08/11 17:52:43 jzhang Exp $
  *
  *   Authors:
  *    Pedro Roque		<roque@di.fc.ul.pt>
@@ -398,6 +398,10 @@
 
 				if ( prefix->if6[0] )
 				{
+#ifndef HAVE_IFADDRS_H
+					flog(LOG_ERR, "invalid all-zeros prefix in %s, line %d", conf_file, num_lines);
+					ABORT;
+#else
 					struct ifaddrs *ifap = 0, *ifa = 0;
 					struct AdvPrefix *next = prefix->next;
 
@@ -450,6 +454,7 @@
 
 					if (ifap)
 						freeifaddrs(ifap);
+#endif
 				}
 			}
 			$$ = prefix;
@@ -463,12 +468,13 @@
 			memset(&zeroaddr, 0, sizeof(zeroaddr));
 
 			if (!memcmp($2, &zeroaddr, sizeof(struct in6_addr))) {
-				struct ifaddrs *ifap = 0, *ifa = 0;
+				//struct ifaddrs *ifap = 0, *ifa = 0;
 				struct AdvPrefix *next = iface->AdvPrefixList;
 #ifndef HAVE_IFADDRS_H
 				flog(LOG_ERR, "invalid all-zeros prefix in %s, line %d", conf_file, num_lines);
 				ABORT;
 #else
+				struct ifaddrs *ifap = 0, *ifa = 0;
 				while (next) {
 					if (next->AutoSelected) {
 						flog(LOG_ERR, "auto selecting prefixes works only once per interface.  See %s, line %d", conf_file, num_lines);
diff -Naur radvd-1.8/log.c radvd-1.8-brcm/log.c
--- radvd-1.8/log.c	2011-02-26 12:00:23.000000000 -0400
+++ radvd-1.8-brcm/log.c	2018-11-24 16:42:07.693984085 -0400
@@ -130,6 +130,9 @@
 {
 	va_list ap;
 	int res;
+      
+        if (debug_level < (prio-3))
+          return;
 
 	va_start(ap, format);
 	res = vlog(prio, format, ap);
diff -Naur radvd-1.8/Makefile radvd-1.8-brcm/Makefile
--- radvd-1.8/Makefile	1969-12-31 20:00:00.000000000 -0400
+++ radvd-1.8-brcm/Makefile	2018-11-24 16:42:07.677997787 -0400
@@ -0,0 +1,955 @@
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+#
+#   $Id: Makefile,v 1.1.2.1 2011/08/11 17:52:43 jzhang Exp $
+#
+#   Authors:
+#    Lars Fenneberg		<lf@elemental.net>
+#
+#   This software is Copyright 1996,1997 by the above mentioned author(s),
+#   All Rights Reserved.
+#
+#   The license which is distributed with this software in the file COPYRIGHT
+#   applies to this software. If your distribution is missing this file, you
+#   may request it from <pekkas@netcore.fi>.
+#
+
+
+pkgdatadir = $(datadir)/radvd
+pkgincludedir = $(includedir)/radvd
+pkglibdir = $(libdir)/radvd
+pkglibexecdir = $(libexecdir)/radvd
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = i686-pc-linux-gnu
+host_triplet = mips-unknown-linux-gnu
+target_triplet = mips-unknown-linux-gnu
+sbin_PROGRAMS = radvd$(EXEEXT) radvdump$(EXEEXT)
+subdir = .
+DIST_COMMON = README $(am__configure_deps) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in $(srcdir)/config.h.in \
+	$(top_srcdir)/configure TODO config.guess config.sub depcomp \
+	gram.c gram.h install-sh missing scanner.c ylwrap
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__installdirs = "$(DESTDIR)$(sbindir)" "$(DESTDIR)$(man5dir)" \
+	"$(DESTDIR)$(man8dir)"
+PROGRAMS = $(sbin_PROGRAMS)
+am__objects_1 = log.$(OBJEXT) recv.$(OBJEXT) socket.$(OBJEXT) \
+	util.$(OBJEXT)
+am_radvd_OBJECTS = $(am__objects_1) device-common.$(OBJEXT) \
+	gram.$(OBJEXT) interface.$(OBJEXT) process.$(OBJEXT) \
+	radvd.$(OBJEXT) scanner.$(OBJEXT) send.$(OBJEXT) \
+	timer.$(OBJEXT)
+radvd_OBJECTS = $(am_radvd_OBJECTS)
+am_radvdump_OBJECTS = $(am__objects_1) radvdump.$(OBJEXT)
+radvdump_OBJECTS = $(am_radvdump_OBJECTS)
+radvdump_LDADD = $(LDADD)
+DEFAULT_INCLUDES = -I.
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_$(V))
+am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
+am__v_CC_0 = @echo "  CC    " $@;
+AM_V_at = $(am__v_at_$(V))
+am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
+am__v_at_0 = @
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_$(V))
+am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
+am__v_CCLD_0 = @echo "  CCLD  " $@;
+LEXCOMPILE = $(LEX) $(LFLAGS) $(AM_LFLAGS)
+AM_V_LEX = $(am__v_LEX_$(V))
+am__v_LEX_ = $(am__v_LEX_$(AM_DEFAULT_VERBOSITY))
+am__v_LEX_0 = @echo "  LEX   " $@;
+YLWRAP = $(top_srcdir)/ylwrap
+YACCCOMPILE = $(YACC) $(YFLAGS) $(AM_YFLAGS)
+AM_V_YACC = $(am__v_YACC_$(V))
+am__v_YACC_ = $(am__v_YACC_$(AM_DEFAULT_VERBOSITY))
+am__v_YACC_0 = @echo "  YACC  " $@;
+AM_V_GEN = $(am__v_GEN_$(V))
+am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
+am__v_GEN_0 = @echo "  GEN   " $@;
+SOURCES = $(radvd_SOURCES) $(EXTRA_radvd_SOURCES) $(radvdump_SOURCES)
+DIST_SOURCES = $(radvd_SOURCES) $(EXTRA_radvd_SOURCES) \
+	$(radvdump_SOURCES)
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+man5dir = $(mandir)/man5
+man8dir = $(mandir)/man8
+NROFF = nroff
+MANS = $(man_MANS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+am__remove_distdir = \
+  { test ! -d "$(distdir)" \
+    || { find "$(distdir)" -type d ! -perm -200 -exec chmod u+w {} ';' \
+         && rm -fr "$(distdir)"; }; }
+DIST_ARCHIVES = $(distdir).tar.gz
+GZIP_ENV = --best
+distuninstallcheck_listfiles = find . -type f -print
+distcleancheck_listfiles = find . -type f -print
+ACLOCAL = ${SHELL} /home/jzhang/project/q2000_mk/bcm462/userspace/gpl/apps/radvd/missing --run aclocal-1.11
+AMTAR = ${SHELL} /home/jzhang/project/q2000_mk/bcm462/userspace/gpl/apps/radvd/missing --run tar
+AM_DEFAULT_VERBOSITY = 0
+AUTOCONF = ${SHELL} /home/jzhang/project/q2000_mk/bcm462/userspace/gpl/apps/radvd/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/jzhang/project/q2000_mk/bcm462/userspace/gpl/apps/radvd/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/jzhang/project/q2000_mk/bcm462/userspace/gpl/apps/radvd/missing --run automake-1.11
+AWK = gawk
+###CC = /opt/toolchains/uclibc-crosstools-gcc-4.4.2-1/usr/bin/mips-linux-gcc
+CCDEPMODE = depmode=gcc3
+###CFLAGS = -g -O2
+CFLAGS = -Os -fomit-frame-pointer
+CONDITIONAL_SOURCES = device-linux.o privsep-linux.o netlink.o
+CPP = /opt/toolchains/uclibc-crosstools-gcc-4.4.2-1/usr/bin/mips-linux-gcc -E
+CPPFLAGS =
+CYGPATH_W = echo
+DEFS = \
+	-DINET6=1 \
+	-DLOG_FACILITY=$(LOG_FACILITY) \
+	-DPATH_RADVD_CONF=\"$(PATH_RADVD_CONF)\" \
+	-DPATH_RADVD_LOG=\"$(PATH_RADVD_LOG)\" \
+	-DPATH_RADVD_PID=\"$(PATH_RADVD_PID)\" \
+	-DVERSION=\"$(VERSION)\"
+
+DEPDIR = .deps
+ECHO_C =
+ECHO_N = -n
+ECHO_T =
+EGREP = /bin/grep -E
+EXEEXT =
+GREP = /bin/grep
+GZIP = /bin/gzip
+INSTALL = /usr/bin/install -c
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = $(install_sh) -c -s
+LDFLAGS =
+LEX = flex
+LEXLIB =
+LEX_OUTPUT_ROOT = lex.yy
+LIBOBJS =
+LIBS = -lc -lgcc_s
+LN = /bin/ln
+LOG_FACILITY = LOG_DAEMON
+LTLIBOBJS =
+MAKEINFO = ${SHELL} /home/jzhang/project/q2000_mk/bcm462/userspace/gpl/apps/radvd/missing --run makeinfo
+MKDIR_P = /bin/mkdir -p
+OBJEXT = o
+PACKAGE = radvd
+PACKAGE_BUGREPORT =
+PACKAGE_NAME =
+PACKAGE_STRING =
+PACKAGE_TARNAME =
+PACKAGE_URL =
+PACKAGE_VERSION =
+PATH_RADVD_CONF = /etc/radvd.conf
+PATH_RADVD_LOG = /var/log/radvd.log
+PATH_RADVD_PID = /var/run/radvd.pid
+PATH_SEPARATOR = :
+RM = /bin/rm
+SED = /bin/sed
+SET_MAKE =
+SHELL = /bin/sh
+###STRIP = strip
+TAR = /bin/tar
+VERSION = 1.8
+YACC = bison -y
+YFLAGS =
+abs_builddir = /home/jzhang/project/q2000_mk/bcm462/userspace/gpl/apps/radvd
+abs_srcdir = /home/jzhang/project/q2000_mk/bcm462/userspace/gpl/apps/radvd
+abs_top_builddir = /home/jzhang/project/q2000_mk/bcm462/userspace/gpl/apps/radvd
+abs_top_srcdir = /home/jzhang/project/q2000_mk/bcm462/userspace/gpl/apps/radvd
+ac_ct_CC =
+am__include = include
+am__leading_dot = .
+am__quote =
+am__tar = ${AMTAR} chof - "$$tardir"
+am__untar = ${AMTAR} xf -
+bindir = ${exec_prefix}/bin
+build = i686-pc-linux-gnu
+build_alias =
+build_cpu = i686
+build_os = linux-gnu
+build_vendor = pc
+builddir = .
+datadir = ${datarootdir}
+datarootdir = ${prefix}/share
+docdir = ${datarootdir}/doc/${PACKAGE}
+dvidir = ${docdir}
+exec_prefix = ${prefix}
+host = mips-unknown-linux-gnu
+host_alias = mips-linux
+host_cpu = mips
+host_os = linux-gnu
+host_vendor = unknown
+htmldir = ${docdir}
+includedir = ${prefix}/include
+infodir = ${datarootdir}/info
+install_sh = ${SHELL} /home/jzhang/project/q2000_mk/bcm462/userspace/gpl/apps/radvd/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localedir = ${datarootdir}/locale
+localstatedir = ${prefix}/var
+mandir = ${datarootdir}/man
+mkdir_p = /bin/mkdir -p
+oldincludedir = /usr/include
+pdfdir = ${docdir}
+###prefix = /usr/local
+program_transform_name = s,x,x,
+psdir = ${docdir}
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+srcdir = .
+sysconfdir = ${prefix}/etc
+target = mips-unknown-linux-gnu
+target_alias =
+target_cpu = mips
+target_os = linux-gnu
+target_vendor = unknown
+top_build_prefix =
+top_builddir = .
+top_srcdir = .
+AUTOMAKE_OPTIONS = 1.2 foreign
+INCLUDES = \
+	-I$(srcdir) \
+	-I.
+
+COMMON_SRC = \
+	defaults.h \
+	includes.h \
+	log.c \
+	log.h \
+	pathnames.h \
+	radvd.h \
+	recv.c \
+	socket.c \
+	util.c
+
+radvd_SOURCES = \
+	$(COMMON_SRC) \
+	device-common.c \
+	gram.h \
+	gram.y \
+	interface.c \
+	process.c \
+	radvd.c \
+	scanner.l \
+	send.c \
+	timer.c
+
+EXTRA_radvd_SOURCES = \
+	device-bsd44.c \
+	device-linux.c \
+	netlink.c \
+	netlink.h \
+	privsep-bsd44.c \
+	privsep-linux.c
+
+radvd_LDADD = \
+	device-linux.o privsep-linux.o netlink.o
+
+radvd_DEPENDENCIES = \
+	device-linux.o privsep-linux.o netlink.o
+
+AM_YFLAGS = -d
+AM_CFLAGS = \
+	-Wall \
+	-Wcast-align \
+	-Wcast-qual \
+	-Wpointer-arith \
+	-Wmissing-declarations \
+	-Wmissing-prototypes \
+	-Wno-strict-aliasing \
+	-Wstrict-prototypes
+
+radvdump_SOURCES = \
+	$(COMMON_SRC) \
+	radvdump.c
+
+man_MANS = \
+	radvd.8 \
+	radvd.conf.5 \
+	radvdump.8
+
+EXTRA_DIST = \
+	CHANGES \
+	COPYRIGHT \
+	INTRO.html \
+	VERSION \
+	copyright.blurb \
+	radvd.8.man \
+	radvd.conf.5.man \
+	radvd.conf.example \
+	radvdump.8.man \
+	redhat/radvd.conf.empty \
+	redhat/radvd.init \
+	redhat/radvd.spec \
+	redhat/radvd.sysconfig \
+	redhat/radvd-tmpfs.conf
+
+CLEANFILES = \
+	gram.c \
+	gram.h \
+	radvd.8 \
+	radvd.conf.5 \
+	radvdump.8 \
+	scanner.c
+
+SUFFIXES = .man
+all: config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-am
+
+.SUFFIXES:
+.SUFFIXES: .man .c .l .o .obj .y
+am--refresh:
+	@:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
+	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign Makefile
+.PRECIOUS: Makefile
+#Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+#	@case '$?' in \
+#	  *config.status*) \
+#	    echo ' $(SHELL) ./config.status'; \
+#	    $(SHELL) ./config.status;; \
+#	  *) \
+#	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+#	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+#	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	$(am__cd) $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+$(am__aclocal_m4_deps):
+
+config.h: stamp-h1
+	@if test ! -f $@; then \
+	  rm -f stamp-h1; \
+	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
+	else :; fi
+
+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status config.h
+$(srcdir)/config.h.in:  $(am__configure_deps)
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f config.h stamp-h1
+install-sbinPROGRAMS: $(sbin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	test -z "$(sbindir)" || $(MKDIR_P) "$(DESTDIR)$(sbindir)"
+	@list='$(sbin_PROGRAMS)'; test -n "$(sbindir)" || list=; \
+	for p in $$list; do echo "$$p $$p"; done | \
+	sed 's/$(EXEEXT)$$//' | \
+	while read p p1; do if test -f $$p; \
+	  then echo "$$p"; echo "$$p"; else :; fi; \
+	done | \
+	sed -e 'p;s,.*/,,;n;h' -e 's|.*|.|' \
+	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
+	sed 'N;N;N;s,\n, ,g' | \
+	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \
+	  { d=$$3; if (dirs[d] != 1) { print "d", d; dirs[d] = 1 } \
+	    if ($$2 == $$4) files[d] = files[d] " " $$1; \
+	    else { print "f", $$3 "/" $$4, $$1; } } \
+	  END { for (d in files) print "f", d, files[d] }' | \
+	while read type dir files; do \
+	    if test "$$dir" = .; then dir=; else dir=/$$dir; fi; \
+	    test -z "$$files" || { \
+	      echo " $(INSTALL_PROGRAM_ENV) $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(sbindir)$$dir'"; \
+	      $(INSTALL_PROGRAM_ENV) $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(sbindir)$$dir" || exit $$?; \
+	    } \
+	; done
+
+uninstall-sbinPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(sbin_PROGRAMS)'; test -n "$(sbindir)" || list=; \
+	files=`for p in $$list; do echo "$$p"; done | \
+	  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \
+	      -e 's/$$/$(EXEEXT)/' `; \
+	test -n "$$list" || exit 0; \
+	echo " ( cd '$(DESTDIR)$(sbindir)' && rm -f" $$files ")"; \
+	cd "$(DESTDIR)$(sbindir)" && rm -f $$files
+
+clean-sbinPROGRAMS:
+	-test -z "$(sbin_PROGRAMS)" || rm -f $(sbin_PROGRAMS)
+gram.h: gram.c
+	@if test ! -f $@; then \
+	  rm -f gram.c; \
+	  $(MAKE) $(AM_MAKEFLAGS) gram.c; \
+	else :; fi
+radvd$(EXEEXT): $(radvd_OBJECTS) $(radvd_DEPENDENCIES)
+	@rm -f radvd$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(radvd_OBJECTS) ./$(radvd_LDADD) $(LIBS)
+	install -m 755 radvd $(INSTALL_DIR)/bin
+	$(STRIP) $(INSTALL_DIR)/bin/radvd
+
+radvdump$(EXEEXT): $(radvdump_OBJECTS) $(radvdump_DEPENDENCIES)
+	@rm -f radvdump$(EXEEXT)
+	$(AM_V_CCLD)$(LINK) $(radvdump_OBJECTS) $(radvdump_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+include ./$(DEPDIR)/device-bsd44.Po
+include ./$(DEPDIR)/device-common.Po
+include ./$(DEPDIR)/device-linux.Po
+include ./$(DEPDIR)/gram.Po
+include ./$(DEPDIR)/interface.Po
+include ./$(DEPDIR)/log.Po
+include ./$(DEPDIR)/netlink.Po
+include ./$(DEPDIR)/privsep-bsd44.Po
+include ./$(DEPDIR)/privsep-linux.Po
+include ./$(DEPDIR)/process.Po
+include ./$(DEPDIR)/radvd.Po
+include ./$(DEPDIR)/radvdump.Po
+include ./$(DEPDIR)/recv.Po
+include ./$(DEPDIR)/scanner.Po
+include ./$(DEPDIR)/send.Po
+include ./$(DEPDIR)/socket.Po
+include ./$(DEPDIR)/timer.Po
+include ./$(DEPDIR)/util.Po
+
+.c.o:
+	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+#	$(AM_V_CC) \
+#	source='$<' object='$@' libtool=no \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(COMPILE) -c $<
+
+.c.obj:
+	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+#	$(AM_V_CC) \
+#	source='$<' object='$@' libtool=no \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.l.c:
+	$(AM_V_LEX)$(am__skiplex) $(SHELL) $(YLWRAP) $< $(LEX_OUTPUT_ROOT).c $@ -- $(LEXCOMPILE)
+
+.y.c:
+	$(AM_V_YACC)$(am__skipyacc) $(SHELL) $(YLWRAP) $< y.tab.c $@ y.tab.h $*.h y.output $*.output -- $(YACCCOMPILE)
+install-man5: $(man_MANS)
+	@$(NORMAL_INSTALL)
+	test -z "$(man5dir)" || $(MKDIR_P) "$(DESTDIR)$(man5dir)"
+	@list=''; test -n "$(man5dir)" || exit 0; \
+	{ for i in $$list; do echo "$$i"; done; \
+	l2='$(man_MANS)'; for i in $$l2; do echo "$$i"; done | \
+	  sed -n '/\.5[a-z]*$$/p'; \
+	} | while read p; do \
+	  if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; echo "$$p"; \
+	done | \
+	sed -e 'n;s,.*/,,;p;h;s,.*\.,,;s,^[^5][0-9a-z]*$$,5,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,' | \
+	sed 'N;N;s,\n, ,g' | { \
+	list=; while read file base inst; do \
+	  if test "$$base" = "$$inst"; then list="$$list $$file"; else \
+	    echo " $(INSTALL_DATA) '$$file' '$(DESTDIR)$(man5dir)/$$inst'"; \
+	    $(INSTALL_DATA) "$$file" "$(DESTDIR)$(man5dir)/$$inst" || exit $$?; \
+	  fi; \
+	done; \
+	for i in $$list; do echo "$$i"; done | $(am__base_list) | \
+	while read files; do \
+	  test -z "$$files" || { \
+	    echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(man5dir)'"; \
+	    $(INSTALL_DATA) $$files "$(DESTDIR)$(man5dir)" || exit $$?; }; \
+	done; }
+
+uninstall-man5:
+	@$(NORMAL_UNINSTALL)
+	@list=''; test -n "$(man5dir)" || exit 0; \
+	files=`{ for i in $$list; do echo "$$i"; done; \
+	l2='$(man_MANS)'; for i in $$l2; do echo "$$i"; done | \
+	  sed -n '/\.5[a-z]*$$/p'; \
+	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^5][0-9a-z]*$$,5,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,'`; \
+	test -z "$$files" || { \
+	  echo " ( cd '$(DESTDIR)$(man5dir)' && rm -f" $$files ")"; \
+	  cd "$(DESTDIR)$(man5dir)" && rm -f $$files; }
+install-man8: $(man_MANS)
+	@$(NORMAL_INSTALL)
+	test -z "$(man8dir)" || $(MKDIR_P) "$(DESTDIR)$(man8dir)"
+	@list=''; test -n "$(man8dir)" || exit 0; \
+	{ for i in $$list; do echo "$$i"; done; \
+	l2='$(man_MANS)'; for i in $$l2; do echo "$$i"; done | \
+	  sed -n '/\.8[a-z]*$$/p'; \
+	} | while read p; do \
+	  if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; echo "$$p"; \
+	done | \
+	sed -e 'n;s,.*/,,;p;h;s,.*\.,,;s,^[^8][0-9a-z]*$$,8,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,' | \
+	sed 'N;N;s,\n, ,g' | { \
+	list=; while read file base inst; do \
+	  if test "$$base" = "$$inst"; then list="$$list $$file"; else \
+	    echo " $(INSTALL_DATA) '$$file' '$(DESTDIR)$(man8dir)/$$inst'"; \
+	    $(INSTALL_DATA) "$$file" "$(DESTDIR)$(man8dir)/$$inst" || exit $$?; \
+	  fi; \
+	done; \
+	for i in $$list; do echo "$$i"; done | $(am__base_list) | \
+	while read files; do \
+	  test -z "$$files" || { \
+	    echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(man8dir)'"; \
+	    $(INSTALL_DATA) $$files "$(DESTDIR)$(man8dir)" || exit $$?; }; \
+	done; }
+
+uninstall-man8:
+	@$(NORMAL_UNINSTALL)
+	@list=''; test -n "$(man8dir)" || exit 0; \
+	files=`{ for i in $$list; do echo "$$i"; done; \
+	l2='$(man_MANS)'; for i in $$l2; do echo "$$i"; done | \
+	  sed -n '/\.8[a-z]*$$/p'; \
+	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^8][0-9a-z]*$$,8,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,'`; \
+	test -z "$$files" || { \
+	  echo " ( cd '$(DESTDIR)$(man8dir)' && rm -f" $$files ")"; \
+	  cd "$(DESTDIR)$(man8dir)" && rm -f $$files; }
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@list='$(MANS)'; if test -n "$$list"; then \
+	  list=`for p in $$list; do \
+	    if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
+	    if test -f "$$d$$p"; then echo "$$d$$p"; else :; fi; done`; \
+	  if test -n "$$list" && \
+	    grep 'ab help2man is required to generate this page' $$list >/dev/null; then \
+	    echo "error: found man pages containing the \`missing help2man' replacement text:" >&2; \
+	    grep -l 'ab help2man is required to generate this page' $$list | sed 's/^/         /' >&2; \
+	    echo "       to fix them, install help2man, remove and regenerate the man pages;" >&2; \
+	    echo "       typically \`make maintainer-clean' will remove them" >&2; \
+	    exit 1; \
+	  else :; fi; \
+	else :; fi
+	$(am__remove_distdir)
+	test -d "$(distdir)" || mkdir "$(distdir)"
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	$(MAKE) $(AM_MAKEFLAGS) \
+	  top_distdir="$(top_distdir)" distdir="$(distdir)" \
+	  dist-hook
+	-test -n "$(am__skip_mode_fix)" \
+	|| find "$(distdir)" -type d ! -perm -755 \
+		-exec chmod u+rwx,go+rx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r "$(distdir)"
+dist-gzip: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+dist-bzip2: distdir
+	tardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2
+	$(am__remove_distdir)
+
+dist-lzma: distdir
+	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma
+	$(am__remove_distdir)
+
+dist-xz: distdir
+	tardir=$(distdir) && $(am__tar) | xz -c >$(distdir).tar.xz
+	$(am__remove_distdir)
+
+dist-tarZ: distdir
+	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
+	$(am__remove_distdir)
+
+dist-shar: distdir
+	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	$(am__remove_distdir)
+
+dist-zip: distdir
+	-rm -f $(distdir).zip
+	zip -rq $(distdir).zip $(distdir)
+	$(am__remove_distdir)
+
+dist dist-all: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	case '$(DIST_ARCHIVES)' in \
+	*.tar.gz*) \
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\
+	*.tar.bz2*) \
+	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
+	*.tar.lzma*) \
+	  lzma -dc $(distdir).tar.lzma | $(am__untar) ;;\
+	*.tar.xz*) \
+	  xz -dc $(distdir).tar.xz | $(am__untar) ;;\
+	*.tar.Z*) \
+	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
+	*.shar.gz*) \
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\
+	*.zip*) \
+	  unzip $(distdir).zip ;;\
+	esac
+	chmod -R a-w $(distdir); chmod a+w $(distdir)
+	mkdir $(distdir)/_build
+	mkdir $(distdir)/_inst
+	chmod a-w $(distdir)
+	test -d $(distdir)/_build || exit 0; \
+	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
+	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
+	  && am__cwd=`pwd` \
+	  && $(am__cd) $(distdir)/_build \
+	  && ../configure --srcdir=.. --prefix="$$dc_install_base" \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
+	        distuninstallcheck \
+	  && chmod -R a-w "$$dc_install_base" \
+	  && ({ \
+	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
+	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
+	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
+	  && rm -rf "$$dc_destdir" \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist \
+	  && rm -rf $(DIST_ARCHIVES) \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \
+	  && cd "$$am__cwd" \
+	  || exit 1
+	$(am__remove_distdir)
+	@(echo "$(distdir) archives ready for distribution: "; \
+	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
+	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
+distuninstallcheck:
+	@$(am__cd) '$(distuninstallcheck_dir)' \
+	&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \
+	   || { echo "ERROR: files left after uninstall:" ; \
+	        if test -n "$(DESTDIR)"; then \
+	          echo "  (check DESTDIR support)"; \
+	        fi ; \
+	        $(distuninstallcheck_listfiles) ; \
+	        exit 1; } >&2
+distcleancheck: distclean
+	@if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left in build directory after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS) $(MANS) config.h
+installdirs:
+	for dir in "$(DESTDIR)$(sbindir)" "$(DESTDIR)$(man5dir)" "$(DESTDIR)$(man8dir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+	-test -z "$(CLEANFILES)" || rm -f $(CLEANFILES)
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+	-rm -f gram.c
+	-rm -f gram.h
+	-rm -f scanner.c
+clean: clean-am
+
+clean-am: clean-generic clean-sbinPROGRAMS mostlyclean-am
+
+distclean: distclean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-hdr distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-man
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am: install-sbinPROGRAMS
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man: install-man5 install-man8
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-man uninstall-sbinPROGRAMS
+
+uninstall-man: uninstall-man5 uninstall-man8
+
+.MAKE: all install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am am--refresh check check-am clean \
+	clean-generic clean-sbinPROGRAMS ctags dist dist-all \
+	dist-bzip2 dist-gzip dist-hook dist-lzma dist-shar dist-tarZ \
+	dist-xz dist-zip distcheck distclean distclean-compile \
+	distclean-generic distclean-hdr distclean-tags distcleancheck \
+	distdir distuninstallcheck dvi dvi-am html html-am info \
+	info-am install install-am install-data install-data-am \
+	install-dvi install-dvi-am install-exec install-exec-am \
+	install-html install-html-am install-info install-info-am \
+	install-man install-man5 install-man8 install-pdf \
+	install-pdf-am install-ps install-ps-am install-sbinPROGRAMS \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-man uninstall-man5 \
+	uninstall-man8 uninstall-sbinPROGRAMS
+
+
+.man:
+	$(AM_V_GEN)$(SED) \
+		-e 's,@''VERSION''@,$(VERSION),g' \
+		-e 's,@''sbindir''@,$(sbindir),g' \
+		-e 's,@''PATH_RADVD_CONF''@,$(PATH_RADVD_CONF),g' \
+		-e 's,@''PATH_RADVD_PID''@,$(PATH_RADVD_PID),g' \
+		-e 's,@''PATH_RADVD_LOG''@,$(PATH_RADVD_LOG),g' \
+		-e 's,@''LOG_FACILITY''@,$(LOG_FACILITY),g' \
+		$< > $@
+
+dist-hook:
+	rm -f $(distdir)/gram.c
+	rm -f $(distdir)/gram.h
+	rm -f $(distdir)/scanner.c
+
+scanner.o: gram.h
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur radvd-1.8/radvd.c radvd-1.8-brcm/radvd.c
--- radvd-1.8/radvd.c	2011-05-06 23:26:39.000000000 -0300
+++ radvd-1.8-brcm/radvd.c	2018-11-24 16:42:07.697980659 -0400
@@ -1,5 +1,5 @@
 /*
- *   $Id: radvd.c,v 1.61 2011/05/04 17:22:57 reubenhwk Exp $
+ *   $Id: radvd.c,v 1.1.2.1 2011/08/11 17:52:43 jzhang Exp $
  *
  *   Authors:
  *    Pedro Roque		<roque@di.fc.ul.pt>
@@ -19,6 +19,7 @@
 #include "radvd.h"
 #include "pathnames.h"
 
+#undef HAVE_NETLINK // netlink make CDrouter test cases fail, so bypass it
 #ifdef HAVE_NETLINK
 #include "netlink.h"
 #endif
@@ -238,6 +239,7 @@
 		exit(1);
 	}
 
+#if 0 //brcm: no need to check
 	/* check that 'other' cannot write the file
          * for non-root, also that self/own group can't either
          */
@@ -254,6 +256,7 @@
 	if (check_ip6_forwarding()) {
 		flog(LOG_WARNING, "IPv6 forwarding seems to be disabled, but continuing anyway.");
 	}
+#endif
 
 	/* parse config file */
 	if (readin_config(conf_file) < 0) {
@@ -269,8 +272,8 @@
 	/* drop root privileges if requested. */
 	if (username) {
 		if (!singleprocess) {
-		 	dlog(LOG_DEBUG, 3, "Initializing privsep");
-		 	if (privsep_init() < 0)
+			dlog(LOG_DEBUG, 3, "Initializing privsep");
+			if (privsep_init() < 0)
 				flog(LOG_WARNING, "Failed to initialize privsep.");
 		}
 
@@ -310,7 +313,7 @@
 	 * okay, config file is read in, socket and stuff is setup, so
 	 * lets fork now...
 	 */
-
+#if 0 //brcm
 	if (get_debuglevel() == 0) {
 
 		/* Detach from controlling terminal */
@@ -329,7 +332,7 @@
 		}
 
 	}
-
+#endif
 	/*
 	 *	config signal handlers
 	 */
@@ -684,11 +687,11 @@
 
 
 	flog(LOG_INFO, "Resetting prefix lifetimes");
-	
-	for (iface = IfaceList; iface; iface = iface->next) 
+
+	for (iface = IfaceList; iface; iface = iface->next)
 	{
 		for (prefix = iface->AdvPrefixList; prefix;
-							prefix = prefix->next) 
+							prefix = prefix->next)
 		{
 			if (prefix->DecrementLifetimesFlag)
 			{
@@ -701,7 +704,7 @@
 						prefix->AdvPreferredLifetime;
 			}
 		}
-		
+
 	}
 
 }
@@ -855,4 +858,3 @@
 	fprintf(stderr, "usage: %s %s\n", pname, usage_str);
 	exit(1);
 }
-
diff -Naur radvd-1.8/scanner.c radvd-1.8-brcm/scanner.c
--- radvd-1.8/scanner.c	1969-12-31 20:00:00.000000000 -0400
+++ radvd-1.8-brcm/scanner.c	2018-11-24 16:42:07.697980659 -0400
@@ -0,0 +1,2558 @@
+
+#line 3 "scanner.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types.
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t;
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define yywrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 62
+#define YY_END_OF_BUFFER 63
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[592] =
+    {   0,
+        0,    0,   63,   61,    3,    2,   59,   59,   59,   60,
+       50,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+        3,   59,    0,    1,   59,   51,   59,   50,   59,   59,
+       49,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   54,
+       59,   59,   52,   50,   59,   59,   49,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   56,   59,   55,   59,   59,   50,
+       59,   59,   59,   49,   59,   59,   59,   59,   59,   59,
+
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       58,   59,   59,   59,   59,   59,   50,   59,   59,   49,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+        8,   59,   59,   59,   59,   59,   59,   59,   59,    7,
+       59,   59,   59,   59,   59,   59,   59,    6,   59,   59,
+       59,   49,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+
+       59,   59,   59,   59,   59,   59,   59,   57,    5,   59,
+       59,   49,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,    9,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   53,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   23,   59,   59,   59,   59,
+
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,    4,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   16,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   46,   44,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   40,   33,   59,   59,
+
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   42,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   24,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   59,   29,   11,   59,   59,   59,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       19,   59,   59,   59,   59,   59,   31,   14,   59,   59,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   34,
+       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+
+       49,   59,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   59,   18,   59,   59,   59,   59,   59,   59,   27,
+       59,   59,   10,   59,   59,   59,   59,   49,   59,   45,
+       59,   59,   30,   32,   59,   59,   59,   43,   59,   17,
+       39,   59,   59,   25,   59,   59,   59,   59,   59,   59,
+       59,   49,   59,   59,   59,   59,   59,   59,   59,   59,
+       59,   35,   59,   37,   59,   12,   59,   13,   49,   59,
+       20,   59,   59,   15,   59,   41,   38,   22,   28,   59,
+       47,   59,   59,   59,   59,   36,   59,   21,   48,   26,
+        0
+
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    1,    5,    4,    4,    4,    1,    4,
+        4,    4,    4,    4,    6,    7,    8,    9,    9,    9,
+        9,   10,    9,   11,    9,    9,    9,   12,   13,    4,
+        4,    4,    4,    4,   14,   15,   16,   17,   18,   19,
+        4,   20,   21,    4,    4,   22,   23,   24,   25,   26,
+        4,   27,   28,   29,   30,   31,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,   32,   33,   34,   35,
+
+       36,   37,   38,   39,   40,    4,   41,   42,   43,   44,
+       45,   46,    4,   47,   48,   49,   50,   51,   52,   53,
+       54,    4,   55,    1,   56,    4,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[57] =
+    {   0,
+        1,    1,    1,    2,    2,    2,    2,    1,    2,    2,
+        2,    2,    1,    2,    2,    2,    2,    2,    2,    2,
+        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
+        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
+        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
+        2,    2,    2,    2,    1,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[595] =
+    {   0,
+        0,    0, 1168, 1324, 1165, 1324,    0,   56,   51, 1324,
+      106, 1154,   56,   61,   66,   71,   77, 1120, 1126,   57,
+       62, 1119,   92, 1122, 1117, 1115, 1123,   46, 1111, 1112,
+     1148,    0, 1146, 1324,  143,   95,   99,  191,  220,  119,
+        0,  126,  143, 1111,  148, 1088, 1094, 1092, 1082, 1090,
+     1109, 1089, 1091, 1090, 1091,  111, 1076, 1086, 1073,    0,
+     1073, 1058,  152,  249,  157,  278,  307,  331, 1071, 1078,
+      164, 1058, 1056, 1067, 1057, 1074,  152, 1072, 1054, 1058,
+     1055, 1042, 1040, 1043,    0, 1038,    0, 1040, 1027,  174,
+     1063,  354,  383,  412, 1024, 1023,  152, 1027, 1027, 1030,
+
+       82,  121, 1016,  176,   49, 1030, 1041, 1029, 1014, 1013,
+     1009, 1033,  999,  996, 1008,  994, 1014,  990, 1002,  989,
+        0,  979,  975,  971,  980,  983,  206,  441,  470,  499,
+        0,  969,  970,  988,  978,  971,  964,  968,  961,  961,
+      971,  953,  955,  966,  100,  939,  944,  937,  944,  169,
+        0,  942,  950,  170,  945,  940,  928,  923,  917,    0,
+      927,  914,  912,  920,  922,  915,  904,    0,  944,  528,
+      557,  586,  910,  934,  919,  914,  900,  899,  893,  901,
+      905,  891,  894,  892,  900,  893,  879,  876,  883,  870,
+      867,  862,  860,  868,  871,  878,  884,  864,  878,  884,
+
+      865,  882,  862,  829,  829,  827,  843,    0,    0,  615,
+      644,  862,  829,  827,  849,  820,  855,  821,  844,  822,
+      810,  805,  801,  811,  818,  806,  812,  807,  828,  807,
+      805,  790,  828,  787,  781,  792,  795,  774,  780,  781,
+      761,  779,  768,  787,    0,  757,  776,  797,  673,  702,
+      757,  755,  769,  748,  751,  737,  758,  750,  738,  743,
+      767,  735,  170,  749,  736,  222,  738,  726,  739,  724,
+      738,  709,  721,  728,  727,  705,  730,  701,  736,  693,
+      693,  689,    0,  696,  731,  760,  688,  708,  689,  679,
+      691,  694,  695,  689,  695,    0,  677,  668,  674,  658,
+
+      656,  669,  653,  660,  652,  684,  646,  674,  655,  647,
+      649,  664,  659,  653,  646,   70,  633,  651,  635,  649,
+      620,  626,    0,  655,  789,  818,  621,  625,  627,  219,
+      613,  604,    0,  626,  594,  599,  606,  604,  604,  603,
+      596,  608,  599,  599,  593,  591,  595,  579,  578,  565,
+      573,  565,    0,    0,  571,  563,  561,  564,  558,  562,
+      563,  544,  847,  876,  538,  544,  550,  545,  537,  534,
+      557,  539,  534,  542,  543,  541,  526,  532,  523,  518,
+      521,  519,  520,  507,  539,  516,  519,  514,  512,  512,
+      504,  504,  482,  480,  476,  478,    0,    0,  514,  905,
+
+      934,  477,  484,  474,  485,  485,  159,  474,  487,  466,
+      471,  479,  451,    0,  463,  469,  454,  447,  459,  447,
+      444,  457,  442,  456,  436,  436,  434,  434,  432,  428,
+      431,  430,  429,  963,  992,    0,  415,  423,  426,  424,
+      412,  409,  394,  404,  396,  402,  399,  398,  390,  396,
+      399,  394,  386,    0,    0,  397,  385,  378,  376,  363,
+      371,  361,  373,  364,  360,  370,  358,  392, 1021, 1050,
+        0,  360,  347,  359,  353,  347,    0,    0,  336,  363,
+      344,  337,  343,  335,  330,  333,  339,  327,  324,    0,
+      334,  321,  307,  315,  303,  311,  295,  294,  286, 1079,
+
+     1108,  300,  295,  287,  295,  287,  282,  288,  293,  292,
+      283,  284,    0,  283,  265,  272,  271,  272,  262,    0,
+      261,  267,    0,  270,  274,  268,  287, 1137, 1166,    0,
+      255,  255,    0,    0,  261,  247,  229,    0,  243,    0,
+        0,  242,  227,    0,  238,  237,  236,  227,  228,  248,
+      219, 1195, 1224,  215,  206,  207,  209,  206,  207,  206,
+      192,    0,  185,    0,  188,    0,  172,    0,  207, 1253,
+        0,  180,  172,    0,  160,    0,    0,    0,    0,  153,
+        0, 1282,  136,  109,   95,    0,   88,    0,    0,    0,
+     1324,   72, 1319, 1321
+
+    } ;
+
+static yyconst flex_int16_t yy_def[595] =
+    {   0,
+      591,    1,  591,  591,  591,  591,  592,  593,  592,  591,
+      592,  592,   11,   11,   11,   11,   11,  592,  592,  592,
+      592,  592,   11,  592,  592,  592,  592,  592,  592,  592,
+      591,  592,  594,  591,  593,  592,  592,   11,  592,   38,
+      592,   38,   38,  592,   38,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,   38,   64,  592,  592,  592,  592,  592,
+       64,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,   66,   39,   39,  592,  592,  592,  592,  592,  592,
+
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,   66,   66,   94,
+       67,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  129,
+       39,   94,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  129,
+      129,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  211,   39,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  211,  211,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  286,   39,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  286,  286,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  364,
+
+       39,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  364,  364,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  435,   39,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  435,
+
+      435,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  501,   39,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  501,  501,  592,  592,  592,  592,  592,  592,  592,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  501,
+      592,  592,  592,  592,  592,  592,  592,  592,  592,  592,
+      592,  501,  592,  592,  592,  592,  592,  592,  592,  592,
+        0,  591,  591,  591
+
+    } ;
+
+static yyconst flex_int16_t yy_nxt[1381] =
+    {   0,
+        4,    5,    6,    7,    8,    9,    7,   10,   11,   11,
+       11,   12,   10,   13,   14,   15,   16,   15,   17,   18,
+       19,    7,   20,    7,    7,    7,   21,    7,    7,   22,
+        7,   15,   15,   23,   15,   15,   15,    7,   24,   25,
+        7,   26,   27,    7,   28,   29,   30,    7,    7,    7,
+        7,    7,    7,    7,   10,   10,   33,   33,   34,   36,
+       36,   36,   32,   33,   40,   40,   40,   32,   33,   40,
+       40,   40,   32,   32,   40,   40,   40,   32,   51,   40,
+       40,   40,   59,   32,  147,   40,   40,   40,   49,   60,
+       42,  355,   43,  148,   44,  356,   50,   52,   32,  529,
+
+       40,   40,   40,   36,   36,   36,   45,   63,   63,   63,
+       33,   33,   37,  139,   38,   38,   38,   39,   46,   40,
+       40,   40,   40,   40,   40,   32,  140,   65,   65,   65,
+      590,  186,   32,   54,   65,   65,   65,   40,   40,   40,
+       40,   40,   40,   33,   33,   34,  589,   83,  187,   32,
+       33,   65,   65,   65,   32,   33,   65,   65,   65,   84,
+       63,   63,   63,   32,  141,   91,   91,   91,  115,  142,
+       32,  588,   91,   91,   91,  134,   68,  441,  116,  442,
+       37,   71,  127,  127,  127,   39,  196,  135,  586,  192,
+       69,  299,  144,   72,  300,  301,  197,   33,   33,   64,
+
+       64,   64,  585,  584,   65,   65,   65,   65,   65,   65,
+      109,  145,   37,  583,  127,  127,  127,  193,  529,  581,
+      146,  580,   65,   65,   65,   65,   65,   65,   66,   66,
+       66,   67,  579,   66,   66,   66,   66,   66,   66,  578,
+      368,  577,  576,  304,  369,  575,  574,  305,  573,  572,
+      571,   66,   66,   66,   66,   66,   66,   90,   90,   90,
+      568,  567,   91,   91,   91,   91,   91,   91,  306,  566,
+      565,  564,  563,  562,  561,  560,  559,  558,  557,  556,
+       91,   91,   91,   91,   91,   91,   92,   92,   92,   93,
+      555,   92,   92,   92,   92,   92,   92,  554,  470,  551,
+
+      550,  549,  548,  547,  546,  545,  544,  543,  542,   92,
+       92,   92,   92,   92,   92,   94,   94,   94,  541,  540,
+       94,   94,   94,   94,   94,   94,  539,  538,  537,  536,
+      535,  534,  533,  532,  531,  530,  526,  525,   94,   94,
+       94,   94,   94,   94,   95,  524,   96,   97,  523,  522,
+       98,   99,  100,  101,  521,  102,  103,  104,  105,  520,
+      519,  106,  128,  128,  128,  518,  517,  128,  128,  128,
+      128,  128,  128,  516,  515,  514,  513,  512,  511,  510,
+      509,  508,  507,  506,  505,  128,  128,  128,  128,  128,
+      128,  129,  129,  129,  504,  503,  129,  129,  129,  129,
+
+      129,  129,  502,  401,  499,  498,  497,  496,  495,  494,
+      493,  492,  491,  490,  129,  129,  129,  129,  129,  129,
+      130,  130,  130,  131,  489,  130,  130,  130,  130,  130,
+      130,  488,  487,  486,  485,  484,  483,  482,  481,  480,
+      479,  478,  477,  130,  130,  130,  130,  130,  130,  169,
+      169,  169,  476,  475,  169,  169,  169,  169,  169,  169,
+      474,  473,  472,  471,  467,  466,  465,  464,  463,  462,
+      461,  460,  169,  169,  169,  169,  169,  169,  170,  170,
+      170,  171,  459,  170,  170,  170,  170,  170,  170,  458,
+      457,  456,  455,  454,  453,  452,  451,  450,  449,  448,
+
+      447,  170,  170,  170,  170,  170,  170,  172,  172,  172,
+      446,  445,  172,  172,  172,  172,  172,  172,  444,  443,
+      440,  439,  438,  437,  436,  326,  433,  432,  431,  430,
+      172,  172,  172,  172,  172,  172,  210,  210,  210,  429,
+      428,  210,  210,  210,  210,  210,  210,  427,  426,  425,
+      424,  423,  422,  421,  420,  419,  418,  417,  416,  210,
+      210,  210,  210,  210,  210,  211,  211,  211,  415,  414,
+      211,  211,  211,  211,  211,  211,  413,  412,  411,  410,
+      409,  408,  407,  406,  405,  404,  403,  402,  211,  211,
+      211,  211,  211,  211,  212,  212,  212,  398,  397,  212,
+
+      212,  212,  212,  212,  212,  396,  395,  394,  393,  392,
+      391,  390,  389,  388,  387,  386,  385,  212,  212,  212,
+      212,  212,  212,  248,  248,  248,  384,  383,  248,  248,
+      248,  248,  248,  248,  382,  381,  380,  379,  378,  377,
+      376,  375,  374,  373,  372,  371,  248,  248,  248,  248,
+      248,  248,  249,  249,  249,  250,  370,  249,  249,  249,
+      249,  249,  249,  367,  366,  365,  250,  362,  361,  360,
+      359,  358,  357,  354,  353,  249,  249,  249,  249,  249,
+      249,  285,  285,  285,  352,  351,  285,  285,  285,  285,
+      285,  285,  350,  349,  348,  347,  346,  345,  344,  343,
+
+      342,  341,  340,  339,  285,  285,  285,  285,  285,  285,
+      286,  286,  286,  338,  337,  286,  286,  286,  286,  286,
+      286,  336,  335,  334,  333,  332,  331,  330,  329,  328,
+      327,  323,  322,  286,  286,  286,  286,  286,  286,  324,
+      324,  324,  321,  320,  324,  324,  324,  324,  324,  324,
+      319,  318,  317,  316,  315,  314,  313,  312,  311,  310,
+      309,  308,  324,  324,  324,  324,  324,  324,  325,  325,
+      325,  326,  307,  325,  325,  325,  325,  325,  325,  303,
+      302,  298,  297,  296,  295,  294,  293,  292,  291,  290,
+      289,  325,  325,  325,  325,  325,  325,  363,  363,  363,
+
+      288,  287,  363,  363,  363,  363,  363,  363,  171,  284,
+      283,  282,  281,  280,  279,  278,  277,  276,  275,  274,
+      363,  363,  363,  363,  363,  363,  364,  364,  364,  273,
+      272,  364,  364,  364,  364,  364,  364,  271,  270,  269,
+      268,  267,  266,  265,  264,  263,  262,  261,  260,  364,
+      364,  364,  364,  364,  364,  399,  399,  399,  259,  258,
+      399,  399,  399,  399,  399,  399,  257,  256,  255,  254,
+      253,  252,  251,  131,  247,  246,  245,  244,  399,  399,
+      399,  399,  399,  399,  400,  400,  400,  401,  243,  400,
+      400,  400,  400,  400,  400,  242,  241,  240,  239,  238,
+
+      237,  236,  235,  234,  233,  232,  231,  400,  400,  400,
+      400,  400,  400,  434,  434,  434,  230,  229,  434,  434,
+      434,  434,  434,  434,  228,  227,  226,  225,  224,  223,
+      222,  221,  220,  219,  218,  217,  434,  434,  434,  434,
+      434,  434,  435,  435,  435,  216,  215,  435,  435,  435,
+      435,  435,  435,  214,  213,   93,  209,  208,  207,  206,
+      205,  204,  203,  202,  201,  435,  435,  435,  435,  435,
+      435,  468,  468,  468,  200,  199,  468,  468,  468,  468,
+      468,  468,  198,  195,  194,  191,  190,  189,  188,  185,
+      184,  183,  182,  181,  468,  468,  468,  468,  468,  468,
+
+      469,  469,  469,  470,  180,  469,  469,  469,  469,  469,
+      469,  179,  178,  177,  176,  175,  174,  173,  168,  167,
+      166,  165,  164,  469,  469,  469,  469,  469,  469,  500,
+      500,  500,  163,  162,  500,  500,  500,  500,  500,  500,
+      161,  160,  159,  158,  157,  156,  155,  154,  153,  152,
+      151,  150,  500,  500,  500,  500,  500,  500,  501,  501,
+      501,  149,  143,  501,  501,  501,  501,  501,  501,  138,
+      137,  136,  133,  132,   39,  126,  125,  124,  123,  122,
+      121,  501,  501,  501,  501,  501,  501,  527,  527,  527,
+      120,  119,  527,  527,  527,  527,  527,  527,  118,  117,
+
+      114,  113,  112,  111,  110,  108,  107,   89,   88,   87,
+      527,  527,  527,  527,  527,  527,  528,  528,  528,  529,
+       86,  528,  528,  528,  528,  528,  528,   85,   82,   81,
+       80,   79,   78,   77,   76,   75,   74,   73,   70,  528,
+      528,  528,  528,  528,  528,  552,  552,  552,   34,   31,
+      552,  552,  552,  552,  552,  552,   62,   61,   58,   57,
+       56,   55,   53,   48,   47,   41,   31,  591,  552,  552,
+      552,  552,  552,  552,  553,  553,  553,  591,  591,  553,
+      553,  553,  553,  553,  553,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  591,  553,  553,  553,
+
+      553,  553,  553,  569,  569,  569,  591,  591,  569,  569,
+      569,  569,  569,  569,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  569,  569,  569,  569,
+      569,  569,  570,  570,  570,  591,  591,  570,  570,  570,
+      570,  570,  570,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  570,  570,  570,  570,  570,
+      570,  582,  582,  582,  591,  591,  582,  582,  582,  582,
+      582,  582,  591,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  582,  582,  582,  582,  582,  582,
+      587,  587,  587,  591,  591,  587,  587,  587,  587,  587,
+
+      587,  591,  591,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  587,  587,  587,  587,  587,  587,   35,
+       35,   33,   33,    3,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  591,  591,  591,  591
+    } ;
+
+static yyconst flex_int16_t yy_chk[1381] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    8,    8,    8,    9,
+        9,    9,   13,    8,   13,   13,   13,   14,    8,   14,
+       14,   14,   15,  592,   15,   15,   15,   16,   21,   16,
+       16,   16,   28,   17,  105,   17,   17,   17,   20,   28,
+       13,  316,   14,  105,   16,  316,   20,   21,   23,  587,
+
+       23,   23,   23,   36,   36,   36,   16,   37,   37,   37,
+        8,    8,   11,  101,   11,   11,   11,   11,   17,   11,
+       11,   11,   11,   11,   11,   40,  101,   40,   40,   40,
+      585,  145,   42,   23,   42,   42,   42,   11,   11,   11,
+       11,   11,   11,   35,   35,   35,  584,   56,  145,   43,
+       35,   43,   43,   43,   45,   35,   45,   45,   45,   56,
+       63,   63,   63,   65,  102,   65,   65,   65,   77,  102,
+       71,  583,   71,   71,   71,   97,   42,  407,   77,  407,
+       90,   45,   90,   90,   90,   90,  154,   97,  580,  150,
+       43,  263,  104,   45,  263,  263,  154,   35,   35,   38,
+
+       38,   38,  575,  573,   38,   38,   38,   38,   38,   38,
+       71,  104,  127,  572,  127,  127,  127,  150,  569,  567,
+      104,  565,   38,   38,   38,   38,   38,   38,   39,   39,
+       39,   39,  563,   39,   39,   39,   39,   39,   39,  561,
+      330,  560,  559,  266,  330,  558,  557,  266,  556,  555,
+      554,   39,   39,   39,   39,   39,   39,   64,   64,   64,
+      551,  550,   64,   64,   64,   64,   64,   64,  266,  549,
+      548,  547,  546,  545,  543,  542,  539,  537,  536,  535,
+       64,   64,   64,   64,   64,   64,   66,   66,   66,   66,
+      532,   66,   66,   66,   66,   66,   66,  531,  527,  526,
+
+      525,  524,  522,  521,  519,  518,  517,  516,  515,   66,
+       66,   66,   66,   66,   66,   67,   67,   67,  514,  512,
+       67,   67,   67,   67,   67,   67,  511,  510,  509,  508,
+      507,  506,  505,  504,  503,  502,  499,  498,   67,   67,
+       67,   67,   67,   67,   68,  497,   68,   68,  496,  495,
+       68,   68,   68,   68,  494,   68,   68,   68,   68,  493,
+      492,   68,   92,   92,   92,  491,  489,   92,   92,   92,
+       92,   92,   92,  488,  487,  486,  485,  484,  483,  482,
+      481,  480,  479,  476,  475,   92,   92,   92,   92,   92,
+       92,   93,   93,   93,  474,  473,   93,   93,   93,   93,
+
+       93,   93,  472,  468,  467,  466,  465,  464,  463,  462,
+      461,  460,  459,  458,   93,   93,   93,   93,   93,   93,
+       94,   94,   94,   94,  457,   94,   94,   94,   94,   94,
+       94,  456,  453,  452,  451,  450,  449,  448,  447,  446,
+      445,  444,  443,   94,   94,   94,   94,   94,   94,  128,
+      128,  128,  442,  441,  128,  128,  128,  128,  128,  128,
+      440,  439,  438,  437,  433,  432,  431,  430,  429,  428,
+      427,  426,  128,  128,  128,  128,  128,  128,  129,  129,
+      129,  129,  425,  129,  129,  129,  129,  129,  129,  424,
+      423,  422,  421,  420,  419,  418,  417,  416,  415,  413,
+
+      412,  129,  129,  129,  129,  129,  129,  130,  130,  130,
+      411,  410,  130,  130,  130,  130,  130,  130,  409,  408,
+      406,  405,  404,  403,  402,  399,  396,  395,  394,  393,
+      130,  130,  130,  130,  130,  130,  170,  170,  170,  392,
+      391,  170,  170,  170,  170,  170,  170,  390,  389,  388,
+      387,  386,  385,  384,  383,  382,  381,  380,  379,  170,
+      170,  170,  170,  170,  170,  171,  171,  171,  378,  377,
+      171,  171,  171,  171,  171,  171,  376,  375,  374,  373,
+      372,  371,  370,  369,  368,  367,  366,  365,  171,  171,
+      171,  171,  171,  171,  172,  172,  172,  362,  361,  172,
+
+      172,  172,  172,  172,  172,  360,  359,  358,  357,  356,
+      355,  352,  351,  350,  349,  348,  347,  172,  172,  172,
+      172,  172,  172,  210,  210,  210,  346,  345,  210,  210,
+      210,  210,  210,  210,  344,  343,  342,  341,  340,  339,
+      338,  337,  336,  335,  334,  332,  210,  210,  210,  210,
+      210,  210,  211,  211,  211,  211,  331,  211,  211,  211,
+      211,  211,  211,  329,  328,  327,  324,  322,  321,  320,
+      319,  318,  317,  315,  314,  211,  211,  211,  211,  211,
+      211,  249,  249,  249,  313,  312,  249,  249,  249,  249,
+      249,  249,  311,  310,  309,  308,  307,  306,  305,  304,
+
+      303,  302,  301,  300,  249,  249,  249,  249,  249,  249,
+      250,  250,  250,  299,  298,  250,  250,  250,  250,  250,
+      250,  297,  295,  294,  293,  292,  291,  290,  289,  288,
+      287,  284,  282,  250,  250,  250,  250,  250,  250,  285,
+      285,  285,  281,  280,  285,  285,  285,  285,  285,  285,
+      279,  278,  277,  276,  275,  274,  273,  272,  271,  270,
+      269,  268,  285,  285,  285,  285,  285,  285,  286,  286,
+      286,  286,  267,  286,  286,  286,  286,  286,  286,  265,
+      264,  262,  261,  260,  259,  258,  257,  256,  255,  254,
+      253,  286,  286,  286,  286,  286,  286,  325,  325,  325,
+
+      252,  251,  325,  325,  325,  325,  325,  325,  248,  247,
+      246,  244,  243,  242,  241,  240,  239,  238,  237,  236,
+      325,  325,  325,  325,  325,  325,  326,  326,  326,  235,
+      234,  326,  326,  326,  326,  326,  326,  233,  232,  231,
+      230,  229,  228,  227,  226,  225,  224,  223,  222,  326,
+      326,  326,  326,  326,  326,  363,  363,  363,  221,  220,
+      363,  363,  363,  363,  363,  363,  219,  218,  217,  216,
+      215,  214,  213,  212,  207,  206,  205,  204,  363,  363,
+      363,  363,  363,  363,  364,  364,  364,  364,  203,  364,
+      364,  364,  364,  364,  364,  202,  201,  200,  199,  198,
+
+      197,  196,  195,  194,  193,  192,  191,  364,  364,  364,
+      364,  364,  364,  400,  400,  400,  190,  189,  400,  400,
+      400,  400,  400,  400,  188,  187,  186,  185,  184,  183,
+      182,  181,  180,  179,  178,  177,  400,  400,  400,  400,
+      400,  400,  401,  401,  401,  176,  175,  401,  401,  401,
+      401,  401,  401,  174,  173,  169,  167,  166,  165,  164,
+      163,  162,  161,  159,  158,  401,  401,  401,  401,  401,
+      401,  434,  434,  434,  157,  156,  434,  434,  434,  434,
+      434,  434,  155,  153,  152,  149,  148,  147,  146,  144,
+      143,  142,  141,  140,  434,  434,  434,  434,  434,  434,
+
+      435,  435,  435,  435,  139,  435,  435,  435,  435,  435,
+      435,  138,  137,  136,  135,  134,  133,  132,  126,  125,
+      124,  123,  122,  435,  435,  435,  435,  435,  435,  469,
+      469,  469,  120,  119,  469,  469,  469,  469,  469,  469,
+      118,  117,  116,  115,  114,  113,  112,  111,  110,  109,
+      108,  107,  469,  469,  469,  469,  469,  469,  470,  470,
+      470,  106,  103,  470,  470,  470,  470,  470,  470,  100,
+       99,   98,   96,   95,   91,   89,   88,   86,   84,   83,
+       82,  470,  470,  470,  470,  470,  470,  500,  500,  500,
+       81,   80,  500,  500,  500,  500,  500,  500,   79,   78,
+
+       76,   75,   74,   73,   72,   70,   69,   62,   61,   59,
+      500,  500,  500,  500,  500,  500,  501,  501,  501,  501,
+       58,  501,  501,  501,  501,  501,  501,   57,   55,   54,
+       53,   52,   51,   50,   49,   48,   47,   46,   44,  501,
+      501,  501,  501,  501,  501,  528,  528,  528,   33,   31,
+      528,  528,  528,  528,  528,  528,   30,   29,   27,   26,
+       25,   24,   22,   19,   18,   12,    5,    3,  528,  528,
+      528,  528,  528,  528,  529,  529,  529,    0,    0,  529,
+      529,  529,  529,  529,  529,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,  529,  529,  529,
+
+      529,  529,  529,  552,  552,  552,    0,    0,  552,  552,
+      552,  552,  552,  552,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,  552,  552,  552,  552,
+      552,  552,  553,  553,  553,    0,    0,  553,  553,  553,
+      553,  553,  553,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,  553,  553,  553,  553,  553,
+      553,  570,  570,  570,    0,    0,  570,  570,  570,  570,
+      570,  570,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,  570,  570,  570,  570,  570,  570,
+      582,  582,  582,    0,    0,  582,  582,  582,  582,  582,
+
+      582,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,  582,  582,  582,  582,  582,  582,  593,
+      593,  594,  594,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  591,  591,  591,  591,
+      591,  591,  591,  591,  591,  591,  591,  591,  591,  591
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "scanner.l"
+/*
+ *   $Id: scanner.c,v 1.1.2.1 2011/08/11 17:52:43 jzhang Exp $
+ *
+ *   Authors:
+ *    Pedro Roque		<roque@di.fc.ul.pt>
+ *    Lars Fenneberg		<lf@elemental.net>
+ *
+ *   This software is Copyright 1996-2000 by the above mentioned author(s),
+ *   All Rights Reserved.
+ *
+ *   The license which is distributed with this software in the file COPYRIGHT
+ *   applies to this software. If your distribution is missing this file, you
+ *   may request it from <pekkas@netcore.fi>.
+ *
+ */
+#define YY_NO_INPUT 1
+#line 20 "scanner.l"
+#include "config.h"
+#include "includes.h"
+#include "log.h"
+#include "gram.h"
+
+extern char *conf_file;
+
+int num_lines = 1;
+#line 986 "scanner.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+
+#line 41 "scanner.l"
+
+
+#line 1174 "scanner.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 592 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 1324 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up yytext again */
+YY_RULE_SETUP
+#line 43 "scanner.l"
+{/* ignore comments */}
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 44 "scanner.l"
+{num_lines++;}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 45 "scanner.l"
+{}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 47 "scanner.l"
+{ return T_INTERFACE; }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 48 "scanner.l"
+{ return T_PREFIX; }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 49 "scanner.l"
+{ return T_ROUTE; }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 50 "scanner.l"
+{ return T_RDNSS; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 51 "scanner.l"
+{ return T_DNSSL; }
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 52 "scanner.l"
+{ return T_CLIENTS; }
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 54 "scanner.l"
+{ return T_IgnoreIfMissing; }
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 55 "scanner.l"
+{ return T_AdvSendAdvert; }
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 56 "scanner.l"
+{ return T_MaxRtrAdvInterval; }
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 57 "scanner.l"
+{ return T_MinRtrAdvInterval; }
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 58 "scanner.l"
+{ return T_AdvManagedFlag; }
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 59 "scanner.l"
+{ return T_AdvOtherConfigFlag; }
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 60 "scanner.l"
+{ return T_AdvLinkMTU; }
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 61 "scanner.l"
+{ return T_AdvReachableTime; }
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 62 "scanner.l"
+{ return T_AdvRetransTimer; }
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 63 "scanner.l"
+{ return T_AdvCurHopLimit; }
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 64 "scanner.l"
+{ return T_AdvDefaultLifetime; }
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 65 "scanner.l"
+{ return T_AdvDefaultPreference; }
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 66 "scanner.l"
+{ return T_AdvSourceLLAddress; }
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 68 "scanner.l"
+{ return T_AdvOnLink; }
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 69 "scanner.l"
+{ return T_AdvAutonomous; }
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 70 "scanner.l"
+{ return T_AdvValidLifetime; }
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 71 "scanner.l"
+{ return T_AdvPreferredLifetime; }
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 72 "scanner.l"
+{ return T_DeprecatePrefix; }
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 73 "scanner.l"
+{ return T_DecrementLifetimes; }
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 75 "scanner.l"
+{ return T_AdvRouterAddr; }
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 76 "scanner.l"
+{ return T_AdvHomeAgentFlag; }
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 77 "scanner.l"
+{ return T_AdvIntervalOpt; }
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 78 "scanner.l"
+{ return T_AdvHomeAgentInfo; }
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 79 "scanner.l"
+{ return T_UnicastOnly; }
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 81 "scanner.l"
+{ return T_Base6Interface; }
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 82 "scanner.l"
+{ return T_Base6to4Interface; }
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 84 "scanner.l"
+{ return T_HomeAgentPreference; }
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 85 "scanner.l"
+{ return T_HomeAgentLifetime; }
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 87 "scanner.l"
+{ return T_AdvRoutePreference; }
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 88 "scanner.l"
+{ return T_AdvRouteLifetime; }
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 89 "scanner.l"
+{ return T_RemoveRoute; }
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 91 "scanner.l"
+{ return T_AdvRDNSSPreference; }
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 92 "scanner.l"
+{ return T_AdvRDNSSOpenFlag; }
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 93 "scanner.l"
+{ return T_AdvRDNSSLifetime; }
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 94 "scanner.l"
+{ return T_FlushRDNSS; }
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 96 "scanner.l"
+{ return T_AdvDNSSLLifetime; }
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 97 "scanner.l"
+{ return T_FlushDNSSL; }
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 99 "scanner.l"
+{ return T_MinDelayBetweenRAs; }
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 101 "scanner.l"
+{ return T_AdvMobRtrSupportFlag; }
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 103 "scanner.l"
+{
+			static struct in6_addr addr;
+			if (inet_pton(AF_INET6, yytext, &addr) < 1) {
+				flog(LOG_ERR, "invalid address in %s, line %d", conf_file,
+					num_lines);
+				return T_BAD_TOKEN;
+			}
+
+			yylval.addr = &addr;
+			return IPV6ADDR;
+		}
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 115 "scanner.l"
+{
+			unsigned long lnum;
+			char *endp;
+			lnum = strtoul(yytext, &endp, 10);
+			if (*yytext == '\0' || *endp != '\0')
+				return T_BAD_TOKEN;
+			if (lnum > 0xFFFFFFFFUL)
+				return T_BAD_TOKEN;	/* XXX */
+			yylval.num = lnum;
+			return NUMBER;
+		}
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+#line 127 "scanner.l"
+{ yylval.snum = atoi(yytext); return SIGNEDNUMBER; }
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+#line 129 "scanner.l"
+{ yylval.dec = atof(yytext); return DECIMAL; }
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 131 "scanner.l"
+{ return INFINITY; }
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 133 "scanner.l"
+{ yylval.num = 1; return SWITCH; }
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 135 "scanner.l"
+{ yylval.num = 0; return SWITCH; }
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+#line 137 "scanner.l"
+{ yylval.snum = -1; return SIGNEDNUMBER; }
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+#line 139 "scanner.l"
+{ yylval.snum = 0; return SIGNEDNUMBER; }
+	YY_BREAK
+case 58:
+YY_RULE_SETUP
+#line 141 "scanner.l"
+{ yylval.snum = 1; return SIGNEDNUMBER; }
+	YY_BREAK
+case 59:
+YY_RULE_SETUP
+#line 143 "scanner.l"
+{
+			static char string[256];
+
+			strncpy(string, yytext, sizeof(string));
+			string[sizeof(string)-1] = '\0';
+			yylval.str = string;
+			return STRING;
+		}
+	YY_BREAK
+case 60:
+YY_RULE_SETUP
+#line 152 "scanner.l"
+{ return *yytext; }
+	YY_BREAK
+case 61:
+YY_RULE_SETUP
+#line 154 "scanner.l"
+{ return T_BAD_TOKEN; }
+	YY_BREAK
+case 62:
+YY_RULE_SETUP
+#line 155 "scanner.l"
+ECHO;
+	YY_BREAK
+#line 1598 "scanner.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 592 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 592 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 591);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ *
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ *
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ *
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ *
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ *
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *
+ */
+void yypop_buffer_state (void)
+{
+	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ *
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ *
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ *
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ *
+ */
+int yyget_lineno  (void)
+{
+
+    return yylineno;
+}
+
+/** Get the input stream.
+ *
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ *
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ *
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ *
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ *
+ */
+void yyset_lineno (int  line_number )
+{
+
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ *
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 155 "scanner.l"
diff -Naur radvd-1.8/send.c radvd-1.8-brcm/send.c
--- radvd-1.8/send.c	2011-05-06 23:26:39.000000000 -0300
+++ radvd-1.8-brcm/send.c	2018-11-24 16:42:07.697980659 -0400
@@ -1,5 +1,5 @@
 /*
- *   $Id: send.c,v 1.48 2011/05/06 07:51:54 reubenhwk Exp $
+ *   $Id: send.c,v 1.1.2.2 2011/09/07 06:18:52 mili Exp $
  *
  *   Authors:
  *    Pedro Roque		<roque@di.fc.ul.pt>
@@ -87,7 +87,7 @@
 		secs_diff++;
 
 	return secs_diff;
-	
+
 }
 
 static void
@@ -95,7 +95,7 @@
 {
 
 	if (*lifetime > secs) {
-		*lifetime -= secs;	
+		*lifetime -= secs;
 	} else {
 		*lifetime = 0;
 	}
@@ -110,7 +110,30 @@
 	dlog(LOG_DEBUG, 3, "Will cease advertising %s/%u%%%s, preferred lifetime is 0", pfx_str, pfx_len, if_name);
 
 }
-
+static struct AdvPrefix* reverse_prefix_list(struct AdvPrefix* root)
+{
+    if(!root)
+        return root;
+    int perfix_cnt=1;
+    struct AdvPrefix *cur,*pre,*next;
+
+    pre=(struct AdvPrefix *)NULL;
+    cur=root;
+    next=cur->next;
+
+    while(next)
+    {
+        cur->next=pre;
+        pre=cur;
+        cur=next;
+        next=cur->next;
+        perfix_cnt++;
+    }
+
+    cur->next=pre;
+    dlog(LOG_DEBUG, 4,"prefix cnt=%d",perfix_cnt);
+    return cur;
+}
 int
 send_ra(struct Interface *iface, struct in6_addr *dest)
 {
@@ -128,7 +151,6 @@
 	struct AdvDNSSL *dnssl;
 	struct timeval time_now;
 	time_t secs_since_last_ra;
-
 	unsigned char buff[MSG_SIZE_SEND];
 	size_t len = 0;
 	ssize_t err;
@@ -205,6 +227,7 @@
 		/* if forwarding is disabled, send zero router lifetime */
 		radvert->nd_ra_router_lifetime	 =  !check_ip6_forwarding() ? htons(iface->AdvDefaultLifetime) : 0;
 	}
+    dlog(LOG_DEBUG, 4,"nd_ra_router_lifetime=%d",radvert->nd_ra_router_lifetime);
 	radvert->nd_ra_flags_reserved   |=
 		(iface->AdvDefaultPreference << ND_OPT_RI_PRF_SHIFT) & ND_OPT_RI_PRF_MASK;
 
@@ -212,16 +235,34 @@
 	radvert->nd_ra_retransmit = htonl(iface->AdvRetransTimer);
 
 	len = sizeof(struct nd_router_advert);
+/*reverse prefix list*/
 
+    iface->AdvPrefixList = reverse_prefix_list(iface->AdvPrefixList);
+/*end*/
 	prefix = iface->AdvPrefixList;
 
 	/*
 	 *	add prefix options
 	 */
+	static int DepPrefixCnt = 1; // send deprecated prefix for x times
 
 	while(prefix)
 	{
-		if( prefix->enabled && prefix->curr_preferredlft > 0 )
+	    struct in6_addr	*prinPrefix=&prefix->Prefix;
+	    dlog(LOG_DEBUG, 4,"prifix %x:%x:%x:%x:%x:%x:%x:%x",
+         prinPrefix->s6_addr16[0],prinPrefix->s6_addr16[1],prinPrefix->s6_addr16[2],prinPrefix->s6_addr16[3],
+         prinPrefix->s6_addr16[4],prinPrefix->s6_addr16[5],prinPrefix->s6_addr16[6],prinPrefix->s6_addr16[7]);
+
+		dlog(LOG_DEBUG, 4, "prefix info:AdvPreferredLifetime=%d,AdvValidLifetime=%d,DeprecatePrefixFlag=%d,DecrementLifetimesFlag=%d",
+        prefix->AdvPreferredLifetime,prefix->AdvValidLifetime,prefix->DeprecatePrefixFlag,prefix->DecrementLifetimesFlag);
+
+        dlog(LOG_DEBUG, 4,"prefix->curr_preferredlft =%d,prefix->curr_validlft=%d",
+            prefix->curr_preferredlft,prefix->curr_validlft);
+
+	    //if( prefix->enabled )
+	    //if( prefix->enabled && prefix->curr_preferredlft > 0 )
+		//if( prefix->enabled && ((prefix->DeprecatePrefixFlag==0) || (prefix->curr_preferredlft > 0)))
+		if( prefix->enabled && ((prefix->curr_preferredlft > 0) || ((prefix->DecrementLifetimesFlag==0) && (iface->cease_adv==0) && (DepPrefixCnt>0))))
 		{
 			struct nd_opt_prefix_info *pinfo;
 
@@ -247,7 +288,7 @@
 				if (prefix->DecrementLifetimesFlag) {
 					decrement_lifetime(secs_since_last_ra,
 								&prefix->curr_validlft);
-					
+
 					decrement_lifetime(secs_since_last_ra,
 								&prefix->curr_preferredlft);
 					if (prefix->curr_preferredlft == 0)
@@ -267,7 +308,12 @@
 
 		prefix = prefix->next;
 	}
-
+	// 2011.08.19, ipv6_6rd_100-102: Sometimes still fail, so enable this patch.
+	// 2011.08.10, ipv6_6rd_100-102: bypass HAVE_NETLINK also could fix those 3 fail cases. So resume code to old one.
+	DepPrefixCnt --;
+    /*reverse back prefix list */
+    iface->AdvPrefixList = reverse_prefix_list(iface->AdvPrefixList);
+    /*end*/
 	route = iface->AdvRouteList;
 
 	/*
@@ -446,7 +492,7 @@
                 else {
                        ival  = (iface->MaxRtrAdvInterval * 1000);
                 }
- 		a_ival.type	= ND_OPT_RTR_ADV_INTERVAL;
+		a_ival.type	= ND_OPT_RTR_ADV_INTERVAL;
 		a_ival.length	= 1;
 		a_ival.reserved	= 0;
 		a_ival.adv_ival	= htonl(ival);
@@ -466,7 +512,7 @@
 
 	{
 		struct HomeAgentInfo ha_info;
- 		ha_info.type		= ND_OPT_HOME_AGENT_INFO;
+		ha_info.type		= ND_OPT_HOME_AGENT_INFO;
 		ha_info.length		= 1;
 		ha_info.flags_reserved	=
 			(iface->AdvMobRtrSupportFlag)?ND_OPT_HAI_FLAG_SUPPORT_MR:0;
